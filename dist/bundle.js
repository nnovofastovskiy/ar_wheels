/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var e={156:function(e,t,n){"use strict";var i,r=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,i,r)}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||(i=function(e){return i=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},i(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=i(e),s=0;s<n.length;s++)"default"!==n[s]&&r(t,e,n[s]);return a(t,e),t});Object.defineProperty(t,"__esModule",{value:!0});const o=s(n(603));!async function(){try{const e=await o.InferenceSession.create("./models/best.onnx",{executionProviders:["wasm"]});console.log("✅ Модель загружена:",e);const t=new o.Tensor("float32",new Float32Array(150528),[1,3,224,224]),n=(await e.run({input:t}))[e.outputNames[0]];console.log("✅ Результат:",n.data)}catch(e){console.error("❌ Ошибка при запуске модели:",e)}}()},603:(e,t,n)=>{"use strict";var i=(()=>{var e,t,i,r,a,s,o,u,l,d,p,h,c,f,m,g,_,y,w,$,b,v,x,k,S,I,T,E,z,C,O,B,A,R=Object.defineProperty,D=Object.getOwnPropertyDescriptor,M=Object.getOwnPropertyNames,P=Object.prototype.hasOwnProperty,U=n(687),N=(e,t)=>()=>(e&&(t=e(e=0)),t),q=(e,t)=>{for(var n in t)R(e,n,{get:t[n],enumerable:!0})},V=e=>((e,t,n,i)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of M(t))!P.call(e,n)&&undefined!==n&&R(e,n,{get:()=>t[n],enumerable:!(i=D(t,n))||i.enumerable});return e})(R({},"__esModule",{value:!0}),e),L=N(()=>{e=new Map,t=[],i=(n,i,r)=>{if(i&&"function"==typeof i.init&&"function"==typeof i.createInferenceSessionHandler){let a=e.get(n);if(void 0===a)e.set(n,{backend:i,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==i)throw new Error(`cannot register backend "${n}" using priority ${r}`)}if(r>=0){let i=t.indexOf(n);-1!==i&&t.splice(i,1);for(let i=0;i<t.length;i++)if(e.get(t[i]).priority<=r)return void t.splice(i,0,n);t.push(n)}return}throw new TypeError("not a valid backend")},r=async t=>{let n=e.get(t);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{let e=!!n.initPromise;try{return e||(n.initPromise=n.backend.init(t)),await n.initPromise,n.initialized=!0,n.backend}catch(t){return e||(n.error=`${t}`,n.aborted=!0),n.error}finally{delete n.initPromise}}},a=async e=>{let n,i=e.executionProviders||[],a=i.map(e=>"string"==typeof e?e:e.name),s=0===a.length?t:a,o=[],u=new Set;for(let e of s){let t=await r(e);"string"==typeof t?o.push({name:e,err:t}):(n||(n=t),n===t&&u.add(e))}if(!n)throw new Error(`no available backend found. ERR: ${o.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of o)a.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let l=i.filter(e=>u.has("string"==typeof e?e:e.name));return[n,new Proxy(e,{get:(e,t)=>"executionProviders"===t?l:Reflect.get(e,t)})]}}),G=N(()=>{L()}),W=N(()=>{s="1.23.2"}),H=N(()=>{W(),o="warning",u={wasm:{},webgl:{},webgpu:{},versions:{common:s},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);o=e}},get logLevel(){return o}},Object.defineProperty(u,"logLevel",{enumerable:!0})}),F=N(()=>{H(),l=u}),j=N(()=>{d=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let i=n.getContext("2d");if(null!=i){let r,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(r=e.dims[2],a=e.dims[3]):(r=e.dims[3],a=e.dims[2]);let s,o,u=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?s=[255,255,255,255]:"number"==typeof l.mean?s=[l.mean,l.mean,l.mean,l.mean]:(s=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(s[3]=l.mean[3])),void 0===l||void 0===l.bias?o=[0,0,0,0]:"number"==typeof l.bias?o=[l.bias,l.bias,l.bias,l.bias]:(o=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(o[3]=l.bias[3]));let d=a*r,p=0,h=d,c=2*d,f=-1;"RGBA"===u?(p=0,h=d,c=2*d,f=3*d):"RGB"===u?(p=0,h=d,c=2*d):"RBG"===u&&(p=0,c=d,h=2*d);for(let t=0;t<a;t++)for(let n=0;n<r;n++){let r=(e.data[p++]-o[0])*s[0],a=(e.data[h++]-o[1])*s[1],u=(e.data[c++]-o[2])*s[2],l=-1===f?255:(e.data[f++]-o[3])*s[3];i.fillStyle="rgba("+r+","+a+","+u+","+l+")",i.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},p=(e,t)=>{let n,i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==i)throw new Error("Can not access image data");{let r,a,s;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(r=e.dims[2],a=e.dims[1],s=e.dims[3]):(r=e.dims[3],a=e.dims[2],s=e.dims[1]);let o,u,l=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?o=[255,255,255,255]:"number"==typeof d.mean?o=[d.mean,d.mean,d.mean,d.mean]:(o=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(o[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));let p=a*r;if(void 0!==t&&(void 0!==t.format&&4===s&&"RGBA"!==t.format||3===s&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let h=4,c=0,f=1,m=2,g=3,_=0,y=p,w=2*p,$=-1;"RGBA"===l?(_=0,y=p,w=2*p,$=3*p):"RGB"===l?(_=0,y=p,w=2*p):"RBG"===l&&(_=0,w=p,y=2*p),n=i.createImageData(r,a);for(let t=0;t<a*r;c+=h,f+=h,m+=h,g+=h,t++)n.data[c]=(e.data[_++]-u[0])*o[0],n.data[f]=(e.data[y++]-u[1])*o[1],n.data[m]=(e.data[w++]-u[2])*o[2],n.data[g]=-1===$?255:(e.data[$++]-u[3])*o[3]}return n}}),K=N(()=>{X(),h=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,i,{height:r,width:a}=t,s=t.norm??{mean:255,bias:0};n="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],i="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let o=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=r*a,d="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l),p=4,h=0,c=1,f=2,m=3,g=0,_=l,y=2*l,w=-1;"RGB"===o&&(p=3,h=0,c=1,f=2,m=-1),"RGBA"===u?w=3*l:"RBG"===u?(g=0,y=l,_=2*l):"BGR"===u&&(y=0,_=l,g=2*l);for(let t=0;t<l;t++,h+=p,f+=p,c+=p,m+=p)d[g++]=(e[h]+i[0])/n[0],d[_++]=(e[c]+i[1])/n[1],d[y++]=(e[f]+i[2])/n[2],-1!==w&&-1!==m&&(d[w++]=(e[m]+i[3])/n[3]);return new k("float32",d,"RGBA"===u?[1,4,r,a]:[1,3,r,a])},c=async(e,t)=>{let n,i=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,r=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s="string"==typeof e,o=t??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(i){let i=u();i.width=e.width,i.height=e.height;let r=l(i);if(null==r)throw new Error("Can not access image data");{let i=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(i=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=i,o.width=a}else o.tensorFormat="RGBA",o.height=i,o.width=a;r.drawImage(e,0,0),n=r.getImageData(0,0,a,i).data}}else{if(!r){if(a){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let i=u();i.width=e.width,i.height=e.height;let r=l(i);if(null!=r){let t=e.height,i=e.width;return r.drawImage(e,0,0,i,t),n=r.getImageData(0,0,i,t).data,o.height=t,o.width=i,h(n,o)}throw new Error("Can not access image data")}if(s)return new Promise((t,n)=>{let i=u(),r=l(i);if(!e||!r)return n();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{i.width=a.width,i.height=a.height,r.drawImage(a,0,0,i.width,i.height);let e=r.getImageData(0,0,i.width,i.height);o.height=i.height,o.width=i.width,t(h(e.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let i,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(i=t.resizedHeight,r=t.resizedWidth):(i=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=i,o.width=r,void 0!==t){let t=u();t.width=r,t.height=i;let a=l(t);if(null==a)throw new Error("Can not access image data");a.putImageData(e,0,0),n=a.getImageData(0,0,r,i).data}else n=e.data}}if(void 0!==n)return h(n,o);throw new Error("Input data provided is not supported - aborted tensor creation")},f=(e,t)=>{let{width:n,height:i,download:r,dispose:a}=t;return new k({location:"texture",type:"float32",texture:e,dims:[1,i,n,4],download:r,dispose:a})},m=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:a}=t;return new k({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:i,download:r,dispose:a})},g=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:a}=t;return new k({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:i,download:r,dispose:a})},_=(e,t,n)=>new k({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),Z=N(()=>{y=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),w=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),$=!1,b=()=>{if(!$){$=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,i=typeof n<"u"&&n.from;e&&(y.set("int64",BigInt64Array),w.set(BigInt64Array,"int64")),t&&(y.set("uint64",BigUint64Array),w.set(BigUint64Array,"uint64")),i?(y.set("float16",n),w.set(n,"float16")):y.set("float16",Uint16Array)}}}),Q=N(()=>{X(),v=e=>{let t=1;for(let n=0;n<e.length;n++){let i=e[n];if("number"!=typeof i||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);t*=i}return t},x=(e,t)=>{switch(e.location){case"cpu":return new k(e.type,e.data,t);case"cpu-pinned":return new k({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new k({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new k({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new k({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),X=N(()=>{j(),K(),Z(),Q(),k=class{constructor(e,t,n){let i,r;if(b(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,i=e.type,r=e.dims,e.location){case"cpu-pinned":{let t=y.get(i);if(!t)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==i)throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==i&&"float16"!==i&&"int32"!==i&&"int64"!==i&&"uint32"!==i&&"uint8"!==i&&"bool"!==i&&"uint4"!==i&&"int4"!==i)throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==i&&"float16"!==i&&"int32"!==i&&"int64"!==i&&"uint32"!==i&&"uint64"!==i&&"int8"!==i&&"uint8"!==i&&"bool"!==i&&"uint4"!==i&&"int4"!==i)throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,s;if("string"==typeof e)if(i=e,s=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{let n=y.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);a="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");a=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&n!==Uint16Array))throw new TypeError(`A ${i} tensor's data must be type of ${n}`);a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(s=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)i="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);i="bool",a=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)i="uint8",a=Uint8Array.from(e);else{let t=w.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=t,a=e}if(void 0===s)s=[a.length];else if(!Array.isArray(s))throw new TypeError("A tensor's dims must be a number array");r=s,this.cpuData=a,this.dataLocation="cpu"}let a=v(r);if(this.cpuData&&a!==this.cpuData.length&&("uint4"!==i&&"int4"!==i||Math.ceil(a/2)!==this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=r,this.size=a}static async fromImage(e,t){return c(e,t)}static fromTexture(e,t){return f(e,t)}static fromGpuBuffer(e,t){return m(e,t)}static fromMLTensor(e,t){return g(e,t)}static fromPinnedBuffer(e,t,n){return _(e,t,n)}toDataURL(e){return d(this,e)}toImageData(e){return p(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return x(this,e)}}}),Y=N(()=>{X(),S=k}),J=N(()=>{H(),I=(e,t)=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||console.timeStamp(`${e}::ORT::${t}`)},T=(e,t)=>{let n=(new Error).stack?.split(/\r\n|\r|\n/g)||[],i=!1;for(let r=0;r<n.length;r++){if(i&&!n[r].includes("TRACE_FUNC")){let i=`FUNC_${e}::${n[r].trim().split(" ")[1]}`;return t&&(i+=`::${t}`),void I("CPU",i)}n[r].includes("TRACE_FUNC")&&(i=!0)}},E=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||T("BEGIN",e)},z=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||T("END",e)},C=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||console.time(`ORT::${e}`)},O=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||console.timeEnd(`ORT::${e}`)}}),ee=N(()=>{L(),Y(),J(),B=class e{constructor(e){this.handler=e}async run(e,t,n){E(),C("InferenceSession.run");let i={},r={};if("object"!=typeof e||null===e||e instanceof S||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof S)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);i[e]=null}if("object"==typeof n&&null!==n)r=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,s=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==s.indexOf(n)){let r=t[n];(null===r||r instanceof S)&&(e=!0,a=!1,i[n]=r)}if(e){if("object"==typeof n&&null!==n)r=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else r=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)i[e]=null;let s=await this.handler.run(e,i,r),o={};for(let e in s)if(Object.hasOwnProperty.call(s,e)){let t=s[e];o[e]=t instanceof S?t:new S(t.type,t.data,t.dims)}return O("InferenceSession.run"),z(),o}async release(){return this.handler.dispose()}static async create(t,n,i,r){E(),C("InferenceSession.create");let s,o={};if("string"==typeof t){if(s=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,a=0,u=t.byteLength;if("object"==typeof n&&null!==n)o=n;else if("number"==typeof n){if(a=n,!Number.isSafeInteger(a))throw new RangeError("'byteOffset' must be an integer.");if(a<0||a>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-a,"number"==typeof i){if(u=i,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||a+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-a}].`);if("object"==typeof r&&null!==r)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(e,a,u)}}let[u,l]=await a(o),d=await u.createInferenceSessionHandler(s,l);return O("InferenceSession.create"),z(),new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),te=N(()=>{ee(),A=B}),ne=N(()=>{}),ie=N(()=>{}),re=N(()=>{}),ae=N(()=>{}),se={};q(se,{InferenceSession:()=>A,TRACE:()=>I,TRACE_EVENT_BEGIN:()=>C,TRACE_EVENT_END:()=>O,TRACE_FUNC_BEGIN:()=>E,TRACE_FUNC_END:()=>z,Tensor:()=>S,env:()=>l,registerBackend:()=>i});var oe=N(()=>{G(),F(),te(),Y(),ne(),ie(),J(),re(),ae()}),ue=N(()=>{}),le={};q(le,{default:()=>he});var de,pe,he,ce,fe,me,ge,_e,ye,we,$e,be,ve,xe,ke,Se,Ie,Te,Ee,ze,Ce,Oe,Be,Ae,Re,De,Me,Pe,Ue,Ne,qe,Ve,Le,Ge,We,He,Fe,je,Ke,Ze,Qe,Xe,Ye,Je,et,tt,nt,it,rt,at,st,ot,ut,lt,dt,pt,ht,ct,ft,mt,gt,_t,yt,wt,$t,bt,vt,xt,kt,St,It,Tt,Et,zt,Ct,Ot,Bt,At,Rt,Dt,Mt,Pt,Ut,Nt,qt,Vt,Lt,Gt,Wt,Ht,Ft,jt,Kt,Zt,Qt,Xt,Yt,Jt,en,tn,nn,rn,an,sn,on,un,ln,dn,pn,hn,cn,fn,mn,gn,_n,yn,wn,$n,bn,vn,xn,kn,Sn,In,Tn,En,zn,Cn,On,Bn,An,Rn,Dn,Mn,Pn,Un,Nn,qn,Vn,Ln,Gn,Wn,Hn,Fn,jn,Kn,Zn,Qn,Xn,Yn,Jn,ei,ti,ni,ii,ri,ai,si,oi,ui,li,di,pi,hi,ci,fi,mi,gi,_i,yi,wi,$i,bi,vi,xi,ki,Si,Ii,Ti,Ei,zi,Ci,Oi,Bi,Ai,Ri,Di,Mi,Pi,Ui,Ni,qi,Vi,Li,Gi,Wi,Hi,Fi,ji,Ki,Zi,Qi,Xi,Yi,Ji,er,tr,nr,ir,rr,ar,sr,or,ur,lr,dr,pr,hr,cr,fr,mr,gr,_r,yr,wr,$r,br,vr,xr,kr,Sr,Ir,Tr,Er,zr,Cr,Or,Br,Ar,Rr,Dr,Mr,Pr,Ur,Nr,qr,Vr,Lr,Gr,Wr,Hr,Fr,jr,Kr,Zr,Qr,Xr,Yr,Jr,ea,ta,na,ia,ra,aa,sa,oa,ua,la,da,pa,ha,ca,fa,ma,ga,_a,ya,wa,$a,ba,va,xa,ka,Sa,Ia,Ta,Ea,za,Ca,Oa,Ba,Aa,Ra,Da,Ma,Pa,Ua,Na,qa,Va,La,Ga,Wa,Ha,Fa,ja,Ka,Za,Qa,Xa,Ya,Ja,es,ts,ns,is,rs,as,ss,os,us,ls,ds,ps,hs,cs,fs,ms,gs,_s,ys,ws,$s,bs,vs,xs,ks,Ss,Is,Ts,Es,zs,Cs,Os,Bs,As,Rs,Ds,Ms,Ps,Us,Ns,qs,Vs,Ls,Gs,Ws,Hs,Fs,js,Ks,Zs,Qs,Xs,Ys,Js,eo,to,no,io,ro,ao,so,oo,uo,lo,po,ho,co,fo,mo,go,_o,yo,wo,$o,bo,vo,xo,ko,So,Io,To,Eo,zo,Co,Oo,Bo,Ao,Ro,Do,Mo,Po,Uo,No,qo,Vo,Lo,Go,Wo,Ho,Fo,jo,Ko,Zo,Qo,Xo,Yo,Jo,eu,tu,nu,iu,ru,au,su,ou,uu,lu,du,pu,hu,cu,fu,mu,gu,_u,yu,wu,$u,bu,vu,xu,ku,Su,Iu,Tu,Eu,zu,Cu,Ou,Bu,Au,Ru,Du,Mu,Pu,Uu,Nu,qu,Vu,Lu,Gu,Wu,Hu,Fu,ju=N(()=>{tp(),Zu(),Ku(),de="ort-wasm-proxy-worker",(pe=globalThis.self?.name===de)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":Be(n.wasm).then(()=>{bd(n).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})})},e=>{postMessage({type:t,err:e})});break;case"init-ep":{let{epName:e,env:i}=n;vd(i,e).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})});break}case"copy-from":{let{buffer:e}=n,i=Id(e);postMessage({type:t,out:i});break}case"create":{let{model:e,options:i}=n;Td(e,i).then(e=>{postMessage({type:t,out:e})},e=>{postMessage({type:t,err:e})});break}case"release":Ed(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:i,inputs:r,outputIndices:a,options:s}=n;Cd(e,i,r,a,new Array(a.length).fill(null),s).then(e=>{e.some(e=>"cpu"!==e[3])?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},Bd([...r,...e]))},e=>{postMessage({type:t,err:e})});break}case"end-profiling":Od(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),he=pe?null:e=>new Worker(e??fe,{type:"classic",name:de})}),Ku=N(()=>{ue(),ce=typeof location>"u"?void 0:location.origin,fe=typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,me=()=>{if(fe&&!fe.startsWith("blob:"))return fe.substring(0,fe.lastIndexOf("/")+1)},ge=(e,t)=>{try{let n=t??fe;return(n?new URL(e,n):new URL(e)).origin===ce}catch{return!1}},_e=(e,t)=>{let n=t??fe;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},ye=(e,t)=>`${t??"./"}${e}`,we=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},$e=async e=>(await import(e)).default,be=(ju(),V(le)).default,ve=async()=>{if(!fe)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(ge(fe))return[void 0,be()];let e=await we(fe);return[e,be(e)]},xe=void 0,ke=async(e,t,n,i)=>{let r=xe;if(r)if(fe)r=ge(fe);else{if(!i||n)throw new Error("cannot determine the script source URL.");r=!0}if(r)return[void 0,xe];{let i="ort-wasm-simd-threaded.jsep.mjs",r=e??_e(i,t),a=n&&r&&!ge(r,t),s=a?await we(r):r??ye(i,t);return[a?s:void 0,await $e(s)]}}}),Zu=N(()=>{Ku(),Ie=!1,Te=!1,Ee=!1,ze=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Ce=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Oe=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Be=async e=>{if(Ie)return Promise.resolve();if(Te)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ee)throw new Error("previous call to 'initializeWebAssembly()' failed.");Te=!0;let t=e.initTimeout,n=e.numThreads;if(!1!==e.simd)if("relaxed"===e.simd){if(!Oe())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!Ce())throw new Error("WebAssembly SIMD is not supported in the current environment.");let i=ze();n>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,a="string"==typeof r?r:void 0,s=r?.mjs,o=s?.href??s,u=r?.wasm,l=u?.href??u,d=e.wasmBinary,[p,h]=await ke(o,a,n>1,!!d||!!l),c=!1,f=[];if(t>0&&f.push(new Promise(e=>{setTimeout(()=>{c=!0,e()},t)})),f.push(new Promise((e,t)=>{let i={numThreads:n};if(d)i.wasmBinary=d;else if(l||a)i.locateFile=e=>l??a+e;else if(o&&0!==o.indexOf("blob:"))i.locateFile=e=>new URL(e,o).href;else if(p){let e=me();e&&(i.locateFile=t=>e+t)}h(i).then(t=>{Te=!1,Ie=!0,Se=t,e(),p&&URL.revokeObjectURL(p)},e=>{Te=!1,Ee=!0,t(e)})})),await Promise.race(f),c)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ae=()=>{if(Ie&&Se)return Se;throw new Error("WebAssembly is not initialized yet.")}}),Qu=N(()=>{Zu(),Re=(e,t)=>{let n=Ae(),i=n.lengthBytesUTF8(e)+1,r=n._malloc(i);return n.stringToUTF8(e,r,i),t.push(r),r},De=(e,t,n,i)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([e,r])=>{let a=t?t+e:e;if("object"==typeof r)De(r,a+".",n,i);else if("string"==typeof r||"number"==typeof r)i(a,r.toString());else{if("boolean"!=typeof r)throw new Error("Can't handle extra config type: "+typeof r);i(a,r?"1":"0")}})},Me=e=>{let t=Ae(),n=t.stackSave();try{let n=t.PTR_SIZE,i=t.stackAlloc(2*n);t._OrtGetLastError(i,i+n);let r=Number(t.getValue(i,4===n?"i32":"i64")),a=t.getValue(i+n,"*"),s=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(n)}}}),Xu=N(()=>{Zu(),Qu(),Pe=e=>{let t=Ae(),n=0,i=[],r=e||{};try{if(void 0===e?.logSeverityLevel)r.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)r.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(r.terminate=!1);let a=0;return void 0!==e?.tag&&(a=Re(e.tag,i)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),0===n&&Me("Can't create run options."),void 0!==e?.extra&&De(e.extra,"",new WeakSet,(e,r)=>{let a=Re(e,i),s=Re(r,i);0!==t._OrtAddRunConfigEntry(n,a,s)&&Me(`Can't set a run config entry: ${e} - ${r}.`)}),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(e=>t._free(e)),e}}}),Yu=N(()=>{Zu(),Qu(),Ue=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ne=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},qe=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(e=>"webgpu"===("string"==typeof e?e:e.name))&&(e.enableMemPattern=!1)},Ve=(e,t,n,i)=>{let r=Re(t,i),a=Re(n,i);0!==Ae()._OrtAddSessionConfigEntry(e,r,a)&&Me(`Can't set a session config entry: ${t} - ${n}.`)},Le=async(e,t,n)=>{for(let i of t){let t="string"==typeof i?i:i.name,r=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof i){let t=i?.deviceType;t&&Ve(e,"deviceType",t,n)}break;case"webgpu":if(t="JS","string"!=typeof i){let t=i;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);Ve(e,"preferredLayout",t.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=Re(t,n),s=r.length,o=0,u=0;if(s>0){o=Ae()._malloc(s*Ae().PTR_SIZE),n.push(o),u=Ae()._malloc(s*Ae().PTR_SIZE),n.push(u);for(let e=0;e<s;e++)Ae().setValue(o+e*Ae().PTR_SIZE,r[e][0],"*"),Ae().setValue(u+e*Ae().PTR_SIZE,r[e][1],"*")}0!==await Ae()._OrtAppendExecutionProvider(e,a,o,u,s)&&Me(`Can't append execution provider: ${t}.`)}},Ge=async e=>{let t=Ae(),n=0,i=[],r=e||{};qe(r);try{let e=Ue(r.graphOptimizationLevel??"all"),a=Ne(r.executionMode??"sequential"),s="string"==typeof r.logId?Re(r.logId,i):0,o=r.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log severity level is not valid: ${o}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof r.optimizedModelFilePath?Re(r.optimizedModelFilePath,i):0;if(n=t._OrtCreateSessionOptions(e,!!r.enableCpuMemArena,!!r.enableMemPattern,a,!!r.enableProfiling,0,s,o,u,l),0===n&&Me("Can't create session options."),r.executionProviders&&await Le(n,r.executionProviders,i),void 0!==r.enableGraphCapture){if("boolean"!=typeof r.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);Ve(n,"enableGraphCapture",r.enableGraphCapture.toString(),i)}if(r.freeDimensionOverrides)for(let[e,a]of Object.entries(r.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof a||!Number.isInteger(a)||a<0)throw new Error(`free dimension override value must be a non-negative integer: ${a}`);let r=Re(e,i);0!==t._OrtAddFreeDimensionOverride(n,r,a)&&Me(`Can't set a free dimension override: ${e} - ${a}.`)}return void 0!==r.extra&&De(r.extra,"",new WeakSet,(e,t)=>{Ve(n,e,t,i)}),[n,i]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&Me("Can't release session options."),i.forEach(e=>t._free(e)),e}}}),Ju=N(()=>{We=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},He=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Fe=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],i="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return n>0?Math.ceil(i*n):void 0},je=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ke=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ze=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Qe=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Xe=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),el=N(()=>{ue(),Ye=async e=>{if("string"==typeof e){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),i=n?parseInt(n,10):0;if(i<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,r=t.body.getReader();try{n=new ArrayBuffer(i)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(i/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let a=0;for(;;){let{done:e,value:t}=await r.read();if(e)break;let i=t.byteLength;new Uint8Array(n,a,i).set(t),a+=i}return new Uint8Array(n,0,i)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),tl=N(()=>{Ju(),Je=["V","I","W","E","F"],et=(e,t)=>{console.log(`[${Je[e]},${(new Date).toISOString()}]${t}`)},it=(e,t)=>{tt=e,nt=t},rt=(e,t)=>{let n=Ke(e);n>=Ke(tt)&&et(n,"function"==typeof t?t():t)},at=(...e)=>{nt&&rt(...e)}}),nl=N(()=>{st=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},ot=class{static calcShape(e,t,n=!1){let i=e.length,r=t.length;if(0===i)return t;if(0===r)return e;let a=Math.max(e.length,t.length),s=new Array(a);if(n){if(i<2||r<2)return;let n=st.calcMatMulShape([e[i-2],e[i-1]],[t[r-2],t[r-1]]);if(void 0===n)return;[s[a-2],s[a-1]]=n}for(let o=n?3:1;o<=a;o++){let n=i-o<0?1:e[i-o],u=r-o<0?1:t[r-o];if(n!==u&&n>1&&u>1)return;let l=Math.max(n,u);if(n&&u)s[a-o]=Math.max(n,u);else{if(l>1)return;s[a-o]=0}}return s}static isValidBroadcast(e,t){let n=e.length,i=t.length;if(n>i)return!1;for(let r=1;r<=n;r++)if(1!==e[n-r]&&e[n-r]!==t[i-r])return!1;return!0}},ut=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let i=new Array(n),r=n-1;for(;r>=0;){if(e[r]%t===0){i[r]=e[r]/t;break}if(t%e[r]!==0)throw new Error("cannot convert shape");i[r]=1,t/=e[r],r--}for(r--;r>=0;r--)i[r]=e[r];return i}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let i=1;for(let r=t;r<n;r++){if(e[r]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=Number(e[r])}return i}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let i=t-3;i>=0;--i)n[i]=n[i+1]*e[i+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(n=>this.normalizeAxis(n,t??e.length))}static sortBasedOnPerm(e,t){return t?t.map(t=>e[t]):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map((e,i)=>e+t[i]+t[i+n])}static areEqual(e,t){return e.length===t.length&&e.every((e,n)=>e===t[n])}},lt=class e{static adjustPoolAttributes(e,t,n,i,r,a){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("dilations should be greater than or equal to 1")}else r.push(1);for(let e=0;e<2*n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[e]>=n[e]||a[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,i,r,a,s,o){if(o){if(a.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(s?1:2)],n[u],i[u],r[u],a,u,u+t.length-2,o)}}static computePoolOutputShape(t,n,i,r,a,s,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return e.computeShapeHelper(t,n,u,i,r,a,s,o),u}static computeConvOutputShape(t,n,i,r,a,s,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return e.computeShapeHelper(!1,t,u,i,r,a,s,o),u}static computeShapeHelper(t,n,i,r,a,s,o,u){if(t)for(let e=0;e<n.length-2;e++)i.push(1);else for(let t=0;t<n.length-2;t++)i.push(e.adjustPadAndReturnShape(n[t+2],r[t],a[t],s[t],o,t,t+n.length-2,u))}static adjustPadAndReturnShape(e,t,n,i,r,a,s,o){let u=n*(i-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+r[a]+r[s]-u)/t+1);switch(o){case"VALID":return r[a]=0,r[s]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+i-e;return r[a]=Math.floor("SAME_LOWER"===o?(n+1)/2:n/2),r[s]=n-r[a],Math.floor((e+n-i)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},dt=class{static getShapeOfGemmResult(e,t,n,i,r){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,s,o;t?(a=e[1],s=e[0]):(a=e[0],s=e[1]);let u=-1;if(i?(o=n[0],u=1):(o=n[1],u=0),n[u]!==s)throw new Error("dimension mismatch");if(a<=0||o<=0||s<=0)throw new Error("invalid shape specified");if(r&&!ot.isValidBroadcast(r,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,s]}},pt=-34028234663852886e22,ht=34028234663852886e22}),il=N(()=>{Ju(),ct=(e,t)=>new(je(t))(e)}),rl=N(()=>{Ju(),tl(),ft=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),mt=(e,t)=>{if("int32"===t)return e;let n=ft.get(t);if(!n)throw new Error(`WebNN backend does not support data type: ${t}`);let i=n/8;if(e.byteLength%i!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${i}.`);let r=e.byteLength/i,a=new(je(t))(e.buffer,e.byteOffset,r);switch(t){case"int64":case"uint64":{let e=new Int32Array(r);for(let t=0;t<r;t++){let n=a[t];if(n>2147483647n||n<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");e[t]=Number(n)}return new Uint8Array(e.buffer)}case"int8":case"uint8":case"uint32":{if("uint32"===t&&a.some(e=>e>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let e=Int32Array.from(a,Number);return new Uint8Array(e.buffer)}default:throw new Error(`Unsupported data conversion from ${t} to 'int32'`)}},gt=(e,t)=>{if("int32"===t)return e;if(e.byteLength%4!=0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let n=e.byteLength/4,i=new Int32Array(e.buffer,e.byteOffset,n);switch(t){case"int64":{let e=BigInt64Array.from(i,BigInt);return new Uint8Array(e.buffer)}case"uint64":{if(i.some(e=>e<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let e=BigUint64Array.from(i,BigInt);return new Uint8Array(e.buffer)}case"int8":{if(i.some(e=>e<-128||e>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let e=Int8Array.from(i,Number);return new Uint8Array(e.buffer)}case"uint8":if(i.some(e=>e<0||e>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(i,Number);case"uint32":{if(i.some(e=>e<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let e=Uint32Array.from(i,Number);return new Uint8Array(e.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${t}`)}},_t=1,yt=()=>_t++,wt=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),$t=(e,t)=>{let n=ft.get(e);if(!n)throw new Error(`WebNN backend does not support data type: ${e}`);return t.length>0?Math.ceil(t.reduce((e,t)=>e*t)*n/8):0},bt=class{constructor(e){this.isDataConverted=!1;let{sessionId:t,context:n,tensor:i,dataType:r,shape:a,fallbackDataType:s}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=i,this.dataType=r,this.tensorShape=a,this.fallbackDataType=s}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return $t(this.dataType,this.tensorShape)}destroy(){at("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(this.fallbackDataType){let t=await this.mlContext.readTensor(this.mlTensor),n=gt(new Uint8Array(t),this.dataType);return e?void(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(n):n.buffer}return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((e,t)=>e===n[t])}setIsDataConverted(e){this.isDataConverted=e}},vt=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,i){let r,a=this.tensorManager.getMLContext(e);if(!a.opSupportLimits().input.dataTypes.includes(t)){if(r=wt.get(t),!r||!a.opSupportLimits().input.dataTypes.includes(r))throw new Error(`WebNN backend does not support data type: ${t}`);at("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${t} to ${r}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(a,t,n))return this.wrapper.tensor;if(i){if(this.wrapper.byteLength!==$t(t,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let s=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,n,s,!0,!0,r),i&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper){if(this.wrapper.fallbackType){if("int32"!==this.wrapper.fallbackType)throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);t=mt(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0)}if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(t);at("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){if(this.activeUpload){let t=this.wrapper?.isDataConverted?gt(this.activeUpload,this.wrapper?.type):this.activeUpload;return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(t):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t)):t.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},xt=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=yt();return this.tensorTrackersById.set(e,new vt(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,i,r){at("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${i}, copyOld: ${r}}`);let a=this.tensorTrackersById.get(t);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(e,n,i,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){at("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,i){let r=this.getMLContext(e),a=yt(),s=new bt({sessionId:e,context:r,tensor:t,dataType:n,shape:i});return this.tensorTrackersById.set(a,new vt(this,s)),this.externalTensors.add(s),a}async getCachedTensor(e,t,n,i,r,a,s){let o=this.getMLContext(e);for(let[i,r]of this.freeTensors.entries())if(r.canReuseTensor(o,t,n)){at("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, ${s?`fallbackDataType: ${s},`:""} shape: ${n}`);let r=this.freeTensors.splice(i,1)[0];return r.sessionId=e,r}at("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, ${s?`fallbackDataType: ${s},`:""} shape: ${n}}`);let u=await o.createTensor({dataType:s??t,shape:n,dimensions:n,usage:i,writable:r,readable:a});return new bt({sessionId:e,context:o,tensor:u,dataType:t,shape:n,fallbackDataType:s})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},kt=(...e)=>new xt(...e)}),al=N(()=>{Ju(),Zu(),il(),rl(),tl(),St=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),It=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),i=Object.keys(t).sort();return n.length===i.length&&n.every((n,r)=>n===i[r]&&e[n]===t[n])},Tt=class{constructor(e){this.tensorManager=kt(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,it(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){at("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){at("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let e of t)at("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex(t=>t.gpuDevice===e);if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex(e=>void 0===e.options&&void 0===e.gpuDevice);if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex(t=>It(t.options,e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex(e=>e.mlContext===t);-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){at("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,i,r){let a=St.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,a,i,r)}async createTemporaryTensor(e,t,n){at("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let i=St.get(t);if(!i)throw new Error(`Unsupported ONNX data type: ${t}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,r,i,n,!1);let a=this.temporarySessionTensorIds.get(e);return a?a.push(r):this.temporarySessionTensorIds.set(e,[r]),r}uploadTensor(e,t){if(!Ae().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");at("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return ct(n,t)}}registerMLTensor(e,t,n,i){let r=St.get(n);if(!r)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.registerTensor(e,t,r,i);return at("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${r}, dimensions: ${i}} -> {tensorId: ${a}}`),a}registerMLConstant(e,t,n,i,r,a,s=!1){if(!a)throw new Error("External mounted files are not available.");let o=e;e.startsWith("./")&&(o=e.substring(2));let u=a.get(o);if(!u)throw new Error(`File with name ${o} not found in preloaded files.`);if(t+n>u.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,d=u.slice(t,t+n).buffer;switch(r.dataType){case"float32":l=new Float32Array(d);break;case"float16":l=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":l=new Int32Array(d);break;case"uint32":l=new Uint32Array(d);break;case"int64":if(s){let e=mt(new Uint8Array(d),"int64");l=new Int32Array(e.buffer),r.dataType="int32"}else l=new BigInt64Array(d);break;case"uint64":l=new BigUint64Array(d);break;case"int8":l=new Int8Array(d);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return at("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}} ${s?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),i.constant(r,l)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return!!n&&n.includes(t)}isGraphOutput(e,t){let n=this.sessionGraphOutputs.get(e);return!!n&&n.includes(t)}isGraphInputOutputTypeSupported(e,t,n=!0){let i=this.mlContextBySessionId.get(e),r=St.get(We(t));return!(typeof r>"u"||(n?!i?.opSupportLimits().input.dataTypes.includes(r):!i?.opSupportLimits().output.dataTypes.includes(r)))}flush(){}}}),sl=N(()=>{}),ol=N(()=>{tl(),sl(),Et=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),zt=[],Ct=e=>16*Math.ceil(Number(e)/16),Ot=e=>{for(let t=0;t<zt.length;t++){let n=zt[t];if(e<=n)return n}return 16*Math.ceil(e/16)},Bt=1,At=()=>Bt++,Rt=async(e,t,n,i)=>{let r=Ct(n),a=e.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,a,0,r),e.flush(),await a.mapAsync(GPUMapMode.READ);let o=a.getMappedRange();if(i){let e=i();return e.set(new Uint8Array(o,0,n)),e}return new Uint8Array(o.slice(0,n))}finally{a.destroy()}},Dt=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Et)zt.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,i=t.byteOffset,r=t.byteLength,a=Ct(r),s=this.storageCache.get(e);if(!s)throw new Error("gpu data for uploading does not exist");if(Number(s.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${s.originalSize}, data size=${r}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=o.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,i,r)),o.unmap();let l=this.backend.device.createCommandEncoder();l.copyBufferToBuffer(o,0,s.gpuData.buffer,0,a),this.backend.device.queue.submit([l.finish()]),o.destroy(),at("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(t);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=Ct(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,i.gpuData.buffer,0,r)}registerExternalBuffer(e,t,n){let i;if(n){if(i=n[0],e===n[1])return at("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!")}else i=At();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:e},originalSize:t}),at("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, registered.`),i}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),at("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,i=Ot(e),r=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||a){let e=(r?this.freeBuffers:this.freeUniformBuffers).get(i);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:i,usage:t})}else n=this.backend.device.createBuffer({size:i,usage:t});let s={id:At(),type:0,buffer:n};return this.storageCache.set(s.id,{gpuData:s,originalSize:Number(e)}),at("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${s.id}`),s}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return at("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Rt(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=Et.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(e=>{e.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(at("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Mt=(...e)=>new Dt(...e)}),ul=N(()=>{Pt=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},Ut=e=>new Pt(e)}),ll=N(()=>{Ju(),nl(),Nt=64,qt=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},Vt=(e,t=1)=>{let n=qt(e,t);return"string"==typeof n?n:n[0]},Lt=(e,t=1)=>{let n=qt(e,t);return"string"==typeof n?n:n[1]},Gt=(...e)=>{let t=[];return e.forEach(e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:ut.computeStrides(e)})}),t},Wt=e=>e%4==0?4:e%2==0?2:1,Ht=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,Ft=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,jt=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,Kt=(e,t,n,i)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===i?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===i?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Zt=(e,t,n,i,r)=>{let a="number"==typeof n,s=a?n:n.length,o=[...new Array(s).keys()],u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,l=qt(t,r),d="string"==typeof l?l:l[1],p="string"==typeof l?l:l[0],h={indices:u,value:d,storage:p,tensor:t},c=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=a?"uniforms.":"",g=`${m}${e}_shape`,_=`${m}${e}_strides`,y="";for(let e=0;e<s-1;e++)y+=`\n    let dim${e} = current / ${Kt(_,e,s)};\n    let rest${e} = current % ${Kt(_,e,s)};\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;y+=`indices[${s-1}] = current;`;let w=s<2?"":`\n  fn o2i_${e}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${y}\n    return indices;\n  }`,$=[];if(s>=2)for(let e=s-1;e>=0;e--)$.push(`${Kt(_,e,s)} * (indices[${e}])`);let b=s<2?"":`\n  fn i2o_${e}(indices: ${h.indices}) -> u32 {\n    return ${$.join("+")};\n  }`,v=(...e)=>0===s?"0u":`${h.indices}(${e.map(c).join(",")})`,x=(e,t)=>s<2?`${e}`:`${Kt(e,t,s)}`,k={},S=(t,n)=>(()=>{if(h.storage===h.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===h.storage&&"i32"===h.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===h.storage&&"u32"===h.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===h.storage&&"vec4<bool>"===h.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),I=t=>(()=>{if(h.storage===h.value)return`${e}[${t}]`;if("vec2<u32>"===h.storage&&"i32"===h.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===h.storage&&"u32"===h.value)return`u32(${e}[${t}].x)`;if("u32"===h.storage&&"vec4<bool>"===h.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),T=s<2?"":`\n  fn get_${e}ByIndices(indices: ${h.indices}) -> ${d} {\n    return ${I(`i2o_${e}(indices)`)};\n  }`,E=s<2?"":(()=>{let t=o.map(e=>`d${e}: u32`).join(", "),n=o.map(e=>`d${e}`).join(", ");return`\n  fn get_${e}(${t}) -> ${d} {\n    return get_${e}ByIndices(${v(n)});\n  }`})(),z=s<2?"":`\n  fn set_${e}ByIndices(indices: ${h.indices}, value: ${d}) {\n    ${S(`i2o_${e}(indices)`,"value")}\n  }`,C=s<2?"":(()=>{let t=o.map(e=>`d${e}: u32`).join(", "),n=o.map(e=>`d${e}`).join(", ");return`\n  fn set_${e}(${t}, value: ${d}) {\n    set_${e}ByIndices(${v(n)}, value);\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push(w),t=!0),f.indicesToOffset&&(e.push(b),t=!0),f.broadcastedIndicesToOffset&&(Object.values(k).forEach(t=>e.push(t)),t=!0),f.set&&(e.push(C),t=!0),f.setByIndices&&(e.push(z),t=!0),f.get&&(e.push(E),t=!0),f.getByIndices&&(e.push(T),t=!0),!a&&t&&e.unshift(`const ${g} = ${h.indices}(${n.join(",")});`,`const ${_} = ${h.indices}(${ut.computeStrides(n).join(",")});`),e.join("\n")},type:h,offsetToIndices:t=>(f.offsetToIndices=!0,s<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,s<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let i=`${n.name}broadcastedIndicesTo${e}Offset`;if(i in k)return`${i}(${t})`;let r=[];for(let e=s-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-s);r.push(`${x(_,e)} * (${t} % ${x(g,e)})`)}return k[i]=`fn ${i}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${r.length>0?r.join("+"):"0u"};\n           }`,`${i}(${t})`},indices:v,indicesGet:x,indicesSet:(e,t,n)=>s<2?`${e}=${n};`:`${Kt(e,t,s)}=${n};`,set:(...t)=>{if(t.length!==s+1)throw new Error(`indices length must be ${s}`);let n=t[s];if("string"!=typeof n)throw new Error("value must be string");let i=t.slice(0,s).map(c).join(",");return 0===s?S("0u",n):1===s?S(i[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${i}, ${n})`)},setByOffset:S,setByIndices:(t,n)=>s<2?S(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==s)throw new Error(`indices length must be ${s}`);let n=t.map(c).join(",");return 0===s?I("0u"):1===s?I(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:I,getByIndices:t=>s<2?I(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:i,name:e,strides:_,shape:g,rank:s}},Qt=(e,t,n,i=1)=>Zt(e,t,n,"input",i),Xt=(e,t,n,i=1)=>Zt(e,t,n,"output",i),Yt=(e,t,n)=>Zt(e,t,n,"atomicOutput",1),Jt=(e,t,n,i=1)=>Zt(e,t,n,"internal",i),en=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=Nt){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],i="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${i})\n  fn main(${r?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${r?"let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${t*n*i}u + local_idx;`}\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",i="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${i}>;`}declareVariables(...e){return e.map(e=>this.declareVariable(e,this.variableIndex++)).join("\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:i}of this.uniforms)if(i&&i>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(i/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(i/4)}>`);else{let r=null==i||1===i?n:`vec${i}<${n}>`;e.push(`${t}:${r}`)}return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join("\n")+this.internalVariables.map(e=>e.impl()).join("\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},tn=(e,t)=>new en(e,t)}),dl=N(()=>{Ju(),nl(),ul(),ll(),nn=(e,t)=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(0!==t.length&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},rn=(e,t)=>0!==t.length?t:[...new Array(e).keys()].reverse(),an=(e,t)=>ut.sortBasedOnPerm(e,rn(e.length,t)),sn=(e,t,n,i)=>{let r=`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)r+=`a[${e[n]}]=i[${n}];`;return r+"return a;}"},on=(e,t)=>{let n=[],i=[];for(let r=0;r<e.length;++r)1!==e[r]&&n.push(e[r]),1!==e[t[r]]&&i.push(t[r]);return{newShape:n,newPerm:i}},un=(e,t)=>{let n=0;for(let i=0;i<e.length;++i)if(1!==t[e[i]]){if(e[i]<n)return!1;n=e[i]}return!0},ln=(e,t)=>{let n,i=e.dataType,r=e.dims.length,a=rn(r,t),s=an(e.dims,a),o=e.dims,u=s;if(r<2||un(a,e.dims))return n=e=>{let t=Qt("input",i,o,4),n=Xt("output",i,u,4);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    output[global_idx] = input[global_idx];\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=ut.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:l,newPerm:d}=on(e.dims,a),p=ut.areEqual(d,[2,3,1]),h=ut.areEqual(d,[3,1,2]);if(2===l.length||p||h){o=p?[l[0],l[1]*l[2]]:h?[l[0]*l[1],l[2]]:l,u=[o[1],o[0]];let t=16;return n=e=>{let n=Qt("a",i,o.length),r=Xt("output",i,u.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(n,r)}\n  var<workgroup> tile : array<array<${r.type.value}, ${t+1}>, ${t}>;\n  ${e.mainStart([t,t,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${r.setByIndices(`${r.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\n    }\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=ut.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(u[1]/t),y:Math.ceil(u[0]/t)},programUniforms:[{type:12,data:n},...Gt(o,u)]}},getShaderSource:n}}return n=e=>{let t=Qt("a",i,o.length),n=Xt("output",i,u.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n\n  ${sn(a,r,t,n)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${n.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=ut.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...Gt(o,u)]}},getShaderSource:n}},dn=(e,t)=>{nn(e.inputs,t.perm),e.compute(ln(e.inputs[0],t.perm))},pn=e=>Ut({perm:e.perm})}),pl=N(()=>{Ju(),nl(),ll(),hl(),dl(),hn={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},cn={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},fn={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},mn={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},gn=(e,t)=>{let n=[];for(let i=t-e;i<t;++i)n.push(i);return n},_n=(e,t)=>{let n=[],i=e.length;for(let r=0;r<i;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map(t=>e[t])]},yn=(e,t)=>{let n=e.length+t.length,i=[],r=0;for(let a=0;a<n;a++)-1===t.indexOf(a)?i.push(e[r++]):i.push(1);return i},wn=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},$n=(e,t)=>{let n=[];if(!wn(e,t)){for(let i=0;i<t;++i)-1===e.indexOf(i)&&n.push(i);e.forEach(e=>n.push(e))}return n},bn=(e,t,n,i,r,a,s)=>{let o=n[0].dims,u=ut.size(a),l=ut.size(s),d=Qt("_A",n[0].dataType,o),p=Xt("output",r,a),h=64;1===u&&(h=256);let c=`\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:["type"]},getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,p)}\n        ${c}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${fn[i]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${d.getByOffset("offset + k")});\n           bestValue = ${hn[i]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${cn[i]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${p.setByOffset("outputIndex","mean"===i?`${p.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${p.type.storage}(${mn[i]})`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:u},programUniforms:[{type:12,data:l}]})}},vn=(e,t,n,i)=>{let r=1===e.inputs.length?n:Mn(e.inputs,n),a=r.axes;0===a.length&&!r.noopWithEmptyAxes&&(a=e.inputs[0].dims.map((e,t)=>t));let s=ut.normalizeAxes(a,e.inputs[0].dims.length),o=s,u=e.inputs[0],l=$n(o,e.inputs[0].dims.length);l.length>0&&(u=e.compute(ln(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],o=gn(o.length,u.dims.length));let[d,p]=_n(u.dims,o),h=d;r.keepDims&&(h=yn(d,s)),e.compute(bn(t,r.cacheKey,[u],i,e.inputs[0].dataType,h,p),{inputs:[u]})},xn=(e,t)=>{vn(e,"ReduceMeanShared",t,"mean")},kn=(e,t)=>{vn(e,"ReduceL1Shared",t,"l1")},Sn=(e,t)=>{vn(e,"ReduceL2Shared",t,"l2")},In=(e,t)=>{vn(e,"ReduceLogSumExpShared",t,"logSumExp")},Tn=(e,t)=>{vn(e,"ReduceMaxShared",t,"max")},En=(e,t)=>{vn(e,"ReduceMinShared",t,"min")},zn=(e,t)=>{vn(e,"ReduceProdShared",t,"prod")},Cn=(e,t)=>{vn(e,"ReduceSumShared",t,"sum")},On=(e,t)=>{vn(e,"ReduceSumSquareShared",t,"sumSquare")},Bn=(e,t)=>{vn(e,"ReduceLogSumShared",t,"logSum")}}),hl=N(()=>{Ju(),nl(),ul(),ll(),pl(),An=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},Rn=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Dn=(e,t,n,i,r,a,s=!1,o=!1)=>{let u=[],l=n[0].dims,d=l.length,p=ut.normalizeAxes(r,d),h=!o&&0===p.length;l.forEach((e,t)=>{h||p.indexOf(t)>=0?s&&u.push(1):u.push(e)});let c=u.length,f=ut.size(u);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],r=Qt("_A",n[0].dataType,d),o=Xt("output",a,c),u=i(r,o,p),f=u[2];for(let e=0,n=0;e<d;e++)h||p.indexOf(e)>=0?(s&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${l[e]}; j${e}++) {\n                  ${u[2].includes("last_index")?`let last_index = j${e};`:""}\n                  ${r.indicesSet("input_indices",e,`j${e}`)}\n                  ${f}\n                }`):(t.push(`${r.indicesSet("input_indices",e,o.indicesGet("output_indices",n))};`),n++);return`\n\n        ${e.registerUniform("output_size","u32").declareVariables(r,o)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${r.type.indices};\n          let output_indices = ${o.offsetToIndices("global_idx")};\n\n          ${t.join("\n")}\n          ${u[0]}       // init ops for reduce max/min\n          ${u[1]}\n          ${f}\n          ${u[3]}\n          ${4===u.length?o.setByOffset("global_idx","value"):u.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Gt(l,u)]})}},Mn=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(e=>n.push(Number(e))),Ut({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Pn=(e,t,n,i)=>{let r=e.inputs,a=1===r.length?n:Mn(r,n);e.compute(Dn(t,{hint:a.cacheKey,inputDependencies:["rank"]},[r[0]],a.noopWithEmptyAxes&&0===a.axes.length?Rn:i,a.axes,r[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},Un=(e,t)=>{An(e.inputs),Pn(e,"ReduceLogSum",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"])},Nn=(e,t)=>{An(e.inputs),Pn(e,"ReduceL1",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""])},qn=(e,t)=>{An(e.inputs),Pn(e,"ReduceL2",t,(e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Vn=(e,t)=>{An(e.inputs),Pn(e,"ReduceLogSumExp",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"])},Ln=(e,t)=>{An(e.inputs),Pn(e,"ReduceMax",t,(e,t,n)=>{let i=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&i.push(e.indicesSet("input_indices",t,0));return[`${i.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]})},Gn=(e,t)=>{An(e.inputs),Pn(e,"ReduceMean",t,(t,n,i)=>{let r=1;for(let n=0;n<t.rank;n++)(i.indexOf(n)>=0||0===i.length)&&(r*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${r});`]})},Wn=(e,t)=>{An(e.inputs),Pn(e,"ReduceMin",t,(e,t,n)=>{let i=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&i.push(`input_indices[${t}] = 0;`);return[`${i.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]})},Hn=(e,t)=>{An(e.inputs),Pn(e,"ReduceProd",t,(e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""])},Fn=(e,t)=>{An(e.inputs),Pn(e,"ReduceSum",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""])},jn=(e,t)=>{An(e.inputs),Pn(e,"ReduceSumSquare",t,(e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""])},Kn=(e,t,n)=>{if(0===t.length)return n;let i=1,r=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?i*=e[n]:r*=e[n];return r<32&&i>1024},Zn=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Gn(e,t):xn(e,t)},Qn=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nn(e,t):kn(e,t)},Xn=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?qn(e,t):Sn(e,t)},Yn=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Vn(e,t):In(e,t)},Jn=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ln(e,t):Tn(e,t)},ei=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Wn(e,t):En(e,t)},ti=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hn(e,t):zn(e,t)},ni=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fn(e,t):Cn(e,t)},ii=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jn(e,t):On(e,t)},ri=(e,t)=>{Kn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Un(e,t):Bn(e,t)}}),cl=N(()=>{Ju(),ul(),hl(),ai=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},si=(e,t)=>{ai(e.inputs),e.compute(Dn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],(e,n,i)=>{let r=[];for(let t=0;t<e.rank;t++)(i.indexOf(t)>=0||0===i.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]},[t.axis],7,t.keepDims),{inputs:[0]})},oi=(e,t)=>{ai(e.inputs),e.compute(Dn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],(e,n,i)=>{let r=[];for(let t=0;t<e.rank;t++)(i.indexOf(t)>=0||0===i.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]},[t.axis],7,t.keepDims),{inputs:[0]})},ui=e=>Ut(e)}),fl=N(()=>{Ju(),nl(),sl(),ll(),li=(e,t)=>{let n=e[0],i=e[1],r=e[2],a=e[3],s=e[4],o=e[5];if(s&&o)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error('Input "input" must have 3 dimensions');let u=n.dims[0],l=n.dims[1],d=n.dims[2];if(1!==r.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==i.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let p=r.dims[0]/3,h=p,c=h;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");p=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],c=t.qkvHiddenSizes[2]}let f=l;if(p!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==p+h+c)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let m=0;if(s){if(h!==c)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==s.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==s.dims[0])throw new Error('Input "past" first dimension must be 2');if(s.dims[1]!==u)throw new Error('Input "past" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(s.dims[4]!==h/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(m=s.dims[3])}let g=f+m;if(a)throw new Error("Mask not supported");if(s)throw new Error("past is not supported");if(o){if(4!==o.dims.length)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==u||o.dims[1]!==t.numHeads||o.dims[2]!==l||o.dims[3]!==g)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:u,sequenceLength:l,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:g,maxSequenceLength:-1,inputHiddenSize:d,hiddenSize:p,vHiddenSize:c,headSize:Math.floor(p/t.numHeads),vHeadSize:Math.floor(c/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},di=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\n    let present_sequence_length = total_sequence_length;\n    `,pi=(e,t,n,i,r,a,s,o)=>{let u=Wt(s?1:a),l=64,d=a/u;d<l&&(l=32);let p=Math.ceil(a/u/l),h=[{type:12,data:t},{type:12,data:n},{type:12,data:i},{type:12,data:r},{type:12,data:d},{type:12,data:p}],c=Vt(e.dataType,u),f=Lt(1,u),m=["type"];return s&&m.push("type"),o&&m.push("type"),{name:"AttentionProbsSoftmax",shaderCache:{hint:`${l};${c};${u}`,inputDependencies:m},getShaderSource:t=>{let n=Xt("x",e.dataType,e.dims,u),i=[n],r=s?Qt("seq_lens",s.dataType,s.dims):void 0;r&&i.push(r);let a=o?Qt("total_sequence_length_input",o.dataType,o.dims):void 0;a&&i.push(a);let d=Lt(e.dataType);return`\n  var<workgroup> thread_max: array<f32, ${l}>;\n  var<workgroup> thread_sum: array<f32, ${l}>;\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...i)}\n  ${t.mainStart([l,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${di(r,a,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${l}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${s?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\n    var thread_max_vector = ${f}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(u){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${u}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${l}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${f}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(u){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${u}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${l}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${n.type.value}(${d}(1.0) / ${d}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${f}(x[offset + i]);\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${s?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${n.type.value}(${d}(0));\n        }`:""};\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:r,z:t*n},programUniforms:h})}},hi=(e,t,n,i,r,a,s,o,u)=>{let l=s+a.kvSequenceLength,d=[a.batchSize,a.numHeads,a.sequenceLength,l],p=e>1&&i,h=a.kvNumHeads?a.kvNumHeads:a.numHeads,c=p?[a.batchSize,h,l,a.headSize]:void 0,f=a.nReps?a.nReps:1,m=0===a.scale?1/Math.sqrt(a.headSize):a.scale,g=Wt(a.headSize),_=a.headSize/g,y={x:Math.ceil(l/12),y:Math.ceil(a.sequenceLength/12),z:a.batchSize*a.numHeads},w=[{type:12,data:a.sequenceLength},{type:12,data:_},{type:12,data:l},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:m},{type:12,data:s},{type:12,data:a.kvSequenceLength},{type:12,data:f}],$=p&&i&&ut.size(i.dims)>0,b=["type","type"];$&&b.push("type"),r&&b.push("type"),o&&b.push("type"),u&&b.push("type");let v=[{dims:d,dataType:t.dataType,gpuDataType:0}];return p&&v.push({dims:c,dataType:t.dataType,gpuDataType:0}),{name:"AttentionProbs",shaderCache:{hint:`${g};${void 0!==r};${void 0!==i};${e}`,inputDependencies:b},getRunData:()=>({outputs:v,dispatchGroup:y,programUniforms:w}),getShaderSource:e=>{let a=Qt("q",t.dataType,t.dims,g),s=[a,Qt("key",n.dataType,n.dims,g)];if($){let e=Qt("past_key",i.dataType,i.dims,g);s.push(e)}r&&s.push(Qt("attention_bias",r.dataType,r.dims));let l=o?Qt("seq_lens",o.dataType,o.dims):void 0;l&&s.push(l);let h=u?Qt("total_sequence_length_input",u.dataType,u.dims):void 0;h&&s.push(h);let m=Xt("output",t.dataType,d),_=[m];p&&_.push(Xt("present_key",t.dataType,c,g));let y=Lt(1,g);return`\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${a.type.storage}, 144>;\n  var<workgroup> tileK: array<${a.type.storage}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...s,..._)}\n  ${e.mainStart([12,12,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${di(l,h,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${$&&p?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${p?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\n    var value = ${y}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${$&&p?"\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }":"\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }"}\n      ${p?"if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }":""}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(g){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${g}`)}})()};\n        output[outputIdx] = ${m.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};\n    }\n  }`}}},ci=(e,t,n,i,r,a,s=void 0,o=void 0)=>{let u=a+r.kvSequenceLength,l=r.nReps?r.nReps:1,d=r.vHiddenSize*l,p=e>1&&i,h=r.kvNumHeads?r.kvNumHeads:r.numHeads,c=p?[r.batchSize,h,u,r.headSize]:void 0,f=[r.batchSize,r.sequenceLength,d],m={x:Math.ceil(r.vHeadSize/12),y:Math.ceil(r.sequenceLength/12),z:r.batchSize*r.numHeads},g=[{type:12,data:r.sequenceLength},{type:12,data:u},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:d},{type:12,data:a},{type:12,data:r.kvSequenceLength},{type:12,data:l}],_=p&&i&&ut.size(i.dims)>0,y=["type","type"];_&&y.push("type"),s&&y.push("type"),o&&y.push("type");let w=[{dims:f,dataType:t.dataType,gpuDataType:0}];return p&&w.push({dims:c,dataType:t.dataType,gpuDataType:0}),{name:"AttentionScore",shaderCache:{hint:`${void 0!==i};${e}`,inputDependencies:y},getRunData:()=>({outputs:w,dispatchGroup:m,programUniforms:g}),getShaderSource:e=>{let r=Qt("probs",t.dataType,t.dims),a=[r,Qt("v",n.dataType,n.dims)];_&&a.push(Qt("past_value",i.dataType,i.dims));let u=s?Qt("seq_lens",s.dataType,s.dims):void 0;s&&a.push(u);let d=o?Qt("total_sequence_length_input",o.dataType,o.dims):void 0;o&&a.push(d);let h=[Xt("output",t.dataType,f)];return p&&h.push(Xt("present_value",t.dataType,c)),`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${r.type.value}, 144>;\n  var<workgroup> tileV: array<${r.type.value}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...h)}\n  ${e.mainStart([12,12,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${1===l?"headIdx":"headIdx / uniforms.n_reps"};\n   let kv_num_heads = ${1===l?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${di(u,d,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${_&&p?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${p?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\n   var value = ${r.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${_&&p?"\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      ":"\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }"}\n        ${p?"\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }":""}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},fi=(e,t,n,i,r,a,s,o,u,l,d=void 0,p=void 0)=>{let h=Math.min(e.outputCount,1+(s?1:0)+(o?1:0)),c=h>1?l.pastSequenceLength:0,f=c+l.kvSequenceLength,m=u&&ut.size(u.dims)>0?u:void 0,g=[t,n];h>1&&s&&ut.size(s.dims)>0&&g.push(s),m&&g.push(m),d&&g.push(d),p&&g.push(p);let _=e.compute(hi(h,t,n,s,m,l,c,d,p),{inputs:g,outputs:h>1?[-1,1]:[-1]})[0];e.compute(pi(_,l.batchSize,l.numHeads,c,l.sequenceLength,f,d,p),{inputs:d&&p?[_,d,p]:[_],outputs:[]});let y=[_,i];h>1&&o&&ut.size(o.dims)>0&&y.push(o),d&&y.push(d),p&&y.push(p),e.compute(ci(h,_,i,o,l,c,d,p),{inputs:y,outputs:h>1?[0,2]:[0]})},mi=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],i=t.sequenceLength,r=t.inputHiddenSize,a=t.headSize,s={x:Math.ceil(t.headSize/12),y:Math.ceil(t.sequenceLength/12),z:t.batchSize*t.numHeads},o=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:i},{type:12,data:r},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:s,programUniforms:u}),getShaderSource:e=>{let t=Xt("output_q",o[0].dataType,n),i=Xt("output_k",o[0].dataType,n),r=Xt("output_v",o[0].dataType,n),a=Qt("input",o[0].dataType,o[0].dims),s=Qt("weight",o[1].dataType,o[1].dims),u=Qt("bias",o[2].dataType,o[2].dims),l=a.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${l}, 144>;\n  var<workgroup> tileWeightQ: array<${l}, 144>;\n  var<workgroup> tileWeightK: array<${l}, 144>;\n  var<workgroup> tileWeightV: array<${l}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(a,s,u,t,i,r)}\n  ${e.mainStart([12,12,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${l}(0);\n    var valueK = ${l}(0);\n    var valueV = ${l}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:o,outputs:[-1,-1,-1]})},gi=(e,t)=>{let n=li(e.inputs,t),[i,r,a]=mi(e,n);return fi(e,i,r,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),ml=N(()=>{oe(),Ju(),nl(),ul(),ll(),_i=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let i=t.length;if(i!==e.length)throw new Error(`${n}: num dimensions != ${i}`);t.forEach((t,i)=>{if(t!==e[i])throw new Error(`${n}: dim[${i}] do not match`)})};if(e[0].dims.length>1){let i="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,i,"Invalid input scale"),n(e[2].dims,i,"Invalid input B"),n(e[3].dims,i,"Invalid input mean"),n(e[4].dims,i,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},yi=(e,t)=>{let{epsilon:n,spatial:i,format:r}=t,a=e[0].dims,s=i?Wt(a[a.length-1]):1,o="NHWC"===r&&a.length>1?s:1,u=ut.size(a)/s,l=i,d=l?a.length:a,p=Qt("x",e[0].dataType,e[0].dims,s),h=Qt("scale",e[1].dataType,e[1].dims,o),c=Qt("bias",e[2].dataType,e[2].dims,o),f=Qt("inputMean",e[3].dataType,e[3].dims,o),m=Qt("inputVar",e[4].dataType,e[4].dims,o),g=Xt("y",e[0].dataType,d,s);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${i}_${s}`,inputDependencies:l?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\n  const epsilon = ${n};\n  ${e.registerUniform("outputSize","u32").declareVariables(p,h,c,f,m,g)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${g.offsetToIndices(`global_idx * ${s}`)};\n    ${(()=>{let e="";if(i)e=`let cOffset = ${1===a.length?"0u":"NHWC"===r?`outputIndices[${a.length-1}] / ${s}`:"outputIndices[1]"};`;else if("NCHW"===r)e=`\n            ${g.indicesSet("outputIndices","0","0")}\n            let cOffset = ${g.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let t=1;t<h.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return e})()}\n    let scale = ${h.getByOffset("cOffset")};\n    let bias = ${c.getByOffset("cOffset")};\n    let inputMean = ${f.getByOffset("cOffset")};\n    let inputVar = ${m.getByOffset("cOffset")};\n    let x = ${p.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${g.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l?[{type:12,data:u},...Gt(a)]:[{type:12,data:u}]})}},wi=e=>Ut(e),$i=(e,t)=>{let{inputs:n,outputCount:i}=e,r=wi({...t,outputCount:i});if(l.webgpu.validateInputContent&&_i(n,r),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(yi(n,r))}}),gl=N(()=>{nl(),ll(),bi=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},vi=e=>{let t=e[0].dims,n=e[0].dims[2],i=ut.size(t)/4,r=e[0].dataType,a=Qt("input",r,t,4),s=Qt("bias",r,[n],4),o=Qt("residual",r,t,4),u=Xt("output",r,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(a,s,o,u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let value = ${a.getByOffset("global_idx")}\n      + ${s.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx","value")}\n  }`}},xi=e=>{bi(e.inputs),e.compute(vi(e.inputs))}}),_l=N(()=>{Ju(),nl(),ul(),ll(),ki=(e,t,n,i,r,a,s)=>{let o=Math.ceil(t/4),u="";u="string"==typeof r?`${r}(a)`:r("a");let l=Qt("inputData",n,[o],4),d=Xt("outputData",i,[o],4),p=[{name:"vec_size",type:"u32"}];return s&&p.push(...s),`\n      ${e.registerUniforms(p).declareVariables(l,d)}\n\n  ${a??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${l.getByOffset("global_idx")};\n    ${d.setByOffset("global_idx",u)}\n  }`},Si=(e,t,n,i,r,a=e.dataType,s,o)=>{let u=[{type:12,data:Math.ceil(ut.size(e.dims)/4)}];return s&&u.push(...s),{name:t,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:t=>ki(t,ut.size(e.dims),e.dataType,a,n,i,o),getRunData:t=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(ut.size(t[0].dims)/64/4)},programUniforms:u})}},Ii=e=>{e.compute(Si(e.inputs[0],"Abs","abs"))},Ti=e=>{e.compute(Si(e.inputs[0],"Acos","acos"))},Ei=e=>{e.compute(Si(e.inputs[0],"Acosh","acosh"))},zi=e=>{e.compute(Si(e.inputs[0],"Asin","asin"))},Ci=e=>{e.compute(Si(e.inputs[0],"Asinh","asinh"))},Oi=e=>{e.compute(Si(e.inputs[0],"Atan","atan"))},Bi=e=>{e.compute(Si(e.inputs[0],"Atanh","atanh"))},Ai=e=>Ut(e),Ri=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Si(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Di=e=>{let t,n,i=e.length>=2&&0!==e[1].data,r=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=i?e[1].getFloat32Array()[0]:-34028234663852886e22,n=r?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=i?e[1].getUint16Array()[0]:64511,n=r?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Ut({min:t,max:n})},Mi=(e,t)=>{let n=t||Di(e.inputs),i=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Clip",e=>`clamp(${e}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},Pi=e=>{e.compute(Si(e.inputs[0],"Ceil","ceil"))},Ui=e=>{e.compute(Si(e.inputs[0],"Cos","cos"))},Ni=e=>{e.compute(Si(e.inputs[0],"Cosh","cosh"))},qi=e=>Ut(e),Vi=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Elu",e=>`elu_vf32(${e})`,`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Li=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Gi=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Erf",e=>`erf_vf32(${e})`,Li(t)))},Wi=e=>{e.compute(Si(e.inputs[0],"Exp","exp"))},Hi=e=>{e.compute(Si(e.inputs[0],"Floor","floor"))},Fi=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Gelu",e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`,Li(t)))},ji=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"LeakyRelu",e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Ki=e=>{e.compute(Si(e.inputs[0],"Not",e=>`!${e}`))},Zi=e=>{e.compute(Si(e.inputs[0],"Neg",e=>`-${e}`))},Qi=e=>{e.compute(Si(e.inputs[0],"Reciprocal",e=>`1.0/${e}`))},Xi=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Relu",e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`))},Yi=e=>{e.compute(Si(e.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},Ji=e=>Ut(e),er=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"HardSigmoid",e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},tr=e=>{e.compute(Si(e.inputs[0],"Sin","sin"))},nr=e=>{e.compute(Si(e.inputs[0],"Sinh","sinh"))},ir=e=>{e.compute(Si(e.inputs[0],"Sqrt","sqrt"))},rr=e=>{e.compute(Si(e.inputs[0],"Tan","tan"))},ar=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,sr=e=>{e.compute(Si(e.inputs[0],"Tanh",ar))},or=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${ar("v")};\n}\n`,ur=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,lr=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"FastGelu",ur,or(t),void 0,e.inputs[0].dataType))},dr=(e,t)=>{let n=Lt(e.inputs[0].dataType);return e.compute(Si(e.inputs[0],"ThresholdedRelu",e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},pr=e=>{e.compute(Si(e.inputs[0],"Log","log"))},hr=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,cr=e=>`quick_gelu_impl(${e})`,fr=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"QuickGelu",cr,hr(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),yl=N(()=>{nl(),ll(),_l(),mr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},gr=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=Qt("input",e[0].dataType,e[0].dims,4),i=Qt("bias",e[0].dataType,[e[0].dims[2]],4),r=Xt("output",e[0].dataType,t,4),a=ut.size(t)/4,s=Vt(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,i,r)}\n\n  ${Li(s)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${r.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},_r=e=>{mr(e.inputs),e.compute(gr(e.inputs))}}),wl=N(()=>{Ju(),nl(),ll(),yr=(e,t,n,i,r,a,s,o,u,l,d,p)=>{let h,c;"string"==typeof o?h=c=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?h=c=o:(h=o.scalar,c=o.vector);let f,m=Xt("outputData",d,i.length,4),g=Qt("aData",u,t.length,4),_=Qt("bData",l,n.length,4);if(r)if(a){let e=1===ut.size(t),i=1===ut.size(n),r=t.length>0&&t[t.length-1]%4==0,a=n.length>0&&n[n.length-1]%4==0;f=e||i?m.setByOffset("global_idx",c(e?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"),i?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"))):`\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${g.broadcastedIndicesToOffset("outputIndices",m)};\n            let offsetB = ${_.broadcastedIndicesToOffset("outputIndices",m)};\n            ${m.setByOffset("global_idx",c(s||r?g.getByOffset("offsetA / 4u"):`${g.type.value}(${g.getByOffset("offsetA / 4u")}[offsetA % 4u])`,s||a?_.getByOffset("offsetB / 4u"):`${_.type.value}(${_.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else f=m.setByOffset("global_idx",c(g.getByOffset("global_idx"),_.getByOffset("global_idx")));else{if(!a)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let i=`aData[indexA${t}][componentA${t}]`,r=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let offsetB${t} = ${_.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${h(i,r)});\n          `};f=9===d?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(g,_,m)}\n\n        ${p??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${f}\n      }`},wr=(e,t,n,i,r,a,s=n.dataType)=>{let o=n.dims.map(e=>Number(e)??1),u=i.dims.map(e=>Number(e)??1),l=!ut.areEqual(o,u),d=o,p=ut.size(o),h=!1,c=!1,f=[l];if(l){let e=ot.calcShape(o,u,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");d=e.slice(),p=ut.size(d);let t=1===ut.size(o),n=1===ut.size(u),i=o.length>0&&o[o.length-1]%4==0,r=u.length>0&&u[u.length-1]%4==0;f.push(t),f.push(n),f.push(i),f.push(r);let a=1;for(let e=1;e<d.length;e++){let t=o[o.length-e];if(t!==u[u.length-e])break;a*=t}a%4==0?(c=!0,h=!0):(t||n||i||r)&&(h=!0)}else h=!0;return f.push(h),{name:e,shaderCache:{hint:t+f.map(e=>e.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>yr(e,o,u,d,h,l,c,r,n.dataType,i.dataType,s,a),getRunData:()=>({outputs:[{dims:d,dataType:s}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:Math.ceil(ut.size(d)/4)},...Gt(o,u,d)]})}},$r=(e,t,n,i,r,a)=>{e.compute(wr(t,r??"",e.inputs[0],e.inputs[1],n,i,a))},br=e=>{$r(e,"Add",(e,t)=>`${e}+${t}`)},vr=e=>{$r(e,"Div",(e,t)=>`${e}/${t}`)},xr=e=>{$r(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},kr=e=>{$r(e,"Mul",(e,t)=>`${e}*${t}`)},Sr=e=>{let t=Qt("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;$r(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ir=e=>{$r(e,"Sub",(e,t)=>`${e}-${t}`)},Tr=e=>{$r(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Er=e=>{$r(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},zr=e=>{$r(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Cr=e=>{$r(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}}),$l=N(()=>{Ju(),nl(),ul(),ll(),Or=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],i=n.dataType,r=n.dims.length;e.forEach((e,a)=>{if(0!==a){if(e.dataType!==i)throw new Error("input tensors should be one type");if(e.dims.length!==r)throw new Error("input tensors should have the same shape");e.dims.forEach((e,i)=>{if(i!==t&&e!==n.dims[i])throw new Error("non concat dimensions must match")})}})},Br=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Ar=(e,t)=>{let n=e.length,i=[];for(let r=0;r<n;++r){let a=t.setByOffset("global_idx",e[r].getByIndices("indices"));1===n?i.push(a):0===r?i.push(`if (inputIndex == ${r}u) { ${a} }`):r===n-1?i.push(`else { ${a} }`):i.push(`else if (inputIndex == ${r}) { ${a} }`)}return i.join("\n")},Rr=(e,t,n,i)=>{let r=ut.size(n),a=new Array(e.length),s=new Array(e.length),o=0,u=[],l=[],d=[{type:12,data:r}];for(let n=0;n<e.length;++n)o+=e[n].dims[t],a[n]=o,l.push(e[n].dims.length),s[n]=Qt(`input${n}`,i,l[n]),u.push("rank"),d.push({type:12,data:a[n]});for(let t=0;t<e.length;++t)d.push(...Gt(e[t].dims));d.push(...Gt(n));let p=Xt("output",i,n.length),h=p.indicesGet("indices",t),c=Array.from(Array(a.length).keys()).map(e=>`uniforms.sizeInConcatAxis${e}`).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:n,dataType:i}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:d}),getShaderSource:t=>`\n\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...s,p)})()}\n\n  ${Br(a.length,c)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${p.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${c});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Ar(s,p)}\n  }`}},Dr=(e,t)=>{let n=e.inputs,i=n[0].dims,r=ut.normalizeAxis(t.axis,i.length);Or(n,r);let a=i.slice();a[r]=n.reduce((e,t)=>e+(t.dims.length>r?t.dims[r]:0),0);let s=n.filter(e=>ut.size(e.dims)>0);e.compute(Rr(s,r,a,n[0].dataType),{inputs:s})},Mr=e=>Ut({axis:e.axis})}),bl=N(()=>{Ju(),nl(),Pr=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ur=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},Nr=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},qr=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,i]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:i}}if("Clip"===t){let[n,i]=e?.activation_params||[pt,ht];return{activation:t,clipMax:i,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}}),vl=N(()=>{Vr=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Lr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `}),xl=N(()=>{Gr=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`}),kl=N(()=>{Ju(),nl(),ll(),bl(),Wr=(e,t,n,i,r)=>{let a=i-n;return`\n      ${Array.from({length:n}).map((n,s)=>`\n      if (${Kt(t.shape,s,t.rank)} != 1) {\n        ${t.indicesSet(e,s,Kt(r,s+a,i))}\n      } else {\n        ${t.indicesSet(e,s,0)}\n      }`).join("")}\n`},Hr=(e,t,n,i,r=!1,a)=>{let s=e[0].dims,o=e[1].dims,u=s[s.length-2],l=o[o.length-1],d=s[s.length-1],p=Wt(l),h=Wt(d),c=Wt(u),f=ut.size(n)/p/c,m=e.length>2,g=i?i.slice(0,-2):n.slice(0,-2),_=[ut.size(g),u,l],y=[{type:12,data:f},{type:12,data:u},{type:12,data:l},{type:12,data:d}];return Ur(t,y),y.push(...Gt(g,s,o)),m&&y.push(...Gt(e[2].dims)),y.push(...Gt(_)),{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${p};${h};${c};${r}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:y}),getShaderSource:i=>{let a=Jt("batch_dims",e[0].dataType,g.length),u=Qt("a",e[0].dataType,s.length,h),l=Qt("b",e[1].dataType,o.length,p),d=Xt("output",e[0].dataType,_.length,p),f=Vt(d.type.tensor),y=Pr(t,d.type.value,f),w=[u,l],$="";if(m){let t=r?p:1;w.push(Qt("bias",e[2].dataType,e[2].dims.length,t)),$=r?`value += bias[col / ${t}];`:`value += ${d.type.value}(bias[row + i]);`}let b=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];return Nr(t,b),`\n  ${i.registerUniforms(b).registerInternalVariables(a).declareVariables(...w,d)}\n  ${i.mainStart()}\n    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${p})) * ${p};\n    var index1 = global_idx / (uniforms.N / ${p});\n    let stride1 = uniforms.M / ${c};\n    let row = (index1 % stride1) * ${c};\n    let batch = index1 / stride1;\n\n    ${2===n.length?"":`let batch_indices = ${a.offsetToIndices("batch")};`}\n\n    var a_indices: ${u.type.indices};\n    ${Wr("a_indices",u,u.rank-2,a.rank,"batch_indices")}\n    ${u.indicesSet("a_indices",u.rank-2,0)}\n    ${u.indicesSet("a_indices",u.rank-1,0)}\n    let a_offset = ${u.indicesToOffset("a_indices")};\n\n    var b_indices: ${l.type.indices};\n    ${Wr("b_indices",l,l.rank-2,a.rank,"batch_indices")}\n    ${l.indicesSet("b_indices",l.rank-2,0)}\n    ${l.indicesSet("b_indices",l.rank-1,0)}\n    let b_offset = ${l.indicesToOffset("b_indices")};\n    var values: array<${d.type.value}, ${c}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${(()=>{let e=`var a_data: ${u.type.value};`;for(let t=0;t<h;t++)e+=`\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${p}];`;for(let t=0;t<c;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${h}];`;for(let n=0;n<h;n++)e+=`\n            values[${t}] = fma(${l.type.value}(a_data${1===h?"":`[${n}]`}), b_data${n}, values[${t}]);\n`}return e})()}\n    }\n    for (var i = 0u; i < ${c}u; i++) {\n      var value = values[i];\n      ${$}\n      ${y}\n      let cur_indices = ${d.type.indices}(batch, row + i, col);\n      let offset = ${d.indicesToOffset("cur_indices")};\n      ${d.setByOffset(`offset / ${p}`,"value")};\n    }\n  }\n  `}}}}),Sl=N(()=>{Ju(),nl(),ll(),bl(),kl(),vl(),Fr=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,jr=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Kr=(e,t,n="f32",i,r=!1,a=32,s=!1,o=32)=>{let u=t[1]*e[1],l=t[0]*e[0],d=r?u:a,p=r?a:u,h=d/t[0],c=a/t[1];if((!r||4!==h||4!==e[1])&&(r||3!==h&&4!==h)||d%t[0]!==0||a%t[1]!==0||4!==e[0])throw new Error(`If transposeA ${r} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${h}<${n}>, ${d/h}>, ${p}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${s?"0":"i32(globalId.z)"};\n  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let num_tiles = ${s?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${c};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Fr(r,i)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===h?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${jr(r,h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Zr=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Qr=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Xr=(e,t,n="f32",i,r=!1,a=32,s=!1,o=32,u=!1)=>{let l=e[1]*t[1],d=e[0]*t[0],p=r?l:a,h=r?a:l;if(h%t[1]!==0||p%t[0]!==0||a%t[1]!==0)throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let c=h/t[1],f=p/t[0],m=a/t[1],g=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${t[0]}) {\n          ${Zr(r,i)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${i?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${c};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Zr(r,i)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${i?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Qr(r)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${p}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${s?"0":"i32(globalId.z)"};\n    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${s?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${g}\n  }\n`},Yr=(e,t,n,i,r=!1)=>{let[a,s,o,u]=i,l=Vt(i[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Vr(e,l)} {\n      var value = ${Vr(e,l)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${s.type.indices};\n        ${Wr("aIndices",s,s.rank-2,a.rank,"batchIndices")}\n        ${s.indicesSet("aIndices",s.rank-2,"u32(row)")}\n        ${s.indicesSet("aIndices",s.rank-1,"u32(colIn)")}\n        value = ${s.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Vr(e,l)} {\n      var value = ${Vr(e,l)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${o.type.indices};\n        ${Wr("bIndices",o,o.rank-2,a.rank,"batchIndices")}\n        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}\n        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}\n        value = ${o.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Vr(e,l)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${r?"bias[colIn]":`${Vr(e,l)}(bias[row])`};`:""}\n        ${n}\n        ${u.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Jr=(e,t,n,i,r=!1,a)=>{let s=e[0].dims,o=e[1].dims,u=s.slice(0,-2),l=o.slice(0,-2),d=i?i.slice(0,-2):n.slice(0,-2),p=ut.size(d),h=s[s.length-2],c=s[s.length-1],f=o[o.length-1],m=c%4==0&&f%4==0,g=h<=8?[4,1,1]:[4,4,1],_=[8,8,1],y=[Math.ceil(f/_[0]/g[0]),Math.ceil(h/_[1]/g[1]),Math.ceil(p/_[2]/g[2])],w=m?4:1,$=[...u,h,c/w],b=$.length,v=[...l,c,f/w],x=v.length,k=[p,h,f/w],S=[{type:6,data:h},{type:6,data:f},{type:6,data:c}];Ur(t,S),S.push(...Gt(d,$,v));let I=["rank","rank"],T=e.length>2;return T&&(S.push(...Gt(e[2].dims)),I.push("rank")),S.push(...Gt(k)),{name:"MatMul",shaderCache:{hint:`${g};${t.activation};${m};${r}`,inputDependencies:I},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:y[0],y:y[1],z:y[2]},programUniforms:S}),getShaderSource:n=>{let i=d.length,a=Jt("batchDims",e[0].dataType,i,1),s=Vt(e[0].dataType),o=Qt("a",e[0].dataType,b,w),u=Qt("b",e[1].dataType,x,w),l=Xt("result",e[0].dataType,k.length,w),p=[o,u];if(T){let t=r?w:1;p.push(Qt("bias",e[2].dataType,e[2].dims.length,t))}let h=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Nr(t,h);let c=Vt(l.type.tensor),f=Pr(t,l.type.value,c),y=Yr(w,T,f,[a,o,u,l],r);return`\n  ${n.registerUniforms(h).registerInternalVariables(a).declareVariables(...p,l)}\n  ${y}\n  ${m?Kr(g,_,s,a):Xr(g,_,s,a)}\n                   `}}}}),Il=N(()=>{Ju(),tl(),ll(),bl(),vl(),xl(),Sl(),ea=(e,t,n,i,r=!1,a,s=4,o=4,u=4,l="f32")=>{let d=e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}},p=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",h=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",c=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",f=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",m=e?"row":"col",g=e?"col":"row",_=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${m} / outWidth;\n    let outCol = ${m} % outWidth;\n\n    let WRow = ${g} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${g} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${g} % inChannels;\n    var resData = ${Vr(s,l)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${c} && xCol >= 0 && xCol < ${f}) {\n      ${p}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(s)}\n    }\n    return resData;`,y=e?t&&i?`\n    let col = colIn * ${s};\n    ${_}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${_}\n    }\n    return ${Vr(s,l)}(0.0);`:i&&n?`\n    let col = colIn * ${s};\n    ${_}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${_}\n    }\n    return ${Vr(s,l)}(0.0);`,w=e?i&&n?d(o):`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${d(o)}\n    }\n    return ${Vr(o,l)}(0.0);`:`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${d(o)}\n    }\n    return ${Vr(o,l)}(0.0);`,$=Vr(u,l),b=Vr(e?s:o,l),v=Vr(e?o:s,l),x=Pr(a,$,l);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\n      ${e?y:w}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${v} {\n      ${e?w:y}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${$}) {\n      let col = colIn * ${u};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${h}\n      ${Lr(r)}\n      ${x}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ta=(e,t,n,i,r,a,s,o,u)=>{let l="NHWC"===t.format,d=l?e[0].dims[3]:e[0].dims[1],p=n[0],h=l?n[2]:n[3],c=l?n[1]:n[2],f=l?n[3]:n[1],m=l&&(d%4==0||d%3==0)&&f%4==0,g=l?f:h*c,_=l?h*c:f,y=[8,8,1],w=i<=8?[4,1,1]:[4,4,1],$=[Math.ceil(g/y[0]/w[0]),Math.ceil(_/y[1]/w[1]),Math.ceil(p/y[2]/w[2])];at("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${$}`);let b=m?l&&d%4!=0?3:4:1,v=y[1]*w[1],x=y[0]*w[0],k=Math.max(y[0]*b,y[1]),S=i%v===0,I=r%x===0,T=a%k===0,E=m?[b,4,4]:[1,1,1],z=[{type:6,data:i},{type:6,data:r},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ur(t,z),z.push(...Gt(e[0].dims,e[1].dims));let C=["rank","rank"];return s&&(z.push(...Gt(e[2].dims)),C.push("rank")),z.push(...Gt(n)),{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${b};${m};${S};${I};${T};${v};${x};${k}`,inputDependencies:C},getRunData:()=>({outputs:[{dims:u?u(n):n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]},programUniforms:z}),getShaderSource:i=>{let r=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Nr(t,r);let a=m?4:1,u=Vt(e[0].dataType),d=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${u}>`:u}) {\n        result[flatIndex] = ${m?`vec4<${u}>`:u}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${u}>`:u}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);\n      }`,p=[Qt("x",e[0].dataType,e[0].dims.length,3===b?1:b),Qt("w",e[1].dataType,e[1].dims.length,a)],h=Xt("result",e[0].dataType,n.length,a);if(s){let t=Qt("bias",e[2].dataType,e[2].dims.length,a);p.push(t),d+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${u}>`:u} {\n          return bias[coords.${l?"w":"y"}${m?"/ 4":""}];\n        }`}return`\n        ${Gr("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${i.registerUniforms(r).declareVariables(...p,h)}\n        ${d}\n        ${ea(l,S,I,T,s,t,E[0],E[1],E[2],u)}\n        ${m?Kr(w,y,u,void 0,!l,k):Xr(w,y,u,void 0,!l,k,!1,void 0,o)}`}}}}),Tl=N(()=>{Ju(),tl(),nl(),ll(),bl(),vl(),na=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},ia=e=>"number"==typeof e?[e,e,e]:e,ra=(e,t)=>t<=1?e:e+(e-1)*(t-1),aa=(e,t,n,i=1)=>{let r=ra(t,i);return Math.floor((e[0]*(n-1)-n+r)/2)},sa=(e,t,n,i,r)=>{null==r&&(r=aa(e,t[0],i[0]));let a=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*r>=t[n]&&(a[n]=Math.trunc((e[n]-t[n]+2*r)/i[n]+1));return a},oa=(e,t,n,i,r,a,s,o,u,l)=>{let d,p,h,c;if("VALID"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=sa([t,n,i,1],[o,u,l],1,[r,a,s],e);p=f[0],h=f[1],c=f[2]}else if(Array.isArray(e)){if(!e.every((e,t,n)=>e===n[0]))throw Error(`Unsupported padding parameter: ${e}`);d={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=sa([t,n,i,1],[o,u,l],1,[r,a,s],e[0]);p=f[0],h=f[1],c=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{p=Math.ceil(t/r),h=Math.ceil(n/a),c=Math.ceil(i/s);let e=(p-1)*r+o-t,f=(h-1)*a+u-n,m=(c-1)*s+l-i,g=Math.floor(e/2),_=e-g,y=Math.floor(f/2),w=f-y,$=Math.floor(m/2);d={top:y,bottom:w,left:$,right:m-$,front:g,back:_}}}return{padInfo:d,outDepth:p,outHeight:h,outWidth:c}},ua=(e,t,n,i,r,a=!1,s="channelsLast")=>{let o,u,l,d,p;if("channelsLast"===s)[o,u,l,d,p]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[o,p,u,l,d]=e}let[h,,c,f,m]=t,[g,_,y]=ia(n),[w,$,b]=ia(i),v=ra(c,w),x=ra(f,$),k=ra(m,b),{padInfo:S,outDepth:I,outHeight:T,outWidth:E}=oa(r,u,l,d,g,_,y,v,x,k),z=a?h*p:h,C=[0,0,0,0,0];return"channelsFirst"===s?C=[o,z,I,T,E]:"channelsLast"===s&&(C=[o,I,T,E,z]),{batchSize:o,dataFormat:s,inDepth:u,inHeight:l,inWidth:d,inChannels:p,outDepth:I,outHeight:T,outWidth:E,outChannels:z,padInfo:S,strideDepth:g,strideHeight:_,strideWidth:y,filterDepth:c,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:x,effectiveFilterWidth:k,dilationDepth:w,dilationHeight:$,dilationWidth:b,inShape:e,outShape:C,filterShape:t}},la=(e,t,n,i,r,a)=>{let s="channelsLast"===a,o=(s?e[0].dims[3]:e[0].dims[1],{x:n.map((e,t)=>t)}),u=[Math.ceil(na(o.x.map(e=>n[e]))/64),1,1];at("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let l=[{type:12,data:ut.size(n)},{type:12,data:i},{type:12,data:r},{type:12,data:t.strides},{type:12,data:t.dilations}];Ur(t,l),l.push(...Gt(e[0].dims,e[1].dims));let d=["rank","rank"],p=3===e.length;return p&&(l.push(...Gt(e[2].dims)),d.push("rank")),l.push(...Gt(n)),{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${s};1;${p}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:l}),getShaderSource:a=>{let o=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Nr(t,o);let u=Vt(e[0].dataType),l=Qt("x",e[0].dataType,e[0].dims.length,1),d=Qt("W",e[1].dataType,e[1].dims.length,1),h=[l,d],c=Xt("result",e[0].dataType,n.length,1),f="";if(p){let t=Qt("bias",e[2].dataType,e[2].dims.length,1);h.push(t),f+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${u} {\n          return bias[${Kt("coords",s?4:1,5)}];\n        }`}let m=Vr(1,u),g=Pr(t,m,u);return`\n            ${f}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${l.getByIndices("aIndices")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${d.getByIndices("aIndices")};\n            }\n          ${a.registerUniforms(o).declareVariables(...h,c)}\n          ${a.mainStart()}\n          ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n              let coords = ${c.offsetToIndices("global_idx")};\n              let batch = ${Kt("coords",0,l.rank)};\n              let d2 = ${Kt("coords",s?l.rank-1:1,l.rank)};\n              let xFRCCorner = vec3<u32>(${Kt("coords",s?1:2,l.rank)},\n              ${Kt("coords",s?2:3,l.rank)},\n              ${Kt("coords",s?3:4,l.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${Kt("uniforms.x_shape",s?1:2,l.rank)};\n              let xShapeZ = ${Kt("uniforms.x_shape",s?2:3,l.rank)};\n              let xShapeW = ${Kt("uniforms.x_shape",s?3:4,l.rank)};\n              let xShapeU = ${Kt("uniforms.x_shape",s?4:1,l.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${s?"let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            ":"let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            "}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${s?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${s?"let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      ":"let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    "}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${s?"let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      ":"let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    "}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${p?"value = value + getBiasByOutputCoords(coords)":""};\n              ${g}\n              result[global_idx] = f32(value);\n          }`}}}}),El=N(()=>{Ju(),nl(),ll(),bl(),da=(e,t,n,i)=>{let r=e.length>2,a=r?"value += b[output_channel];":"",s=e[0].dims,o=e[1].dims,u="NHWC"===t.format,l=u?n[3]:n[1],d=l/t.group,p=u&&d>=4?Wt(l):1,h=ut.size(n)/p,c=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:d}];Ur(t,c),c.push(...Gt(s,[o[0],o[1],o[2],o[3]/p]));let f=r?["rank","rank","rank"]:["rank","rank"];return c.push(...Gt([n[0],n[1],n[2],n[3]/p])),{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${p}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:c}),getShaderSource:i=>{let l=Xt("output",e[0].dataType,n.length,p),d=Vt(l.type.tensor),h=Pr(t,l.type.value,d),c=Qt("x",e[0].dataType,s.length),f=Qt("w",e[1].dataType,o.length,p),m=[c,f];r&&m.push(Qt("b",e[2].dataType,e[2].dims,p));let g=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Nr(t,g);let _=u?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${c.get("batch","xHeight","xWidth","input_channel")};\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${c.get("batch","input_channel","xHeight","xWidth")};\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${i.registerUniforms(g).declareVariables(...m,l)}\n\n  ${i.mainStart()}\n    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${l.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${u?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${p} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${u?2:1}];\n\n    var value: ${l.type.value} = ${l.type.value}(0);\n    ${_}\n    ${a}\n    ${h}\n    ${l.setByOffset("global_idx","value")}\n  }`}}},pa=(e,t,n,i)=>{let r=e.length>2,a=Wt(n[3]),s=Wt(n[2]),o=ut.size(n)/a/s,u=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],l=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],d=[n[0],n[1],n[2],n[3]/a],p=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ur(t,p),p.push(...Gt(u,l,d));let h=(s-1)*t.strides[1]+l[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${a};${s};${h};${l[0]};${l[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:p}),getShaderSource:n=>{let i=Xt("output",e[0].dataType,d.length,a),o=Vt(i.type.tensor),p=Pr(t,i.type.value,o),c=Qt("x",e[0].dataType,u.length,a),f=Qt("w",e[1].dataType,l.length,a),m=[c,f];r&&m.push(Qt("b",e[2].dataType,e[2].dims,a));let g=r?"value += b[output_channel];":"",_=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Nr(t,_),`\n  ${n.registerUniforms(_).declareVariables(...m,i)}\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${c.type.value}, ${h}>;\n    var values: array<${i.type.value}, ${s}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${l[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${c.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${c.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${l[1]}; w_width++) {\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${s}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${s}u; i++) {\n      var value = values[i];\n      ${g}\n      ${p}\n      ${i.set("batch","row","col + i","output_channel","value")};\n    }\n  }`}}}}),zl=N(()=>{nl(),Il(),Tl(),Sl(),El(),bl(),kl(),dl(),ha=(e,t,n,i,r,a)=>{let s=e[0],o=e.slice(a?1:2,a?3:4),u=o.length,l=t[0],d=t.slice(2).map((e,t)=>e+(e-1)*(n[t]-1)),p=o.map((e,t)=>e+i[t]+i[t+u]).map((e,t)=>Math.floor((e-d[t]+r[t])/r[t]));return p.splice(0,0,s),p.splice(a?3:1,0,l),p},ca=[2,3,1,0],fa=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ma=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let i=e.pads.slice();lt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,i,"NHWC"===e.format,e.autoPad);let r=Object.assign({},e);return Object.assign(r,{kernelShape:n,pads:i}),r},ga=e=>{let t=qr(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},_a=(e,t,n,i)=>{let r="NHWC"===n.format,a=ha(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,r);if(1!==n.group){let s=[t[0]];if(r){let i=e.kernelCustomData.wT??e.compute(ln(t[1],ca),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=i),s.push(i)}else s.push(t[1]);return 3===t.length&&s.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&r&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(pa(s,n,a,i),{inputs:s}):e.compute(da(s,n,a,i),{inputs:s}))}let s=3===t.length,o=t[0].dims[r?1:2],u=t[0].dims[r?2:3],l=t[0].dims[r?3:1],d=t[1].dims[2],p=t[1].dims[3],h=a[r?1:2],c=a[r?2:3],f=a[r?3:1],m=r&&d===o&&p===u&&0===n.pads[0]&&0===n.pads[1];if(m||1===d&&1===p&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let d,p,g,_=a[0],y=[];if(r){let i=e.kernelCustomData.wT??e.compute(ln(t[1],ca),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=i),m){let e=o*u*l;d=t[0].reshape([1,_,e]),p=i.reshape([1,e,f]),g=[1,_,f]}else d=t[0].reshape([_,o*u,l]),p=i.reshape([1,l,f]),g=[_,h*c,f];y.push(d),y.push(p)}else d=t[0].reshape([_,l,o*u]),p=t[1].reshape([1,f,l]),g=[_,f,h*c],y.push(p),y.push(d);s&&y.push(t[2]);let w=g[2],$=y[0].dims[y[0].dims.length-1];return void(w<8&&$<8?e.compute(Hr(y,n,a,g,r,i),{inputs:y}):e.compute(Jr(y,n,a,g,r,i),{inputs:y}))}let g=e.kernelCustomData.wT??e.compute(ln(t[1],ca),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let _=[t[0],g];s&&_.push(t[2]);let y=r?h*c:f,w=r?f:h*c,$=d*p*l;e.compute(ta(_,n,a,y,w,$,s,!0,i),{inputs:_})},ya=(e,t)=>{let n="NHWC"===t.format,i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&i.push(e.inputs[2]);let r=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),o=[1].concat(t.kernelShape),u=ma({...t,pads:r,strides:a,dilations:s,kernelShape:o},i);_a(e,i,u,e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])},wa=(e,t,n)=>{let i="NHWC"===n.format?"channelsLast":"channelsFirst",r=ma(n,t),a="NOTSET"===n.autoPad?n.pads:n.autoPad,s=ua(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,i);e.compute(la(t,r,s.outShape,[s.filterDepth,s.filterHeight,s.filterWidth],[s.padInfo.front,s.padInfo.top,s.padInfo.left],i))},$a=(e,t)=>{if(fa(e.inputs,t),3===e.inputs[0].dims.length)ya(e,t);else if(5===e.inputs[0].dims.length)wa(e,e.inputs,t);else{let n=ma(t,e.inputs);_a(e,e.inputs,n)}}}),Cl=N(()=>{Ju(),tl(),nl(),ll(),ba=(e,t,n)=>{let i=e.length>2,r=t.outputShape,a="NHWC"===t.format,s=t.group,o=e[1].dims,u=o[2]/s,l=o[3],d=a?Wt(u):1,p=a&&1===l&&u>=4,h=p?4*Math.floor(u/4):Math.floor(u/d)*d,c=u-h,f=a?Wt(l):1,m=a?1===l?d:f:1,g=ut.size(r)/f,_=[Math.ceil(g/64),1,1];at("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${_}`);let y=["rank","rank"],w=[t.strides[0],t.strides[1]],$=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],b=[t.dilations[0],t.dilations[1]],v=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],x=[v[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),v[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],k=[{type:12,data:g},{type:12,data:w},{type:12,data:$},{type:12,data:b},{type:12,data:v},{type:6,data:x},{type:12,data:h},{type:12,data:u},{type:12,data:l},...Gt(e[0].dims,e[1].dims)];return i&&(k.push(...Gt(e[2].dims)),y.push("rank")),k.push(...Gt(r)),{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${d}${m}${f}${p}${c}`,inputDependencies:y},getRunData:()=>({dispatchGroup:{x:_[0],y:_[1],z:_[2]},outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],programUniforms:k}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:w.length},{name:"filter_dims",type:"u32",length:$.length},{name:"dilations",type:"u32",length:$.length},{name:"effective_filter_dims",type:"u32",length:v.length},{name:"pads",type:"i32",length:x.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],s=Vt(e[0].dataType),o=a?1:2,u=a?2:3,l=a?3:1,h=Qt("W",e[1].dataType,e[1].dims.length,m),g=Qt("Dy",e[0].dataType,e[0].dims.length,d),_=[g,h];i&&_.push(Qt("bias",e[2].dataType,[r[l]].length,f));let y=Xt("result",e[0].dataType,r.length,f),b=`\n            let outputIndices = ${y.offsetToIndices(`global_idx * ${f}`)};\n            let batch = ${y.indicesGet("outputIndices",0)};\n            let d1 = ${y.indicesGet("outputIndices",l)};\n            let r = ${y.indicesGet("outputIndices",o)};\n            let c = ${y.indicesGet("outputIndices",u)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${y.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${s}(dyRCorner) + ${s}(wR)) / ${s}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${s}(uniforms.Dy_shape[${o}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${s}(dyCCorner) + ${s}(wC)) / ${s}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${s}(uniforms.Dy_shape[${u}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                ${p?`\n                var x_offset = ${g.indicesToOffset(`${g.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${d};\n                var w_offset = ${h.indicesToOffset(`${h.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${m};\n                  `:""}\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${p?4:d}) {\n                  ${(()=>{let e="";if(p)4===d?e+=`\n        let xValue = ${g.getByOffset("x_offset")};\n        let wValue = ${h.getByOffset("w_offset")};\n        dotProd = dotProd + dot(xValue, wValue);\n        x_offset += 1u;\n        w_offset += 1u;`:2===d?e+=`\n          dotProd = dotProd + dot(vec4<${s}>(${g.getByOffset("x_offset")}, ${g.getByOffset("x_offset + 1u")}), vec4<${s}>(${h.getByOffset("w_offset")}, ${h.getByOffset("w_offset + 1u")}));\n          x_offset += 2u;\n          w_offset += 2u;`:1===d&&(e+=`\n          dotProd = dotProd + dot(vec4<${s}>(${g.getByOffset("x_offset")}, ${g.getByOffset("x_offset + 1u")}, ${g.getByOffset("x_offset + 2u")}, ${g.getByOffset("x_offset + 3u")}), vec4<${s}>(${h.getByOffset("w_offset")}, ${h.getByOffset("w_offset + 1u")}, ${h.getByOffset("w_offset + 2u")}, ${h.getByOffset("w_offset + 3u")}));\n          x_offset += 4u;\n          w_offset += 4u;`);else if(e+=`\n                  let xValue = ${a?g.getByOffset(`${g.indicesToOffset(`${g.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${d}`):g.get("batch","inputChannel","idyR","idyC")};\n        `,1===d)e+=`\n          let w_offset = ${h.indicesToOffset(`${h.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n          let wValue = ${h.getByOffset(`w_offset / ${m}`)};\n          dotProd = dotProd + xValue * wValue;`;else for(let t=0;t<d;t++)e+=`\n            let wValue${t} = ${h.getByOffset(`${h.indicesToOffset(`${h.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${t}, wOutChannel)`)} / ${m}`)};\n            dotProd = dotProd + xValue[${t}] * wValue${t};`;return e})()}\n                  inputChannel = inputChannel + ${p?4:d};\n                }\n                ${(()=>{if(0===c)return"";if(!p)throw new Error(`packInputAs4 ${p} is not true.`);let e="";if(1===d){e+="dotProd = dotProd";for(let t=0;t<c;t++)e+=`\n            + ${g.getByOffset(`x_offset + ${t}`)} * ${h.getByOffset(`w_offset + ${t}`)}`;e+=";"}else if(2===d){if(2!==c)throw new Error(`Invalid inputChannelsRemainder ${c}.`);e+=`\n          let xValue = ${g.getByOffset("x_offset")};\n          let wValue = ${h.getByOffset("w_offset")};\n          dotProd = dotProd + dot(xValue, wValue);`}return e})()}\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${i?` + bias[d1 / ${f}]`:""};\n            ${y.setByOffset("global_idx","value")};\n          `;return`\n    ${t.registerUniforms(n).declareVariables(..._,y)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n    ${b}}`}}}}),Ol=N(()=>{Cl(),bl(),dl(),va=(e,t,n,i,r,a)=>(e-1)*t+n+(i-1)*r+1-a,xa=(e,t,n,i,r)=>{let a=Math.floor(e/2);"SAME_UPPER"===t?(n[i]=a,n[r]=e-a):"SAME_LOWER"===t&&(n[i]=e-a,n[r]=a)},ka=(e,t,n,i,r,a,s,o,u,l)=>{let d=e.length-2,p=0===l.length;u.length<d&&u.push(...Array(d-u.length).fill(0));let h=e[0],c=t[o?3:1]*r;for(let r=0,h=e.length-d-(o?1:0);r<d;++r,++h){let o=e[h],c=p?o*s[r]:l[r],f=va(o,s[r],a[r],t[h],n[r],c);xa(f,i,a,r,r+d),p&&l.push(s[r]*(o-1)+u[r]+(t[h]-1)*n[r]+1-a[r]-a[r+d])}l.splice(0,0,h),l.splice(o?3:1,0,c)},Sa=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce((e,t)=>e*t,1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let i="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(i?3:1,0,t[1].dims[1]);let r=e.pads.slice(),a=e.outputShape.slice(),s=e.outputPadding.slice(),o=t[0].dims,u=e.dilations.slice();if(0===u.reduce((e,t)=>e+t,0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce((e,t)=>e+t,0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}ka(o,n,u,e.autoPad,e.group,r,l,i,s,a);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:r,outputPadding:s,outputShape:a,dilations:u,strides:l}),d},Ia=e=>{let t=qr(e),n=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],r=e.dilations,a=e.group,s=e.kernelShape,o=e.pads,u=e.strides,l=e.wIsConst();return{autoPad:i,format:n,dilations:r,group:a,kernelShape:s,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:o,strides:u,wIsConst:l,...t,cacheKey:`${e.format};${t.activation};`}},Ta=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.reduce((e,t)=>e+t,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((e,t)=>e+t,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((e,t)=>e+t,0)>0&&t.pads.length!==2*i)throw new Error(`pads should be ${2*i}D`);if(t.outputPadding.length!==i&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((e,t)=>e+t,0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ea=(e,t,n,i)=>{let r=e.kernelCustomData.wT??e.compute(ln(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r);let a=[t[0],r];3===t.length&&a.push(t[2]),e.compute(ba(a,n,i),{inputs:a})},za=(e,t)=>{let n="NHWC"===t.format,i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&i.push(e.inputs[2]);let r=t.kernelShape;(0===r.length||0===r[0])&&(r=[e.inputs[1].dims[2]]);let a=t.dilations;(0===a.length||0===a[0])&&(a=[1]);let s=t.strides;(0===s.length||0===s[0])&&(s=[1]);let o=t.pads;0===o.length&&(o=[0,0]),o=[0,o[0],0,o[1]],s=[1].concat(s),a=[1].concat(a),r=[1].concat(r);let u=t.outputPadding;u=[0].concat(u);let l=Sa({...t,pads:o,strides:s,dilations:a,kernelShape:r,outputPadding:u},i);Ea(e,i,l,e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])},Ca=(e,t)=>{if(Ta(e.inputs,t),3===e.inputs[0].dims.length)za(e,t);else{let n=Sa(t,e.inputs);Ea(e,e.inputs,n)}}}),Bl=N(()=>{Ju(),nl(),ul(),ll(),Oa=(e,t,n,i)=>{let r=ut.size(t),a=t.length,s=Qt("input",e,a),o=Xt("output",e,a),u=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),l=ut.normalizeAxis(u,a);return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:l},...Gt(t,t)]}),getShaderSource:e=>{let t=` i32(${s.indicesGet("inputIndices","uniforms.axis")}) `,n=Kt("uniforms.input_shape","uniforms.axis",a),r=i.reverse?t+(i.exclusive?" + 1":""):"0",u=i.reverse?n:t+(i.exclusive?"":" + 1");return`\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(s,o)}\n                ${e.mainStart()}\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${o.offsetToIndices("global_idx")};\n                  var sum = ${o.type.value}(0);\n                  let first : i32 = ${r};\n                  let last : i32 = ${u};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${s.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${s.getByIndices("inputIndices")};\n                  }\n                  ${o.setByOffset("global_idx","sum")};\n                }`}}},Ba=(e,t)=>{let n=e.inputs[0].dims,i=e.inputs[0].dataType,r=e.inputs[1];e.compute(Oa(i,n,r,t),{inputs:[0]})},Aa=e=>{let t=1===e.exclusive,n=1===e.reverse;return Ut({exclusive:t,reverse:n})}}),Al=N(()=>{Ju(),nl(),ul(),ll(),Ra=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},Da=(e,t,n,i)=>{let r=[];r.push(`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let i=0;i<t;++i)r.push(n.indicesSet("a",e[i],`i[${i}]`));return r.push("return a;}"),r.join("\n")},Ma=(e,t)=>{let n,i,r,a,s,o,u="NHWC"===t.format,l=t.blocksize,d="DCR"===t.mode;u?([n,i,r,a]=e.dims,s=d?[n,i,r,l,l,a/l**2]:[n,i,r,a/l**2,l,l],o=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,i,r,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=d?[n,l,l,a/l**2,i,r]:[n,a/l**2,l,l,i,r],o=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let p=e.reshape(s),h=p.dims.length,c=e.dataType,f=Qt("a",c,h),m=Xt("output",c,h);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=u?[n,i*l,r*l,a/l**2]:[n,a/l**2,i*l,r*l],s=ut.size(t),d=p.dims,h=ut.sortBasedOnPerm(d,o);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},...Gt(d,h)]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(f,m)}\n\n  ${Da(o,h,f,m)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}\n  }`}},Pa=(e,t)=>{Ra(e.inputs),e.compute(Ma(e.inputs[0],t))},Ua=e=>Ut({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Rl=N(()=>{Ju(),nl(),ul(),ll(),Va="^"+(qa="("+(Na="[a-zA-Z]|\\.\\.\\.")+")+")+"$",La="^("+qa+",)*"+qa+"$",Ga=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Wa=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,i]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(La)))throw new Error("Invalid LHS term");if(n.split(",").forEach((t,n)=>{let i=e[n].dims.slice();if(!t.match(RegExp(Va)))throw new Error("Invalid LHS term");let r=this.processTerm(t,!0,i,n);this.lhs.push(r)}),""===i)i+=[...this.symbolToInfo.entries()].filter(([e,t])=>1===t.count||"..."===e).map(([e])=>e).join("");else if(!i.match(RegExp(qa)))throw new Error("Invalid RHS");i.match(RegExp(Na,"g"))?.forEach(e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(e,t,n){let i=this.symbolToInfo.get(e);if(void 0!==i){if(i.dimValue!==t&&1!==i.count)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(n)}else i={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,i)}processTerm(e,t,n,i=-1){let r=n.length,a=!1,s=[],o=0;if(!e.match(RegExp(Va))&&!t&&""!==e)throw new Error("Invalid LHS term");let u=e.match(RegExp(Na,"g")),l=new Ga(i);return u?.forEach((e,d)=>{if("..."===e){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let e=r-u.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(s=n.slice(o,o+e),this.hasEllipsis){if(this.ellipsisDims.length!==s.length||this.ellipsisDims.toString()!==s.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=s}for(let e=0;e<s.length;e++){let t=String.fromCharCode(48+e);l.addSymbol(t,d+e),this.addSymbol(t,n[o++],i)}}else l.addSymbol(e,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[o++],i)}),l}},Ha=e=>e+"_max",Fa=(e,t,n,i)=>{let r=e.map(e=>e.length).map((e,n)=>Qt(`input${n}`,t,e)),a=ut.size(i),s=Xt("output",t,i.length),o=[...n.symbolToInfo.keys()].filter(e=>!n.rhs.symbolToIndices.has(e));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let r=o.filter(e=>n.symbolToInfo.has(e)).map(e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0}));r.push({type:12,data:a});let s=e.map((e,t)=>[...Gt(e)]).reduce((e,t)=>e.concat(t),r);return s.push(...Gt(i)),{outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:s}},getShaderSource:e=>{let t=[],i=[],a=[],u=[],l=[],d=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((e,o)=>{if(n.rhs.symbolToIndices.has(o)){let i=n.rhs.symbolToIndices.get(o)?.[0];void 0!==i&&n.lhs.forEach((n,a)=>{if(e.inputIndices.includes(a)){let e=n.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach(e=>{t.push(`${r[a].indicesSet(`input${a}Indices`,e,s.indicesGet("outputIndices",i))}`)})}})}else n.lhs.forEach((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach(e=>{i.push(`${r[n].indicesSet(`input${n}Indices`,e,`${o}`)}`)}),l.push(`prod *= ${r[n].getByIndices(`input${n}Indices`)};`)}}),a.push(`for(var ${o}: u32 = 0; ${o} < uniforms.${Ha(o)}; ${o}++) {`),u.push("}")});let p=d?[...t,`let sum = ${r.map((e,t)=>e.getByIndices(`input${t}Indices`)).join(" * ")};`]:[...t,"var sum = 0.0;",...a,...i,"var prod = 1.0;",...l,"sum += prod;",...u];return`\n            ${e.registerUniforms(o.map(e=>({name:`${Ha(e)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,s)}\n\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${s.offsetToIndices("global_idx")};\n            ${r.map((e,t)=>`var input${t}Indices: ${r[t].type.indices};`).join("\n")}\n            ${p.join("\n")};\n            ${s.setByOffset("global_idx","sum")};\n          }`}}},ja=(e,t)=>{let n=new Wa(e.inputs,t.equation),i=n.outputDims,r=e.inputs.map((e,t)=>e.dims);e.compute(Fa(r,e.inputs[0].dataType,n,i))},Ka=e=>{let t=e.equation.replace(/\s+/g,"");return Ut({equation:t})}}),Dl=N(()=>{Ju(),nl(),ll(),Za=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=n.length<t.length?0:n.length-t.length,r=t.length<n.length?0:t.length-n.length;for(;i<n.length&&r<t.length;++i,++r)if(n[i]!==t[r]&&1!==n[i]&&1!==t[r])throw new Error("Expand requires shape to be broadcastable to input")},Qa=(e,t)=>{let n=e.length-t.length,i=[];for(let t=0;t<n;++t)i.push(e[t]);for(let r=0;r<t.length;++r)i.push(1===t[r]?e[r+n]:t[r]);return i},Xa=(e,t)=>e.length>t.length?Qa(e,t):Qa(t,e),Ya=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=Xa(t,n),r=e[0].dataType,a=9===r||1===ut.size(t),s=9===r||t.length>0&&t[t.length-1]%4==0?4:1,o=a||i.length>0&&i[i.length-1]%4==0?4:1,u=Math.ceil(ut.size(i)/o),l=[{type:12,data:u},...Gt(t,i)];return{name:"Expand",shaderCache:{hint:`${i.length};${s}${o}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,a=Qt("input",r,t.length,s),u=Xt("output",r,i.length,o);if(9===r){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${u.offsetToIndices(`outputOffset + ${t}u`)};\n          let offset${t} = ${a.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${a.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${o};\n        var data = vec4<u32>(0);\n        ${e("data",0,"u32")}\n        ${e("data",1,"u32")}\n        ${e("data",2,"u32")}\n        ${e("data",3,"u32")}\n        ${u.setByOffset("global_idx","data")}\n      }`}else n=`\n        let outputIndices = ${u.offsetToIndices(`global_idx * ${o}`)};\n        let inputOffset = ${a.broadcastedIndicesToOffset("outputIndices",u)};\n        let data = ${u.type.value}(${a.getByOffset(`inputOffset / ${s}`)});\n        ${u.setByOffset("global_idx","data")}\n      }`;return`\n    ${e.registerUniform("vec_size","u32").declareVariables(a,u)}\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${n}`},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l})}},Ja=e=>{Za(e.inputs),e.compute(Ya(e.inputs),{inputs:[0]})}}),Ml=N(()=>{Ju(),nl(),ll(),_l(),es=e=>{let t=e[0].dataType,n=ut.size(e[0].dims),i=ut.size(e[1].dims),r=i%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=Qt("x",t,[1],4),i=Qt("bias",t,[1],4),a=Xt("y",t,[1],4),s=e=>`\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\n      let bias${e} = ${i.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,o=r?`\n      let bias = ${i.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${s(0)}${s(1)}${s(2)}${s(3)}\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,i,a)}\n\n    ${or(Lt(t))}\n\n    ${e.mainStart(Nt)}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${n.getByOffset("global_idx")};\n      ${o}\n      let x_in = x + bias;\n      ${a.setByOffset("global_idx",ur("x_in"))}\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(n/Nt/4)}})}},ts=e=>{e.inputs.length<2||0===ut.size(e.inputs[1].dims)?lr(e):e.compute(es(e.inputs))}}),Pl=N(()=>{Ju(),nl(),ul(),ll(),ns=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},is=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,a=ut.normalizeAxis(t.axis,r),s=n.slice(0);s.splice(a,1,...i);let o=n[a],u=9===e[0].dataType?4:1,l=Math.ceil(ut.size(s)/u),d=[{type:12,data:l},{type:6,data:o},{type:12,data:a},...Gt(e[0].dims,e[1].dims,s)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:t=>{let n,o=Qt("data",e[0].dataType,e[0].dims.length,u),l=Qt("inputIndices",e[1].dataType,e[1].dims.length),d=Xt("output",e[0].dataType,s.length,u),p=e=>{let t=i.length,n=`var indicesIndices${e}  = ${l.type.indices}(0);`;for(let i=0;i<t;i++)n+=`${t>1?`indicesIndices${e}[${i}]`:`indicesIndices${e}`} = ${s.length>1?`outputIndices${e}[uniforms.axis + ${i}]`:`outputIndices${e}`};`;n+=`\n          var idx${e} = ${l.getByIndices(`indicesIndices${e}`)};\n          if (idx${e} < 0) {\n            idx${e} = idx${e} + uniforms.axisDimLimit;\n          }\n          var dataIndices${e} : ${o.type.indices};\n        `;for(let i=0,o=0;i<r;i++)i===a?(n+=`${r>1?`dataIndices${e}[${i}]`:`dataIndices${e}`} = u32(idx${e});`,o+=t):(n+=`${r>1?`dataIndices${e}[${i}]`:`dataIndices${e}`} = ${s.length>1?`outputIndices${e}[${o}]`:`outputIndices${e}`};`,o++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${d.offsetToIndices(`outputOffset + ${t}u`)};\n          ${p(t)};\n          let offset${t} = ${o.indicesToOffset(`dataIndices${t}`)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${u};\n        var value = vec4<u32>(0);\n        ${e("value",0,"u32")}\n        ${e("value",1,"u32")}\n        ${e("value",2,"u32")}\n        ${e("value",3,"u32")}\n        ${d.setByOffset("global_idx","value")}\n      `}else n=`\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      ${p("")};\n      let value = ${o.getByIndices("dataIndices")};\n      ${d.setByOffset("global_idx","value")};\n      `;return`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(o,l,d)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${n}\n      }`}}},rs=e=>Ut({axis:e.axis}),as=(e,t)=>{let n=e.inputs;ns(n),e.compute(is(e.inputs,t))}}),Ul=N(()=>{Ju(),nl(),ll(),ss=(e,t,n,i,r,a,s,o,u)=>{let l=[{type:12,data:a},{type:12,data:i},{type:12,data:r},{type:12,data:n},{type:12,data:s},{type:12,data:o},{type:12,data:u}],d=[a];return l.push(...Gt(t.dims,d)),e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:e=>{let i=[Qt("indices_data",t.dataType,t.dims.length),Xt("input_slice_offsets_data",12,1,1)],a=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\n  ${e.registerUniforms(a).declareVariables(...i)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${1===r.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\n      }\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`}},{inputs:[t],outputs:[-1]})[0]},os=(e,t)=>{let n=e.inputs,i=n[0].dims,r=n[0].dataType,a=n[1].dims,s=a[a.length-1],o=ut.sizeToDimension(a,a.length-1),u=ut.sizeFromDimension(i,t.batchDims+s),l=ut.sizeToDimension(i,t.batchDims),d=ut.sizeFromDimension(i,t.batchDims),p=o/l,h=new Array(s),c=u;for(let e=0;e<s;++e)h[s-1-e]=c,c*=i[t.batchDims+s-1-e];let f=ss(e,n[1],h,t.batchDims,i,o,p,d,s),m=t.batchDims+s;if(m>i.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let g=a.slice(0,-1).concat(i.slice(m)),_=ut.size(g),y=[{type:12,data:_},{type:12,data:u},...Gt(n[0].dims,f.dims,g)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:g,dataType:r}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:y}),getShaderSource:e=>{let t=Qt("data",n[0].dataType,n[0].dims.length),i=Qt("slice_offsets",12,f.dims.length),r=Xt("output",n[0].dataType,g.length);return`\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,i,r)}\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`}},{inputs:[n[0],f]})},us=e=>({batchDims:e.batch_dims,cacheKey:""})}),Nl=N(()=>{Ju(),nl(),ul(),ll(),ls=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=ut.normalizeAxis(t.quantizeAxis,e[0].dims.length),i=t.blockSize,r=e[0],a=e[2],s=4===e.length?e[3]:void 0;if(a.dims.length!==r.dims.length||!r.dims.map((e,t)=>t===n?Math.ceil(e/i)===a.dims[t]:e===a.dims[t]).reduce((e,t)=>e&&t,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(s){if(s.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(s.dims.length!==a.dims.length||!s.dims.map((e,t)=>e===a.dims[t]).reduce((e,t)=>e&&t,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},ds=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,a=ut.normalizeAxis(t.gatherAxis,r),s=ut.normalizeAxis(t.quantizeAxis,r),o=n.slice(0);o.splice(a,1,...i);let u=ut.size(o),l=e[2].dataType,d=22===e[0].dataType,p=[{type:12,data:u},{type:12,data:s},{type:12,data:a},{type:12,data:t.blockSize},...Gt(...e.map((e,t)=>e.dims),o)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((e,t)=>1!==t).map(e=>e.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(e,t)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:l}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:p}),getShaderSource:t=>{let r=Qt("data",e[0].dataType,e[0].dims.length),s=Qt("inputIndices",e[1].dataType,e[1].dims.length),u=Qt("scales",e[2].dataType,e[2].dims.length),p=e.length>3?Qt("zeroPoint",e[3].dataType,e[3].dims.length):void 0,h=Xt("output",l,o.length),c=[r,s,u];return p&&c.push(p),`\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...c,h)}\n        ${t.mainStart()}\n        let output_indices = ${h.offsetToIndices("global_idx")};\n        var indices_indices = ${s.type.indices}(0);\n        ${i.length>1?`\n          for (var i: u32 = 0; i < ${i.length}; i++) {\n            let index = ${h.indicesGet("output_indices","uniforms.gather_axis + i")};\n            ${s.indicesSet("indices_indices","i","index")};\n          }`:`indices_indices = ${h.indicesGet("output_indices","uniforms.gather_axis")};`};\n        var data_indices = ${r.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${h.indicesGet("output_indices","i")};\n          ${r.indicesSet("data_indices","i","index")};\n        }\n        var index_from_indices = ${s.getByIndices("indices_indices")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${r.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\n        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {\n          let index = ${h.indicesGet("output_indices",`i + ${i.length} - 1`)};\n          ${r.indicesSet("data_indices","i","index")};\n        }\n        let data_offset = ${r.indicesToOffset("data_indices")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${r.getByOffset("data_offset / 8")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${u.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\n        ${u.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\n        var scale = ${u.getByIndices("scale_indices")};\n        ${p?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${p.indicesToOffset("zero_point_indices")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${p.getByOffset("zero_point_offset / 8")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\n        let dequantized_data = ${Lt(l)}(quantized_data - zero_point) * scale;\n        ${h.setByOffset("global_idx","dequantized_data")};\n    }`}}},ps=(e,t)=>{let n=e.inputs;ls(n,t),e.compute(ds(e.inputs,t))},hs=e=>Ut({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),ql=N(()=>{Ju(),nl(),ul(),ll(),cs=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},fs=(e,t)=>{let n=e[0].dims,i=e[0].dataType,r=n.length,a=e[1].dims,s=e[1].dataType,o=ut.normalizeAxis(t.axis,r),u=n[o],l=a.slice(0),d=ut.size(l),p=Qt("input",i,r),h=Qt("indicesInput",s,a.length),c=Xt("output",i,l.length),f=[{type:12,data:d},{type:6,data:u},{type:12,data:o}];return f.push(...Gt(n,a,l)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:e=>`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,h,c)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${c.offsetToIndices("global_idx")};\n\n      var idx = ${h.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${p.type.indices}(outputIndices);\n      ${p.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${p.getByIndices("inputIndices")};\n\n      ${c.setByOffset("global_idx","value")};\n  }`}},ms=e=>Ut({axis:e.axis}),gs=(e,t)=>{let n=e.inputs;cs(n),e.compute(fs(e.inputs,t))}}),Vl=N(()=>{Ju(),nl(),ll(),_s=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},ys=(e,t)=>{let n=e[0].dims.slice(),i=e[1].dims.slice(),[r,a,s]=dt.getShapeOfGemmResult(n,t.transA,i,t.transB,3===e.length?e[2].dims:void 0),o=[r,a];if(!o)throw new Error("Can't use gemm on the given tensors");let u=Math.ceil(a/16),l=Math.ceil(r/16),d=(ut.size(o),[{type:12,data:u},{type:12,data:r},{type:12,data:a},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}]),p=["type","type"];return 3===e.length&&(d.push(...Gt(e[2].dims)),p.push("rank")),d.push(...Gt(o)),{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*l},programUniforms:d}),getShaderSource:n=>{let i=Qt("a",e[0].dataType,e[0].dims),r=Qt("b",e[1].dataType,e[1].dims),a=null,s=[i,r];3===e.length&&(a=Qt("c",e[2].dataType,e[2].dims.length),s.push(a));let u=Xt("output",e[0].dataType,o.length);s.push(u);let l="",d="";t.transA&&t.transB?(d=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(d=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(d=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(d=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let p=1===t.alpha?"":"value *= uniforms.alpha;";return`\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...s)}\n  var<workgroup> tile_a: array<array<${i.type.storage}, 16>, 16>;\n  var<workgroup> tile_b: array<array<${r.type.storage}, 16>, 16>;\n  ${n.mainStart([16,16,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\n    var k_start = 0u;\n    var value = ${u.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${d}\n      k_start = k_start + 16;\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < 16; k++) {\n        ${l}\n      }\n      workgroupBarrier();\n    }\n\n    ${p}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${null!=a?`let cOffset = ${a.broadcastedIndicesToOffset("vec2(m, n)",u)}; value += ${u.type.value}(uniforms.beta) * ${a.getByOffset("cOffset")};`:""}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`}}},ws=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),$s=(e,t)=>{_s(e.inputs),e.compute(ys(e.inputs,t))}}),Ll=N(()=>{Ju(),nl(),ul(),ll(),[bs,vs,xs,ks]=[0,1,2,3],Ss=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Is=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Ts=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${0===e.alignCorners?"\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    ":"\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    "}\n  }\n`,Es=e=>`\n  ${"reflection"===e.paddingMode?"\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }":""}\n`,zs=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${bs}] = batch;\n     indices[${vs}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${xs}] = u32(r);\n            indices[${ks}] = u32(c);\n          } else {\n            return ${t}(0);\n          }\n        `;case"border":return`\n          indices[${xs}] = u32(clamp(r, 0, H - 1));\n          indices[${ks}] = u32(clamp(c, 0, W - 1));\n        `;case"reflection":return`\n          indices[${xs}] = gs_reflect(r, border[1], border[3]);\n          indices[${ks}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices("indices")};\n  }\n`,Cs=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${bs}], indices[${vs}], border);\n        `;case"bilinear":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${bs}], indices[${vs}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${bs}], indices[${vs}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${bs}], indices[${vs}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${bs}], indices[${vs}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case"bicubic":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${bs}], indices[${vs}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,Os=(e,t)=>{let n=Qt("x",e[0].dataType,e[0].dims.length),i=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],r=Qt("grid",e[1].dataType,i.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[bs,vs,xs,ks]=[0,3,1,2]);let s=Xt("output",e[0].dataType,a.length),o=n.type.value,u=[{type:12,data:ut.size(a)},...Gt(e[0].dims,i,a)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=ut.size(a);return{outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:u}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(n,r,s)}\n  \n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n\n  ${Is(o)}\n  ${Ts(t)}\n  ${Es(t)}\n  ${zs(n,o,t)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let H_in = i32(uniforms.x_shape[${xs}]);\n      let W_in = i32(uniforms.x_shape[${ks}]);\n\n      ${0===t.alignCorners?"\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      ":"\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      "};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${s.offsetToIndices("global_idx")};\n      var grid_indices = vec3<u32>(indices[${bs}], indices[${xs}], indices[${ks}]);\n      let nxy = ${r.getByIndices("grid_indices")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Cs(s,o,t)}\n  }`}},Bs=(e,t)=>{Ss(e.inputs),e.compute(Os(e.inputs,t))},As=e=>Ut({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),Gl=N(()=>{Ju(),nl(),ul(),sl(),fl(),ll(),dl(),Rs=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Ds=(e,t)=>{let n=e[0],i=Rs(e,1),r=Rs(e,2),a=Rs(e,3),s=Rs(e,4),o=Rs(e,5),u=Rs(e,6),l=Rs(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let d,p=n.dims[0],h=n.dims[1],c=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=h,m=0,g=0,_=Math.floor(c/t.numHeads);if(u&&l&&ut.size(u.dims)&&ut.size(l.dims)){if(4!==u.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(u.dims[0]!==p||u.dims[1]!==t.numHeads||u.dims[3]!==_)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[0]!==p||l.dims[1]!==t.numHeads||l.dims[3]!==_)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[2]!==l.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(4!==l.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');m=u.dims[2],g=u.dims[2]}else if(u&&ut.size(u.dims)||l&&ut.size(l.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');if(i&&ut.size(i.dims)>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===i.dims.length){if(i.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');d=2,f=i.dims[1]}else if(5===i.dims.length){if(i.dims[2]!==t.numHeads||2!==i.dims[3]||i.dims[4]!==_)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');d=5,f=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==_)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=0,f=i.dims[2]}}else{if(5!==n.dims.length)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');d=3}if(a&&ut.size(a.dims)>0){if(1!==a.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&5===i.dims.length&&2===i.dims[3])throw new Error("bias is not allowed for packed kv.")}let y=m+f,w=0;if(s&&ut.size(s.dims)>0){w=8;let e=s.dims;throw 1===e.length?e[0]===p?w=1:e[0]===3*p+2&&(w=3):2===e.length&&e[0]===p&&e[1]===y&&(w=5),8===w?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let $=!1,b=c;if(r&&ut.size(r.dims)>0){if(3!==r.dims.length&&4!==r.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===r.dims.length){if(f!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');b=r.dims[2]}else{if(f!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');b=r.dims[1]*r.dims[3],$=!0}}if(s&&ut.size(s.dims)>0)throw new Error("Key padding mask is not supported");if(o&&ut.size(o.dims)>0){if(4!==o.dims.length)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==p||o.dims[1]!==t.numHeads||o.dims[2]!==h||o.dims[3]!==y)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:p,sequenceLength:h,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:y,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:c,vHiddenSize:b,headSize:_,vHeadSize:Math.floor(b/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:w,scale:t.scale,broadcastResPosBias:!1,passPastInKv:$,qkvFormat:d}},Ms=e=>Ut({...e}),Ps=Ut({perm:[0,2,1,3]}),Us=(e,t,n,i,r,a,s)=>{let o=[i,r,a],u=ut.size(o),l=[{type:12,data:u},{type:12,data:s},{type:12,data:a}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l}),getShaderSource:e=>{let i=Xt("qkv_with_bias",t.dataType,o),r=Qt("qkv",t.dataType,o),a=Qt("bias",n.dataType,o);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(r,a,i)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},Ns=(e,t,n,i,r,a,s,o)=>{let u=a;if(s&&ut.size(s.dims)>0){if(1===i)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return u=Us(e,a,s,t,i,n*r,o),u=u.reshape([t,i,n,r]),1===n||1===i?u:e.compute(ln(u,Ps.perm),{inputs:[u],outputs:[-1]})[0]}return 3===a.dims.length&&(u=a.reshape([t,i,n,r])),1===n||1===i?u:e.compute(ln(u,Ps.perm),{inputs:[u],outputs:[-1]})[0]},qs=(e,t)=>{let n=Ds(e.inputs,t),i=e.inputs[0],r=Rs(e.inputs,1),a=Rs(e.inputs,2),s=Rs(e.inputs,3),o=Rs(e.inputs,4),u=Rs(e.inputs,5),l=Rs(e.inputs,6),d=Rs(e.inputs,7);if(5===i.dims.length)throw new Error("Packed QKV is not implemented");if(5===r?.dims.length)throw new Error("Packed KV is not implemented");let p=r&&a&&4===r.dims.length&&4===a.dims.length,h=Ns(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,i,s,0);if(p)return fi(e,h,r,a,o,void 0,l,d,u,n);if(!r||!a)throw new Error("key and value must be provided");let c=Ns(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r,s,n.hiddenSize),f=Ns(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,s,2*n.hiddenSize);fi(e,h,c,f,o,void 0,l,d,u,n)}}),Wl=N(()=>{Ju(),nl(),ul(),ll(),Vs=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Ls=(e,t)=>{let n=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(e=>n.push(Number(e))),i=n.length),Ut({numOutputs:i,axis:t.axis,splitSizes:n})},Gs=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${Kt("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Ws=e=>{let t=e.length,n=[];for(let i=0;i<t;++i){let r=e[i].setByIndices("indices","input[global_idx]");1===t?n.push(r):0===i?n.push(`if (output_number == ${i}u) { ${r} }`):i===t-1?n.push(`else { ${r} }`):n.push(`else if (output_number == ${i}) { ${r} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},Hs=(e,t)=>{let n=e[0].dims,i=ut.size(n),r=e[0].dataType,a=ut.normalizeAxis(t.axis,n.length),s=new Array(t.numOutputs),o=Qt("input",r,n.length),u=new Array(t.numOutputs),l=[],d=[],p=0,h=[{type:12,data:i}];for(let i=0;i<t.numOutputs;i++){p+=t.splitSizes[i],u[i]=p;let o=n.slice();o[a]=t.splitSizes[i],d.push(o),s[i]=Xt(`output${i}`,r,o.length),l.push({dims:d[i],dataType:e[0].dataType})}return h.push({type:12,data:u},...Gt(n,...d)),{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",u.length).declareVariables(o,...s)}\n  ${Gs(u.length)}\n  ${Ws(s)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${o.offsetToIndices("global_idx")};\n    var index = ${o.indicesGet("indices",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${Kt("uniforms.size_in_split_axis","output_number - 1u",u.length)};\n      ${o.indicesSet("indices",a,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:l,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:h})}},Fs=(e,t)=>{Vs(e.inputs);let n=1===e.inputs.length?t:Ls(e.inputs,t);e.compute(Hs(e.inputs,n),{inputs:[0]})},js=e=>{let t=e.axis,n=e.splitSizes,i=e.numOutputs<0?n.length:e.numOutputs;if(i!==n.length)throw new Error("numOutputs and splitSizes length must be equal");return Ut({axis:t,numOutputs:i,splitSizes:n})}}),Hl=N(()=>{Ju(),nl(),ul(),ll(),Ks=(e,t)=>{let[n,i,r,a]=e,{numHeads:s,rotaryEmbeddingDim:o}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!ut.areEqual(i.dims,[])&&!ut.areEqual(i.dims,[1])&&2!==i.dims.length)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(2!==r.dims.length)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(2!==a.dims.length)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!ut.areEqual(r.dims,a.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&0===s)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let u=n.dims[0],l=n.dims[n.dims.length-2],d=r.dims[0],p=ut.sizeFromDimension(n.dims,1)/l,h=0===o?2*r.dims[1]:p/s;if(o>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===i.dims.length){if(u!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(l!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(h/2!==r.dims[1]&&o/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(l>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Zs=(e,t)=>{let{interleaved:n,numHeads:i,rotaryEmbeddingDim:r,scale:a}=t,s=e[0].dims[0],o=ut.sizeFromDimension(e[0].dims,1),u=e[0].dims[e[0].dims.length-2],l=o/u,d=e[2].dims[1],p=0===r?2*d:l/i,h=new Array(s,u,l/p,p-d),c=ut.computeStrides(h),f=[{type:1,data:a},{type:12,data:h},{type:12,data:c},...3===e[0].dims.length?new Array({type:12,data:[o,l,p,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[o,p,u*p,1]}):[],...Gt(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:Ut({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let i=Qt("input",e[0].dataType,e[0].dims.length),r=Qt("position_ids",e[1].dataType,e[1].dims.length),a=Qt("cos_cache",e[2].dataType,e[2].dims.length),s=Qt("sin_cache",e[3].dataType,e[3].dims.length),o=Xt("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:c.length},{name:"input_output_strides",type:"u32",length:c.length}]),`\n        ${t.declareVariables(i,r,a,s,o)}\n\n        ${t.mainStart(Nt)}\n          let half_rotary_emb_dim = uniforms.${a.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${r.broadcastedIndicesToOffset("bsnh.xy",Xt("",r.type.tensor,2))};\n            let position_id =\n                u32(${r.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${i.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} -\n                ${i.getByOffset("j")} * ${s.get("position_id","bsnh[3]")};\n            ${o.setByOffset("i","re")}\n            let im = ${i.getByOffset("i")} * ${s.get("position_id","bsnh[3]")} +\n                ${i.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\n            ${o.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${o.setByOffset("k",i.getByOffset("k"))}\n          }\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ut.size(h)/Nt)},programUniforms:f})}},Qs=(e,t)=>{Ks(e.inputs,t),e.compute(Zs(e.inputs,t))}}),Fl=N(()=>{ul(),Ju(),fl(),Gl(),Wl(),dl(),Hl(),ll(),Xs=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],i=e[1],r=e[2],a=e[3],s=e[4];if(0!==t.doRotary&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=n.dims[0],u=n.dims[1],l=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],d=u,p=0,h=!i||0===i.dims.length,c=Math.floor(h?l/(t.numHeads+2*t.kvNumHeads):l/t.numHeads);h&&(l=c*t.numHeads);let f=a&&0!==a.dims.length,m=s&&0!==s.dims.length;if(f&&4===a.dims.length&&a.dims[0]===o&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===c)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&m){if(4!==a.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==s.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');p=a.dims[2]}else if(f||m)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g=1;if(i&&i.dims.length>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===i.dims.length){if(n.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');d=i.dims[1]}else if(5===i.dims.length){if(i.dims[2]!==t.numHeads||2!==i.dims[3]||i.dims[4]!==c)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');d=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==c)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=i.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let _=!1,y=t.kvNumHeads?c*t.kvNumHeads:l;if(r&&r.dims.length>0){if(3!==r.dims.length&&4!==r.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===r.dims.length){if(d!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');y=r.dims[2]}else{if(d!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');y=r.dims[1]*r.dims[3],_=!0}}let w=e.length>4?e[5]:void 0;if(w&&1!==w.dims.length&&w.dims[0]!==o)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:o,sequenceLength:u,pastSequenceLength:p,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:l,vHiddenSize:y,headSize:c,vHeadSize:Math.floor(y/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:_,qkvFormat:g}},Ys=Ut({perm:[0,2,1,3]}),Js=(e,t,n)=>{let i=t,r=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(i=t.reshape([n.batchSize,n.kvSequenceLength,r,n.headSize]),i=e.compute(ln(i,Ys.perm),{inputs:[i],outputs:[-1]})[0]),i},eo=(e,t,n,i)=>{let r=[e*t],a=e*t,s=[{type:12,data:a},{type:12,data:t},{type:12,data:e}];return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:7}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:s}),getShaderSource:e=>{let t=Qt("seq_lens",n.dataType,n.dims),a=Qt("total_seq_lens",i.dataType,i.dims),s=Xt("pos_ids",7,r);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}]).declareVariables(t,a,s)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let total_sequence_length = u32(${a.getByOffset("0")});\n    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;\n    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;\n    let batch_idx = global_idx / uniforms.sequence_length;\n    let sequence_idx = i32(global_idx % uniforms.sequence_length);\n    var pos_id: i32 = 0;\n    let seqlen = ${t.getByOffset("batch_idx")};\n    let total_seqlen = seqlen + 1;\n    if (is_first_prompt) {\n      if (sequence_idx < total_seqlen) {\n        pos_id = sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${s.setByOffset("global_idx","pos_id")}\n    } else if (is_subsequent_prompt) {\n      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);\n      if (past_seqlen + sequence_idx < total_seqlen) {\n        pos_id = past_seqlen + sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${s.setByOffset("global_idx","pos_id")}\n    } else if (global_idx < uniforms.batch_size) {\n      ${s.setByOffset("global_idx","seqlen")}\n    };\n  }\n  `}}},to=(e,t)=>{let n=Xs(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let i,r,a=e.inputs[0],s=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,o=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,u=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,l=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,d=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,h=n.kvNumHeads?n.kvNumHeads:n.numHeads,c=Ut({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,h*n.headSize,h*n.headSize]}),[f,m,g]=s||o?[a,s,o]:e.compute(Hs([a],c),{inputs:[a],outputs:[-1,-1,-1]});if(t.doRotary){let a=e.compute(eo(n.batchSize,n.sequenceLength,d,p),{inputs:[d,p],outputs:[-1]})[0],s=e.inputs[7],o=e.inputs[8],u=Ut({interleaved:0!==t.rotaryInterleaved,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),l=[f,a,s,o],h=[-1];i=e.compute(Zs(l,u),{inputs:l,outputs:h})[0],l.splice(0,1,m);let c=Ut({interleaved:0!==t.rotaryInterleaved,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});r=e.compute(Zs(l,c),{inputs:l,outputs:h})[0]}let _=Ns(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?i:f,void 0,0),y=Js(e,t.doRotary?r:m,n),w=Js(e,g,n);fi(e,_,y,w,void 0,void 0,u,l,void 0,n,d,p)}}),jl=N(()=>{Ju(),nl(),dl(),ll(),no=(e,t,n,i,r,a,s,o)=>{let u=Wt(a),l=1===u?"f32":`vec${u}f`,d=1===u?"vec2f":`mat2x${u}f`,p=r*s,h=64;1===p&&(h=256);let c=[r,s,a/u],f=[r,s,2],m=[];return m.push(...Gt(c,f)),e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${u};${o};${h}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:p},programUniforms:m}),getShaderSource:e=>{let r=Qt("x",t.dataType,3,u),a=[r,Qt("scale",n.dataType,n.dims),Qt("bias",i.dataType,i.dims),Xt("output",1,3,2)];return`\n  var<workgroup> workgroup_shared : array<${d}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${e.declareVariables(...a)}\n  ${e.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${l}(0);\n    var squared_sum = ${l}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${l}(${r.get("batch","channel","h")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${d}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${jt("workgroup_shared[0][0]",u)} / f32(hight * ${u});\n      let squared_sum_final = ${jt("workgroup_shared[0][1]",u)} / f32(hight * ${u});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`}},{inputs:[t,n,i],outputs:[-1]})[0]},io=(e,t,n)=>{let i=t[0].dims,r=i,a=i[0],s=i[1],o=ut.sizeFromDimension(i,2),u=Wt(o),l=ut.size(r)/u,d=no(e,t[0],t[1],t[2],a,o,s,n.epsilon),p=[a,s,o/u],h=[a,s];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:[{type:12,data:l},...Gt(p,h,p)]}),getShaderSource:e=>{let n=Qt("x",t[0].dataType,p.length,u),i=Qt("scale_shift",1,h.length,2),r=Xt("output",t[0].dataType,p.length,u),a=[n,i,r];return`\n  ${e.registerUniform("output_size","u32").declareVariables(...a)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let outputIndices = ${r.offsetToIndices("global_idx")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${i.getByIndices("vec2<u32>(batch, channel)")};\n      let value = ${n.getByOffset("global_idx")} * ${r.type.value}(scale_shift.x) + ${r.type.value}(scale_shift.y);\n      ${r.setByOffset("global_idx","value")};\n  }`}},{inputs:[t[0],d]})},ro=(e,t,n)=>{let i=t[0].dims,r=i,a=i[0],s=i[i.length-1],o=ut.sizeFromDimension(i,1)/s,u=Wt(s),l=ut.size(r)/u,d=[{type:12,data:o},{type:12,data:Math.floor(s/u)}],p=!1,h=[0,i.length-1];for(let e=0;e<i.length-2;e++)p=p||1!==i[e+1],h.push(e+1);p=p&&1!==i[i.length-1];let c=p?e.compute(ln(e.inputs[0],h),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:i.length},(e,t)=>i[h[t]])),f=no(e,c,t[1],t[2],a,o,s,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${u}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:e=>{let n=Vt(t[0].dataType),i=1===u?"vec2f":`mat${u}x2f`,a=e=>{let t=0===e?"x":"y",i=1===u?"f32":`vec${u}f`;switch(u){case 1:return`${n}(${i}(scale.${t}))`;case 2:return`vec2<${n}>(${i}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${i}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${u}`)}},s=Qt("input",t[0].dataType,t[0].dims,u),o=Xt("output",t[0].dataType,r,u);return`\n  @group(0) @binding(0) var<storage, read> input : array<${s.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${i}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${o.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${a(0)}, ${a(1)});\n  }`}},{inputs:[t[0],f]})},ao=(e,t)=>{"NHWC"===t.format?ro(e,e.inputs,t):io(e,e.inputs,t)}}),Kl=N(()=>{Ju(),nl(),ll(),so=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},oo=(e,t,n)=>{let i=t.simplified,r=e[0].dims,a=e[1],s=!i&&e[2],o=r,u=ut.normalizeAxis(t.axis,r.length),l=ut.sizeToDimension(r,u),d=ut.sizeFromDimension(r,u),p=ut.size(a.dims),h=s?ut.size(s.dims):0;if(p!==d||s&&h!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${p} and bias size of ${h}`);let c=[];for(let e=0;e<r.length;++e)e<u?c.push(r[e]):c.push(1);let f=Wt(d),m=["type","type"],g=[{type:12,data:l},{type:1,data:d},{type:12,data:Math.floor(d/f)},{type:1,data:t.epsilon}];s&&m.push("type");let _=n>1,y=n>2,w=[{dims:o,dataType:e[0].dataType}];return _&&w.push({dims:c,dataType:1}),y&&w.push({dims:c,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${i}`,inputDependencies:m},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(l/64)},programUniforms:g}),getShaderSource:t=>{let n=Vt(e[0].dataType),r=[Qt("x",e[0].dataType,e[0].dims,f),Qt("scale",a.dataType,a.dims,f)];return s&&r.push(Qt("bias",s.dataType,s.dims,f)),r.push(Xt("output",e[0].dataType,o,f)),_&&r.push(Xt("mean_data_output",1,c)),y&&r.push(Xt("inv_std_output",1,c)),`\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...r)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${Ht("f32",f)};\n    var mean_square_vector = ${Ht("f32",f)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Ft(n,f,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${jt("mean_vector",f)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${jt("mean_square_vector",f)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Ft(n,f,"x[j + offset]")};\n      let f32scale = ${Ft(n,f,"scale[j]")};\n      output[j + offset] = ${r[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale\n        ${s?`+ ${Ft(n,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${_?"mean_data_output[global_idx] = mean":""};\n    ${y?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`}}},uo=(e,t)=>{so(e.inputs),e.compute(oo(e.inputs,t,e.outputCount))}}),Zl=N(()=>{nl(),kl(),Sl(),lo=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},po=e=>{lo(e.inputs);let t=ot.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],i=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&i<8)e.compute(Hr(e.inputs,{activation:""},t));else{let r=t[t.length-2],a=ut.size(e.inputs[0].dims.slice(0,-2)),s=ut.size(e.inputs[1].dims.slice(0,-2));if(1!==a&&1===r&&1===s){let r=[1,a,n],s=[e.inputs[0].reshape([1,a,i]),e.inputs[1].reshape([1,i,n])];e.compute(Jr(s,{activation:""},t,r),{inputs:s})}else e.compute(Jr(e.inputs,{activation:""},t))}}}),Ql=N(()=>{Ju(),nl(),ul(),ll(),ho=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],i=n.dims.length;if(n.dims[i-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,s=e[1];if(!ut.areEqual(s.dims,[t.n,r,a]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(ut.size(o)!==t.n*r)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,i=t.n*(8===t.bits?r:Math.floor((r*t.bits+7)/8));if(ut.size(n)!==i)throw new Error("zeroPoints input size error.")}},co=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],a=t.k,s=t.n,o=n.slice(0,i-2),u=ut.size(o),l=e[1].dims[2]/4,d=e[0].dataType,p=Wt(t.k),h=Wt(l),c=Wt(s),f=o.concat([r,s]),m=r>1&&s/c%2==0?2:1,g=ut.size(f)/c/m,_=[],y=[u,r,a/p],w=ut.convertShape(e[1].dims).slice();w.splice(-1,1,l/h),_.push(...Gt(y)),_.push(...Gt(w)),_.push(...Gt(e[2].dims)),4===e.length&&_.push(...Gt(ut.convertShape(e[3].dims)));let $=[u,r,s/c];return _.push(...Gt($)),{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${p};${h};${c};${m};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:d}],dispatchGroup:{x:g},programUniforms:_}),getShaderSource:n=>{let i=y.length,r=Qt("a",e[0].dataType,i,p),a=Qt("b",12,w.length,h),s=Qt("scales",e[2].dataType,e[2].dims.length),o=[r,a,s],u=4===e.length?Qt("zero_points",12,e[3].dims.length):void 0;u&&o.push(u);let d=$.length,f=Xt("output",e[0].dataType,d,c),g=Vt(e[0].dataType),_=(()=>{switch(p){case 1:return`array<${g}, 8>`;case 2:return`mat4x2<${g}>`;case 4:return`mat2x4<${g}>`;default:throw new Error(`${p}-component is not supported.`)}})();return`\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${64*m}>;\n        ${n.declareVariables(...o,f)}\n        ${n.mainStart([64,1,1])}\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${m}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/p};\n            ${(()=>{let e=`\n            var col_index = col * ${c};\n            ${u?"\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;":`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${g}(8);`}\n            `;for(let t=0;t<c*m;t++)e+=`\n            let scale${t} = ${s.getByOffset("col_index * nBlocksPerCol + block")};\n            ${u?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${u.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point${t} = ${g}((zero_point_word) & 0xFu);`:""}\n            col_index += 1;`;return e})()}\n            for (var word: u32 = 0; word < ${l}; word += ${h}) {\n              ${(()=>{let e=`col_index = col * ${c};`;for(let t=0;t<c*m;t++)e+=`\n            let b${t}_data = ${a.getByIndices(`${a.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return e+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${_};\n            var b_dequantized_values: ${_};`,e})()}\n              for (var i: u32 = 0; i < ${h}; i++) {\n                ${(()=>{let e=`\n          // reuse a data\n            var input_offset = ${r.indicesToOffset(`${r.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${_};\n            for (var j: u32 = 0; j < ${8/p}; j++) {\n              a_data[j] = ${r.getByOffset("input_offset")};\n              input_offset++;\n            }\n          `;for(let t=0;t<c*m;t++)e+=`\n            b_value = ${1===h?`b${t}_data`:`b${t}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${_}(${Array.from({length:4},(e,t)=>`${g}(b_value_lower[${t}]), ${g}(b_value_upper[${t}])`).join(", ")});\n            b_dequantized_values = ${1===p?`${_}(${Array.from({length:8},(e,n)=>`(b_quantized_values[${n}] - ${u?`zero_point${t}`:"zero_point"}) * scale${t}`).join(", ")});`:`(b_quantized_values - ${_}(${Array(8).fill(u?`zero_point${t}`:"zero_point").join(",")})) * scale${t};`};\n            workgroup_shared[local_id.x * ${m} + ${Math.floor(t/c)}]${c>1?`[${t%c}]`:""} += ${Array.from({length:8/p},(e,t)=>1===p?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`).join(" + ")};\n          `;return e})()}\n                word_offset += ${8/p};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${m}) {\n            var output_value: ${f.type.value} = ${f.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < 64u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${m};\n            }\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\n          }\n        }`}}},fo=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],a=t.k,s=t.n,o=n.slice(0,i-2),u=ut.size(o),l=e[1].dims[2]/4,d=e[0].dataType,p=Wt(t.k),h=Wt(l),c=o.concat([r,s]),f=s%8==0?8:s%4==0?4:1,m=128/f,g=m*h*8,_=g/p,y=g/t.blockSize,w=ut.size(c)/f,$=[],b=[u,r,a/p],v=ut.convertShape(e[1].dims).slice();v.splice(-1,1,l/h),$.push(...Gt(b)),$.push(...Gt(v)),$.push(...Gt(e[2].dims)),4===e.length&&$.push(...Gt(ut.convertShape(e[3].dims)));let x=[u,r,s];return $.push(...Gt(x)),{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${p};${h};${m};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:c,dataType:d}],dispatchGroup:{x:w},programUniforms:$}),getShaderSource:n=>{let i=b.length,r=Qt("a",e[0].dataType,i,p),a=Qt("b",12,v.length,h),s=Qt("scales",e[2].dataType,e[2].dims.length),o=[r,a,s],u=4===e.length?Qt("zero_points",12,e[3].dims.length):void 0;u&&o.push(u);let l=x.length,d=Xt("output",e[0].dataType,l),c=Vt(e[0].dataType);return`\n        var<workgroup> sub_a: array<${r.type.value}, ${_}>;\n        var<workgroup> inter_results: array<array<${d.type.value}, ${m}>, ${f}>;\n        ${n.declareVariables(...o,d)}\n        ${n.mainStart([m,f,1])}\n          let output_indices = ${d.offsetToIndices(`workgroup_index * ${f}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${y} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${_};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${_}; a_offset += 128)\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${r.getByIndices(`${r.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${r.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${y} + local_id.x;\n            ${u?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${u.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point = ${c}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${c}(8);`}\n            let scale = ${s.getByOffset("b_row * n_blocks_per_col + block")};\n            let b_data = ${a.getByIndices(`${a.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/p};\n            for (var i: u32 = 0; i < ${h}; i++) {\n              ${(()=>{switch(p){case 1:return`\n          let a_data0 = vec4<${c}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${c}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${c}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${c}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${p}-component is not supported.`)}})()}\n              let b_value = ${1===h?"b_data":"b_data[i]"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${c}>(${Array.from({length:4},(e,t)=>`${c}(b_value_lower[${t}]), ${c}(b_value_upper[${t}])`).join(", ")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${c}>(${Array(8).fill("zero_point").join(",")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`).join(" + ")};\n              word_offset += ${8/p};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${f}) {\n            var output_value: ${d.type.value} = ${d.type.value}(0);\n            for (var b = 0u; b < ${m}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${d.setByIndices(`${d.type.indices}(batch, row, col + local_idx)`,"output_value")}\n            }\n          }\n        }`}}},mo=(e,t)=>{ho(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(fo(e.inputs,t)):e.compute(co(e.inputs,t))},go=e=>Ut(e)}),Xl=N(()=>{Ju(),nl(),ll(),_o=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},yo=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n            k = i32(${e.indicesGet("indices",r)}) - ${Kt("uniforms.pads",r,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${Kt("uniforms.x_shape",r,t)})) {\n              break;\n            }\n            offset += k * i32(${Kt("uniforms.x_strides",r,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${i}\n            value = x[offset];\n          }\n      `},wo=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n                k = i32(${e.indicesGet("indices",r)}) - ${Kt("uniforms.pads",r,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${Kt("uniforms.x_shape",r,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${Kt("uniforms.x_shape",r,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${Kt("uniforms.x_strides",r,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},$o=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n                k = i32(${e.indicesGet("indices",r)}) - ${Kt("uniforms.pads",r,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${Kt("uniforms.x_shape",r,t)})) {\n                  k = i32(${Kt("uniforms.x_shape",r,t)}) - 1;\n                }\n                offset += k * i32(${Kt("uniforms.x_strides",r,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},bo=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n                k = i32(${e.indicesGet("indices",r)}) - ${Kt("uniforms.pads",r,n)};\n                if (k < 0)  {\n                  k += i32(${Kt("uniforms.x_shape",r,t)}]);\n                }\n                if (k >= i32(${Kt("uniforms.x_shape",r,t)})) {\n                  k -= i32(${Kt("uniforms.x_shape",r,t)});\n                }\n                offset += k * i32(${Kt("uniforms.x_strides",r,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},vo=(e,t,n)=>{switch(n.mode){case 0:return yo(e,t,n.pads.length);case 1:return wo(e,t,n.pads.length);case 2:return $o(e,t,n.pads.length);case 3:return bo(e,t,n.pads.length);default:throw new Error("Invalid mode")}},xo=(e,t)=>{let n=ut.padShape(e[0].dims.slice(),t.pads),i=e[0].dims,r=[{type:12,data:ut.size(n)},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;return 0===t.mode&&r.push({type:a?e[2].dataType:1,data:t.value}),r.push(...Gt(e[0].dims,n)),{name:"Pad",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ut.size(n)/64)},programUniforms:r}),getShaderSource:r=>{let s=Xt("output",e[0].dataType,n.length),o=Qt("x",e[0].dataType,i.length),u=o.type.value,l=vo(s,i.length,t),d=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&d.push({name:"constant_value",type:a?u:"f32"}),`\n            ${r.registerUniforms(d).declareVariables(o,s)}\n            ${r.mainStart()}\n            ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${s.offsetToIndices("global_idx")};\n\n            var value = ${u}(0);\n            ${l}\n            output[global_idx] = value;\n        }`}}},ko=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,r=e[0].dims.length,a=new Int32Array(2*r).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)a[Number(t[e])]=Number(n[e]),a[Number(t[e])+r]=Number(n[e+t.length])}else n.forEach((e,t)=>a[Number(t)]=Number(e));let s=[];return a.forEach(e=>s.push(e)),{mode:t.mode,value:i,pads:s}}return t},So=(e,t)=>{_o(e.inputs);let n=ko(e.inputs,t);e.compute(xo(e.inputs,n),{inputs:[0]})}}),Yl=N(()=>{oe(),Ju(),nl(),ll(),Io=e=>{if(l.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},To=(e,t,n)=>{let i="NHWC"===t.format,r=e.dims.slice();i&&r.splice(1,0,r.pop());let a=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),o=t.strides.slice(),u=a?t.dilations.slice():[],l=t.pads.slice();lt.adjustPoolAttributes(n,r,s,o,u,l);let d=lt.computePoolOutputShape(n,r,o,u,s,l,t.autoPad),p=Object.assign({},t);a?Object.assign(p,{kernelShape:s,strides:o,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:s,strides:o,pads:l,cacheKey:t.cacheKey});let h=d.slice();return h.push(h.splice(1,1)[0]),[p,i?h:d]},Eo=(e,t)=>{let n="NHWC"===t.format,i=[{type:12,data:ut.size(e)},{type:12,data:ut.size(t.kernelShape)}],r=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],a=t.pads[t.pads.length/2-1],s=t.pads[t.pads.length-1],o=!!(a+s);i.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:s}),r.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let u=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],a=t.pads[t.pads.length/2-2],s=t.pads[t.pads.length-2];u=!!(a+s),i.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:s}),r.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[i,r,!0,o,u]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=ut.computeStrides(t.kernelShape);return i.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),r.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[i,r,!!t.pads.reduce((e,t)=>e+t),!1,!1]}},zo=(e,t,n,i,r,a,s,o,u,l,d,p)=>{let h="NHWC"===r.format,c=t.type.value,f=Xt("output",t.type.tensor,i);if(r.kernelShape.length<=2){let i="",l="",m="",g=n-(h?2:1);if(i=d?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${g}] < 0 || xIndices[${g}]\n                      >= uniforms.x_shape[${g}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`,2===r.kernelShape.length){let e=n-(h?3:2);l=p?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                `,m="\n              }\n            "}return`\n            ${e.registerUniforms(u).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value = ${c}(${o});\n              var pad = 0;\n              ${l}\n              ${i}\n              ${m}\n              ${s}\n\n              output[global_idx] = value;\n            }`}{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let i=r.kernelShape.length,d=r.pads.length,p="";return p=l?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${a}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(u).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${i}>;\n\n              var value = ${c}(${o});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${i-1}u; j++) {\n                  offsets[j] = offset / ${Kt("uniforms.kernelStrides","j",i)};\n                  offset -= offsets[j] * ${Kt("uniforms.kernelStrides","j",i)};\n                }\n                offsets[${i-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-i}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${Kt("uniforms.strides",`j - ${n-i}u`,i)}\n                    + offsets[j - ${n-i}u] - ${Kt("uniforms.pads","j - 2u",d)};\n                  ${p}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},Co=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Oo=e=>`${Co(e)};${e.countIncludePad}`,Bo=e=>`${Co(e)};${e.storageOrder};${e.dilations}`,Ao=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ro=(e,t,n,i)=>{let[r,a]=To(t,i,n),s=Qt("x",t.dataType,t.dims.length),o=s.type.value,u="";r.countIncludePad?u+=`value /= ${o}(uniforms.kernelSize);`:u+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[l,d,p,h,c]=Eo(a,r);return l.push(...Gt(t.dims,a)),{name:e,shaderCache:{hint:`${i.cacheKey};${p};${h};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ut.size(a)/64)},programUniforms:l}),getShaderSource:e=>zo(e,s,t.dims.length,a.length,r,"value += x_val;",u,0,d,p,h,c)}},Do=e=>{let t=0!==e.count_include_pad,n=Ao(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:t,...n,cacheKey:""};return{...i,cacheKey:Oo(i)}},Mo=(e,t)=>{Io(e.inputs),e.compute(Ro("AveragePool",e.inputs[0],!1,t))},Po={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Uo=e=>{let t=e.format;return{format:t,...Po,cacheKey:t}},No=(e,t)=>{Io(e.inputs),e.compute(Ro("GlobalAveragePool",e.inputs[0],!0,t))},qo=(e,t,n,i)=>{let[r,a]=To(t,i,n),s=Qt("x",t.dataType,t.dims.length),[o,u,l,d,p]=Eo(a,r);return o.push(...Gt(t.dims,a)),{name:e,shaderCache:{hint:`${i.cacheKey};${l};${d};${p}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ut.size(a)/64)},programUniforms:o}),getShaderSource:e=>zo(e,s,t.dims.length,a.length,r,"\n      value = max(x_val, value);\n    ","",10===t.dataType?-65504:-1e5,u,l,d,p)}},Vo=(e,t)=>{Io(e.inputs),e.compute(qo("MaxPool",e.inputs[0],!1,t))},Lo=e=>{let t=e.storage_order,n=e.dilations,i=Ao(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==i.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:t,dilations:n,...i,cacheKey:""};return{...r,cacheKey:Bo(r)}},Go=e=>{let t=e.format;return{format:t,...Po,cacheKey:t}},Wo=(e,t)=>{Io(e.inputs),e.compute(qo("GlobalMaxPool",e.inputs[0],!0,t))}}),Jl=N(()=>{Ju(),nl(),ul(),ll(),Ho=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((t,n)=>t===e[2].dims[n]).reduce((e,t)=>e&&t,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((n,i)=>i===t.axis||n===e[0].dims[i]).reduce((e,t)=>e&&t,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],i=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/i)||t.blockSize>Math.ceil(n/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Fo=(e,t)=>{let n=ut.normalizeAxis(t.axis,e[0].dims.length),i=e[0].dataType,r=3===i,a=e[0].dims,s=e[1].dataType,o=ut.size(a),u=3===i||2===i,l=u?[Math.ceil(ut.size(e[0].dims)/4)]:e[0].dims,d=e[1].dims,p=e.length>2?e[2]:void 0,h=p?u?[Math.ceil(ut.size(p.dims)/4)]:p.dims:void 0,c=0===d.length||1===d.length&&1===d[0],f=!1===c&&1===d.length,m=Wt(o),g=c&&(!u||4===m),_=g?m:1,y=g&&!u?m:1,w=Qt("input",u?12:i,l.length,y),$=Qt("scale",s,d.length),b=p?Qt("zero_point",u?12:i,h.length):void 0,v=Xt("output",s,a.length,_),x=[w,$];b&&x.push(b);let k=[l,d];p&&k.push(h);let S=[{type:12,data:o/_},{type:12,data:n},{type:12,data:t.blockSize},...Gt(...k,a)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:b?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...x,v)}\n      ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let output_indices = ${v.offsetToIndices("global_idx")};\n\n          // Set input x\n          ${u?`\n            let input = ${w.getByOffset("global_idx / 4")};\n            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};\n            let x_value = ${1===_?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${w.getByOffset("global_idx")};`};\n\n          // Set scale input\n          ${c?`let scale_value= ${$.getByOffset("0")}`:f?`\n            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};\n            let scale_value= ${$.getByOffset("scale_index")};`:`\n            var scale_indices: ${$.type.indices} = output_indices;\n            let index = ${$.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\n            ${$.indicesSet("scale_indices","uniforms.axis","index")};\n            let scale_value= ${$.getByIndices("scale_indices")};`};\n\n          // Set zero-point input\n          ${b?c?u?`\n                let zero_point_input = ${b.getByOffset("0")};\n                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${b.getByOffset("0")}`:f?u?`\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_input = ${b.getByOffset("zero_point_index / 4")};\n                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_value = ${b.getByOffset("zero_point_index")};`:u?`\n                let zero_point_offset = ${$.indicesToOffset("scale_indices")};\n                let zero_point_input = ${b.getByOffset("zero_point_offset / 4")};\n                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${b.getByIndices("scale_indices")};`:`let zero_point_value = ${u?r?"i32":"u32":w.type.value}(0);`};\n      // Compute and write output\n      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(o/_/64),y:1,z:1},programUniforms:S})}},jo=(e,t)=>{Ho(e.inputs,t),e.compute(Fo(e.inputs,t))},Ko=e=>Ut({axis:e.axis,blockSize:e.blockSize})}),ed=N(()=>{oe(),Ju(),ll(),Zo=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},Qo=(e,t,n,i)=>{let r=Math.abs(Math.ceil((t-e)/n)),a=[r],s=r,o=[{type:12,data:s},{type:i,data:e},{type:i,data:n},...Gt(a)];return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:e=>{let t=Xt("output",i,a.length),n=t.type.value,r=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\n        ${e.registerUniforms(r).declareVariables(t)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:o})}},Xo=e=>{let t=0,n=0,i=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),l.webgpu.validateInputContent&&Zo(t,n,i),e.compute(Qo(t,n,i,e.inputs[0].dataType),{inputs:[]})}}),td=N(()=>{Ju(),nl(),ul(),ll(),Yo=(e,t,n,i)=>{if("none"!==e&&"i32"!==i&&"u32"!==i&&"f32"!==i)throw new Error(`Input ${i} is not supported with reduction ${e}.`);let r="{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =",a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===i||"u32"===i?`atomicAdd(&${t}, bitcast<${i}>(${n}));`:`\n              ${r}bitcast<${i}>(oldValue) + (${n})${a}`;case"max":return"i32"===i||"u32"===i?`atomicMax(&${t}, bitcast<${i}>(${n}));`:`\n                ${r}max(bitcast<f32>(oldValue), (${n}))${a}`;case"min":return"i32"===i||"u32"===i?`atomicMin(&${t}, bitcast<${i}>(${n}));`:`${r}min(bitcast<${i}>(oldValue), (${n}))${a}`;case"mul":return`${r}(bitcast<${i}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},Jo=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n,a=Math.ceil(ut.sizeToDimension(i,i.length-1)/1),s=i[i.length-1],o=ut.sizeFromDimension(n,s),u=[{type:12,data:a},{type:12,data:s},{type:12,data:o},...Gt(e[1].dims,e[2].dims,r)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}),getShaderSource:n=>{let i=Qt("indices",e[1].dataType,e[1].dims.length),a=Qt("updates",e[2].dataType,e[2].dims.length,1),s="none"!==t.reduction&&""!==t.reduction?Yt("output",e[0].dataType,r.length):Xt("output",e[0].dataType,r.length,1);return`\n      ${n.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(i,a,s)}\n      ${n.mainStart()}\n        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n  var data_offset = 0u;\n  let indices_start = uniforms.last_index_dimension * global_idx;\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${1===e[0].dims.length?"\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;":"\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start];"}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${Yo(t.reduction,"output[data_offset + i]","value",s.type.value)}\n  }\n\n      }`}}},eu=e=>Ut({reduction:e.reduction}),tu=(e,t)=>{e.compute(Jo(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),nd=N(()=>{Ju(),nl(),ul(),ll(),nu=(e,t)=>{if(e.every(e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},iu=(e,t,n)=>{t.every(e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(n).fill(1);return t.forEach((t,n)=>i[t]=e[n]),i},ru=(e,t,n,i,r,a)=>{let[s,o,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(e=>a.push(e));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach(e=>i.push(e)),0!==i.length&&i.length!==l&&n>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");nu(i,t),t.axes.length>0&&iu(i,t.axes,l).forEach((e,t)=>i[t]=e)}if(u>0&&e.length>u&&1===e[u].dims.length&&e[u].dims[0]>0&&(e[u].getBigInt64Array().forEach(e=>r.push(Number(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==i.length&&i.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(0!==r.length&&r.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof r<"u"&&i.length>0&&r.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},au=(e,t,n,i)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${i}(big / (${n}));\n  let fract = ${i}(big % (${n})) / ${i}(${n});\n  return whole + fract;\n`,su=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${au("xResized","lengthOriginal","lengthResized",t)}\n          }\n        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${au("xResized","lengthOriginal - 1","lengthResized - 1",t)}\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",ou=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",uu=(e,t,n)=>{let i=new Array(n).fill(0).concat(new Array(n).fill(1)),r=0===e.length?i:e.slice();return t.length>0?(t.forEach((e,a)=>{i[e]=r[a],i[a+n]=r[t.length+a]}),i):r},lu=(e,t,n,i)=>{let r=[];if(n.length>0)if(i.length>0){if(e.forEach(e=>r.push(e)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((e,t)=>r[e]=n[t])}else n.forEach(e=>r.push(e));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");r=e.map((e,n)=>Math.round(e*t[n]))}return r},du=(e,t,n)=>{let i=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(e=>t[e]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(e=>t[e]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let r=e.slice();return n.axes.length>0?(n.axes.forEach(e=>t[e]=i),n.axes.forEach(n=>r[n]=Math.round(e[n]*t[n]))):(t.fill(i,0,t.length),r.forEach((e,n)=>r[n]=Math.round(e*t[n]))),r},pu=(e,t,n,i,r)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${Kt("uniforms.scales","i",i)};\n        var roi_low = ${Kt("uniforms.roi","i",r)};\n        var roi_hi = ${Kt("uniforms.roi",`i + ${t.length}`,r)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${Kt("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${Kt("uniforms.output_shape","i",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,hu=(e,t,n,i,r,a,s)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${i.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${Kt("uniforms.scales","i",r)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${Kt("uniforms.roi","i",a)};\n          var roi_hi = ${Kt("uniforms.roi",`i + ${n.length}`,a)};\n          var input_shape_i = ${Kt("uniforms.input_shape","i",n.length)};\n          var output_shape_i = ${Kt("uniforms.output_shape","i",i.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i","input_index")}\n      }\n      return input_indices;\n    }`,cu=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${Kt("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,fu=(e,t,n,i)=>e.rank>i?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",n,"batch")};\n`:"",mu=(e,t,n,i,r)=>{let[a,s,o,u]=2===n.length?[-1,0,1,-1]:[0,2,3,1],l=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${l} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",s,`max(0, min(row, ${n[s]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};\n      ${fu(e,u,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${l} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${l} = originalIndices[${s}];\n      var col:${l} = originalIndices[${o}];\n      ${i?`if (row < 0 || row > (${n[s]} - 1) || col < 0 || col > (${n[o]} - 1)) {\n        return ${r};\n      }`:""};\n      row = max(0, min(row, ${n[s]} - 1));\n      col = max(0, min(col, ${n[o]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${u}])`:"0"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${l} = getInputValue(batch, channel, row1, col1);\n      var x12: ${l} = getInputValue(batch, channel, row1, col2);\n      var x21: ${l} = getInputValue(batch, channel, row2, col1);\n      var x22: ${l} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${l} = abs(row - ${l}(row1));\n      var dx2: ${l} = abs(${l}(row2) - row);\n      var dy1: ${l} = abs(col - ${l}(col1));\n      var dy2: ${l} = abs(${l}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},gu=(e,t,n,i,r,a,s,o,u,l)=>{let d=2===n.length,[p,h]=d?[0,1]:[2,3],c=e.type.value,f=s=>{let d=s===p?"row":"col";return`\n      fn ${d}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${c} {\n        var output_index = ${t.indicesGet("output_indices",s)};\n        var originalIdx: ${c} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[s]},\n        ${i[s]}, ${n[s]}, ${a[s]}, ${a[s]} + ${n.length});\n        var fractOriginalIdx: ${c} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${o} && (originalIdx < 0 || originalIdx > (${n[s]} - 1))) {\n          return ${u};\n        }\n        var data: array<${c}, 4> = array<${c}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${d}: ${c} = originalIdx + ${c}(i);\n          if (${d} < 0 || ${d} >= ${n[s]}) {\n            ${l?"coefs[i + 1] = 0.0;\n                        continue;":o?`return ${u};`:`${d} = max(0, min(${d}, ${n[s]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",s,`u32(${d})`)};\n          data[i + 1] = ${s===p?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${f(p)};\n    ${f(h)};\n  fn getCubicInterpolationCoefs(s: ${c}) -> array<${c}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${c}, 4> = array<${c}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${c} = 1.0 - absS;\n    var twoMinusAbsS: ${c} = 2.0 - absS;\n    var onePlusAbsS: ${c} = 1.0 + absS;\n    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};\n    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${c}, 4>, coefs: array<${c}, 4>) -> ${c} {\n    var coefsSum: ${c} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${c} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},_u=(e,t,n,i,r)=>{let[a,s,o,u,l]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",s,`max(0, min(depth, ${n[s]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};\n      ${e.indicesSet("input_indices",u,`max(0, min(width, ${n[u]} - 1))`)};\n      ${fu(e,l,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${d} = originalIndices[${s}];\n      var height:${d} = originalIndices[${o}];\n      var width:${d} = originalIndices[${u}];\n      ${i?`if (depth < 0 || depth > (${n[s]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[u]} - 1)) {\n      return ${r};\n        }`:""};\n\n    depth = max(0, min(depth, ${n[s]} - 1));\n      height = max(0, min(height, ${n[o]} - 1));\n      width = max(0, min(width, ${n[u]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${l}])`:"0"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${d} = abs(depth - ${d}(depth1));\n      var dx2: ${d} = abs(${d}(depth2) - depth);\n      var dy1: ${d} = abs(height - ${d}(height1));\n      var dy2: ${d} = abs(${d}(height2) - height);\n      var dz1: ${d} = abs(width - ${d}(width1));\n      var dz2: ${d} = abs(${d}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},yu=(e,t,n,i,r,a)=>{let s=e.dims,o=uu(a,t.axes,s.length),u=lu(s,i,r,t.axes),l=i.slice();0===i.length&&(l=s.map((e,t)=>0===e?1:u[t]/e),"stretch"!==t.keepAspectRatioPolicy&&(u=du(s,l,t)));let d=Xt("output",e.dataType,u.length),p=Qt("input",e.dataType,s.length),h=ut.size(u),c=s.length===u.length&&s.every((e,t)=>e===u[t]),f="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,g=p.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?"cubic"===t.mode?l:l.length:""}|${r.length>0?r:""}|${o.length>0?o:""}|${c}|${"nearest"===t.mode?s.length:s}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${c?"":`\n      ${su(t.coordinateTransformMode,g)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${cu(p,s)};\n              ${ou(t.nearestMode,n,g)};\n              ${hu(p,d,s,u,l.length,o.length,f)};\n              `;case"linear":return`\n              ${pu(d,s,u,l.length,o.length)};\n              ${(()=>{if(2===s.length||4===s.length)return`${mu(p,d,s,f,m)}`;if(3===s.length||5===s.length)return`${_u(p,d,s,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===s.length||4===s.length)return`${gu(p,d,s,u,l,o,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",l.length).registerUniform("roi","f32",o.length).declareVariables(p,d)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${c?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${p.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${p.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===s.length||4===s.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:l},{type:1,data:o},...Gt(s,u)]})}},wu=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},$u=(e,t)=>{let n=[],i=[],r=[],a=wu(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");ru(e.inputs,t,a,n,i,r),e.compute(yu(e.inputs[0],t,a,n,i,r),{inputs:[0]})},bu=e=>{let t=e.antialias,n=e.axes,i=e.coordinateTransformMode,r=e.cubicCoeffA,a=0!==e.excludeOutside,s=e.extrapolationValue,o=e.keepAspectRatioPolicy,u=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return Ut({antialias:t,axes:n,coordinateTransformMode:i,cubicCoeffA:r,excludeOutside:a,extrapolationValue:s,keepAspectRatioPolicy:o,mode:u,nearestMode:l})}}),id=N(()=>{Ju(),nl(),ll(),vu=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],i=e[2];if(t.dataType!==n.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let r=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==a)throw new Error("Skip must have the same sequence length as input");if(1!==i.dims.length)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},xu=(e,t,n,i)=>{let r=t.simplified,a=e[0].dims,s=ut.size(a),o=a,u=s,l=a.slice(-1)[0],d=i?a.slice(0,-1).concat(1):[],p=!r&&e.length>3,h=e.length>4,c=i&&n>1,f=i&&n>2,m=n>3,g=Wt(l),_=[{type:12,data:u},{type:12,data:g},{type:12,data:l},{type:1,data:t.epsilon}],y=[{dims:o,dataType:e[0].dataType}];return n>1&&y.push({dims:d,dataType:1}),n>2&&y.push({dims:d,dataType:1}),n>3&&y.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${c};${f};${m}`,inputDependencies:e.map((e,t)=>"type")},getShaderSource:t=>{let n=[Qt("x",e[0].dataType,e[0].dims,g),Qt("skip",e[1].dataType,e[1].dims,g),Qt("gamma",e[2].dataType,e[2].dims,g)];p&&n.push(Qt("beta",e[3].dataType,e[3].dims,g)),h&&n.push(Qt("bias",e[4].dataType,e[4].dims,g)),n.push(Xt("output",e[0].dataType,o,g)),c&&n.push(Xt("mean_output",1,d)),f&&n.push(Xt("inv_std_output",1,d)),m&&n.push(Xt("input_skip_bias_sum",e[0].dataType,o,g));let i=Vt(e[0].dataType),a=Vt(1,g);return`\n\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\n      var<workgroup> sum_shared : array<${a}, 64>;\n      var<workgroup> sum_squared_shared : array<${a}, 64>;\n\n      ${t.mainStart([64,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / 64;\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / 64;\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == 63) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h?"bias[offset1d + i]":i+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${m?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${Ft(i,g,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = 64;\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${jt("sum",g)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${jt("square_sum",g)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);\n        ${c?"mean_output[global_idx] = mean;":""}\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${r?"":`- ${i}(mean)`}) *\n            ${i}(inv_std_dev) * gamma[offset1d + i]\n            ${p?"+ beta[offset1d + i]":""};\n        }\n      }`},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(u/l)},programUniforms:_})}},ku=(e,t)=>{vu(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(xu(e.inputs,t,e.outputCount,!1),{outputs:n})}}),rd=N(()=>{Ju(),nl(),ul(),ll(),Su=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)})},Iu=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach(e=>n.push(Number(e)));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach(e=>n.push(Number(e)))}return n},Tu=(e,t)=>{if(e.length>1){let t=Iu(e,1),n=Iu(e,2),i=Iu(e,3);return 0===i.length&&(i=[...Array(e[0].dims.length).keys()]),Ut({starts:t,ends:n,axes:i})}return t},Eu=(e,t,n,i,r)=>{let a=e;return e<0&&(a+=n[i[t]]),r[t]<0?Math.max(0,Math.min(a,n[i[t]]-1)):Math.max(0,Math.min(a,n[i[t]]))},zu=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length-1}; i >= 0; i--) {\n            let input_shape_i = ${Kt("uniforms.input_shape","i",n.length)};\n            let steps_i = ${Kt("uniforms.steps","i",n.length)};\n            let signs_i = ${Kt("uniforms.signs","i",n.length)};\n            let starts_i = ${Kt("uniforms.starts","i",n.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Cu=(e,t)=>{let n=e[0].dims,i=ut.size(n),r=t.axes.length>0?ut.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=Iu(e,4);a.forEach(e=>0!==e||(()=>{throw new Error("step cannot be 0")})),0===a.length&&(a=Array(r.length).fill(1));let s=t.starts.map((e,t)=>Eu(e,t,n,r,a)),o=t.ends.map((e,t)=>Eu(e,t,n,r,a));if(r.length!==s.length||r.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==n.length)for(let e=0;e<n.length;++e)r.includes(e)||(s.splice(e,0,0),o.splice(e,0,n[e]),a.splice(e,0,1));let u=a.map(e=>Math.sign(e));a.forEach((e,t,n)=>{if(e<0){let i=(o[t]-s[t])/e,r=s[t],u=r+i*a[t];s[t]=u,o[t]=r,n[t]=-e}});let l=n.slice(0);r.forEach((e,t)=>{l[e]=Math.ceil((o[e]-s[e])/a[e])});let d={dims:l,dataType:e[0].dataType},p=Xt("output",e[0].dataType,l.length),h=Qt("input",e[0].dataType,e[0].dims.length),c=ut.size(l),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:s.length},{name:"signs",type:"i32",length:u.length},{name:"steps",type:"u32",length:a.length}],m=[{type:12,data:c},{type:12,data:s},{type:6,data:u},{type:12,data:a},...Gt(e[0].dims,l)];return{name:"Slice",shaderCache:{hint:`${u.length}_${s.length}_${a.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${e.registerUniforms(f).declareVariables(h,p)}\n        ${zu(h,p,n)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${p.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${p.setByOffset("global_idx",h.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:m})}},Ou=(e,t)=>{Su(e.inputs,t);let n=Tu(e.inputs,t);e.compute(Cu(e.inputs,n),{inputs:[0]})},Bu=e=>{let t=e.starts,n=e.ends,i=e.axes;return Ut({starts:t,ends:n,axes:i})}}),ad=N(()=>{Ju(),nl(),ul(),dl(),ll(),Au=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},Ru=(e,t)=>{let n,i=e.inputs[0],r=i.dims,a=ut.size(r),s=r.length,o=ut.normalizeAxis(t.axis,s),u=o<r.length-1,l=[];u?(l=Array.from({length:s},(e,t)=>t),l[o]=s-1,l[s-1]=o,n=e.compute(ln(i,l),{inputs:[i],outputs:[-1]})[0]):n=i;let d=n.dims,p=d[s-1],h=a/p,c=Wt(p),f=p/c,m=64;1===h&&(m=256);let g=Qt("x",n.dataType,n.dims,c),_=Xt("result",n.dataType,n.dims,c),y=g.type.value,w="f32"===Vt(n.dataType)?`var threadMax = ${y}(-3.402823e+38f);`:`var threadMax = ${y}(-65504.0h);`,$=e.compute({name:"Softmax",shaderCache:{hint:`${c};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:d,dataType:n.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${y};\n      var<workgroup> rowSumShared : ${y};\n      var<workgroup> threadShared : array<${y}, ${m}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${y} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${y}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${e.registerUniform("packedCols","i32").declareVariables(g,_)}\n      ${e.mainStart(m)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${m};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${y}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",c)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${y}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${y}(${jt("threadShared[0]",c)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          // max operation protects against NaN since all values should be >=0\n          value = max(value, ${y}(0.0));\n          setValue(row, col, row_stride, value);\n        }\n      }`},{inputs:[n],outputs:[u?-1:0]})[0];u&&e.compute(ln($,l),{inputs:[$]})},Du=(e,t)=>{Au(e.inputs),Ru(e,t)},Mu=e=>Ut({axis:e.axis})}),sd=N(()=>{Ju(),nl(),ll(),Pu=e=>Array.from(e.getBigInt64Array(),Number),Uu=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Pu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Nu=(e,t)=>{let n=[];for(let i=0;i<e.length;++i)n.push(e[i]*t[i]);return n},qu=(e,t)=>{let n=e[0].dims,i=t??Pu(e[1]),r=Nu(n,i),a=ut.size(r),s=e[0].dataType,o=Qt("input",s,n.length),u=Xt("output",s,r.length);return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Gt(e[0].dims,r)]}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...n)};\n      ${e.registerUniform("output_size","u32").declareVariables(o,u)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${u.offsetToIndices("global_idx")};\n      var input_indices: ${o.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${u.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${o.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${u.setByOffset("global_idx",o.getByIndices("input_indices"))}\n    }`}},Vu=e=>{Uu(e.inputs),e.compute(qu(e.inputs),{inputs:[0]})}}),od=N(()=>{Ju(),nl(),ll(),Lu=(e,t,n,i,r)=>{let a,s=Xt("output_data",r,n.length,4),o=Qt("a_data",t[1].dataType,t[1].dims.length,4),u=Qt("b_data",t[2].dataType,t[2].dims.length,4),l=Qt("c_data",t[0].dataType,t[0].dims.length,4),d=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(i){let e=(e,t,n="")=>{let i=`a_data[index_a${t}][component_a${t}]`,r=`b_data[index_b${t}][component_b${t}]`,a=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\n            let output_indices${t} = ${s.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offset_a${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,s)};\n            let offset_b${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,s)};\n            let offset_c${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,s)};\n            let index_a${t} = offset_a${t} / 4u;\n            let index_b${t} = offset_b${t} / 4u;\n            let index_c${t} = offset_c${t} / 4u;\n            let component_a${t} = offset_a${t} % 4u;\n            let component_b${t} = offset_b${t} % 4u;\n            let component_c${t} = offset_c${t} % 4u;\n            ${e}[${t}] = ${n}(${d(i,r,a)});\n          `};a=9===r?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("output_data[global_idx]",0)}\n            ${e("output_data[global_idx]",1)}\n            ${e("output_data[global_idx]",2)}\n            ${e("output_data[global_idx]",3)}\n          `}else a=s.setByOffset("global_idx",d(o.getByOffset("global_idx"),u.getByOffset("global_idx"),l.getByOffset("global_idx")));return`\n        ${e.registerUniform("vec_size","u32").declareVariables(l,o,u,s)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${a}\n      }`},Gu=e=>{let t=e[1].dims,n=e[2].dims,i=e[0].dims,r=e[1].dataType,a=!(ut.areEqual(t,n)&&ut.areEqual(n,i)),s=t,o=ut.size(t);if(a){let e=ot.calcShape(ot.calcShape(t,n,!1),i,!1);if(!e)throw new Error("Can't perform where op on the given tensors");s=e,o=ut.size(s)}let u=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>Lu(t,e,s,a,r),getRunData:()=>({outputs:[{dims:s,dataType:r}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:u},...Gt(i,t,n,s)]})}},Wu=e=>{e.compute(Gu(e.inputs))}}),ud=N(()=>{cl(),fl(),ml(),gl(),yl(),wl(),$l(),zl(),Ol(),Bl(),Al(),Rl(),Dl(),Ml(),Pl(),Ul(),Nl(),ql(),Vl(),Ll(),Fl(),jl(),Kl(),Zl(),Ql(),Gl(),Xl(),Yl(),Jl(),ed(),td(),hl(),nd(),Hl(),id(),rd(),ad(),Wl(),sd(),dl(),_l(),od(),Hu=new Map([["Abs",[Ii]],["Acos",[Ti]],["Acosh",[Ei]],["Add",[br]],["ArgMax",[oi,ui]],["ArgMin",[si,ui]],["Asin",[zi]],["Asinh",[Ci]],["Atan",[Oi]],["Atanh",[Bi]],["Attention",[gi]],["AveragePool",[Mo,Do]],["BatchNormalization",[$i]],["BiasAdd",[xi]],["BiasSplitGelu",[_r]],["Cast",[Ri,Ai]],["Ceil",[Pi]],["Clip",[Mi]],["Concat",[Dr,Mr]],["Conv",[$a,ga]],["ConvTranspose",[Ca,Ia]],["Cos",[Ui]],["Cosh",[Ni]],["CumSum",[Ba,Aa]],["DepthToSpace",[Pa,Ua]],["DequantizeLinear",[jo,Ko]],["Div",[vr]],["Einsum",[ja,Ka]],["Elu",[Vi,qi]],["Equal",[xr]],["Erf",[Gi]],["Exp",[Wi]],["Expand",[Ja]],["FastGelu",[ts]],["Floor",[Hi]],["FusedConv",[$a,ga]],["Gather",[as,rs]],["GatherElements",[gs,ms]],["GatherBlockQuantized",[ps,hs]],["GatherND",[os,us]],["Gelu",[Fi]],["Gemm",[$s,ws]],["GlobalAveragePool",[No,Uo]],["GlobalMaxPool",[Wo,Go]],["Greater",[Tr]],["GreaterOrEqual",[zr]],["GridSample",[Bs,As]],["GroupQueryAttention",[to]],["HardSigmoid",[er,Ji]],["InstanceNormalization",[ao]],["LayerNormalization",[uo]],["LeakyRelu",[ji,qi]],["Less",[Er]],["LessOrEqual",[Cr]],["Log",[pr]],["MatMul",[po]],["MatMulNBits",[mo,go]],["MaxPool",[Vo,Lo]],["Mul",[kr]],["MultiHeadAttention",[qs,Ms]],["Neg",[Zi]],["Not",[Ki]],["Pad",[So]],["Pow",[Sr]],["QuickGelu",[fr,qi]],["Range",[Xo]],["Reciprocal",[Qi]],["ReduceMin",[ei]],["ReduceMean",[Zn]],["ReduceMax",[Jn]],["ReduceSum",[ni]],["ReduceProd",[ti]],["ReduceL1",[Qn]],["ReduceL2",[Xn]],["ReduceLogSum",[ri]],["ReduceLogSumExp",[Yn]],["ReduceSumSquare",[ii]],["Relu",[Xi]],["Resize",[$u,bu]],["RotaryEmbedding",[Qs]],["ScatterND",[tu,eu]],["Sigmoid",[Yi]],["Sin",[tr]],["Sinh",[nr]],["Slice",[Ou,Bu]],["SkipLayerNormalization",[ku]],["Split",[Fs,js]],["Sqrt",[ir]],["Softmax",[Du,Mu]],["Sub",[Ir]],["Tan",[rr]],["Tanh",[sr]],["ThresholdedRelu",[dr,qi]],["Tile",[Vu]],["Transpose",[dn,pn]],["Where",[Wu]]])}),ld=N(()=>{oe(),tl(),ll(),Fu=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,i,r){E(e.programInfo.name);let a=this.backend.device,s=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let o=[];for(let e of t)o.push({binding:o.length,resource:{buffer:e.buffer}});for(let e of n)o.push({binding:o.length,resource:{buffer:e.buffer}});r&&o.push({binding:o.length,resource:r});let u=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:u,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}s.setPipeline(e.computePipeline),s.setBindGroup(0,u),s.dispatchWorkgroups(...i),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),z(e.programInfo.name)}dispose(){}build(e,t){E(e.name);let n=this.backend.device,i=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(e=>{n.features.has(e.feature)&&i.push(`enable ${e.extension};`)});let r=tn(t,this.backend.device.limits),a=e.getShaderSource(r),s=`${i.join("\n")}\n${r.additionalImplementations}\n${a}`,o=n.createShaderModule({code:s,label:e.name});at("verbose",()=>`[WebGPU] ${e.name} shader code: ${s}`);let u=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return z(e.name),{programInfo:e,computePipeline:u,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,i="number"==typeof e?1:e.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=r&&n<=r&&i<=r)return[t,n,i];let a=t*n*i,s=Math.ceil(Math.sqrt(a));if(s>r){if(s=Math.ceil(Math.cbrt(a)),s>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[s,s,s]}return[s,s,1]}}}),dd={};q(dd,{WebGpuBackend:()=>fd});var pd,hd,cd,fd,md=N(()=>{oe(),Ju(),tl(),il(),ol(),ud(),ld(),pd=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let i=0;i<e.length;++i){let r=e[i].dataType;switch(t[i]){case"none":n.push("");break;case"type":n.push(`${r}`);break;case"rank":{let t=e[i].dims.length;n.push(`${r};${t}`);break}case"dims":{let t=e[i].dims.join(",");n.push(`${r};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return n.join("|")},hd=(e,t,n)=>{let i=e.name;return e.shaderCache?.hint&&(i+="["+e.shaderCache.hint+"]"),i+=":"+n+`:${pd(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,i},cd=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},fd=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},r=e=>t.features.has(e)&&n.push(e)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups"),this.device=await t.requestDevice(i),this.adapterInfo=new cd(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Mt(this),this.programManager=new Fu(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,it(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;E(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then(()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let i=n[e],r=i.kernelId,a=this.kernels.get(r),s=a.kernelType,o=a.kernelName,u=i.programName,l=i.inputTensorViews,d=i.outputTensorViews,p=t[2*e],h=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=p);let c=Number(p-this.queryTimeBase),f=Number(h-this.queryTimeBase);if(!Number.isSafeInteger(c)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:l.map(e=>({dims:e.dims,dataType:He(e.dataType)})),outputsMetadata:d.map(e=>({dims:e.dims,dataType:He(e.dataType)})),kernelId:r,kernelType:s,kernelName:o,programName:u,startTime:c,endTime:f});else{let e="";l.forEach((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${He(t.dataType)}, `});let t="";d.forEach((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${He(e.dataType)}, `}),console.log(`[profiling] kernel "${r}|${s}|${o}|${u}" ${e}${t}start time: ${c} ns, execution time: ${f-c} ns`)}I("GPU",`${u}::${p}::${h}`)}e.unmap(),this.pendingQueries.delete(e)}),z()}run(e,t,n,i,r,a){E(e.name);let s=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let i=this.gpuDataManager.get(n);if(!i)throw new Error(`no GPU data for input: ${n}`);s.push(i)}let{outputs:o,dispatchGroup:u,programUniforms:l}=e.getRunData(t),d=0===n.length?o.map((e,t)=>t):n;if(d.length!==o.length)throw new Error(`Output size ${d.length} must be equal to ${o.length}.`);let p,h=[],c=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(d[e])||d[e]<-3||d[e]>=a)throw new Error(`Invalid output index: ${d[e]}`);if(-3===d[e])continue;let t=-1===d[e],n=-2===d[e],s=t||n?r(o[e].dataType,o[e].dims):i(d[e],o[e].dataType,o[e].dims);if(h.push(s),0===s.data)continue;let u=this.gpuDataManager.get(s.data);if(!u)throw new Error(`no GPU data for output: ${s.data}`);if(t&&this.temporaryData.push(u),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(u)}c.push(u)}if(s.length!==t.length||c.length!==h.length){if(0===c.length)return z(e.name),h;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(l){let e=0,t=[];l.forEach(n=>{let i="number"==typeof n.data?[n.data]:n.data;if(0===i.length)return;let r,a,s=10===n.type?2:4;10===n.type?(a=i.length>4?16:i.length>2?8:i.length*s,r=i.length>4?16:s*i.length):(a=i.length<=2?i.length*s:16,r=16),e=Math.ceil(e/a)*a,t.push(e);let o=10===n.type?8:4;e+=i.length>4?Math.ceil(i.length/o)*r:i.length*s});let n=16;e=Math.ceil(e/n)*n;let i=new ArrayBuffer(e);l.forEach((e,n)=>{let r=t[n],a="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(i,r,a.length).set(a);else if(12===e.type)new Uint32Array(i,r,a.length).set(a);else if(10===e.type)new Uint16Array(i,r,a.length).set(a);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${He(e.type)}`);new Float32Array(i,r,a.length).set(a)}});let r=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(r.buffer,0,i,0,e),this.gpuDataManager.release(r.id),p={offset:0,size:e,buffer:r.buffer}}let f=this.programManager.normalizeDispatchGroupSize(u),m=1===f[1]&&1===f[2],g=hd(e,t,m),_=this.programManager.getArtifact(g);if(_||(_=this.programManager.build(e,f),this.programManager.setArtifact(g,_),at("info",()=>`[artifact] key: ${g}, programName: ${e.name}`)),l&&_.uniformVariablesInfo){if(l.length!==_.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${_.uniformVariablesInfo.length}, got ${l.length} in program "${_.programInfo.name}".`);for(let e=0;e<l.length;e++){let t=l[e],n=t.type,i="number"==typeof t.data?1:t.data.length,[r,a]=_.uniformVariablesInfo[e];if(n!==r||i!==a)throw new Error(`Uniform variable ${e} mismatch: expect type ${r} with size ${a}, got type ${n} with size ${i} in program "${_.programInfo.name}".`)}}if(at("info",()=>`[ProgramManager] run "${e.name}" (key=${g}) with ${f[0]}x${f[1]}x${f[2]}`),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:_.programInfo.name,inputTensorViews:t,outputTensorViews:h};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(_,s,c,f,p),z(e.name),h}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,i){let r=Hu.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);let a={kernelType:e,kernelName:i,kernelEntry:r[0],attributes:[r[1],n]};this.kernels.set(t,a)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let i=this.kernels.get(e);if(!i)throw new Error(`kernel not created: ${e}`);let r=i.kernelType,a=i.kernelName,s=i.kernelEntry,o=i.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${r}] ${a}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),at("info",()=>`[WebGPU] Start to run kernel "[${r}] ${a}"...`);let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),s(t,o[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${a}" failed. ${e}`)),1}finally{u&&n.push(this.device.popErrorScope().then(e=>e?`GPU validation error for kernel "[${r}] ${a}": ${e.message}`:null));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,i){let r=this.sessionExternalDataMapping.get(e);r||(r=new Map,this.sessionExternalDataMapping.set(e,r));let a=r.get(t),s=this.gpuDataManager.registerExternalBuffer(n,i,a);return r.set(t,[s,n]),s}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(e=>this.gpuDataManager.unregisterExternalBuffer(e[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let i=await Rt(this,e,t);return ct(i.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){at("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){at("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){at("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let i=0;i<n;i++){let n=this.getComputePassEncoder(),r=e[i];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(r.computePipeline),n.setBindGroup(0,r.bindGroup),n.dispatchWorkgroups(...r.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),gd={};q(gd,{init:()=>wd});var _d,yd,wd,$d,bd,vd,xd,kd,Sd,Id,Td,Ed,zd,Cd,Od,Bd,Ad,Rd,Dd,Md,Pd,Ud,Nd,qd,Vd,Ld,Gd,Wd,Hd,Fd,jd,Kd,Zd,Qd,Xd,Yd,Jd,ep=N(()=>{Ju(),tl(),nl(),al(),_d=class e{constructor(e,t,n,i){this.module=e,this.dataType=t,this.data=n,this.dims=i}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(ut.size(t)!==ut.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},yd=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let i=e.PTR_SIZE,r=n/e.PTR_SIZE,a=4===i?"i32":"i64";this.opKernelContext=Number(e.getValue(i*r++,a));let s=Number(e.getValue(i*r++,a));this.outputCount=Number(e.getValue(i*r++,a)),this.customDataOffset=Number(e.getValue(i*r++,"*")),this.customDataSize=Number(e.getValue(i*r++,a));let o=[];for(let t=0;t<s;t++){let t=Number(e.getValue(i*r++,a)),n=Number(e.getValue(i*r++,"*")),s=Number(e.getValue(i*r++,a)),u=[];for(let t=0;t<s;t++)u.push(Number(e.getValue(i*r++,a)));o.push(new _d(e,t,n,u))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map(e=>"number"==typeof e?this.inputs[e]:e)??this.inputs,i=t?.outputs??[];return this.backend.run(e,n,i,(e,t,n)=>new _d(this.module,t,this.output(e,n),n),(e,t)=>{let n=Fe(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let i=n>0?this.backend.gpuDataManager.create(n).id:0;return new _d(this.module,e,i,t)},this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,i=4===n?"i32":"i64",r=this.module.stackAlloc((1+t.length)*n);this.module.setValue(r,t.length,i);for(let e=0;e<t.length;e++)this.module.setValue(r+n*(e+1),t[e],i);return this.module._JsepOutput(this.opKernelContext,e,r)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},wd=async(e,t,n,i)=>{let r=t.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new(0,(md(),V(dd)).WebGpuBackend);await e.initialize(n,i),r("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,i,r,a=!1)=>{if(a)at("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(i)}, size=${Number(r)}`),e.memcpy(Number(n),Number(i));else{at("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(i)}, size=${Number(r)}`);let a=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(r));e.upload(Number(i),a)}},async(n,i,r)=>{at("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${i}, size=${r}`),await e.download(Number(n),()=>t.HEAPU8.subarray(Number(i)>>>0,Number(i+r)>>>0))},(n,i,r)=>e.createKernel(n,Number(i),r,t.UTF8ToString(t._JsepGetNodeName(Number(i)))),t=>e.releaseKernel(t),(n,i,r,a)=>{at("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${r}, kernel=${n}, contextDataOffset=${i}`);let s=new yd(t,e,Number(i));return e.computeKernel(Number(n),s,a)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new Tt(n);r("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,i,r,a)=>e.ensureTensor(t,n,i,r,a),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n),(t,n)=>e.registerMLContext(t,n),!!n.trace])}}}),tp=N(()=>{oe(),Xu(),Yu(),Ju(),Zu(),Qu(),el(),$d=(e,t)=>{0!==Ae()._OrtInit(e,t)&&Me("Can't initialize onnxruntime.")},bd=async e=>{$d(e.wasm.numThreads,Ke(e.logLevel))},vd=async(e,t)=>{Ae().asyncInit?.();let n=e.webgpu.adapter;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(n){if("object"!=typeof n.limits||"object"!=typeof n.features||"function"!=typeof n.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let t=e.webgpu.powerPreference;if(void 0!==t&&"low-power"!==t&&"high-performance"!==t)throw new Error(`Invalid powerPreference setting: "${t}"`);let i=e.webgpu.forceFallbackAdapter;if(void 0!==i&&"boolean"!=typeof i)throw new Error(`Invalid forceFallbackAdapter setting: "${i}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:t,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===t&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");{let i=(ep(),V(gd)).init;"webgpu"===t&&await i("webgpu",Ae(),e,n),"webnn"===t&&await i("webnn",Ae(),e)}},xd=new Map,kd=e=>{let t=Ae(),n=t.stackSave();try{let n=t.PTR_SIZE,i=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,i,i+n)&&Me("Can't get session input/output count.");let r=4===n?"i32":"i64";return[Number(t.getValue(i,r)),Number(t.getValue(i+n,r))]}finally{t.stackRestore(n)}},Sd=(e,t)=>{let n=Ae(),i=n.stackSave(),r=0;try{let i=n.PTR_SIZE,a=n.stackAlloc(2*i);0!==n._OrtGetInputOutputMetadata(e,t,a,a+i)&&Me("Can't get session input/output metadata.");let s=Number(n.getValue(a,"*"));r=Number(n.getValue(a+i,"*"));let o=n.HEAP32[r/4];if(0===o)return[s,0];let u=n.HEAPU32[r/4+1],l=[];for(let e=0;e<u;e++){let t=Number(n.getValue(r+8+e*i,"*"));l.push(0!==t?n.UTF8ToString(t):Number(n.getValue(r+8+(e+u)*i,"*")))}return[s,o,l]}finally{n.stackRestore(i),0!==r&&n._OrtFree(r)}},Id=e=>{let t=Ae(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Td=async(e,t)=>{let n,i,r=Ae();Array.isArray(e)?[n,i]=e:e.buffer===r.HEAPU8.buffer?[n,i]=[e.byteOffset,e.byteLength]:[n,i]=Id(e);let a=0,s=0,o=0,u=[],l=[],d=[];try{if([s,u]=await Ge(t),t?.externalData&&r.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(Ye("string"==typeof n?n:n.data).then(e=>{r.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(r.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,i=t?.gpuDevice,a=t?.deviceType,s=t?.powerPreference;r.currentContext=n||(i?await r.webnnCreateMLContext(i):await r.webnnCreateMLContext({deviceType:a,powerPreference:s}))}else r.currentContext=await r.webnnCreateMLContext();break}a=await r._OrtCreateSession(n,i,s),r.webgpuOnCreateSession?.(a),0===a&&Me("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.webnnRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[e,p]=kd(a),h=!!t?.enableGraphCapture,c=[],f=[],m=[],g=[],_=[];for(let t=0;t<e;t++){let[e,n,i]=Sd(a,t);0===e&&Me("Can't get an input name."),l.push(e);let s=r.UTF8ToString(e);c.push(s),m.push(0===n?{name:s,isTensor:!1}:{name:s,isTensor:!0,type:He(n),shape:i})}for(let n=0;n<p;n++){let[i,s,o]=Sd(a,n+e);0===i&&Me("Can't get an output name."),d.push(i);let u=r.UTF8ToString(i);f.push(u),g.push(0===s?{name:u,isTensor:!1}:{name:u,isTensor:!0,type:He(s),shape:o});{if(h&&void 0===t?.preferredOutputLocation){_.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[u]??"cpu",n=r.webnnIsGraphOutput;if("cpu"===e&&n&&n(a,u)){_.push("ml-tensor-cpu-output");continue}if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(h&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);_.push(e)}}let y=null;return _.some(e=>"gpu-buffer"===e||"ml-tensor"===e||"ml-tensor-cpu-output"===e)&&(o=r._OrtCreateBinding(a),0===o&&Me("Can't create IO binding."),y={handle:o,outputPreferredLocations:_,outputPreferredLocationsEncoded:_.map(e=>"ml-tensor-cpu-output"===e?"ml-tensor":e).map(e=>Xe(e))}),xd.set(a,[a,l,d,y,h,!1]),[a,c,f,m,g]}catch(e){throw l.forEach(e=>r._OrtFree(e)),d.forEach(e=>r._OrtFree(e)),0!==o&&0!==r._OrtReleaseBinding(o)&&Me("Can't release IO binding."),0!==a&&0!==r._OrtReleaseSession(a)&&Me("Can't release session."),e}finally{r._free(n),0!==s&&0!==r._OrtReleaseSessionOptions(s)&&Me("Can't release session options."),u.forEach(e=>r._free(e)),r.unmountExternalData?.()}},Ed=e=>{let t=Ae(),n=xd.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,r,a,s,o]=n;s&&(o&&0!==t._OrtClearBoundOutputs(s.handle)&&Me("Can't clear bound outputs."),0!==t._OrtReleaseBinding(s.handle)&&Me("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),r.forEach(e=>t._OrtFree(e)),a.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(i)&&Me("Can't release session."),xd.delete(e)},zd=async(e,t,n,i,r,a,s=!1)=>{if(!e)return void t.push(0);let o,u,l=Ae(),d=l.PTR_SIZE,p=e[0],h=e[1],c=e[3],f=c;if("string"===p&&("gpu-buffer"===c||"ml-tensor"===c))throw new Error("String tensor is not supported on GPU.");if(s&&"gpu-buffer"!==c)throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if("gpu-buffer"===c){let t=e[2].gpuBuffer;u=Fe(We(p),h);{let e=l.jsepRegisterBuffer;if(!e)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');o=e(i,a,t,u)}}else if("ml-tensor"===c){let t=e[2].mlTensor;u=Fe(We(p),h);let n=l.webnnRegisterMLTensor;if(!n)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');o=n(i,t,We(p),h)}else{let t=e[2];if(Array.isArray(t)){u=d*t.length,o=l._malloc(u),n.push(o);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(o+e*d,Re(t[e],n),"*")}}else{let e=l.webnnIsGraphInput,a=l.webnnIsGraphOutput;if("string"!==p&&e&&a){let s=l.UTF8ToString(r);if(e(i,s)||a(i,s)){let e=We(p);u=Fe(e,h),f="ml-tensor";let n=l.webnnCreateTemporaryTensor,r=l.webnnUploadTensor;if(!n||!r)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let a=await n(i,e,h);r(a,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),o=a}else u=t.byteLength,o=l._malloc(u),n.push(o),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),o)}else u=t.byteLength,o=l._malloc(u),n.push(o),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),o)}}let m=l.stackSave(),g=l.stackAlloc(4*h.length);try{h.forEach((e,t)=>l.setValue(g+t*d,e,4===d?"i32":"i64"));let e=l._OrtCreateTensor(We(p),o,u,g,h.length,Xe(f));0===e&&Me(`Can't create tensor for input/output. session=${i}, index=${a}.`),t.push(e)}finally{l.stackRestore(m)}},Cd=async(e,t,n,i,r,a)=>{let s=Ae(),o=s.PTR_SIZE,u=xd.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let l=u[0],d=u[1],p=u[2],h=u[3],c=u[4],f=u[5],m=t.length,g=i.length,_=0,y=[],w=[],$=[],b=[],v=s.stackSave(),x=s.stackAlloc(m*o),k=s.stackAlloc(m*o),S=s.stackAlloc(g*o),I=s.stackAlloc(g*o);try{[_,y]=Pe(a),C("wasm prepareInputOutputTensor");for(let i=0;i<m;i++)await zd(n[i],w,b,e,d[t[i]],t[i],c);for(let t=0;t<g;t++)await zd(r[t],$,b,e,p[i[t]],m+i[t],c);O("wasm prepareInputOutputTensor");for(let e=0;e<m;e++)s.setValue(x+e*o,w[e],"*"),s.setValue(k+e*o,d[t[e]],"*");for(let e=0;e<g;e++)s.setValue(S+e*o,$[e],"*"),s.setValue(I+e*o,p[i[e]],"*");if(h&&!f){let{handle:n,outputPreferredLocations:a,outputPreferredLocationsEncoded:o}=h;if(d.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${d.length}).`);C("wasm bindInputsOutputs");for(let i=0;i<m;i++){let r=t[i];0!==await s._OrtBindInput(n,d[r],w[i])&&Me(`Can't bind input[${i}] for session=${e}.`)}for(let t=0;t<g;t++){let u=i[t];r[t]?.[3]?0!==s._OrtBindOutput(n,p[u],$[t],0)&&Me(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==s._OrtBindOutput(n,p[u],0,o[u])&&Me(`Can't bind output[${t}] to ${a[t]} for session=${e}.`)}O("wasm bindInputsOutputs"),xd.set(e,[l,d,p,h,c,!0])}let u;s.jsepOnRunStart?.(l),s.webnnOnRunStart?.(l),u=h?await s._OrtRunWithBinding(l,h.handle,g,S,_):await s._OrtRun(l,k,x,m,I,g,S,_),0!==u&&Me("failed to call OrtRun().");let v=[],T=[];C("wasm ProcessOutputTensor");for(let t=0;t<g;t++){let n=Number(s.getValue(S+t*o,"*"));if(n===$[t]){v.push(r[t]);continue}let a,u=s.stackSave(),l=s.stackAlloc(4*o),d=!1,p=0;try{0!==s._OrtGetTensorData(n,l,l+o,l+2*o,l+3*o)&&Me(`Can't access output tensor data on index ${t}.`);let r=4===o?"i32":"i64",u=Number(s.getValue(l,r));p=s.getValue(l+o,"*");let c=s.getValue(l+2*o,"*"),f=Number(s.getValue(l+3*o,r)),m=[];for(let e=0;e<f;e++)m.push(Number(s.getValue(c+e*o,r)));0!==s._OrtFree(c)&&Me("Can't free memory for tensor dims.");let g=m.reduce((e,t)=>e*t,1);a=He(u);let _=h?.outputPreferredLocations[i[t]];if("string"===a){if("gpu-buffer"===_||"ml-tensor"===_)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<g;t++){let n=s.getValue(p+t*o,"*"),i=s.getValue(p+(t+1)*o,"*"),r=t===g-1?void 0:i-n;e.push(s.UTF8ToString(n,r))}v.push([a,m,e,"cpu"])}else if("gpu-buffer"===_&&g>0){let e=s.jsepGetBuffer;if(!e)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(p),i=Fe(u,g);if(void 0===i||!Ze(a))throw new Error(`Unsupported data type: ${a}`);d=!0,v.push([a,m,{gpuBuffer:t,download:s.jsepCreateDownloader(t,i,a),dispose:()=>{0!==s._OrtReleaseTensor(n)&&Me("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===_&&g>0){let t=s.webnnEnsureTensor,i=s.webnnIsGraphInputOutputTypeSupported;if(!t||!i)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===Fe(u,g)||!Qe(a))throw new Error(`Unsupported data type: ${a}`);if(!i(e,a,!1))throw new Error(`preferredLocation "ml-tensor" for ${a} output is not supported by current WebNN Context.`);let r=await t(e,p,u,m,!1);d=!0,v.push([a,m,{mlTensor:r,download:s.webnnCreateMLTensorDownloader(p,a),dispose:()=>{s.webnnReleaseTensorId(p),s._OrtReleaseTensor(n)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===_&&g>0){let e=s.webnnCreateMLTensorDownloader(p,a)(),t=v.length;d=!0,T.push((async()=>{let i=[t,await e];return s.webnnReleaseTensorId(p),s._OrtReleaseTensor(n),i})()),v.push([a,m,[],"cpu"])}else{let e=new(je(a))(g);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(s.HEAPU8.subarray(p,p+e.byteLength)),v.push([a,m,e,"cpu"])}}finally{s.stackRestore(u),"string"===a&&p&&s._free(p),d||s._OrtReleaseTensor(n)}}h&&!c&&(0!==s._OrtClearBoundOutputs(h.handle)&&Me("Can't clear bound outputs."),xd.set(e,[l,d,p,h,c,!1]));for(let[e,t]of await Promise.all(T))v[e][2]=t;return O("wasm ProcessOutputTensor"),v}finally{s.webnnOnRunEnd?.(l),s.stackRestore(v),w.forEach(e=>s._OrtReleaseTensor(e)),$.forEach(e=>s._OrtReleaseTensor(e)),b.forEach(e=>s._free(e)),0!==_&&s._OrtReleaseRunOptions(_),y.forEach(e=>s._free(e))}},Od=e=>{let t=Ae(),n=xd.get(e);if(!n)throw new Error("invalid session id");let i=n[0],r=t._OrtEndProfiling(i);0===r&&Me("Can't get an profile file name."),t._OrtFree(r)},Bd=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}}),np=N(()=>{oe(),tp(),Zu(),Ku(),Ad=()=>!!l.wasm.proxy&&typeof document<"u",Dd=!1,Md=!1,Pd=!1,qd=new Map,Vd=(e,t)=>{let n=qd.get(e);n?n.push(t):qd.set(e,[t])},Ld=()=>{if(Dd||!Md||Pd||!Rd)throw new Error("worker not ready")},Gd=e=>{switch(e.data.type){case"init-wasm":Dd=!1,e.data.err?(Pd=!0,Nd[1](e.data.err)):(Md=!0,Nd[0]()),Ud&&(URL.revokeObjectURL(Ud),Ud=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=qd.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},Wd=async()=>{if(!Md){if(Dd)throw new Error("multiple calls to 'initWasm()' detected.");if(Pd)throw new Error("previous call to 'initWasm()' failed.");if(Dd=!0,Ad())return new Promise((e,t)=>{Rd?.terminate(),ve().then(([n,i])=>{try{(Rd=i).onerror=e=>t(e),Rd.onmessage=Gd,Nd=[e,t];let r={type:"init-wasm",in:l};if(!r.in.wasm.wasmPaths&&n){let e=me();e&&(r.in.wasm.wasmPaths=e)}Rd.postMessage(r),Ud=n}catch(e){t(e)}},t)});try{await Be(l.wasm),await bd(l),Md=!0}catch(e){throw Pd=!0,e}finally{Dd=!1}}},Hd=async e=>{if(Ad())return Ld(),new Promise((t,n)=>{Vd("init-ep",[t,n]);let i={type:"init-ep",in:{epName:e,env:l}};Rd.postMessage(i)});await vd(l,e)},Fd=async e=>Ad()?(Ld(),new Promise((t,n)=>{Vd("copy-from",[t,n]);let i={type:"copy-from",in:{buffer:e}};Rd.postMessage(i,[e.buffer])})):Id(e),jd=async(e,t)=>{if(Ad()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Ld(),new Promise((n,i)=>{Vd("create",[n,i]);let r={type:"create",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),Rd.postMessage(r,a)})}return Td(e,t)},Kd=async e=>{if(Ad())return Ld(),new Promise((t,n)=>{Vd("release",[t,n]);let i={type:"release",in:e};Rd.postMessage(i)});Ed(e)},Zd=async(e,t,n,i,r,a)=>{if(Ad()){if(n.some(e=>"cpu"!==e[3]))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(e=>e))throw new Error("pre-allocated output tensor is not supported for proxy.");return Ld(),new Promise((r,s)=>{Vd("run",[r,s]);let o=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:i,options:a}};Rd.postMessage(u,Bd(o))})}return Cd(e,t,n,i,r,a)},Qd=async e=>{if(Ad())return Ld(),new Promise((t,n)=>{Vd("end-profiling",[t,n]);let i={type:"end-profiling",in:e};Rd.postMessage(i)});Od(e)}}),ip=N(()=>{oe(),np(),Ju(),ue(),el(),Xd=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Yd=e=>{switch(e[3]){case"cpu":return new S(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ze(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:i,dispose:r}=e[2];return S.fromGpuBuffer(n,{dataType:t,dims:e[1],download:i,dispose:r})}case"ml-tensor":{let t=e[0];if(!Qe(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:i,dispose:r}=e[2];return S.fromMLTensor(n,{dataType:t,dims:e[1],download:i,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},Jd=class{async fetchModelAndCopyToWasmMemory(e){return Fd(await Ye(e))}async loadModel(e,t){let n;E(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await jd(n,t),z()}async dispose(){return Kd(this.sessionId)}async run(e,t,n){E();let i=[],r=[];Object.entries(e).forEach(e=>{let t=e[0],n=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw new Error(`invalid input '${t}'`);i.push(n),r.push(a)});let a=[],s=[];Object.entries(t).forEach(e=>{let t=e[0],n=e[1],i=this.outputNames.indexOf(t);if(-1===i)throw new Error(`invalid output '${t}'`);a.push(n),s.push(i)});let o=i.map((e,t)=>Xd(e,()=>`input "${this.inputNames[r[t]]}"`)),u=a.map((e,t)=>e?Xd(e,()=>`output "${this.outputNames[s[t]]}"`):null),l=await Zd(this.sessionId,r,o,s,u,n),d={};for(let e=0;e<l.length;e++)d[this.outputNames[s[e]]]=a[e]??Yd(l[e]);return z(),d}startProfiling(){}endProfiling(){Qd(this.sessionId)}}}),rp={};q(rp,{OnnxruntimeWebAssemblyBackend:()=>sp,initializeFlags:()=>ap,wasmBackend:()=>op});var ap,sp,op,up=N(()=>{oe(),np(),ip(),ap=()=>{("number"!=typeof l.wasm.initTimeout||l.wasm.initTimeout<0)&&(l.wasm.initTimeout=0);let e=l.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),l.wasm.simd=!1),"boolean"!=typeof l.wasm.proxy&&(l.wasm.proxy=!1),"boolean"!=typeof l.wasm.trace&&(l.wasm.trace=!1),"number"!=typeof l.wasm.numThreads||!Number.isInteger(l.wasm.numThreads)||l.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)l.wasm.numThreads=1;else{let e=typeof navigator>"u"?U("node:os").cpus().length:navigator.hardwareConcurrency;l.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},op=new(sp=class{async init(e){ap(),await Wd(),await Hd(e)}async createInferenceSessionHandler(e,t){let n=new Jd;return await n.loadModel(e,t),n}})}),lp={};q(lp,{InferenceSession:()=>A,TRACE:()=>I,TRACE_EVENT_BEGIN:()=>C,TRACE_EVENT_END:()=>O,TRACE_FUNC_BEGIN:()=>E,TRACE_FUNC_END:()=>z,Tensor:()=>S,default:()=>dp,env:()=>l,registerBackend:()=>i}),oe(),oe(),oe();var dp=se;{let e=(up(),V(rp)).wasmBackend;i("webgpu",e,5),i("webnn",e,5),i("cpu",e,10),i("wasm",e,10)}return Object.defineProperty(l.versions,"web",{value:"1.23.2",enumerable:!0}),V(lp)})();e.exports=i},687:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=687,e.exports=t}},t={};function n(i){var r=t[i];if(void 0!==r)return r.exports;var a=t[i]={exports:{}};return e[i].call(a.exports,a,a.exports,n),a.exports}n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n(156)})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWwrQyxRQUdyQixJQUFJbXhDLEVBQVM0TSxFQUF5QkUsR0FBWSxDQUdqRGorQyxRQUFTLENBQUMsR0FPWCxPQUhBbStDLEVBQW9CRixHQUFVdCtDLEtBQUt3eEMsRUFBT254QyxRQUFTbXhDLEVBQVFBLEVBQU9ueEMsUUFBU2crQyxHQUdwRTdNLEVBQU9ueEMsT0FDZixDQ3RCQWcrQyxFQUFvQjEvQyxFQUFJLENBQUM4L0MsRUFBS0MsSUFBVWpnRCxPQUFPcUIsVUFBVUMsZUFBZUMsS0FBS3krQyxFQUFLQyxHQ0d4REwsRUFBb0IsSSIsInNvdXJjZXMiOlsid2VicGFjazovL2FyX3doZWVscy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9hcl93aGVlbHMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm1pbi5qcyIsIndlYnBhY2s6Ly9hcl93aGVlbHMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3QvIHN5bmMiLCJ3ZWJwYWNrOi8vYXJfd2hlZWxzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2FyX3doZWVscy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2FyX3doZWVscy93ZWJwYWNrL3N0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG9ydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwib25ueHJ1bnRpbWUtd2ViXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIHJ1bk1vZGVsKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIDHvuI/ig6Mg0JfQsNCz0YDRg9C30LrQsCDQvNC+0LTQtdC70LhcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShcIi4vbW9kZWxzL2Jlc3Qub25ueFwiLCB7XG4gICAgICAgICAgICBleGVjdXRpb25Qcm92aWRlcnM6IFtcIndhc21cIl0sIC8vINCY0YHQv9C+0LvRjNC30YPQtdC8IFdlYkFzc2VtYmx5XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSDQnNC+0LTQtdC70Ywg0LfQsNCz0YDRg9C20LXQvdCwOlwiLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gMu+4j+KDoyDQn9C+0LTQs9C+0YLQvtCy0LrQsCDQstGF0L7QtNC90YvRhSDQtNCw0L3QvdGL0YVcbiAgICAgICAgLy8g0J/RgNC40LzQtdGAOiDQstGF0L7QtNC90L7QuSDRgtC10L3Qt9C+0YAgKDEsIDMsIDIyNCwgMjI0KVxuICAgICAgICBjb25zdCBpbnB1dCA9IG5ldyBvcnQuVGVuc29yKFwiZmxvYXQzMlwiLCBuZXcgRmxvYXQzMkFycmF5KDEgKiAzICogMjI0ICogMjI0KSwgWzEsIDMsIDIyNCwgMjI0XSk7XG4gICAgICAgIC8vIDPvuI/ig6Mg0JLRi9C/0L7Qu9C90LXQvdC40LUg0LjQvdGE0LXRgNC10L3RgdCwXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzZXNzaW9uLnJ1bih7IGlucHV0OiBpbnB1dCB9KTtcbiAgICAgICAgLy8gNO+4j+KDoyDQntCx0YDQsNCx0L7RgtC60LAg0LLRi9Cy0L7QtNCwXG4gICAgICAgIGNvbnN0IG91dHB1dE5hbWUgPSBzZXNzaW9uLm91dHB1dE5hbWVzWzBdO1xuICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSByZXN1bHRzW291dHB1dE5hbWVdO1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSDQoNC10LfRg9C70YzRgtCw0YI6XCIsIG91dHB1dFRlbnNvci5kYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MINCe0YjQuNCx0LrQsCDQv9GA0Lgg0LfQsNC/0YPRgdC60LUg0LzQvtC00LXQu9C4OlwiLCBlcnIpO1xuICAgIH1cbn1cbnJ1bk1vZGVsKCk7XG4iLCIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjMuMlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblwidXNlIHN0cmljdFwiO3ZhciBvcnQ9KCgpPT57dmFyIHduPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgVnU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgTnU9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIEx1PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyICRuPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LG4pPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtuXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgaz0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBudD0oZSx0KT0+e2Zvcih2YXIgbiBpbiB0KXduKGUsbix7Z2V0OnRbbl0sZW51bWVyYWJsZTohMH0pfSxXdT0oZSx0LG4scik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG8gb2YgTnUodCkpIUx1LmNhbGwoZSxvKSYmbyE9PW4mJnduKGUsbyx7Z2V0OigpPT50W29dLGVudW1lcmFibGU6IShyPVZ1KHQsbykpfHxyLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIGR0PWU9Pld1KHduKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciB4dCxqZSxXZSxHdSx5cix2bj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHQ9bmV3IE1hcCxqZT1bXSxXZT0oZSx0LG4pPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgcj14dC5nZXQoZSk7aWYocj09PXZvaWQgMCl4dC5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5Om59KTtlbHNle2lmKHIucHJpb3JpdHk+bilyZXR1cm47aWYoci5wcmlvcml0eT09PW4mJnIuYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke259YCl9aWYobj49MCl7bGV0IG89amUuaW5kZXhPZihlKTtvIT09LTEmJmplLnNwbGljZShvLDEpO2ZvcihsZXQgaT0wO2k8amUubGVuZ3RoO2krKylpZih4dC5nZXQoamVbaV0pLnByaW9yaXR5PD1uKXtqZS5zcGxpY2UoaSwwLGUpO3JldHVybn1qZS5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sR3U9YXN5bmMgZT0+e2xldCB0PXh0LmdldChlKTtpZighdClyZXR1cm5cImJhY2tlbmQgbm90IGZvdW5kLlwiO2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpcmV0dXJuIHQuZXJyb3I7e2xldCBuPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIG58fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KGUpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKHIpe3JldHVybiBufHwodC5lcnJvcj1gJHtyfWAsdC5hYm9ydGVkPSEwKSx0LmVycm9yfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX0seXI9YXN5bmMgZT0+e2xldCB0PWUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSxuPXQubWFwKHU9PnR5cGVvZiB1PT1cInN0cmluZ1wiP3U6dS5uYW1lKSxyPW4ubGVuZ3RoPT09MD9qZTpuLG8saT1bXSxzPW5ldyBTZXQ7Zm9yKGxldCB1IG9mIHIpe2xldCBkPWF3YWl0IEd1KHUpO3R5cGVvZiBkPT1cInN0cmluZ1wiP2kucHVzaCh7bmFtZTp1LGVycjpkfSk6KG98fChvPWQpLG89PT1kJiZzLmFkZCh1KSl9aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2kubWFwKHU9PmBbJHt1Lm5hbWV9XSAke3UuZXJyfWApLmpvaW4oXCIsIFwiKX1gKTtmb3IobGV0e25hbWU6dSxlcnI6ZH1vZiBpKW4uaW5jbHVkZXModSkmJmNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7dX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZH1gKTtsZXQgYT10LmZpbHRlcih1PT5zLmhhcyh0eXBlb2YgdT09XCJzdHJpbmdcIj91OnUubmFtZSkpO3JldHVybltvLG5ldyBQcm94eShlLHtnZXQ6KHUsZCk9PmQ9PT1cImV4ZWN1dGlvblByb3ZpZGVyc1wiP2E6UmVmbGVjdC5nZXQodSxkKX0pXX19KTt2YXIgYnI9aygoKT0+e1widXNlIHN0cmljdFwiO3ZuKCl9KTt2YXIgX3Isd3I9aygoKT0+e1widXNlIHN0cmljdFwiO19yPVwiMS4yMy4yXCJ9KTt2YXIgJHIsbGUseG49aygoKT0+e1widXNlIHN0cmljdFwiO3dyKCk7JHI9XCJ3YXJuaW5nXCIsbGU9e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246X3J9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTskcj1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuICRyfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIHRlLHZyPWsoKCk9PntcInVzZSBzdHJpY3RcIjt4bigpO3RlPWxlfSk7dmFyIHhyLFNyLFRyPWsoKCk9PntcInVzZSBzdHJpY3RcIjt4cj0oZSx0KT0+e2xldCBuPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtuLndpZHRoPWUuZGltc1szXSxuLmhlaWdodD1lLmRpbXNbMl07bGV0IHI9bi5nZXRDb250ZXh0KFwiMmRcIik7aWYociE9bnVsbCl7bGV0IG8saTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0pO2xldCBzPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGE9dD8ubm9ybSx1LGQ7YT09PXZvaWQgMHx8YS5tZWFuPT09dm9pZCAwP3U9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGEubWVhbj09XCJudW1iZXJcIj91PVthLm1lYW4sYS5tZWFuLGEubWVhbixhLm1lYW5dOih1PVthLm1lYW5bMF0sYS5tZWFuWzFdLGEubWVhblsyXSwwXSxhLm1lYW5bM10hPT12b2lkIDAmJih1WzNdPWEubWVhblszXSkpLGE9PT12b2lkIDB8fGEuYmlhcz09PXZvaWQgMD9kPVswLDAsMCwwXTp0eXBlb2YgYS5iaWFzPT1cIm51bWJlclwiP2Q9W2EuYmlhcyxhLmJpYXMsYS5iaWFzLGEuYmlhc106KGQ9W2EuYmlhc1swXSxhLmJpYXNbMV0sYS5iaWFzWzJdLDBdLGEuYmlhc1szXSE9PXZvaWQgMCYmKGRbM109YS5iaWFzWzNdKSk7bGV0IGw9aSpvLGM9MCxwPWwsZj1sKjIsbT0tMTtzPT09XCJSR0JBXCI/KGM9MCxwPWwsZj1sKjIsbT1sKjMpOnM9PT1cIlJHQlwiPyhjPTAscD1sLGY9bCoyKTpzPT09XCJSQkdcIiYmKGM9MCxmPWwscD1sKjIpO2ZvcihsZXQgaD0wO2g8aTtoKyspZm9yKGxldCBiPTA7YjxvO2IrKyl7bGV0IHk9KGUuZGF0YVtjKytdLWRbMF0pKnVbMF0sZz0oZS5kYXRhW3ArK10tZFsxXSkqdVsxXSxfPShlLmRhdGFbZisrXS1kWzJdKSp1WzJdLHc9bT09PS0xPzI1NTooZS5kYXRhW20rK10tZFszXSkqdVszXTtyLmZpbGxTdHlsZT1cInJnYmEoXCIreStcIixcIitnK1wiLFwiK18rXCIsXCIrdytcIilcIixyLmZpbGxSZWN0KGIsaCwxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiBuKXJldHVybiBuLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0sU3I9KGUsdCk9PntsZXQgbj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxyO2lmKG4hPW51bGwpe2xldCBvLGksczt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzFdLHM9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0scz1lLmRpbXNbMV0pO2xldCBhPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsdT10Py5ub3JtLGQsbDt1PT09dm9pZCAwfHx1Lm1lYW49PT12b2lkIDA/ZD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgdS5tZWFuPT1cIm51bWJlclwiP2Q9W3UubWVhbix1Lm1lYW4sdS5tZWFuLHUubWVhbl06KGQ9W3UubWVhblswXSx1Lm1lYW5bMV0sdS5tZWFuWzJdLDI1NV0sdS5tZWFuWzNdIT09dm9pZCAwJiYoZFszXT11Lm1lYW5bM10pKSx1PT09dm9pZCAwfHx1LmJpYXM9PT12b2lkIDA/bD1bMCwwLDAsMF06dHlwZW9mIHUuYmlhcz09XCJudW1iZXJcIj9sPVt1LmJpYXMsdS5iaWFzLHUuYmlhcyx1LmJpYXNdOihsPVt1LmJpYXNbMF0sdS5iaWFzWzFdLHUuYmlhc1syXSwwXSx1LmJpYXNbM10hPT12b2lkIDAmJihsWzNdPXUuYmlhc1szXSkpO2xldCBjPWkqbztpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJnM9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxzPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgcD00LGY9MCxtPTEsaD0yLGI9Myx5PTAsZz1jLF89YyoyLHc9LTE7YT09PVwiUkdCQVwiPyh5PTAsZz1jLF89YyoyLHc9YyozKTphPT09XCJSR0JcIj8oeT0wLGc9YyxfPWMqMik6YT09PVwiUkJHXCImJih5PTAsXz1jLGc9YyoyKSxyPW4uY3JlYXRlSW1hZ2VEYXRhKG8saSk7Zm9yKGxldCB2PTA7djxpKm87Zis9cCxtKz1wLGgrPXAsYis9cCx2Kyspci5kYXRhW2ZdPShlLmRhdGFbeSsrXS1sWzBdKSpkWzBdLHIuZGF0YVttXT0oZS5kYXRhW2crK10tbFsxXSkqZFsxXSxyLmRhdGFbaF09KGUuZGF0YVtfKytdLWxbMl0pKmRbMl0sci5kYXRhW2JdPXc9PT0tMT8yNTU6KGUuZGF0YVt3KytdLWxbM10pKmRbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiByfX0pO3ZhciBTbixJcixDcixBcixFcixrcixQcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7U3QoKTtTbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0Om4sd2lkdGg6cn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0saSxzO3R5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/aT1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTppPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSxvLm1lYW5bM10/PzI1NV0sdHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9zPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOnM9W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07bGV0IGE9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsdT10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixkPW4qcixsPXU9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KGQqNCk6bmV3IEZsb2F0MzJBcnJheShkKjMpLGM9NCxwPTAsZj0xLG09MixoPTMsYj0wLHk9ZCxnPWQqMixfPS0xO2E9PT1cIlJHQlwiJiYoYz0zLHA9MCxmPTEsbT0yLGg9LTEpLHU9PT1cIlJHQkFcIj9fPWQqMzp1PT09XCJSQkdcIj8oYj0wLGc9ZCx5PWQqMik6dT09PVwiQkdSXCImJihnPTAseT1kLGI9ZCoyKTtmb3IobGV0IHY9MDt2PGQ7disrLHArPWMsbSs9YyxmKz1jLGgrPWMpbFtiKytdPShlW3BdK3NbMF0pL2lbMF0sbFt5KytdPShlW2ZdK3NbMV0pL2lbMV0sbFtnKytdPShlW21dK3NbMl0pL2lbMl0sXyE9PS0xJiZoIT09LTEmJihsW18rK109KGVbaF0rc1szXSkvaVszXSk7cmV0dXJuIHU9PT1cIlJHQkFcIj9uZXcgbWUoXCJmbG9hdDMyXCIsbCxbMSw0LG4scl0pOm5ldyBtZShcImZsb2F0MzJcIixsLFsxLDMsbixyXSl9LElyPWFzeW5jKGUsdCk9PntsZXQgbj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQscj10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsaT10eXBlb2YgZT09XCJzdHJpbmdcIixzLGE9dD8/e30sdT0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LGQ9bD0+dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PFwidVwiJiZsIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fGwgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/bC5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihuKXtsZXQgbD11KCk7bC53aWR0aD1lLndpZHRoLGwuaGVpZ2h0PWUuaGVpZ2h0O2xldCBjPWQobCk7aWYoYyE9bnVsbCl7bGV0IHA9ZS5oZWlnaHQsZj1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihwPXQucmVzaXplZEhlaWdodCxmPXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihhPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7YS50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsYS5oZWlnaHQ9cCxhLndpZHRoPWZ9ZWxzZSBhLnRlbnNvckZvcm1hdD1cIlJHQkFcIixhLmhlaWdodD1wLGEud2lkdGg9ZjtjLmRyYXdJbWFnZShlLDAsMCkscz1jLmdldEltYWdlRGF0YSgwLDAsZixwKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKHIpe2xldCBsLGM7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obD10LnJlc2l6ZWRIZWlnaHQsYz10LnJlc2l6ZWRXaWR0aCk6KGw9ZS5oZWlnaHQsYz1lLndpZHRoKSx0IT09dm9pZCAwJiYoYT10KSxhLmZvcm1hdD1cIlJHQkFcIixhLmhlaWdodD1sLGEud2lkdGg9Yyx0IT09dm9pZCAwKXtsZXQgcD11KCk7cC53aWR0aD1jLHAuaGVpZ2h0PWw7bGV0IGY9ZChwKTtpZihmIT1udWxsKWYucHV0SW1hZ2VEYXRhKGUsMCwwKSxzPWYuZ2V0SW1hZ2VEYXRhKDAsMCxjLGwpLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2Ugcz1lLmRhdGF9ZWxzZSBpZihvKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IGw9dSgpO2wud2lkdGg9ZS53aWR0aCxsLmhlaWdodD1lLmhlaWdodDtsZXQgYz1kKGwpO2lmKGMhPW51bGwpe2xldCBwPWUuaGVpZ2h0LGY9ZS53aWR0aDtyZXR1cm4gYy5kcmF3SW1hZ2UoZSwwLDAsZixwKSxzPWMuZ2V0SW1hZ2VEYXRhKDAsMCxmLHApLmRhdGEsYS5oZWlnaHQ9cCxhLndpZHRoPWYsU24ocyxhKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihpKXJldHVybiBuZXcgUHJvbWlzZSgobCxjKT0+e2xldCBwPXUoKSxmPWQocCk7aWYoIWV8fCFmKXJldHVybiBjKCk7bGV0IG09bmV3IEltYWdlO20uY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIixtLnNyYz1lLG0ub25sb2FkPSgpPT57cC53aWR0aD1tLndpZHRoLHAuaGVpZ2h0PW0uaGVpZ2h0LGYuZHJhd0ltYWdlKG0sMCwwLHAud2lkdGgscC5oZWlnaHQpO2xldCBoPWYuZ2V0SW1hZ2VEYXRhKDAsMCxwLndpZHRoLHAuaGVpZ2h0KTthLmhlaWdodD1wLmhlaWdodCxhLndpZHRoPXAud2lkdGgsbChTbihoLmRhdGEsYSkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKHMhPT12b2lkIDApcmV0dXJuIFNuKHMsYSk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LENyPShlLHQpPT57bGV0e3dpZHRoOm4saGVpZ2h0OnIsZG93bmxvYWQ6byxkaXNwb3NlOml9PXQscz1bMSxyLG4sNF07cmV0dXJuIG5ldyBtZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczpzLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LEFyPShlLHQpPT57bGV0e2RhdGFUeXBlOm4sZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgbWUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6bj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LEVyPShlLHQpPT57bGV0e2RhdGFUeXBlOm4sZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgbWUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsdHlwZTpuPz9cImZsb2F0MzJcIixtbFRlbnNvcjplLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxrcj0oZSx0LG4pPT5uZXcgbWUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpuPz9bdC5sZW5ndGhdfSl9KTt2YXIgWmUsbHQsenIsQnIsRHI9aygoKT0+e1widXNlIHN0cmljdFwiO1plPW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldLFtcImludDRcIixVaW50OEFycmF5XSxbXCJ1aW50NFwiLFVpbnQ4QXJyYXldXSksbHQ9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLHpyPSExLEJyPSgpPT57aWYoIXpyKXt6cj0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLG49Z2xvYmFsVGhpcy5GbG9hdDE2QXJyYXkscj10eXBlb2YgbjxcInVcIiYmbi5mcm9tO2UmJihaZS5zZXQoXCJpbnQ2NFwiLEJpZ0ludDY0QXJyYXkpLGx0LnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHQmJihaZS5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSksbHQuc2V0KEJpZ1VpbnQ2NEFycmF5LFwidWludDY0XCIpKSxyPyhaZS5zZXQoXCJmbG9hdDE2XCIsbiksbHQuc2V0KG4sXCJmbG9hdDE2XCIpKTpaZS5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgT3IsTXIsVXI9aygoKT0+e1widXNlIHN0cmljdFwiO1N0KCk7T3I9ZT0+e2xldCB0PTE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2xldCByPWVbbl07aWYodHlwZW9mIHIhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7bn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke3J9YCk7aWYocjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7bn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke3J9YCk7dCo9cn1yZXR1cm4gdH0sTXI9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBtZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IG1lKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyBtZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgbWUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gbmV3IG1lKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLG1sVGVuc29yOmUubWxUZW5zb3IsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIG1lLFN0PWsoKCk9PntcInVzZSBzdHJpY3RcIjtUcigpO1ByKCk7RHIoKTtVcigpO21lPWNsYXNze2NvbnN0cnVjdG9yKHQsbixyKXtCcigpO2xldCBvLGk7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbz10LnR5cGUsaT10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgYT1aZS5nZXQobyk7aWYoIWEpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7YS5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihvIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcIm1sLXRlbnNvclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ2NFwiJiZvIT09XCJpbnQ4XCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7dGhpcy5tbFRlbnNvckRhdGE9dC5tbFRlbnNvcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgYSx1O2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG89dCx1PXIsdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KG4pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2E9bn1lbHNle2xldCBkPVplLmdldCh0KTtpZihkPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkobikpe2lmKHQ9PT1cImZsb2F0MTZcIiYmZD09PVVpbnQxNkFycmF5fHx0PT09XCJ1aW50NFwifHx0PT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke3R9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7ZC5uYW1lfSBhcyBkYXRhLmApO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2E9ZC5mcm9tKG4sQmlnSW50KTphPWQuZnJvbShuKX1lbHNlIGlmKG4gaW5zdGFuY2VvZiBkKWE9bjtlbHNlIGlmKG4gaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlpZih0PT09XCJ1aW50OFwiKWE9VWludDhBcnJheS5mcm9tKG4pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhcIik7ZWxzZSBpZih0PT09XCJmbG9hdDE2XCImJm4gaW5zdGFuY2VvZiBVaW50MTZBcnJheSYmZCE9PVVpbnQxNkFycmF5KWE9bmV3IGdsb2JhbFRoaXMuRmxvYXQxNkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxuLmxlbmd0aCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7b30gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtkfWApfWVsc2UgaWYodT1uLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBkPXR5cGVvZiB0WzBdO2lmKGQ9PT1cInN0cmluZ1wiKW89XCJzdHJpbmdcIixhPXQ7ZWxzZSBpZihkPT09XCJib29sZWFuXCIpbz1cImJvb2xcIixhPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7ZH0uYCl9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpbz1cInVpbnQ4XCIsYT1VaW50OEFycmF5LmZyb20odCk7ZWxzZXtsZXQgZD1sdC5nZXQodC5jb25zdHJ1Y3Rvcik7aWYoZD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtvPWQsYT10fWlmKHU9PT12b2lkIDApdT1bYS5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkodSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2k9dSx0aGlzLmNwdURhdGE9YSx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBzPU9yKGkpO2lmKHRoaXMuY3B1RGF0YSYmcyE9PXRoaXMuY3B1RGF0YS5sZW5ndGgmJiEoKG89PT1cInVpbnQ0XCJ8fG89PT1cImludDRcIikmJk1hdGguY2VpbChzLzIpPT09dGhpcy5jcHVEYXRhLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c30pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1vLHRoaXMuZGltcz1pLHRoaXMuc2l6ZT1zfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxuKXtyZXR1cm4gSXIodCxuKX1zdGF0aWMgZnJvbVRleHR1cmUodCxuKXtyZXR1cm4gQ3IodCxuKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LG4pe3JldHVybiBBcih0LG4pfXN0YXRpYyBmcm9tTUxUZW5zb3IodCxuKXtyZXR1cm4gRXIodCxuKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LG4scil7cmV0dXJuIGtyKHQsbixyKX10b0RhdGFVUkwodCl7cmV0dXJuIHhyKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIFNyKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9Z2V0IG1sVGVuc29yKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLm1sVGVuc29yRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuXCIpO3JldHVybiB0aGlzLm1sVGVuc29yRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6Y2FzZVwibWwtdGVuc29yXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IG49YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9bix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxufWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLm1sVGVuc29yRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIE1yKHRoaXMsdCl9fX0pO3ZhciB2ZSxUbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7U3QoKTt2ZT1tZX0pO3ZhciBjdCxScixoZSxmZSxVZSxSZSxJbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eG4oKTtjdD0oZSx0KT0+eyh0eXBlb2YgbGUudHJhY2U+XCJ1XCI/IWxlLndhc20udHJhY2U6IWxlLnRyYWNlKXx8Y29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSxScj0oZSx0KT0+e2xldCBuPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLHI9ITE7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aDtvKyspe2lmKHImJiFuW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IGk9YEZVTkNfJHtlfTo6JHtuW29dLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYoaSs9YDo6JHt0fWApLGN0KFwiQ1BVXCIsaSk7cmV0dXJufW5bb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYocj0hMCl9fSxoZT1lPT57KHR5cGVvZiBsZS50cmFjZT5cInVcIj8hbGUud2FzbS50cmFjZTohbGUudHJhY2UpfHxScihcIkJFR0lOXCIsZSl9LGZlPWU9PnsodHlwZW9mIGxlLnRyYWNlPlwidVwiPyFsZS53YXNtLnRyYWNlOiFsZS50cmFjZSl8fFJyKFwiRU5EXCIsZSl9LFVlPWU9PnsodHlwZW9mIGxlLnRyYWNlPlwidVwiPyFsZS53YXNtLnRyYWNlOiFsZS50cmFjZSl8fGNvbnNvbGUudGltZShgT1JUOjoke2V9YCl9LFJlPWU9PnsodHlwZW9mIGxlLnRyYWNlPlwidVwiPyFsZS53YXNtLnRyYWNlOiFsZS50cmFjZSl8fGNvbnNvbGUudGltZUVuZChgT1JUOjoke2V9YCl9fSk7dmFyIFR0LFZyPWsoKCk9PntcInVzZSBzdHJpY3RcIjt2bigpO1RuKCk7SW4oKTtUdD1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LG4scil7aGUoKSxVZShcIkluZmVyZW5jZVNlc3Npb24ucnVuXCIpO2xldCBvPXt9LGk9e307aWYodHlwZW9mIHQhPVwib2JqZWN0XCJ8fHQ9PT1udWxsfHx0IGluc3RhbmNlb2YgdmV8fEFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgcz0hMDtpZih0eXBlb2Ygbj09XCJvYmplY3RcIil7aWYobj09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZihuIGluc3RhbmNlb2YgdmUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheShuKSl7aWYobi5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTtzPSExO2ZvcihsZXQgZCBvZiBuKXtpZih0eXBlb2YgZCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZih0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZCk9PT0tMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7ZH0uYCk7b1tkXT1udWxsfWlmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClpPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBkPSExLGw9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobik7Zm9yKGxldCBjIG9mIHRoaXMub3V0cHV0TmFtZXMpaWYobC5pbmRleE9mKGMpIT09LTEpe2xldCBwPW5bY107KHA9PT1udWxsfHxwIGluc3RhbmNlb2YgdmUpJiYoZD0hMCxzPSExLG9bY109cCl9aWYoZCl7aWYodHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKWk9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaT1ufX1lbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2ZvcihsZXQgZCBvZiB0aGlzLmlucHV0TmFtZXMpaWYodHlwZW9mIHRbZF0+XCJ1XCIpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtkfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO2lmKHMpZm9yKGxldCBkIG9mIHRoaXMub3V0cHV0TmFtZXMpb1tkXT1udWxsO2xldCBhPWF3YWl0IHRoaXMuaGFuZGxlci5ydW4odCxvLGkpLHU9e307Zm9yKGxldCBkIGluIGEpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYSxkKSl7bGV0IGw9YVtkXTtsIGluc3RhbmNlb2YgdmU/dVtkXT1sOnVbZF09bmV3IHZlKGwudHlwZSxsLmRhdGEsbC5kaW1zKX1yZXR1cm4gUmUoXCJJbmZlcmVuY2VTZXNzaW9uLnJ1blwiKSxmZSgpLHV9YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxuLHIsbyl7aGUoKSxVZShcIkluZmVyZW5jZVNlc3Npb24uY3JlYXRlXCIpO2xldCBpLHM9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKGk9dCx0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpcz1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoaT10LHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClzPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCBsPXQsYz0wLHA9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClzPW47ZWxzZSBpZih0eXBlb2Ygbj09XCJudW1iZXJcIil7aWYoYz1uLCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKGM8MHx8Yz49bC5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2wuYnl0ZUxlbmd0aH0pLmApO2lmKHA9dC5ieXRlTGVuZ3RoLWMsdHlwZW9mIHI9PVwibnVtYmVyXCIpe2lmKHA9ciwhTnVtYmVyLmlzU2FmZUludGVnZXIocCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihwPD0wfHxjK3A+bC5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2wuYnl0ZUxlbmd0aC1jfV0uYCk7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKXM9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2k9bmV3IFVpbnQ4QXJyYXkobCxjLHApfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXRbYSx1XT1hd2FpdCB5cihzKSxkPWF3YWl0IGEuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoaSx1KTtyZXR1cm4gUmUoXCJJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZVwiKSxmZSgpLG5ldyBlKGQpfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpfWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9Z2V0IGlucHV0TWV0YWRhdGEoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TWV0YWRhdGF9Z2V0IG91dHB1dE1ldGFkYXRhKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXRNZXRhZGF0YX19fSk7dmFyIE5yLExyPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWcigpO05yPVR0fSk7dmFyIFdyPWsoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBHcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgSHI9aygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIHFyPWsoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBDbj17fTtudChDbix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+TnIsVFJBQ0U6KCk9PmN0LFRSQUNFX0VWRU5UX0JFR0lOOigpPT5VZSxUUkFDRV9FVkVOVF9FTkQ6KCk9PlJlLFRSQUNFX0ZVTkNfQkVHSU46KCk9PmhlLFRSQUNFX0ZVTkNfRU5EOigpPT5mZSxUZW5zb3I6KCk9PnZlLGVudjooKT0+dGUscmVnaXN0ZXJCYWNrZW5kOigpPT5XZX0pO3ZhciB5ZT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YnIoKTt2cigpO0xyKCk7VG4oKTtXcigpO0dyKCk7SW4oKTtIcigpO3FyKCl9KTt2YXIgSXQ9aygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFpyPXt9O250KFpyLHtkZWZhdWx0OigpPT5IdX0pO3ZhciBLcixqcixIdSxRcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7QW4oKTtHZSgpO0N0KCk7S3I9XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIixqcj1nbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1LcjtqciYmKHNlbGYub25tZXNzYWdlPWU9PntsZXR7dHlwZTp0LGluOm59PWUuZGF0YTt0cnl7c3dpdGNoKHQpe2Nhc2VcImluaXQtd2FzbVwiOkF0KG4ud2FzbSkudGhlbigoKT0+e0V0KG4pLnRoZW4oKCk9Pntwb3N0TWVzc2FnZSh7dHlwZTp0fSl9LHI9Pntwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpyfSl9KX0scj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX0pO2JyZWFrO2Nhc2VcImluaXQtZXBcIjp7bGV0e2VwTmFtZTpyLGVudjpvfT1uO2t0KG8scikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0saT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOml9KX0pO2JyZWFrfWNhc2VcImNvcHktZnJvbVwiOntsZXR7YnVmZmVyOnJ9PW4sbz1wdChyKTtwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpvfSk7YnJlYWt9Y2FzZVwiY3JlYXRlXCI6e2xldHttb2RlbDpyLG9wdGlvbnM6b309bjtQdChyLG8pLnRoZW4oaT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Oml9KX0saT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOml9KX0pO2JyZWFrfWNhc2VcInJlbGVhc2VcIjp6dChuKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7Y2FzZVwicnVuXCI6e2xldHtzZXNzaW9uSWQ6cixpbnB1dEluZGljZXM6byxpbnB1dHM6aSxvdXRwdXRJbmRpY2VzOnMsb3B0aW9uczphfT1uO0J0KHIsbyxpLHMsbmV3IEFycmF5KHMubGVuZ3RoKS5maWxsKG51bGwpLGEpLnRoZW4odT0+e3Uuc29tZShkPT5kWzNdIT09XCJjcHVcIik/cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6XCJQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLlwifSk6cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6dX0sT3QoWy4uLmksLi4udV0pKX0sdT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnV9KX0pO2JyZWFrfWNhc2VcImVuZC1wcm9maWxpbmdcIjpEdChuKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7ZGVmYXVsdDp9fWNhdGNoKHIpe3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX19KTtIdT1qcj9udWxsOmU9Pm5ldyBXb3JrZXIoZT8/YmUse3R5cGU6XCJjbGFzc2ljXCIsbmFtZTpLcn0pfSk7dmFyIHF1LEZ1LGJlLE10LEVuLEt1LGp1LEpyLFp1LFhyLGVvLFlyLHRvLEN0PWsoKCk9PntcInVzZSBzdHJpY3RcIjtJdCgpO3F1PXR5cGVvZiBsb2NhdGlvbj5cInVcIj92b2lkIDA6bG9jYXRpb24ub3JpZ2luLEZ1PSgpPT57aWYoISExKXJldHVybiB0eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3VycmVudFNjcmlwdD8uc3JjOnR5cGVvZiBzZWxmPFwidVwiP3NlbGYubG9jYXRpb24/LmhyZWY6dm9pZCAwfSxiZT1GdSgpLE10PSgpPT57aWYoYmUmJiFiZS5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIGJlLnN1YnN0cmluZygwLGJlLmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sRW49KGUsdCk9Pnt0cnl7bGV0IG49dD8/YmU7cmV0dXJuKG4/bmV3IFVSTChlLG4pOm5ldyBVUkwoZSkpLm9yaWdpbj09PXF1fWNhdGNoe3JldHVybiExfX0sS3U9KGUsdCk9PntsZXQgbj10Pz9iZTt0cnl7cmV0dXJuKG4/bmV3IFVSTChlLG4pOm5ldyBVUkwoZSkpLmhyZWZ9Y2F0Y2h7cmV0dXJufX0sanU9KGUsdCk9PmAke3Q/P1wiLi9cIn0ke2V9YCxKcj1hc3luYyBlPT57bGV0IG49YXdhaXQoYXdhaXQgZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkpLmJsb2IoKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuKX0sWnU9YXN5bmMgZT0+KGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6dHJ1ZSovZSkpLmRlZmF1bHQsWHI9KFFyKCksZHQoWnIpKS5kZWZhdWx0LGVvPWFzeW5jKCk9PntpZighYmUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC5cIik7aWYoRW4oYmUpKXJldHVyblt2b2lkIDAsWHIoKV07bGV0IGU9YXdhaXQgSnIoYmUpO3JldHVybltlLFhyKGUpXX0sWXI9dm9pZCAwLHRvPWFzeW5jKGUsdCxuLHIpPT57bGV0IG89WXImJiEoZXx8dCk7aWYobylpZihiZSlvPUVuKGJlKTtlbHNlIGlmKHImJiFuKW89ITA7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC5cIik7aWYobylyZXR1cm5bdm9pZCAwLFlyXTt7bGV0IGk9XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzXCIscz1lPz9LdShpLHQpLGE9ISExJiZuJiZzJiYhRW4ocyx0KSx1PWE/YXdhaXQgSnIocyk6cz8/anUoaSx0KTtyZXR1cm5bYT91OnZvaWQgMCxhd2FpdCBadSh1KV19fX0pO3ZhciBrbixQbixVdCxubyxRdSxYdSxZdSxBdCxuZSxHZT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q3QoKTtQbj0hMSxVdD0hMSxubz0hMSxRdT0oKT0+e2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4hMTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sWHU9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sWXU9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDUsMSw5NiwwLDEsMTIzLDMsMiwxLDAsMTAsMTksMSwxNywwLDY1LDEsMjUzLDE1LDY1LDIsMjUzLDE1LDY1LDMsMjUzLDE1LDI1MywxNDcsMiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LEF0PWFzeW5jIGU9PntpZihQbilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoVXQpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYobm8pdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7VXQ9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxuPWUubnVtVGhyZWFkcztpZihlLnNpbWQhPT0hMSl7aWYoZS5zaW1kPT09XCJyZWxheGVkXCIpe2lmKCFZdSgpKXRocm93IG5ldyBFcnJvcihcIlJlbGF4ZWQgV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlwiKX1lbHNlIGlmKCFYdSgpKXRocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cIil9bGV0IHI9UXUoKTtuPjEmJiFyJiYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK24rXCIsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiBTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uXCIpLGNvbnNvbGUud2FybihcIldlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy5cIiksZS5udW1UaHJlYWRzPW49MSk7bGV0IG89ZS53YXNtUGF0aHMsaT10eXBlb2Ygbz09XCJzdHJpbmdcIj9vOnZvaWQgMCxzPW8/Lm1qcyxhPXM/LmhyZWY/P3MsdT1vPy53YXNtLGQ9dT8uaHJlZj8/dSxsPWUud2FzbUJpbmFyeSxbYyxwXT1hd2FpdCB0byhhLGksbj4xLCEhbHx8ISFkKSxmPSExLG09W107aWYodD4wJiZtLnB1c2gobmV3IFByb21pc2UoaD0+e3NldFRpbWVvdXQoKCk9PntmPSEwLGgoKX0sdCl9KSksbS5wdXNoKG5ldyBQcm9taXNlKChoLGIpPT57bGV0IHk9e251bVRocmVhZHM6bn07aWYobCl5Lndhc21CaW5hcnk9bDtlbHNlIGlmKGR8fGkpeS5sb2NhdGVGaWxlPWc9PmQ/P2krZztlbHNlIGlmKGEmJmEuaW5kZXhPZihcImJsb2I6XCIpIT09MCl5LmxvY2F0ZUZpbGU9Zz0+bmV3IFVSTChnLGEpLmhyZWY7ZWxzZSBpZihjKXtsZXQgZz1NdCgpO2cmJih5LmxvY2F0ZUZpbGU9Xz0+ZytfKX1wKHkpLnRoZW4oZz0+e1V0PSExLFBuPSEwLGtuPWcsaCgpLGMmJlVSTC5yZXZva2VPYmplY3RVUkwoYyl9LGc9PntVdD0hMSxubz0hMCxiKGcpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKG0pLGYpdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxuZT0oKT0+e2lmKFBuJiZrbilyZXR1cm4ga247dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9fSk7dmFyIF9lLG10LFksUnQ9aygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7X2U9KGUsdCk9PntsZXQgbj1uZSgpLHI9bi5sZW5ndGhCeXRlc1VURjgoZSkrMSxvPW4uX21hbGxvYyhyKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgoZSxvLHIpLHQucHVzaChvKSxvfSxtdD0oZSx0LG4scik9PntpZih0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpe2lmKG4uaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO24uYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLGldKT0+e2xldCBzPXQ/dCtvOm87aWYodHlwZW9mIGk9PVwib2JqZWN0XCIpbXQoaSxzK1wiLlwiLG4scik7ZWxzZSBpZih0eXBlb2YgaT09XCJzdHJpbmdcInx8dHlwZW9mIGk9PVwibnVtYmVyXCIpcihzLGkudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2YgaT09XCJib29sZWFuXCIpcihzLGk/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIGl9YCl9KX0sWT1lPT57bGV0IHQ9bmUoKSxuPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCByPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipyKTt0Ll9PcnRHZXRMYXN0RXJyb3IobyxvK3IpO2xldCBpPU51bWJlcih0LmdldFZhbHVlKG8scj09PTQ/XCJpMzJcIjpcImk2NFwiKSkscz10LmdldFZhbHVlKG8rcixcIipcIiksYT1zP3QuVVRGOFRvU3RyaW5nKHMpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7aX0sIEVSUk9SX01FU1NBR0U6ICR7YX1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKG4pfX19KTt2YXIgcm8sb289aygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7UnQoKTtybz1lPT57bGV0IHQ9bmUoKSxuPTAscj1bXSxvPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW8ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNldmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApby5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihvLnRlcm1pbmF0ZT0hMSk7bGV0IGk9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYoaT1fZShlLnRhZyxyKSksbj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKG8ubG9nU2V2ZXJpdHlMZXZlbCxvLmxvZ1ZlcmJvc2l0eUxldmVsLCEhby50ZXJtaW5hdGUsaSksbj09PTAmJlkoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZtdChlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHMsYSk9PntsZXQgdT1fZShzLHIpLGQ9X2UoYSxyKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShuLHUsZCkhPT0wJiZZKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke3N9IC0gJHthfS5gKX0pLFtuLHJdfWNhdGNoKGkpe3Rocm93IG4hPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhuKSxyLmZvckVhY2gocz0+dC5fZnJlZShzKSksaX19fSk7dmFyIEp1LGVkLHRkLFZ0LG5kLGlvLHNvPWsoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO1J0KCk7SnU9ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJsYXlvdXRcIjpyZXR1cm4gMztjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0sZWQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LHRkPWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShuPT4odHlwZW9mIG49PVwic3RyaW5nXCI/bjpuLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxWdD0oZSx0LG4scik9PntsZXQgbz1fZSh0LHIpLGk9X2UobixyKTtuZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxvLGkpIT09MCYmWShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dH0gLSAke259LmApfSxuZD1hc3luYyhlLHQsbik9Pntmb3IobGV0IHIgb2YgdCl7bGV0IG89dHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWUsaT1bXTtzd2l0Y2gobyl7Y2FzZVwid2Vibm5cIjppZihvPVwiV0VCTk5cIix0eXBlb2YgciE9XCJzdHJpbmdcIil7bGV0IGM9cj8uZGV2aWNlVHlwZTtjJiZWdChlLFwiZGV2aWNlVHlwZVwiLGMsbil9YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYobz1cIkpTXCIsdHlwZW9mIHIhPVwic3RyaW5nXCIpe2xldCBsPXI7aWYobD8ucHJlZmVycmVkTGF5b3V0KXtpZihsLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZsLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7bC5wcmVmZXJyZWRMYXlvdXR9YCk7VnQoZSxcInByZWZlcnJlZExheW91dFwiLGwucHJlZmVycmVkTGF5b3V0LG4pfX1icmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299YCl9bGV0IHM9X2UobyxuKSxhPWkubGVuZ3RoLHU9MCxkPTA7aWYoYT4wKXt1PW5lKCkuX21hbGxvYyhhKm5lKCkuUFRSX1NJWkUpLG4ucHVzaCh1KSxkPW5lKCkuX21hbGxvYyhhKm5lKCkuUFRSX1NJWkUpLG4ucHVzaChkKTtmb3IobGV0IGw9MDtsPGE7bCsrKW5lKCkuc2V0VmFsdWUodStsKm5lKCkuUFRSX1NJWkUsaVtsXVswXSxcIipcIiksbmUoKS5zZXRWYWx1ZShkK2wqbmUoKS5QVFJfU0laRSxpW2xdWzFdLFwiKlwiKX1hd2FpdCBuZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLHMsdSxkLGEpIT09MCYmWShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfS5gKX19LGlvPWFzeW5jIGU9PntsZXQgdD1uZSgpLG49MCxyPVtdLG89ZXx8e307dGQobyk7dHJ5e2xldCBpPUp1KG8uZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIikscz1lZChvLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxhPXR5cGVvZiBvLmxvZ0lkPT1cInN0cmluZ1wiP19lKG8ubG9nSWQscik6MCx1PW8ubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8dTwwfHx1PjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2V2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3V9YCk7bGV0IGQ9by5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihkKXx8ZDwwfHxkPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtkfWApO2xldCBsPXR5cGVvZiBvLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/X2Uoby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLHIpOjA7aWYobj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhpLCEhby5lbmFibGVDcHVNZW1BcmVuYSwhIW8uZW5hYmxlTWVtUGF0dGVybixzLCEhby5lbmFibGVQcm9maWxpbmcsMCxhLHUsZCxsKSxuPT09MCYmWShcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG8uZXhlY3V0aW9uUHJvdmlkZXJzJiZhd2FpdCBuZChuLG8uZXhlY3V0aW9uUHJvdmlkZXJzLHIpLG8uZW5hYmxlR3JhcGhDYXB0dXJlIT09dm9pZCAwKXtpZih0eXBlb2Ygby5lbmFibGVHcmFwaENhcHR1cmUhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke28uZW5hYmxlR3JhcGhDYXB0dXJlfWApO1Z0KG4sXCJlbmFibGVHcmFwaENhcHR1cmVcIixvLmVuYWJsZUdyYXBoQ2FwdHVyZS50b1N0cmluZygpLHIpfWlmKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W2MscF1vZiBPYmplY3QuZW50cmllcyhvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgYyE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtjfWApO2lmKHR5cGVvZiBwIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3B9YCk7bGV0IGY9X2UoYyxyKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUobixmLHApIT09MCYmWShgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7Y30gLSAke3B9LmApfXJldHVybiBvLmV4dHJhIT09dm9pZCAwJiZtdChvLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKGMscCk9PntWdChuLGMscCxyKX0pLFtuLHJdfWNhdGNoKGkpe3Rocm93IG4hPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobikhPT0wJiZZKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHIuZm9yRWFjaChzPT50Ll9mcmVlKHMpKSxpfX19KTt2YXIgSGUsRWUscWUscnQsZnQsTnQsTHQsem4sVj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SGU9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2Nhc2VcImludDRcIjpyZXR1cm4gMjI7Y2FzZVwidWludDRcIjpyZXR1cm4gMjE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sRWU9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2Nhc2UgMjI6cmV0dXJuXCJpbnQ0XCI7Y2FzZSAyMTpyZXR1cm5cInVpbnQ0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0scWU9KGUsdCk9PntsZXQgbj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgobyxpKT0+byppLDEpO3JldHVybiBuPjA/TWF0aC5jZWlsKHIqbik6dm9pZCAwfSxydD1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxmdD1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sTnQ9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixMdD1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLHpuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBodCxCbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SXQoKTtodD1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoITEpdHJ5e2xldHtyZWFkRmlsZTp0fT0kbihcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOm59PSRuKFwibm9kZTpmc1wiKSxyPW4oZSksbz1bXTtmb3IgYXdhaXQobGV0IGkgb2YgcilvLnB1c2goaSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQobykpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCBuPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxyPW4/cGFyc2VJbnQobiwxMCk6MDtpZihyPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IG89dC5ib2R5LmdldFJlYWRlcigpLGk7dHJ5e2k9bmV3IEFycmF5QnVmZmVyKHIpfWNhdGNoKGEpe2lmKGEgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgdT1NYXRoLmNlaWwoci82NTUzNik7aT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOnUsbWF4aW11bTp1fSkuYnVmZmVyfWVsc2UgdGhyb3cgYX1sZXQgcz0wO2Zvcig7Oyl7bGV0e2RvbmU6YSx2YWx1ZTp1fT1hd2FpdCBvLnJlYWQoKTtpZihhKWJyZWFrO2xldCBkPXUuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShpLHMsZCkuc2V0KHUpLHMrPWR9cmV0dXJuIG5ldyBVaW50OEFycmF5KGksMCxyKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciByZCxvZCxhbyx1byxXdCxpZCxqLGtlPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cmQ9W1wiVlwiLFwiSVwiLFwiV1wiLFwiRVwiLFwiRlwiXSxvZD0oZSx0KT0+e2NvbnNvbGUubG9nKGBbJHtyZFtlXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7dH1gKX0sV3Q9KGUsdCk9Pnthbz1lLHVvPXR9LGlkPShlLHQpPT57bGV0IG49ZnQoZSkscj1mdChhbyk7bj49ciYmb2Qobix0eXBlb2YgdD09XCJmdW5jdGlvblwiP3QoKTp0KX0saj0oLi4uZSk9Pnt1byYmaWQoLi4uZSl9fSk7dmFyIERuLFBlLHgsWGUsR3QsbG8sY28scT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RG49Y2xhc3N7c3RhdGljIGNhbGNNYXRNdWxTaGFwZSh0LG4pe3JldHVybiB0WzFdIT09blswXT92b2lkIDA6W3RbMF0sblsxXV19fSxQZT1jbGFzc3tzdGF0aWMgY2FsY1NoYXBlKHQsbixyPSExKXtsZXQgbz10Lmxlbmd0aCxpPW4ubGVuZ3RoO2lmKG89PT0wKXJldHVybiBuO2lmKGk9PT0wKXJldHVybiB0O2xldCBzPU1hdGgubWF4KHQubGVuZ3RoLG4ubGVuZ3RoKSxhPW5ldyBBcnJheShzKTtpZihyKXtpZihvPDJ8fGk8MilyZXR1cm47bGV0IHU9RG4uY2FsY01hdE11bFNoYXBlKFt0W28tMl0sdFtvLTFdXSxbbltpLTJdLG5baS0xXV0pO2lmKHU9PT12b2lkIDApcmV0dXJuO1thW3MtMl0sYVtzLTFdXT11fWZvcihsZXQgdT1yPzM6MTt1PD1zO3UrKyl7bGV0IGQ9by11PDA/MTp0W28tdV0sbD1pLXU8MD8xOm5baS11XTtpZihkIT09bCYmZD4xJiZsPjEpcmV0dXJuO2xldCBjPU1hdGgubWF4KGQsbCk7aWYoZCYmbClhW3MtdV09TWF0aC5tYXgoZCxsKTtlbHNle2lmKGM+MSlyZXR1cm47YVtzLXVdPTB9fXJldHVybiBhfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQsbil7bGV0IHI9dC5sZW5ndGgsbz1uLmxlbmd0aDtpZihyPm8pcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9cjtpKyspaWYodFtyLWldIT09MSYmdFtyLWldIT09bltvLWldKXJldHVybiExO3JldHVybiEwfX0seD1jbGFzcyBle3N0YXRpYyBzaXplKHQpe3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgY29udmVydFNoYXBlKHQsbj00KXtsZXQgcj10Lmxlbmd0aDtpZihyPT09MClyZXR1cm5bXTtsZXQgbz1uZXcgQXJyYXkociksaT1yLTE7Zm9yKDtpPj0wOyl7aWYodFtpXSVuPT09MCl7b1tpXT10W2ldL247YnJlYWt9aWYobiV0W2ldIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29udmVydCBzaGFwZVwiKTtvW2ldPTEsbi89dFtpXSxpLS19Zm9yKGktLTtpPj0wO2ktLSlvW2ldPXRbaV07cmV0dXJuIG99c3RhdGljIHNpemVGcm9tRGltZW5zaW9uKHQsbil7aWYobjwwfHxuPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtufSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxuLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZVRvRGltZW5zaW9uKHQsbil7aWYobjwwfHxuPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtufSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCxuKX1zdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LG4scil7bGV0IG89MTtmb3IobGV0IGk9bjtpPHI7aSsrKXtpZih0W2ldPDApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLlwiKTtvKj1OdW1iZXIodFtpXSl9cmV0dXJuIG99c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wKXJldHVybltdO2lmKG49PT0xKXJldHVyblsxXTtsZXQgcj1uZXcgQXJyYXkobik7cltuLTFdPTEscltuLTJdPXRbbi0xXTtmb3IobGV0IG89bi0zO28+PTA7LS1vKXJbb109cltvKzFdKnRbbysxXTtyZXR1cm4gcn1zdGF0aWMgbm9ybWFsaXplQXhpcyh0LG4pe2lmKHQ8LW4mJnQ+PW4pdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtuOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxuKXtyZXR1cm4gdC5tYXAocj0+dGhpcy5ub3JtYWxpemVBeGlzKHIsbj8/dC5sZW5ndGgpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKHQsbil7cmV0dXJuIG4/bi5tYXAocj0+dFtyXSk6dC5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUodCxuKXtsZXQgcj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKG8saSk9Pm8rbltpXStuW2krcl0pfXN0YXRpYyBhcmVFcXVhbCh0LG4pe3JldHVybiB0Lmxlbmd0aCE9PW4ubGVuZ3RoPyExOnQuZXZlcnkoKHIsbyk9PnI9PT1uW29dKX19LFhlPWNsYXNzIGV7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsbixyLG8saSxzKXtpZighdCYmci5sZW5ndGghPT1uLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IGE9MDthPG4ubGVuZ3RoLTI7YSsrKWE+PXIubGVuZ3RoP3IucHVzaChuW2ErMl0pOnJbYV09blthKzJdO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKWlmKGE8by5sZW5ndGgpe2lmKG9bYV08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIG8ucHVzaCgxKTtmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKylpZihhPGkubGVuZ3RoKXtpZihpW2FdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IGE9MDthPHIubGVuZ3RoKjI7YSsrKWlmKGE8cy5sZW5ndGgpe2lmKHNbYV08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugcy5wdXNoKDApO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKXtpZihyW2FdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihzW2FdPj1yW2FdfHxzW2Erci5sZW5ndGhdPj1yW2FdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxuLHIsbyxpLHMsYSl7aWYoYSl7aWYoaS5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYobi5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihvLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgdT0wO3U8dC5sZW5ndGgtMjt1KyspZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W3UrKHM/MToyKV0sblt1XSxyW3VdLG9bdV0saSx1LHUrdC5sZW5ndGgtMixhKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxuLHIsbyxpLHMsYSl7aWYobi5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCB1PVtuWzBdLG5bMV1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcih0LG4sdSxyLG8saSxzLGEpLHV9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxuLHIsbyxpLHMsYSl7aWYodC5sZW5ndGg8PTB8fG4ubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IHU9W3RbMF0sblswXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsdSxyLG8saSxzLGEpLHV9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LG4scixvLGkscyxhLHUpe2lmKHQpZm9yKGxldCBkPTA7ZDxuLmxlbmd0aC0yO2QrKylyLnB1c2goMSk7ZWxzZSBmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoLTI7ZCsrKXIucHVzaChlLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKG5bZCsyXSxvW2RdLGlbZF0sc1tkXSxhLGQsZCtuLmxlbmd0aC0yLHUpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxuLHIsbyxpLHMsYSx1KXtsZXQgZD1yKihvLTEpKzE7aWYodSYmdSE9PVwiTk9UU0VUXCIpc3dpdGNoKHUpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIGlbc109MCxpW2FdPTAsTWF0aC5mbG9vcigodC1kKS9uKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYociE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgYz0oKHQrbi0xKS9uLTEpKm4rby10O3JldHVybiBpW3NdPU1hdGguZmxvb3IodT09PVwiU0FNRV9MT1dFUlwiPyhjKzEpLzI6Yy8yKSxpW2FdPWMtaVtzXSxNYXRoLmZsb29yKCh0K2MtbykvbisxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K2lbc10raVthXS1kKS9uKzEpfX0sR3Q9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsbixyLG8saSl7aWYodC5sZW5ndGghPT0yfHxyLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IHMsYSx1O24/KHM9dFsxXSxhPXRbMF0pOihzPXRbMF0sYT10WzFdKTtsZXQgZD0tMTtpZihvPyh1PXJbMF0sZD0xKToodT1yWzFdLGQ9MCkscltkXSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKHM8PTB8fHU8PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIVBlLmlzVmFsaWRCcm9hZGNhc3QoaSxbcyx1XSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW3MsdSxhXX19LGxvPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMixjbz0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0pO3ZhciBIdCxPbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO0h0PShlLHQpPT5uZXcocnQodCkpKGUpfSk7dmFyIG1vLFVuLGZvLHNkLHBvLGFkLGhvLHF0LEZ0LE1uLGdvLHlvPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7a2UoKTttbz1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsMzJdLFtcImZsb2F0MTZcIiwxNl0sW1wiaW50MzJcIiwzMl0sW1widWludDMyXCIsMzJdLFtcImludDY0XCIsNjRdLFtcInVpbnQ2NFwiLDY0XSxbXCJpbnQ4XCIsOF0sW1widWludDhcIiw4XSxbXCJpbnQ0XCIsNF0sW1widWludDRcIiw0XV0pLFVuPShlLHQpPT57aWYodD09PVwiaW50MzJcIilyZXR1cm4gZTtsZXQgbj1tby5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke3R9YCk7bGV0IHI9bi84O2lmKGUuYnl0ZUxlbmd0aCVyIT09MCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVWludDhBcnJheSBsZW5ndGggLSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtyfS5gKTtsZXQgbz1lLmJ5dGVMZW5ndGgvcixpPW5ldyhydCh0KSkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LG8pO3N3aXRjaCh0KXtjYXNlXCJpbnQ2NFwiOmNhc2VcInVpbnQ2NFwiOntsZXQgcz1uZXcgSW50MzJBcnJheShvKTtmb3IobGV0IGE9MDthPG87YSsrKXtsZXQgdT1pW2FdO2lmKHU+MjE0NzQ4MzY0N258fHU8LTIxNDc0ODM2NDhuKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbnQ2NCBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLlwiKTtzW2FdPU51bWJlcih1KX1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkocy5idWZmZXIpfWNhc2VcImludDhcIjpjYXNlXCJ1aW50OFwiOmNhc2VcInVpbnQzMlwiOntpZih0PT09XCJ1aW50MzJcIiYmaS5zb21lKGE9PmE+MjE0NzQ4MzY0NykpdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IHVpbnQzMiBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLlwiKTtsZXQgcz1JbnQzMkFycmF5LmZyb20oaSxOdW1iZXIpO3JldHVybiBuZXcgVWludDhBcnJheShzLmJ1ZmZlcil9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgY29udmVyc2lvbiBmcm9tICR7dH0gdG8gJ2ludDMyJ2ApfX0sZm89KGUsdCk9PntpZih0PT09XCJpbnQzMlwiKXJldHVybiBlO2lmKGUuYnl0ZUxlbmd0aCU0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFVpbnQ4QXJyYXkgbGVuZ3RoIC0gbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQgKGludDMyKS5cIik7bGV0IG49ZS5ieXRlTGVuZ3RoLzQscj1uZXcgSW50MzJBcnJheShlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsbik7c3dpdGNoKHQpe2Nhc2VcImludDY0XCI6e2xldCBvPUJpZ0ludDY0QXJyYXkuZnJvbShyLEJpZ0ludCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyKX1jYXNlXCJ1aW50NjRcIjp7aWYoci5zb21lKGk9Pmk8MCkpdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGludDMyIGRhdGEgdG8gdWluNjQgLSBuZWdhdGl2ZSB2YWx1ZSBmb3VuZC5cIik7bGV0IG89QmlnVWludDY0QXJyYXkuZnJvbShyLEJpZ0ludCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyKX1jYXNlXCJpbnQ4XCI6e2lmKHIuc29tZShpPT5pPC0xMjh8fGk+MTI3KSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byBpbnQ4IC0gdmFsdWUgb3V0IG9mIHJhbmdlLlwiKTtsZXQgbz1JbnQ4QXJyYXkuZnJvbShyLE51bWJlcik7cmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyKX1jYXNlXCJ1aW50OFwiOntpZihyLnNvbWUobz0+bzwwfHxvPjI1NSkpdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGludDMyIGRhdGEgdG8gdWludDggLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuXCIpO3JldHVybiBVaW50OEFycmF5LmZyb20ocixOdW1iZXIpfWNhc2VcInVpbnQzMlwiOntpZihyLnNvbWUoaT0+aTwwKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW50MzIgLSBuZWdhdGl2ZSB2YWx1ZSBmb3VuZC5cIik7bGV0IG89VWludDMyQXJyYXkuZnJvbShyLE51bWJlcik7cmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSBjb252ZXJzaW9uIGZyb20gJ2ludDMyJyB0byAke3R9YCl9fSxzZD0xLHBvPSgpPT5zZCsrLGFkPW5ldyBNYXAoW1tcImludDhcIixcImludDMyXCJdLFtcInVpbnQ4XCIsXCJpbnQzMlwiXSxbXCJ1aW50MzJcIixcImludDMyXCJdLFtcImludDY0XCIsXCJpbnQzMlwiXV0pLGhvPShlLHQpPT57bGV0IG49bW8uZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgV2ViTk4gYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGRhdGEgdHlwZTogJHtlfWApO3JldHVybiB0Lmxlbmd0aD4wP01hdGguY2VpbCh0LnJlZHVjZSgocixvKT0+cipvKSpuLzgpOjB9LHF0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuaXNEYXRhQ29udmVydGVkPSExO2xldHtzZXNzaW9uSWQ6bixjb250ZXh0OnIsdGVuc29yOm8sZGF0YVR5cGU6aSxzaGFwZTpzLGZhbGxiYWNrRGF0YVR5cGU6YX09dDt0aGlzLnNlc3Npb25JZD1uLHRoaXMubWxDb250ZXh0PXIsdGhpcy5tbFRlbnNvcj1vLHRoaXMuZGF0YVR5cGU9aSx0aGlzLnRlbnNvclNoYXBlPXMsdGhpcy5mYWxsYmFja0RhdGFUeXBlPWF9Z2V0IHRlbnNvcigpe3JldHVybiB0aGlzLm1sVGVuc29yfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuZGF0YVR5cGV9Z2V0IGZhbGxiYWNrVHlwZSgpe3JldHVybiB0aGlzLmZhbGxiYWNrRGF0YVR5cGV9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMudGVuc29yU2hhcGV9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gaG8odGhpcy5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlKX1kZXN0cm95KCl7aihcInZlcmJvc2VcIiwoKT0+XCJbV2ViTk5dIFRlbnNvcldyYXBwZXIuZGVzdHJveVwiKSx0aGlzLm1sVGVuc29yLmRlc3Ryb3koKX13cml0ZSh0KXt0aGlzLm1sQ29udGV4dC53cml0ZVRlbnNvcih0aGlzLm1sVGVuc29yLHQpfWFzeW5jIHJlYWQodCl7aWYodGhpcy5mYWxsYmFja0RhdGFUeXBlKXtsZXQgbj1hd2FpdCB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpLHI9Zm8obmV3IFVpbnQ4QXJyYXkobiksdGhpcy5kYXRhVHlwZSk7aWYodCl7KHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9uZXcgVWludDhBcnJheSh0KTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKSkuc2V0KHIpO3JldHVybn1lbHNlIHJldHVybiByLmJ1ZmZlcn1lbHNlIHJldHVybiB0P3RoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcix0KTp0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpfWNhblJldXNlVGVuc29yKHQsbixyKXtyZXR1cm4gdGhpcy5tbENvbnRleHQ9PT10JiZ0aGlzLmRhdGFUeXBlPT09biYmdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGg9PT1yLmxlbmd0aCYmdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgobyxpKT0+bz09PXJbaV0pfXNldElzRGF0YUNvbnZlcnRlZCh0KXt0aGlzLmlzRGF0YUNvbnZlcnRlZD10fX0sRnQ9Y2xhc3N7Y29uc3RydWN0b3IodCxuKXt0aGlzLnRlbnNvck1hbmFnZXI9dDt0aGlzLndyYXBwZXI9bn1nZXQgdGVuc29yV3JhcHBlcigpe3JldHVybiB0aGlzLndyYXBwZXJ9cmVsZWFzZVRlbnNvcigpe3RoaXMudGVuc29yV3JhcHBlciYmKHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCl9YXN5bmMgZW5zdXJlVGVuc29yKHQsbixyLG8pe2xldCBpPXRoaXMudGVuc29yTWFuYWdlci5nZXRNTENvbnRleHQodCkscztpZighaS5vcFN1cHBvcnRMaW1pdHMoKS5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMobikpe2lmKHM9YWQuZ2V0KG4pLCFzfHwhaS5vcFN1cHBvcnRMaW1pdHMoKS5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMocykpdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke259YCk7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29ySWRUcmFja2VyLmVuc3VyZVRlbnNvcjogZmFsbGJhY2sgZGF0YVR5cGUgZnJvbSAke259IHRvICR7c31gKX1pZih0aGlzLndyYXBwZXIpe2lmKHRoaXMud3JhcHBlci5jYW5SZXVzZVRlbnNvcihpLG4scikpcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7aWYobyl7aWYodGhpcy53cmFwcGVyLmJ5dGVMZW5ndGghPT1obyhuLHIpKXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb3B5IGRhdGEgdG8gdGVuc29yIHdpdGggZGlmZmVyZW50IHNpemUuXCIpO3RoaXMuYWN0aXZlVXBsb2FkPW5ldyBVaW50OEFycmF5KGF3YWl0IHRoaXMud3JhcHBlci5yZWFkKCkpfXRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMud3JhcHBlcil9bGV0IGE9dHlwZW9mIE1MVGVuc29yVXNhZ2U+XCJ1XCI/dm9pZCAwOk1MVGVuc29yVXNhZ2UuUkVBRHxNTFRlbnNvclVzYWdlLldSSVRFO3JldHVybiB0aGlzLndyYXBwZXI9YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmdldENhY2hlZFRlbnNvcih0LG4scixhLCEwLCEwLHMpLG8mJnRoaXMuYWN0aXZlVXBsb2FkJiYodGhpcy53cmFwcGVyLndyaXRlKHRoaXMuYWN0aXZlVXBsb2FkKSx0aGlzLmFjdGl2ZVVwbG9hZD12b2lkIDApLHRoaXMud3JhcHBlci50ZW5zb3J9dXBsb2FkKHQpe2xldCBuPXQ7aWYodGhpcy53cmFwcGVyKXtpZih0aGlzLndyYXBwZXIuZmFsbGJhY2tUeXBlKWlmKHRoaXMud3JhcHBlci5mYWxsYmFja1R5cGU9PT1cImludDMyXCIpbj1Vbih0LHRoaXMud3JhcHBlci50eXBlKSx0aGlzLndyYXBwZXIuc2V0SXNEYXRhQ29udmVydGVkKCEwKTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZmFsbGJhY2sgZGF0YSB0eXBlOiAke3RoaXMud3JhcHBlci5mYWxsYmFja1R5cGV9YCk7aWYodC5ieXRlTGVuZ3RoPT09dGhpcy53cmFwcGVyLmJ5dGVMZW5ndGgpe3RoaXMud3JhcHBlci53cml0ZShuKTtyZXR1cm59ZWxzZSBqKFwidmVyYm9zZVwiLCgpPT5cIkRhdGEgc2l6ZSBkb2VzIG5vdCBtYXRjaCB0ZW5zb3Igc2l6ZS4gUmVsZWFzaW5nIHRlbnNvci5cIiksdGhpcy5yZWxlYXNlVGVuc29yKCl9dGhpcy5hY3RpdmVVcGxvYWQ/dGhpcy5hY3RpdmVVcGxvYWQuc2V0KG4pOnRoaXMuYWN0aXZlVXBsb2FkPW5ldyBVaW50OEFycmF5KG4pfWFzeW5jIGRvd25sb2FkKHQpe2lmKHRoaXMuYWN0aXZlVXBsb2FkKXtsZXQgbj10aGlzLndyYXBwZXI/LmlzRGF0YUNvbnZlcnRlZD9mbyh0aGlzLmFjdGl2ZVVwbG9hZCx0aGlzLndyYXBwZXI/LnR5cGUpOnRoaXMuYWN0aXZlVXBsb2FkO2lmKHQpe3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9uZXcgVWludDhBcnJheSh0KS5zZXQobik6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KG4pO3JldHVybn1lbHNlIHJldHVybiBuLmJ1ZmZlcn1pZighdGhpcy53cmFwcGVyKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBoYXMgbm90IGJlZW4gY3JlYXRlZC5cIik7cmV0dXJuIHQ/dGhpcy53cmFwcGVyLnJlYWQodCk6dGhpcy53cmFwcGVyLnJlYWQoKX19LE1uPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMudGVuc29yVHJhY2tlcnNCeUlkPW5ldyBNYXA7dGhpcy5mcmVlVGVuc29ycz1bXTt0aGlzLmV4dGVybmFsVGVuc29ycz1uZXcgU2V0fWdldE1MQ29udGV4dCh0KXtsZXQgbj10aGlzLmJhY2tlbmQuZ2V0TUxDb250ZXh0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIk1MQ29udGV4dCBub3QgZm91bmQgZm9yIHNlc3Npb24uXCIpO3JldHVybiBufXJlc2VydmVUZW5zb3JJZCgpe2xldCB0PXBvKCk7cmV0dXJuIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0LG5ldyBGdCh0aGlzKSksdH1yZWxlYXNlVGVuc29ySWQodCl7bGV0IG49dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO24mJih0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5kZWxldGUodCksbi50ZW5zb3JXcmFwcGVyJiZ0aGlzLnJlbGVhc2VUZW5zb3Iobi50ZW5zb3JXcmFwcGVyKSl9YXN5bmMgZW5zdXJlVGVuc29yKHQsbixyLG8saSl7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke259LCBkYXRhVHlwZTogJHtyfSwgc2hhcGU6ICR7b30sIGNvcHlPbGQ6ICR7aX19YCk7bGV0IHM9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KG4pO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBzLmVuc3VyZVRlbnNvcih0LHIsbyxpKX11cGxvYWQodCxuKXtsZXQgcj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7ci51cGxvYWQobil9YXN5bmMgZG93bmxvYWQodCxuKXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0fSwgZHN0QnVmZmVyOiAke24/LmJ5dGVMZW5ndGh9fWApO2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gci5kb3dubG9hZChuKX1yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCl7Zm9yKGxldCBuIG9mIHRoaXMuZnJlZVRlbnNvcnMpbi5zZXNzaW9uSWQ9PT10JiZuLmRlc3Ryb3koKTt0aGlzLmZyZWVUZW5zb3JzPXRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKG49Pm4uc2Vzc2lvbklkIT09dCl9cmVnaXN0ZXJUZW5zb3IodCxuLHIsbyl7bGV0IGk9dGhpcy5nZXRNTENvbnRleHQodCkscz1wbygpLGE9bmV3IHF0KHtzZXNzaW9uSWQ6dCxjb250ZXh0OmksdGVuc29yOm4sZGF0YVR5cGU6cixzaGFwZTpvfSk7cmV0dXJuIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldChzLG5ldyBGdCh0aGlzLGEpKSx0aGlzLmV4dGVybmFsVGVuc29ycy5hZGQoYSksc31hc3luYyBnZXRDYWNoZWRUZW5zb3IodCxuLHIsbyxpLHMsYSl7bGV0IHU9dGhpcy5nZXRNTENvbnRleHQodCk7Zm9yKGxldFtsLGNdb2YgdGhpcy5mcmVlVGVuc29ycy5lbnRyaWVzKCkpaWYoYy5jYW5SZXVzZVRlbnNvcih1LG4scikpe2ooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFJldXNpbmcgdGVuc29yIHtkYXRhVHlwZTogJHtufSwgJHthP2BmYWxsYmFja0RhdGFUeXBlOiAke2F9LGA6XCJcIn0gc2hhcGU6ICR7cn1gKTtsZXQgcD10aGlzLmZyZWVUZW5zb3JzLnNwbGljZShsLDEpWzBdO3JldHVybiBwLnNlc3Npb25JZD10LHB9aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gTUxDb250ZXh0LmNyZWF0ZVRlbnNvciB7ZGF0YVR5cGU6ICR7bn0sICR7YT9gZmFsbGJhY2tEYXRhVHlwZTogJHthfSxgOlwiXCJ9IHNoYXBlOiAke3J9fWApO2xldCBkPWF3YWl0IHUuY3JlYXRlVGVuc29yKHtkYXRhVHlwZTphPz9uLHNoYXBlOnIsZGltZW5zaW9uczpyLHVzYWdlOm8sd3JpdGFibGU6aSxyZWFkYWJsZTpzfSk7cmV0dXJuIG5ldyBxdCh7c2Vzc2lvbklkOnQsY29udGV4dDp1LHRlbnNvcjpkLGRhdGFUeXBlOm4sc2hhcGU6cixmYWxsYmFja0RhdGFUeXBlOmF9KX1yZWxlYXNlVGVuc29yKHQpe3RoaXMuZXh0ZXJuYWxUZW5zb3JzLmhhcyh0KSYmdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHQpLHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0KX19LGdvPSguLi5lKT0+bmV3IE1uKC4uLmUpfSk7dmFyIEt0LHVkLGp0LGJvPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7R2UoKTtPbigpO3lvKCk7a2UoKTtLdD1uZXcgTWFwKFtbMSxcImZsb2F0MzJcIl0sWzEwLFwiZmxvYXQxNlwiXSxbNixcImludDMyXCJdLFsxMixcInVpbnQzMlwiXSxbNyxcImludDY0XCJdLFsxMyxcInVpbnQ2NFwiXSxbMjIsXCJpbnQ0XCJdLFsyMSxcInVpbnQ0XCJdLFszLFwiaW50OFwiXSxbMixcInVpbnQ4XCJdLFs5LFwidWludDhcIl1dKSx1ZD0oZSx0KT0+e2lmKGU9PT10KXJldHVybiEwO2lmKGU9PT12b2lkIDB8fHQ9PT12b2lkIDApcmV0dXJuITE7bGV0IG49T2JqZWN0LmtleXMoZSkuc29ydCgpLHI9T2JqZWN0LmtleXModCkuc29ydCgpO3JldHVybiBuLmxlbmd0aD09PXIubGVuZ3RoJiZuLmV2ZXJ5KChvLGkpPT5vPT09cltpXSYmZVtvXT09PXRbb10pfSxqdD1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnRlbnNvck1hbmFnZXI9Z28odGhpcyk7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZD1uZXcgTWFwO3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0PW5ldyBNYXA7dGhpcy5tbENvbnRleHRDYWNoZT1bXTt0aGlzLnNlc3Npb25HcmFwaElucHV0cz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cz1uZXcgTWFwO3RoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHM9W107dGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHM9W107dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzPW5ldyBNYXA7V3QodC5sb2dMZXZlbCwhIXQuZGVidWcpfWdldCBjdXJyZW50U2Vzc2lvbklkKCl7aWYodGhpcy5hY3RpdmVTZXNzaW9uSWQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHNlc3Npb25cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkfW9uUnVuU3RhcnQodCl7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gb25SdW5TdGFydCB7c2Vzc2lvbklkOiAke3R9fWApLHRoaXMuYWN0aXZlU2Vzc2lvbklkPXR9b25SdW5FbmQodCl7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gb25SdW5FbmQge3Nlc3Npb25JZDogJHt0fX1gKTtsZXQgbj10aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHQpO2lmKG4pe2ZvcihsZXQgciBvZiBuKWooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlbGVhc2luZyB0ZW1wb3JhcnkgdGVuc29yIHt0ZW5zb3JJZDogJHtyfX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHIpO3RoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5kZWxldGUodCksdGhpcy5hY3RpdmVTZXNzaW9uSWQ9dm9pZCAwfX1hc3luYyBjcmVhdGVNTENvbnRleHQodCl7aWYodCBpbnN0YW5jZW9mIEdQVURldmljZSl7bGV0IHI9dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5ncHVEZXZpY2U9PT10KTtpZihyIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbcl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtncHVEZXZpY2U6dCxtbENvbnRleHQ6b30pLG99fWVsc2UgaWYodD09PXZvaWQgMCl7bGV0IHI9dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5vcHRpb25zPT09dm9pZCAwJiZvLmdwdURldmljZT09PXZvaWQgMCk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHttbENvbnRleHQ6b30pLG99fWxldCBuPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KHI9PnVkKHIub3B0aW9ucyx0KSk7aWYobiE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW25dLm1sQ29udGV4dDt7bGV0IHI9YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7b3B0aW9uczp0LG1sQ29udGV4dDpyfSkscn19cmVnaXN0ZXJNTENvbnRleHQodCxuKXt0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLnNldCh0LG4pO2xldCByPXRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChuKTtyfHwocj1uZXcgU2V0LHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LnNldChuLHIpKSxyLmFkZCh0KSx0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzLmxlbmd0aD4wJiYodGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuc2V0KHQsdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cyksdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cz1bXSksdGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHMubGVuZ3RoPjAmJih0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuc2V0KHQsdGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHMpLHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzPVtdKX1vblJlbGVhc2VTZXNzaW9uKHQpe3RoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLmRlbGV0ZSh0KSx0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZGVsZXRlKHQpO2xldCBuPXRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHQpO2lmKCFuKXJldHVybjt0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHQpLHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZGVsZXRlKHQpO2xldCByPXRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChuKTtpZihyLmRlbGV0ZSh0KSxyLnNpemU9PT0wKXt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5kZWxldGUobik7bGV0IG89dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoaT0+aS5tbENvbnRleHQ9PT1uKTtvIT09LTEmJnRoaXMubWxDb250ZXh0Q2FjaGUuc3BsaWNlKG8sMSl9fWdldE1MQ29udGV4dCh0KXtyZXR1cm4gdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCl9cmVzZXJ2ZVRlbnNvcklkKCl7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKX1yZWxlYXNlVGVuc29ySWQodCl7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0fX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHQpfWFzeW5jIGVuc3VyZVRlbnNvcih0LG4scixvLGkpe2xldCBzPUt0LmdldChyKTtpZighcyl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodD8/dGhpcy5jdXJyZW50U2Vzc2lvbklkLG4scyxvLGkpfWFzeW5jIGNyZWF0ZVRlbXBvcmFyeVRlbnNvcih0LG4scil7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gY3JlYXRlVGVtcG9yYXJ5VGVuc29yIHtvbm54RGF0YVR5cGU6ICR7bn0sIHNoYXBlOiAke3J9fWApO2xldCBvPUt0LmdldChuKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke259YCk7bGV0IGk9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO2F3YWl0IHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodCxpLG8sciwhMSk7bGV0IHM9dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmdldCh0KTtyZXR1cm4gcz9zLnB1c2goaSk6dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLnNldCh0LFtpXSksaX11cGxvYWRUZW5zb3IodCxuKXtpZighbmUoKS5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIHVwbG9hZCB0byBhIE1MVGVuc29yIHdoaWxlIHNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciBpcyBmYWxzZVwiKTtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSB1cGxvYWRUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhOiAke24uYnl0ZUxlbmd0aH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0LG4pfWFzeW5jIGRvd25sb2FkVGVuc29yKHQsbil7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0LG4pfWNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0LG4pe3JldHVybiBhc3luYygpPT57bGV0IHI9YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQpO3JldHVybiBIdChyLG4pfX1yZWdpc3Rlck1MVGVuc29yKHQsbixyLG8pe2xldCBpPUt0LmdldChyKTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7bGV0IHM9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlZ2lzdGVyVGVuc29yKHQsbixpLG8pO3JldHVybiBqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWdpc3Rlck1MVGVuc29yIHt0ZW5zb3I6ICR7bn0sIGRhdGFUeXBlOiAke2l9LCBkaW1lbnNpb25zOiAke299fSAtPiB7dGVuc29ySWQ6ICR7c319YCksc31yZWdpc3Rlck1MQ29uc3RhbnQodCxuLHIsbyxpLHMsYT0hMSl7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7bGV0IHU9dDt0LnN0YXJ0c1dpdGgoXCIuL1wiKSYmKHU9dC5zdWJzdHJpbmcoMikpO2xldCBkPXMuZ2V0KHUpO2lmKCFkKXRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHt1fSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO2lmKG4rcj5kLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLlwiKTtsZXQgbD1kLnNsaWNlKG4sbityKS5idWZmZXIsYztzd2l0Y2goaS5kYXRhVHlwZSl7Y2FzZVwiZmxvYXQzMlwiOmM9bmV3IEZsb2F0MzJBcnJheShsKTticmVhaztjYXNlXCJmbG9hdDE2XCI6Yz10eXBlb2YgRmxvYXQxNkFycmF5PFwidVwiJiZGbG9hdDE2QXJyYXkuZnJvbT9uZXcgRmxvYXQxNkFycmF5KGwpOm5ldyBVaW50MTZBcnJheShsKTticmVhaztjYXNlXCJpbnQzMlwiOmM9bmV3IEludDMyQXJyYXkobCk7YnJlYWs7Y2FzZVwidWludDMyXCI6Yz1uZXcgVWludDMyQXJyYXkobCk7YnJlYWs7Y2FzZVwiaW50NjRcIjppZihhKXtsZXQgcD1VbihuZXcgVWludDhBcnJheShsKSxcImludDY0XCIpO2M9bmV3IEludDMyQXJyYXkocC5idWZmZXIpLGkuZGF0YVR5cGU9XCJpbnQzMlwifWVsc2UgYz1uZXcgQmlnSW50NjRBcnJheShsKTticmVhaztjYXNlXCJ1aW50NjRcIjpjPW5ldyBCaWdVaW50NjRBcnJheShsKTticmVhaztjYXNlXCJpbnQ4XCI6Yz1uZXcgSW50OEFycmF5KGwpO2JyZWFrO2Nhc2VcImludDRcIjpjYXNlXCJ1aW50NFwiOmNhc2VcInVpbnQ4XCI6Yz1uZXcgVWludDhBcnJheShsKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2kuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKX1yZXR1cm4gaihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHtpLmRhdGFUeXBlfSwgc2hhcGU6ICR7aS5zaGFwZX19fSAke2E/XCIoTm90ZTogaXQgd2FzIGludDY0IGRhdGEgdHlwZSBhbmQgcmVnaXN0ZXJlZCB0byBpbnQzMiBhcyB3b3JrYXJvdW5kKVwiOlwiXCJ9YCksby5jb25zdGFudChpLGMpfXJlZ2lzdGVyR3JhcGhJbnB1dCh0KXt0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzLnB1c2godCl9cmVnaXN0ZXJHcmFwaE91dHB1dCh0KXt0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cy5wdXNoKHQpfWlzR3JhcGhJbnB1dCh0LG4pe2xldCByPXRoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLmdldCh0KTtyZXR1cm4gcj9yLmluY2x1ZGVzKG4pOiExfWlzR3JhcGhPdXRwdXQodCxuKXtsZXQgcj10aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZ2V0KHQpO3JldHVybiByP3IuaW5jbHVkZXMobik6ITF9aXNHcmFwaElucHV0T3V0cHV0VHlwZVN1cHBvcnRlZCh0LG4scj0hMCl7bGV0IG89dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCksaT1LdC5nZXQoSGUobikpO3JldHVybiB0eXBlb2YgaT5cInVcIj8hMTpyPyEhbz8ub3BTdXBwb3J0TGltaXRzKCkuaW5wdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGkpOiEhbz8ub3BTdXBwb3J0TGltaXRzKCkub3V0cHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhpKX1mbHVzaCgpe319fSk7dmFyIFp0PWsoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBfbyxSbixWbixkZCxsZCx3byxMbixObix2byx4bz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7a2UoKTtadCgpO19vPW5ldyBNYXAoW1s2NCwyNTBdLFsxMjgsMjAwXSxbMjU2LDIwMF0sWzUxMiwyMDBdLFsyMDQ4LDIzMF0sWzQwOTYsMjAwXSxbODE5Miw1MF0sWzE2Mzg0LDUwXSxbMzI3NjgsNTBdLFs2NTUzNiw1MF0sWzEzMTA3Miw1MF0sWzI2MjE0NCw1MF0sWzUyNDI4OCw1MF0sWzEwNDg1NzYsNTBdLFsyMDk3MTUyLDMwXSxbNDE5NDMwNCwyMF0sWzgzODg2MDgsMTBdLFsxMjU4MjkxMiwxMF0sWzE2Nzc3MjE2LDEwXSxbMjYyMTQ0MDAsMTVdLFszMzU1NDQzMiwyMl0sWzQ0MjM2ODAwLDJdLFs1ODk4MjQwMCw2XSxbNjcxMDg4NjQsNl0sWzEzNDIxNzcyOCw2XSxbMTY3NzcyMTYwLDZdXSksUm49W10sVm49ZT0+TWF0aC5jZWlsKE51bWJlcihlKS8xNikqMTYsZGQ9ZT0+e2ZvcihsZXQgdD0wO3Q8Um4ubGVuZ3RoO3QrKyl7bGV0IG49Um5bdF07aWYoZTw9bilyZXR1cm4gbn1yZXR1cm4gTWF0aC5jZWlsKGUvMTYpKjE2fSxsZD0xLHdvPSgpPT5sZCsrLExuPWFzeW5jKGUsdCxuLHIpPT57bGV0IG89Vm4obiksaT1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgcz1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLHMuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxpLDAsbyksZS5mbHVzaCgpLGF3YWl0IGkubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgYT1pLmdldE1hcHBlZFJhbmdlKCk7aWYocil7bGV0IHU9cigpO3JldHVybiB1LnNldChuZXcgVWludDhBcnJheShhLDAsbikpLHV9ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5zbGljZSgwLG4pKX1maW5hbGx5e2kuZGVzdHJveSgpfX0sTm49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwO2ZvcihsZXRbbl1vZiBfbylSbi5wdXNoKG4pLHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KG4sW10pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChuLFtdKTt0aGlzLnNlc3Npb25Db3VudD0wfXVwbG9hZCh0LG4pe2xldCByPW4uYnVmZmVyLG89bi5ieXRlT2Zmc2V0LGk9bi5ieXRlTGVuZ3RoLHM9Vm4oaSksYT10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihOdW1iZXIoYS5vcmlnaW5hbFNpemUpIT09aSl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHthLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke2l9YCk7bGV0IHU9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTpzLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLGQ9dS5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KGQpLnNldChuZXcgVWludDhBcnJheShyLG8saSkpLHUudW5tYXAoKTtsZXQgbD10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7bC5jb3B5QnVmZmVyVG9CdWZmZXIodSwwLGEuZ3B1RGF0YS5idWZmZXIsMCxzKSx0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbbC5maW5pc2goKV0pLHUuZGVzdHJveSgpLGooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHt0fSlgKX1tZW1jcHkodCxuKXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IG89dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KG4pO2lmKCFvKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYoci5vcmlnaW5hbFNpemUhPT1vLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCBpPVZuKHIub3JpZ2luYWxTaXplKSxzPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHMuY29weUJ1ZmZlclRvQnVmZmVyKHIuZ3B1RGF0YS5idWZmZXIsMCxvLmdwdURhdGEuYnVmZmVyLDAsaSl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LG4scil7bGV0IG87aWYocil7aWYobz1yWzBdLHQ9PT1yWzFdKXJldHVybiBqKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7bn0pID0+IGlkPSR7b30sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKSxvO2lmKHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCkpdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlcmluZyBhIGRpZmZlcmVudCBleHRlcm5hbCBidWZmZXIgdW5kZXIgZ3JhcGggY2FwdHVyZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKX1lbHNlIG89d28oKTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KG8se2dwdURhdGE6e2lkOm8sdHlwZTowLGJ1ZmZlcjp0fSxvcmlnaW5hbFNpemU6bn0pLGooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtufSkgPT4gaWQ9JHtvfSwgcmVnaXN0ZXJlZC5gKSxvfXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXt0IT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLGooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3R9YCkpfWNyZWF0ZSh0LG49R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IHI9ZGQodCksbyxpPShuJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSxzPShuJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihpfHxzKXtsZXQgZD0oaT90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzKS5nZXQocik7ZD9kLmxlbmd0aD4wP289ZC5wb3AoKTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnIsdXNhZ2U6bn0pOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6cix1c2FnZTpufSl9ZWxzZSBvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnIsdXNhZ2U6bn0pO2xldCBhPXtpZDp3bygpLHR5cGU6MCxidWZmZXI6b307cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChhLmlkLHtncHVEYXRhOmEsb3JpZ2luYWxTaXplOk51bWJlcih0KX0pLGooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3R9KSA9PiBpZD0ke2EuaWR9YCksYX1nZXQodCl7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KT8uZ3B1RGF0YX1yZWxlYXNlKHQpe2xldCBuPXR5cGVvZiB0PT1cImJpZ2ludFwiP051bWJlcih0KTp0LHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KG4pO2lmKCFyKXtpZih0aGlzLnN0b3JhZ2VDYWNoZS5zaXplPT09MClyZXR1cm4gMDt0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKX1yZXR1cm4gaihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtufSksIGdwdURhdGFJZD0ke3IuZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUobiksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKHIuZ3B1RGF0YS5idWZmZXIpLHIub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQsbil7bGV0IHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcih0KSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBMbih0aGlzLmJhY2tlbmQsci5ncHVEYXRhLmJ1ZmZlcixyLm9yaWdpbmFsU2l6ZSxuKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtpZih0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCE9PTApaWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImRlZmF1bHRcIil7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpe2xldCBuPV9vLmdldCh0LnNpemUpO2lmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSl7bGV0IHI9dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKXx8W107bj09PXZvaWQgMHx8ci5sZW5ndGg+PW4/dC5kZXN0cm95KCk6ci5wdXNoKHQpfWVsc2UgaWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNKXtsZXQgcj10aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKXx8W107bj09PXZvaWQgMHx8ci5sZW5ndGg+PW4/dC5kZXN0cm95KCk6ci5wdXNoKHQpfWVsc2UgdC5kZXN0cm95KCl9dGhpcy5idWZmZXJzUGVuZGluZz1bXX1lbHNle2xldCB0PXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpO3R8fCh0PVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsdCkpO2ZvcihsZXQgbiBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXQucHVzaChuKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gobj0+e24uZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gobj0+e24uZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gobj0+e24uZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwfW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuc2Vzc2lvbkNvdW50Kz0xfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IG49dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0KTtuJiYobi5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUodCkpLHRoaXMuc2Vzc2lvbkNvdW50LT0xLHRoaXMuc2Vzc2lvbkNvdW50PT09MCYmKGooXCJ3YXJuaW5nXCIsKCk9PlwiW1dlYkdQVV0gQ2xlYXJpbmcgd2ViZ3B1IGJ1ZmZlciBjYWNoZVwiKSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHI9PntyLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXApfX0sdm89KC4uLmUpPT5uZXcgTm4oLi4uZSl9KTt2YXIgV24sTixpZT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V249Y2xhc3N7Y29uc3RydWN0b3IodCl7T2JqZWN0LmFzc2lnbih0aGlzLHQpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLmtleXx8KHRoaXMua2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAodD0+YCR7dGhpc1t0XX1gKS5qb2luKFwiO1wiKSksdGhpcy5rZXl9fSxOPWU9Pm5ldyBXbihlKX0pO3ZhciBZZSxIbixyZSxjZSxQLFgscW4sSmUsVGUsTyxRdCxTLEMsU28sWHQsR24sVG8sSz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtZZT02NCxIbj0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKE51bWJlcihlKSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2Nhc2UgMjI6cmV0dXJuXCJpMzJcIjtjYXNlIDIxOnJldHVyblwidTMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxyZT0oZSx0PTEpPT57bGV0IG49SG4oZSx0KTtyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCI/bjpuWzBdfSxjZT0oZSx0PTEpPT57bGV0IG49SG4oZSx0KTtyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCI/bjpuWzFdfSxQPSguLi5lKT0+e2xldCB0PVtdO3JldHVybiBlLmZvckVhY2gobj0+e24ubGVuZ3RoIT09MCYmdC5wdXNoKHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTp4LmNvbXB1dGVTdHJpZGVzKG4pfSl9KSx0fSxYPWU9PmUlND09PTA/NDplJTI9PT0wPzI6MSxxbj0oZT1cImYzMlwiLHQsbj1cIjBcIik9PiF0fHx0PT09MT9gJHtlfSgke259KWA6YHZlYyR7dH08JHtlfT4oJHtufSlgLEplPShlLHQsbik9PmU9PT1cImYzMlwiP246dD09PTE/YGYzMigke259KWA6YHZlYyR7dH08ZjMyPigke259KWAsVGU9KGUsdCk9PnQ9PT00P2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56ICsgJHtlfS53KWA6dD09PTI/YCgke2V9LnggKyAke2V9LnkpYDp0PT09Mz9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueilgOmUsTz0oZSx0LG4scik9PmUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmbj40P3R5cGVvZiB0PT1cInN0cmluZ1wiP3I9PT1cImYxNlwiP2Ake2V9Wygke3R9KSAvIDhdWygke3R9KSAlIDggLyA0XVsoJHt0fSkgJSA4ICUgNF1gOmAke2V9Wygke3R9KSAvIDRdWygke3R9KSAlIDRdYDpyPT09XCJmMTZcIj9gJHtlfVske01hdGguZmxvb3IodC84KX1dWyR7TWF0aC5mbG9vcih0JTgvNCl9XVske3QlOCU0fV1gOmAke2V9WyR7TWF0aC5mbG9vcih0LzQpfV1bJHt0JTR9XWA6bj4xP2Ake2V9WyR7dH1dYDplLFF0PShlLHQsbixyLG8pPT57bGV0IGk9dHlwZW9mIG49PVwibnVtYmVyXCIscz1pP246bi5sZW5ndGgsYT1bLi4ubmV3IEFycmF5KHMpLmtleXMoKV0sdT1zPDI/XCJ1MzJcIjpzPD00P2B2ZWMke3N9PHUzMj5gOmBhcnJheTx1MzIsICR7c30+YCxkPUhuKHQsbyksbD10eXBlb2YgZD09XCJzdHJpbmdcIj9kOmRbMV0sYz10eXBlb2YgZD09XCJzdHJpbmdcIj9kOmRbMF0scD17aW5kaWNlczp1LHZhbHVlOmwsc3RvcmFnZTpjLHRlbnNvcjp0fSxmPUU9PnR5cGVvZiBFPT1cInN0cmluZ1wiP0U6YCR7RX11YCxtPXtvZmZzZXRUb0luZGljZXM6ITEsaW5kaWNlc1RvT2Zmc2V0OiExLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiExLHNldDohMSxzZXRCeUluZGljZXM6ITEsZ2V0OiExLGdldEJ5SW5kaWNlczohMX0saD1pP1widW5pZm9ybXMuXCI6XCJcIixiPWAke2h9JHtlfV9zaGFwZWAseT1gJHtofSR7ZX1fc3RyaWRlc2AsZz1cIlwiO2ZvcihsZXQgRT0wO0U8cy0xO0UrKylnKz1gXG4gICAgbGV0IGRpbSR7RX0gPSBjdXJyZW50IC8gJHtPKHksRSxzKX07XG4gICAgbGV0IHJlc3Qke0V9ID0gY3VycmVudCAlICR7Tyh5LEUscyl9O1xuICAgIGluZGljZXNbJHtFfV0gPSBkaW0ke0V9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtFfTtcbiAgICBgO2crPWBpbmRpY2VzWyR7cy0xfV0gPSBjdXJyZW50O2A7bGV0IF89czwyP1wiXCI6YFxuICBmbiBvMmlfJHtlfShvZmZzZXQ6IHUzMikgLT4gJHtwLmluZGljZXN9IHtcbiAgICB2YXIgaW5kaWNlczogJHtwLmluZGljZXN9O1xuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xuICAgICR7Z31cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfWAsdz1FPT4obS5vZmZzZXRUb0luZGljZXM9ITAsczwyP0U6YG8yaV8ke2V9KCR7RX0pYCksdj1bXTtpZihzPj0yKWZvcihsZXQgRT1zLTE7RT49MDtFLS0pdi5wdXNoKGAke08oeSxFLHMpfSAqIChpbmRpY2VzWyR7RX1dKWApO2xldCAkPXM8Mj9cIlwiOmBcbiAgZm4gaTJvXyR7ZX0oaW5kaWNlczogJHtwLmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke3Yuam9pbihcIitcIil9O1xuICB9YCxUPUU9PihtLmluZGljZXNUb09mZnNldD0hMCxzPDI/RTpgaTJvXyR7ZX0oJHtFfSlgKSxJPSguLi5FKT0+cz09PTA/XCIwdVwiOmAke3AuaW5kaWNlc30oJHtFLm1hcChmKS5qb2luKFwiLFwiKX0pYCxBPShFLEwpPT5zPDI/YCR7RX1gOmAke08oRSxMLHMpfWAsej0oRSxMLG9lKT0+czwyP2Ake0V9PSR7b2V9O2A6YCR7TyhFLEwscyl9PSR7b2V9O2AsTT17fSxVPShFLEwpPT57bS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgb2U9YCR7TC5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtlfU9mZnNldGA7aWYob2UgaW4gTSlyZXR1cm5gJHtvZX0oJHtFfSlgO2xldCAkZT1bXTtmb3IobGV0IFNlPXMtMTtTZT49MDtTZS0tKXtsZXQgdWU9TC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFNlK0wucmFuay1zKTskZS5wdXNoKGAke0EoeSxTZSl9ICogKCR7dWV9ICUgJHtBKGIsU2UpfSlgKX1yZXR1cm4gTVtvZV09YGZuICR7b2V9KG91dHB1dEluZGljZXM6ICR7TC50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAkeyRlLmxlbmd0aD4wPyRlLmpvaW4oXCIrXCIpOlwiMHVcIn07XG4gICAgICAgICAgIH1gLGAke29lfSgke0V9KWB9LEc9KEUsTCk9PigoKT0+e2lmKHAuc3RvcmFnZT09PXAudmFsdWUpcmV0dXJuYCR7ZX1bJHtFfV09JHtMfTtgO2lmKHAuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnAudmFsdWU9PT1cImkzMlwiKXJldHVybmAke2V9WyR7RX1dPXZlYzI8dTMyPih1MzIoJHtMfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7TH0gPCAwKSk7YDtpZihwLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZwLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske0V9XT12ZWMyPHUzMj4odTMyKCR7TH0pLCAwdSk7YDtpZihwLnN0b3JhZ2U9PT1cInUzMlwiJiZwLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYCR7ZX1bJHtFfV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHtMfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3Auc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtwLnZhbHVlfSB5ZXRgKX0pKCksQj1FPT4oKCk9PntpZihwLnN0b3JhZ2U9PT1wLnZhbHVlKXJldHVybmAke2V9WyR7RX1dYDtpZihwLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZwLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtFfV0ueClgO2lmKHAuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnAudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske0V9XS54KWA7aWYocC5zdG9yYWdlPT09XCJ1MzJcIiYmcC52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske0V9XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7RX1dICYgMHhGRjAwdSksIGJvb2woJHtlfVske0V9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske0V9XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtwLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7cC52YWx1ZX0geWV0YCl9KSgpLGVlPXM8Mj9cIlwiOmBcbiAgZm4gZ2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtwLmluZGljZXN9KSAtPiAke2x9IHtcbiAgICByZXR1cm4gJHtCKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcbiAgfWAsVz1zPDI/XCJcIjooKCk9PntsZXQgRT1hLm1hcChvZT0+YGQke29lfTogdTMyYCkuam9pbihcIiwgXCIpLEw9YS5tYXAob2U9PmBkJHtvZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBnZXRfJHtlfSgke0V9KSAtPiAke2x9IHtcbiAgICByZXR1cm4gZ2V0XyR7ZX1CeUluZGljZXMoJHtJKEwpfSk7XG4gIH1gfSkoKSxEPSguLi5FKT0+e2lmKEUubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtzfWApO2xldCBMPUUubWFwKGYpLmpvaW4oXCIsXCIpO3JldHVybiBzPT09MD9CKFwiMHVcIik6cz09PTE/QihMWzBdKToobS5nZXQ9ITAsbS5nZXRCeUluZGljZXM9ITAsbS5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9KCR7TH0pYCl9LFo9RT0+czwyP0IoRSk6KG0uZ2V0QnlJbmRpY2VzPSEwLG0uaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfUJ5SW5kaWNlcygke0V9KWApLFI9czwyP1wiXCI6YFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3AuaW5kaWNlc30sIHZhbHVlOiAke2x9KSB7XG4gICAgJHtHKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAsUT1zPDI/XCJcIjooKCk9PntsZXQgRT1hLm1hcChvZT0+YGQke29lfTogdTMyYCkuam9pbihcIiwgXCIpLEw9YS5tYXAob2U9PmBkJHtvZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBzZXRfJHtlfSgke0V9LCB2YWx1ZTogJHtsfSkge1xuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7SShMKX0sIHZhbHVlKTtcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IEU9W10sTD0hMTtyZXR1cm4gbS5vZmZzZXRUb0luZGljZXMmJihFLnB1c2goXyksTD0hMCksbS5pbmRpY2VzVG9PZmZzZXQmJihFLnB1c2goJCksTD0hMCksbS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmKE9iamVjdC52YWx1ZXMoTSkuZm9yRWFjaChvZT0+RS5wdXNoKG9lKSksTD0hMCksbS5zZXQmJihFLnB1c2goUSksTD0hMCksbS5zZXRCeUluZGljZXMmJihFLnB1c2goUiksTD0hMCksbS5nZXQmJihFLnB1c2goVyksTD0hMCksbS5nZXRCeUluZGljZXMmJihFLnB1c2goZWUpLEw9ITApLCFpJiZMJiZFLnVuc2hpZnQoYGNvbnN0ICR7Yn0gPSAke3AuaW5kaWNlc30oJHtuLmpvaW4oXCIsXCIpfSk7YCxgY29uc3QgJHt5fSA9ICR7cC5pbmRpY2VzfSgke3guY29tcHV0ZVN0cmlkZXMobikuam9pbihcIixcIil9KTtgKSxFLmpvaW4oYFxuYCl9LHR5cGU6cCxvZmZzZXRUb0luZGljZXM6dyxpbmRpY2VzVG9PZmZzZXQ6VCxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpVLGluZGljZXM6SSxpbmRpY2VzR2V0OkEsaW5kaWNlc1NldDp6LHNldDooLi4uRSk9PntpZihFLmxlbmd0aCE9PXMrMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtzfWApO2xldCBMPUVbc107aWYodHlwZW9mIEwhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IG9lPUUuc2xpY2UoMCxzKS5tYXAoZikuam9pbihcIixcIik7cmV0dXJuIHM9PT0wP0coXCIwdVwiLEwpOnM9PT0xP0cob2VbMF0sTCk6KG0uc2V0PSEwLG0uc2V0QnlJbmRpY2VzPSEwLG0uaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke29lfSwgJHtMfSlgKX0sc2V0QnlPZmZzZXQ6RyxzZXRCeUluZGljZXM6KEUsTCk9PnM8Mj9HKEUsTCk6KG0uc2V0QnlJbmRpY2VzPSEwLG0uaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke0V9LCAke0x9KTtgKSxnZXQ6RCxnZXRCeU9mZnNldDpCLGdldEJ5SW5kaWNlczpaLHVzYWdlOnIsbmFtZTplLHN0cmlkZXM6eSxzaGFwZTpiLHJhbms6c319LFM9KGUsdCxuLHI9MSk9PlF0KGUsdCxuLFwiaW5wdXRcIixyKSxDPShlLHQsbixyPTEpPT5RdChlLHQsbixcIm91dHB1dFwiLHIpLFNvPShlLHQsbik9PlF0KGUsdCxuLFwiYXRvbWljT3V0cHV0XCIsMSksWHQ9KGUsdCxuLHI9MSk9PlF0KGUsdCxuLFwiaW50ZXJuYWxcIixyKSxHbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9dDt0aGlzLmxpbWl0cz1uO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXM9W107dGhpcy52YXJpYWJsZXM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1ZZSl7bGV0IG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdO2lmKG4+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfHxyPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWXx8bz50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVopdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHtufSwgJHtyfSwgJHtvfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWX0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCk7aWYobipyKm8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7bn0sICR7cn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIGludm9jYXRpb25zICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwfS5gKTtsZXQgaT10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdPT09MSYmdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXT09PTEscz1pP2BAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIG51bV93b3JrZ3JvdXBzIDogdmVjMzx1MzI+YCxhPWk/YGxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YDpgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54O1xuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke24qcipvfXUgKyBsb2NhbF9pZHg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7bn0sICR7cn0sICR7b30pXG4gIGZuIG1haW4oJHtzfSkge1xuICAgICR7YX1cbiAgYH1hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpe3QucmFuayE9PTAmJih0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pKX1kZWNsYXJlVmFyaWFibGUodCxuKXtpZih0LnVzYWdlPT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLnZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KTtsZXQgcj10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLG89dC51c2FnZT09PVwiYXRvbWljT3V0cHV0XCI/XCJhdG9taWM8aTMyPlwiOnQudHlwZS5zdG9yYWdlO3JldHVybmBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtufSkgdmFyPHN0b3JhZ2UsICR7cn0+ICR7dC5uYW1lfTogYXJyYXk8JHtvfT47YH1kZWNsYXJlVmFyaWFibGVzKC4uLnQpe3JldHVybiB0Lm1hcChuPT50aGlzLmRlY2xhcmVWYXJpYWJsZShuLHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbihgXG5gKX1yZWdpc3RlckludGVybmFsVmFyaWFibGUodCl7aWYodC51c2FnZSE9PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5mb3JFYWNoKG49PnRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKG4pKSx0aGlzfXJlZ2lzdGVyVW5pZm9ybSh0LG4scj0xKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpuLGxlbmd0aDpyfSksdGhpc31yZWdpc3RlclVuaWZvcm1zKHQpe3JldHVybiB0aGlzLnVuaWZvcm1zPXRoaXMudW5pZm9ybXMuY29uY2F0KHQpLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOm4sdHlwZTpyLGxlbmd0aDpvfW9mIHRoaXMudW5pZm9ybXMpaWYobyYmbz40KXI9PT1cImYxNlwiP3QucHVzaChgQGFsaWduKDE2KSAke259OmFycmF5PG1hdDJ4NDwke3J9PiwgJHtNYXRoLmNlaWwoby84KX0+YCk6dC5wdXNoKGAke259OmFycmF5PHZlYzQ8JHtyfT4sICR7TWF0aC5jZWlsKG8vNCl9PmApO2Vsc2V7bGV0IGk9bz09bnVsbHx8bz09PTE/cjpgdmVjJHtvfTwke3J9PmA7dC5wdXNoKGAke259OiR7aX1gKX1yZXR1cm5gXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3Quam9pbihcIiwgXCIpfSB9O1xuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7dGhpcy52YXJpYWJsZUluZGV4fSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztgfWdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCl7cmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkrdGhpcy52YXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApK3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApfWdldCB2YXJpYWJsZXNJbmZvKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVybjtsZXQgdD1uPT5bMTIsMTAsMSw2XVtbXCJ1MzJcIixcImYxNlwiLFwiZjMyXCIsXCJpMzJcIl0uaW5kZXhPZihuKV07cmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKG49Plt0KG4udHlwZSksbi5sZW5ndGg/PzFdKX19LFRvPShlLHQpPT5uZXcgR24oZSx0KX0pO3ZhciBjZCxJbyxwZCxtZCxmZCxoZCxwZSxDbyxBbyxWZT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtjZD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKHQubGVuZ3RoIT09MCYmdC5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgcGVybSBzaXplICR7dC5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIGlucHV0IHJhbmsgJHtlWzBdLmRpbXMubGVuZ3RofWApfSxJbz0oZSx0KT0+dC5sZW5ndGghPT0wP3Q6Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKSxwZD0oZSx0KT0+eC5zb3J0QmFzZWRPblBlcm0oZSxJbyhlLmxlbmd0aCx0KSksbWQ9KGUsdCxuLHIpPT57bGV0IG89YGZuIHBlcm0oaTogJHtyLnR5cGUuaW5kaWNlc30pIC0+ICR7bi50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtuLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IGk9MDtpPHQ7KytpKW8rPWBhWyR7ZVtpXX1dPWlbJHtpfV07YDtyZXR1cm4gbys9XCJyZXR1cm4gYTt9XCJ9LGZkPShlLHQpPT57bGV0IG49W10scj1bXTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyllW29dIT09MSYmbi5wdXNoKGVbb10pLGVbdFtvXV0hPT0xJiZyLnB1c2godFtvXSk7cmV0dXJue25ld1NoYXBlOm4sbmV3UGVybTpyfX0saGQ9KGUsdCk9PntsZXQgbj0wO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKHRbZVtyXV0hPT0xKXtpZihlW3JdPG4pcmV0dXJuITE7bj1lW3JdfXJldHVybiEwfSxwZT0oZSx0KT0+e2xldCBuPWUuZGF0YVR5cGUscj1lLmRpbXMubGVuZ3RoLG89SW8ocix0KSxpPXBkKGUuZGltcyxvKSxzPWUuZGltcyxhPWksdT1yPDJ8fGhkKG8sZS5kaW1zKSxkO2lmKHUpcmV0dXJuIGQ9aD0+e2xldCBiPVMoXCJpbnB1dFwiLG4scyw0KSx5PUMoXCJvdXRwdXRcIixuLGEsNCk7cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGIseSl9XG4gICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VDb3B5XCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgaD14LnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoaC80KX1dfX0sZ2V0U2hhZGVyU291cmNlOmR9O2xldHtuZXdTaGFwZTpsLG5ld1Blcm06Y309ZmQoZS5kaW1zLG8pLHA9eC5hcmVFcXVhbChjLFsyLDMsMV0pLGY9eC5hcmVFcXVhbChjLFszLDEsMl0pO2lmKGwubGVuZ3RoPT09Mnx8cHx8Zil7cz1wP1tsWzBdLGxbMV0qbFsyXV06Zj9bbFswXSpsWzFdLGxbMl1dOmwsYT1bc1sxXSxzWzBdXTtsZXQgaD0xNjtyZXR1cm4gZD1iPT57bGV0IHk9UyhcImFcIixuLHMubGVuZ3RoKSxnPUMoXCJvdXRwdXRcIixuLGEubGVuZ3RoKTtyZXR1cm5gXG4gICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxnKX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7Zy50eXBlLnZhbHVlfSwgJHtoKzF9PiwgJHtofT47XG4gICR7Yi5tYWluU3RhcnQoW2gsaCwxXSl9XG4gICAgbGV0IHN0cmlkZSA9ICh1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0gLSAxKSAvICR7aH0gKyAxO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeCA9IHdvcmtncm91cF9pbmRleCAlIHN0cmlkZTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3kgPSB3b3JrZ3JvdXBfaW5kZXggLyBzdHJpZGU7XG4gICAgbGV0IGlucHV0X2NvbCA9IHdvcmtncm91cF9pZF95ICogJHtofXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBpbnB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeCAqICR7aH11ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt5LmdldEJ5SW5kaWNlcyhgJHt5LnR5cGUuaW5kaWNlc30oaW5wdXRfcm93LCBpbnB1dF9jb2wpYCl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgb3V0cHV0X2NvbCA9IHdvcmtncm91cF9pZF94ICogJHtofXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke2h9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKG91dHB1dF9yb3cgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF0gJiYgb3V0cHV0X2NvbCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSkge1xuICAgICAgJHtnLnNldEJ5SW5kaWNlcyhgJHtnLnR5cGUuaW5kaWNlc30ob3V0cHV0X3Jvdywgb3V0cHV0X2NvbClgLFwidGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XVwiKX1cbiAgICB9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVNoYXJlZFwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IGI9eC5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhWzFdL2gpLHk6TWF0aC5jZWlsKGFbMF0vaCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpifSwuLi5QKHMsYSldfX0sZ2V0U2hhZGVyU291cmNlOmR9fXJldHVybiBkPWg9PntsZXQgYj1TKFwiYVwiLG4scy5sZW5ndGgpLHk9QyhcIm91dHB1dFwiLG4sYS5sZW5ndGgpO3JldHVybmBcbiAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhiLHkpfVxuXG4gICR7bWQobyxyLGIseSl9XG5cbiAgJHtoLm1haW5TdGFydCgpfVxuICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHt5LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGIuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCBoPXguc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpofSwuLi5QKHMsYSldfX0sZ2V0U2hhZGVyU291cmNlOmR9fSxDbz0oZSx0KT0+e2NkKGUuaW5wdXRzLHQucGVybSksZS5jb21wdXRlKHBlKGUuaW5wdXRzWzBdLHQucGVybSkpfSxBbz1lPT5OKHtwZXJtOmUucGVybX0pfSk7dmFyIGdkLHlkLGJkLF9kLHdkLCRkLHZkLHhkLFNkLFRkLHplLEVvLGtvLFBvLHpvLEJvLERvLE9vLE1vLFVvLFJvLFZvPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtZdCgpO1ZlKCk7Z2Q9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSlcIixsMTpcImJlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0seWQ9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDE6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxiZD17bWF4OlwiX0Fbb2Zmc2V0XVwiLG1pbjpcIl9BW29mZnNldF1cIixtZWFuOlwiMFwiLHN1bTpcIjBcIixwcm9kOlwiMVwiLHN1bVNxdWFyZTpcIjBcIixsb2dTdW1FeHA6XCIwXCIsbDE6XCIwXCIsbDI6XCIwXCIsbG9nU3VtOlwiMFwifSxfZD17bWF4OlwiYmVzdFZhbHVlXCIsbWluOlwiYmVzdFZhbHVlXCIsc3VtOlwiYmVzdFZhbHVlXCIscHJvZDpcImJlc3RWYWx1ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZVwiLGxvZ1N1bUV4cDpcImxvZyhiZXN0VmFsdWUpXCIsbDE6XCJiZXN0VmFsdWVcIixsMjpcInNxcnQoYmVzdFZhbHVlKVwiLGxvZ1N1bTpcImxvZyhiZXN0VmFsdWUpXCJ9LHdkPShlLHQpPT57bGV0IG49W107Zm9yKGxldCByPXQtZTtyPHQ7KytyKW4ucHVzaChyKTtyZXR1cm4gbn0sJGQ9KGUsdCk9PntsZXQgbj1bXSxyPWUubGVuZ3RoO2ZvcihsZXQgaT0wO2k8cjtpKyspdC5pbmRleE9mKGkpPT09LTEmJm4ucHVzaChlW2ldKTtsZXQgbz10Lm1hcChpPT5lW2ldKTtyZXR1cm5bbixvXX0sdmQ9KGUsdCk9PntsZXQgbj1lLmxlbmd0aCt0Lmxlbmd0aCxyPVtdLG89MDtmb3IobGV0IGk9MDtpPG47aSsrKXQuaW5kZXhPZihpKT09PS0xP3IucHVzaChlW28rK10pOnIucHVzaCgxKTtyZXR1cm4gcn0seGQ9KGUsdCk9Pntmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZihlW2UubGVuZ3RoLW4tMV0hPT10LTEtbilyZXR1cm4hMTtyZXR1cm4hMH0sU2Q9KGUsdCk9PntsZXQgbj1bXTtpZigheGQoZSx0KSl7Zm9yKGxldCByPTA7cjx0OysrcillLmluZGV4T2Yocik9PT0tMSYmbi5wdXNoKHIpO2UuZm9yRWFjaChyPT5uLnB1c2gocikpfXJldHVybiBufSxUZD0oZSx0LG4scixvLGkscyk9PntsZXQgYT1uWzBdLmRpbXMsdT14LnNpemUoaSksZD14LnNpemUocyksbD1TKFwiX0FcIixuWzBdLmRhdGFUeXBlLGEpLGM9QyhcIm91dHB1dFwiLG8saSkscD02NDt1PT09MSYmKHA9MjU2KTtsZXQgZj1gXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7cH0+O1xuICAgICAgIGAsbT1oPT5gXG4gICAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJyZWR1Y2VTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhsLGMpfVxuICAgICAgICAke2Z9XG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICAgICB9XG4gICAgICAgICAke2gubWFpblN0YXJ0KHApfVxuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7cH07XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBmMzIoJHtiZFtyXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHtwfSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7bC5nZXRCeU9mZnNldChcIm9mZnNldCArIGtcIil9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtnZFtyXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7cH11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3lkW3JdfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke2Muc2V0QnlPZmZzZXQoXCJvdXRwdXRJbmRleFwiLGAke3I9PT1cIm1lYW5cIj9gJHtjLnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWA6YCR7Yy50eXBlLnN0b3JhZ2V9KCR7X2Rbcl19KWB9YCl9O1xuICAgICAgICAgfVxuICAgICAgICB9YDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3R9OyR7cH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTptLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDp1fSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6ZH1dfSl9fSx6ZT0oZSx0LG4scik9PntsZXQgbz1lLmlucHV0cy5sZW5ndGg9PT0xP246Rm4oZS5pbnB1dHMsbiksaT1vLmF4ZXM7aS5sZW5ndGg9PT0wJiYhby5ub29wV2l0aEVtcHR5QXhlcyYmKGk9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKGYsbSk9Pm0pKTtsZXQgcz14Lm5vcm1hbGl6ZUF4ZXMoaSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCksYT1zLHU9ZS5pbnB1dHNbMF0sZD1TZChhLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtkLmxlbmd0aD4wJiYodT1lLmNvbXB1dGUocGUoZS5pbnB1dHNbMF0sZCkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0sYT13ZChhLmxlbmd0aCx1LmRpbXMubGVuZ3RoKSk7bGV0W2wsY109JGQodS5kaW1zLGEpLHA9bDtvLmtlZXBEaW1zJiYocD12ZChsLHMpKSxlLmNvbXB1dGUoVGQodCxvLmNhY2hlS2V5LFt1XSxyLGUuaW5wdXRzWzBdLmRhdGFUeXBlLHAsYykse2lucHV0czpbdV19KX0sRW89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxrbz0oZSx0KT0+e3plKGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sUG89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LHpvPShlLHQpPT57emUoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LEJvPShlLHQpPT57emUoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LERvPShlLHQpPT57emUoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LE9vPShlLHQpPT57emUoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0sTW89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0sVW89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0sUm89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgQmUsSWQsSnQsRm4sRGUsQ2QsQWQsRWQsa2QsUGQsemQsQmQsRGQsT2QsTWQsT2UsTm8sTG8sV28sR28sSG8scW8sRm8sS28sam8sWm8sWXQ9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7Vm8oKTtCZT1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZS5sZW5ndGg9PT0yJiZlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy5cIil9LElkPWU9PltcIlwiLFwiXCIsYHZhciB2YWx1ZSA9ICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdLEp0PShlLHQsbixyLG8saSxzPSExLGE9ITEpPT57bGV0IHU9W10sZD1uWzBdLmRpbXMsbD1kLmxlbmd0aCxjPXgubm9ybWFsaXplQXhlcyhvLGwpLHA9IWEmJmMubGVuZ3RoPT09MDtkLmZvckVhY2goKGIseSk9PntwfHxjLmluZGV4T2YoeSk+PTA/cyYmdS5wdXNoKDEpOnUucHVzaChiKX0pO2xldCBmPXUubGVuZ3RoLG09eC5zaXplKHUpO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6dCxnZXRTaGFkZXJTb3VyY2U6Yj0+e2xldCB5PVtdLGc9UyhcIl9BXCIsblswXS5kYXRhVHlwZSxsKSxfPUMoXCJvdXRwdXRcIixpLGYpLHc9cihnLF8sYyksdj13WzJdO2ZvcihsZXQgJD0wLFQ9MDskPGw7JCsrKXB8fGMuaW5kZXhPZigkKT49MD8ocyYmVCsrLHY9YGZvcih2YXIgaiR7JH06IHUzMiA9IDA7IGokeyR9IDwgJHtkWyRdfTsgaiR7JH0rKykge1xuICAgICAgICAgICAgICAgICAgJHt3WzJdLmluY2x1ZGVzKFwibGFzdF9pbmRleFwiKT9gbGV0IGxhc3RfaW5kZXggPSBqJHskfTtgOlwiXCJ9XG4gICAgICAgICAgICAgICAgICAke2cuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIiwkLGBqJHskfWApfVxuICAgICAgICAgICAgICAgICAgJHt2fVxuICAgICAgICAgICAgICAgIH1gKTooeS5wdXNoKGAke2cuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIiwkLF8uaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsVCkpfTtgKSxUKyspO3JldHVybmBcblxuICAgICAgICAke2IucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcsXyl9XG5cbiAgICAgICAgJHtiLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7Zy50eXBlLmluZGljZXN9O1xuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICR7eS5qb2luKGBcbmApfVxuICAgICAgICAgICR7d1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICAgJHt3WzFdfVxuICAgICAgICAgICR7dn1cbiAgICAgICAgICAke3dbM119XG4gICAgICAgICAgJHt3Lmxlbmd0aD09PTQ/Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpOncuc2xpY2UoNCkuam9pbihgXG5gKX1cbiAgICAgICAgfWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTppfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTptfSwuLi5QKGQsdSldfSl9fSxGbj0oZSx0KT0+e2xldCBuPVtdO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChyPT5uLnB1c2goTnVtYmVyKHIpKSksTih7YXhlczpuLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxEZT0oZSx0LG4scik9PntsZXQgbz1lLmlucHV0cyxpPW8ubGVuZ3RoPT09MT9uOkZuKG8sbik7ZS5jb21wdXRlKEp0KHQse2hpbnQ6aS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbb1swXV0saS5ub29wV2l0aEVtcHR5QXhlcyYmaS5heGVzLmxlbmd0aD09PTA/SWQ6cixpLmF4ZXMsb1swXS5kYXRhVHlwZSxpLmtlZXBEaW1zLGkubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LENkPShlLHQpPT57QmUoZS5pbnB1dHMpLERlKGUsXCJSZWR1Y2VMb2dTdW1cIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sQWQ9KGUsdCk9PntCZShlLmlucHV0cyksRGUoZSxcIlJlZHVjZUwxXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl0pfSxFZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlTDJcIix0LChyLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LGtkPShlLHQpPT57QmUoZS5pbnB1dHMpLERlKGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxQZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlTWF4XCIsdCwocixvLGkpPT57bGV0IHM9W107Zm9yKGxldCBhPTA7YTxyLnJhbms7YSsrKShpLmluZGV4T2YoYSk+PTB8fGkubGVuZ3RoPT09MCkmJnMucHVzaChyLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsYSwwKSk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSx6ZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlTWVhblwiLHQsKHIsbyxpKT0+e2xldCBzPTE7Zm9yKGxldCBhPTA7YTxyLnJhbms7YSsrKShpLmluZGV4T2YoYSk+PTB8fGkubGVuZ3RoPT09MCkmJihzKj1lLmlucHV0c1swXS5kaW1zW2FdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLGBsZXQgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oc3VtIC8gJHtzfSk7YF19KX0sQmQ9KGUsdCk9PntCZShlLmlucHV0cyksRGUoZSxcIlJlZHVjZU1pblwiLHQsKHIsbyxpKT0+e2xldCBzPVtdO2ZvcihsZXQgYT0wO2E8ci5yYW5rO2ErKykoaS5pbmRleE9mKGEpPj0wfHxpLmxlbmd0aD09PTApJiZzLnB1c2goYGlucHV0X2luZGljZXNbJHthfV0gPSAwO2ApO3JldHVybltgJHtzLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sRGQ9KGUsdCk9PntCZShlLmlucHV0cyksRGUoZSxcIlJlZHVjZVByb2RcIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxPZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlU3VtXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sTWQ9KGUsdCk9PntCZShlLmlucHV0cyksRGUoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKHIsbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxPZT0oZSx0LG4pPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiBuO2xldCByPTEsbz0xO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXQuaW5kZXhPZihpKT09PS0xP3IqPWVbaV06byo9ZVtpXTtyZXR1cm4gbzwzMiYmcj4xMDI0fSxObz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3pkKGUsdCk6RW8oZSx0KX0sTG89KGUsdCk9PntPZShlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9BZChlLHQpOmtvKGUsdCl9LFdvPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RWQoZSx0KTpQbyhlLHQpfSxHbz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2tkKGUsdCk6em8oZSx0KX0sSG89KGUsdCk9PntPZShlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9QZChlLHQpOkJvKGUsdCl9LHFvPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/QmQoZSx0KTpEbyhlLHQpfSxGbz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0RkKGUsdCk6T28oZSx0KX0sS289KGUsdCk9PntPZShlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9PZChlLHQpOk1vKGUsdCl9LGpvPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/TWQoZSx0KTpVbyhlLHQpfSxabz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0NkKGUsdCk6Um8oZSx0KX19KTt2YXIgUW8sWG8sWW8sS24sSm89aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtpZSgpO1l0KCk7UW89ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sWG89KGUsdCk9PntRbyhlLmlucHV0cyk7bGV0IG49KHIsbyxpKT0+e2xldCBzPVtdO2ZvcihsZXQgYT0wO2E8ci5yYW5rO2ErKykoaS5pbmRleE9mKGEpPj0wfHxpLmxlbmd0aD09PTApJiZzLnB1c2goYGlucHV0X2luZGljZXNbJHthfV0gPSAwO2ApO3JldHVybltgJHtzLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEp0KFwiQXJnTWluXCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLG4sW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxZbz0oZSx0KT0+e1FvKGUuaW5wdXRzKTtsZXQgbj0ocixvLGkpPT57bGV0IHM9W107Zm9yKGxldCBhPTA7YTxyLnJhbms7YSsrKShpLmluZGV4T2YoYSk+PTB8fGkubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRfaW5kaWNlc1ske2F9XSA9IDA7YCk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI+PVwiOlwiPlwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoSnQoXCJhcmdNYXhcIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0sbixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LEtuPWU9Pk4oZSl9KTt2YXIgVWQsam4sUmQsVmQsTmQsb3QsTGQsZWksZW49aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7WnQoKTtLKCk7VWQ9KGUsdCk9PntsZXQgbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1lWzNdLHM9ZVs0XSxhPWVbNV07aWYocyYmYSl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbnRpb24gY2Fubm90IGhhdmUgYm90aCBwYXN0IGFuZCBhdHRlbnRpb25fYmlhc1wiKTtpZihuLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiaW5wdXRcIiBtdXN0IGhhdmUgMyBkaW1lbnNpb25zJyk7bGV0IHU9bi5kaW1zWzBdLGQ9bi5kaW1zWzFdLGw9bi5kaW1zWzJdO2lmKG8uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtpZihyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09bCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDBcIik7aWYoby5kaW1zWzBdIT09ci5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtsZXQgYz1vLmRpbXNbMF0vMyxwPWMsZj1wO2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoPjApe2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSAzIGVsZW1lbnRzXCIpO2ZvcihsZXQgXyBvZiB0LnFrdkhpZGRlblNpemVzKWlmKF8ldC5udW1IZWFkcyE9PTApdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkc1wiKTtjPXQucWt2SGlkZGVuU2l6ZXNbMF0scD10LnFrdkhpZGRlblNpemVzWzFdLGY9dC5xa3ZIaWRkZW5TaXplc1syXX1sZXQgbT1kO2lmKGMhPT1wKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kXCIpO2lmKG8uZGltc1swXSE9PWMrcCtmKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplcycpO2xldCBoPTA7aWYocyl7aWYocCE9PWYpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBleHBlY3Qga19oaWRkZW5fc2l6ZSA9PSB2X2hpZGRlbl9zaXplJyk7aWYocy5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7aWYocy5kaW1zWzBdIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtpZihzLmRpbXNbMV0hPT11KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtpZihzLmRpbXNbMl0hPT10Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7aWYocy5kaW1zWzRdIT09cC90Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkcycpO3QucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcnx8KGg9cy5kaW1zWzNdKX1sZXQgYj1tK2gseT0tMSxnPTA7aWYoaSl0aHJvdyBuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIik7aWYocyl0aHJvdyBuZXcgRXJyb3IoXCJwYXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoYSl7aWYoYS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgbXVzdCBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGEuZGltc1swXSE9PXV8fGEuZGltc1sxXSE9PXQubnVtSGVhZHN8fGEuZGltc1syXSE9PWR8fGEuZGltc1szXSE9PWIpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpfXJldHVybntiYXRjaFNpemU6dSxzZXF1ZW5jZUxlbmd0aDpkLHBhc3RTZXF1ZW5jZUxlbmd0aDpoLGt2U2VxdWVuY2VMZW5ndGg6bSx0b3RhbFNlcXVlbmNlTGVuZ3RoOmIsbWF4U2VxdWVuY2VMZW5ndGg6eSxpbnB1dEhpZGRlblNpemU6bCxoaWRkZW5TaXplOmMsdkhpZGRlblNpemU6ZixoZWFkU2l6ZTpNYXRoLmZsb29yKGMvdC5udW1IZWFkcyksdkhlYWRTaXplOk1hdGguZmxvb3IoZi90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6ZyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ITEscGFzc1Bhc3RJbkt2OiExLHFrdkZvcm1hdDoxfX0sam49KGUsdCxuKT0+dCYmZT9gXG4gICAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0ID0gdTMyKCR7dC5nZXRCeU9mZnNldChcIjBcIil9KTtcbiAgICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IG1heCh0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQsIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdDogYm9vbCA9IHNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcbiAgICAgIGxldCBpc19maXJzdF9wcm9tcHQ6IGJvb2wgPSBpc19zdWJzZXF1ZW50X3Byb21wdCA9PSBmYWxzZSAmJiBzZXF1ZW5jZV9sZW5ndGggPT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7ZT8uZ2V0QnlPZmZzZXQoXCJiYXRjaElkeFwiKX0pICsgMTtcbiAgICAgIHZhciBwYXN0X3NlcXVlbmNlX2xlbmd0aDogdTMyID0gMDtcbiAgICAgIGlmIChpc19maXJzdF9wcm9tcHQgPT0gZmFsc2UpIHtcbiAgICAgICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggLSBzZXF1ZW5jZV9sZW5ndGg7XG4gICAgICB9XG4gICAgICAgYDpgXG4gICAgJHtuP1wibGV0IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGhcIjpcIlwifTtcbiAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgYCxSZD0oZSx0LG4scixvLGkscyxhKT0+e2xldCB1PVgocz8xOmkpLGQ9NjQsbD1pL3U7bDxkJiYoZD0zMik7bGV0IGM9TWF0aC5jZWlsKGkvdS9kKSxwPVt7dHlwZToxMixkYXRhOnR9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpjfV0sZj1yZShlLmRhdGFUeXBlLHUpLG09Y2UoMSx1KSxoPVtcInR5cGVcIl07cyYmaC5wdXNoKFwidHlwZVwiKSxhJiZoLnB1c2goXCJ0eXBlXCIpO2xldCBiPXk9PntsZXQgZz1DKFwieFwiLGUuZGF0YVR5cGUsZS5kaW1zLHUpLF89W2ddLHc9cz9TKFwic2VxX2xlbnNcIixzLmRhdGFUeXBlLHMuZGltcyk6dm9pZCAwO3cmJl8ucHVzaCh3KTtsZXQgdj1hP1MoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO3YmJl8ucHVzaCh2KTtsZXQgJD1jZShlLmRhdGFUeXBlKSxUPVt7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3RocmVhZFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke2R9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke2R9PjtcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybXMoVCkuZGVjbGFyZVZhcmlhYmxlcyguLi5fKX1cbiAgJHt5Lm1haW5TdGFydChbZCwxLDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke2puKHcsdiwhMSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtkfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHtzP1widTMyKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgd29ya2dyb3VwX2lkLnkgKyAxKVwiOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCJ9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7bX0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke219KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKHUpe2Nhc2UgMTpyZXR1cm5cInRocmVhZF9tYXhfdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwibWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpXCI7Y2FzZSA0OnJldHVyblwibWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke3V9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7ZH07IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke219KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke219KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2godSl7Y2FzZSAxOnJldHVyblwic3VtX3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueVwiO2Nhc2UgNDpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke3V9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke2R9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7Zy50eXBlLnZhbHVlfSgkeyR9KDEuMCkgLyAkeyR9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7bX0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke2cudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHtzP2BcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7Zy50eXBlLnZhbHVlfSgkeyR9KDApKTtcbiAgICAgICAgfWA6XCJcIn07XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke2R9OyR7Zn07JHt1fWAsaW5wdXREZXBlbmRlbmNpZXM6aH0sZ2V0U2hhZGVyU291cmNlOmIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6MSx5Om8sejp0Km59LHByb2dyYW1Vbmlmb3JtczpwfSl9fSxWZD0oZSx0LG4scixvLGkscyxhLHUpPT57bGV0IGQ9cytpLmt2U2VxdWVuY2VMZW5ndGgsbD1baS5iYXRjaFNpemUsaS5udW1IZWFkcyxpLnNlcXVlbmNlTGVuZ3RoLGRdLGM9ZT4xJiZyLHA9aS5rdk51bUhlYWRzP2kua3ZOdW1IZWFkczppLm51bUhlYWRzLGY9Yz9baS5iYXRjaFNpemUscCxkLGkuaGVhZFNpemVdOnZvaWQgMCxtPWkublJlcHM/aS5uUmVwczoxLGg9aS5zY2FsZT09PTA/MS9NYXRoLnNxcnQoaS5oZWFkU2l6ZSk6aS5zY2FsZSxiPVgoaS5oZWFkU2l6ZSkseT1pLmhlYWRTaXplL2IsZz0xMixfPXt4Ok1hdGguY2VpbChkL2cpLHk6TWF0aC5jZWlsKGkuc2VxdWVuY2VMZW5ndGgvZyksejppLmJhdGNoU2l6ZSppLm51bUhlYWRzfSx3PVt7dHlwZToxMixkYXRhOmkuc2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmkubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6aS5oZWFkU2l6ZX0se3R5cGU6MSxkYXRhOmh9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTppLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6bX1dLHY9YyYmciYmeC5zaXplKHIuZGltcyk+MCwkPVtcInR5cGVcIixcInR5cGVcIl07diYmJC5wdXNoKFwidHlwZVwiKSxvJiYkLnB1c2goXCJ0eXBlXCIpLGEmJiQucHVzaChcInR5cGVcIiksdSYmJC5wdXNoKFwidHlwZVwiKTtsZXQgVD1be2RpbXM6bCxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XTtjJiZULnB1c2goe2RpbXM6ZixkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9KTtsZXQgST1BPT57bGV0IHo9UyhcInFcIix0LmRhdGFUeXBlLHQuZGltcyxiKSxNPVMoXCJrZXlcIixuLmRhdGFUeXBlLG4uZGltcyxiKSxVPVt6LE1dO2lmKHYpe2xldCBSPVMoXCJwYXN0X2tleVwiLHIuZGF0YVR5cGUsci5kaW1zLGIpO1UucHVzaChSKX1vJiZVLnB1c2goUyhcImF0dGVudGlvbl9iaWFzXCIsby5kYXRhVHlwZSxvLmRpbXMpKTtsZXQgRz1hP1MoXCJzZXFfbGVuc1wiLGEuZGF0YVR5cGUsYS5kaW1zKTp2b2lkIDA7RyYmVS5wdXNoKEcpO2xldCBCPXU/UyhcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLHUuZGF0YVR5cGUsdS5kaW1zKTp2b2lkIDA7QiYmVS5wdXNoKEIpO2xldCBlZT1DKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxsKSxXPVtlZV07YyYmVy5wdXNoKEMoXCJwcmVzZW50X2tleVwiLHQuZGF0YVR5cGUsZixiKSk7bGV0IEQ9Y2UoMSxiKSxaPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwicGFzdF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia3Zfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5fcmVwc1wiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtnfXU7XG5cbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7ei50eXBlLnN0b3JhZ2V9LCAke2cqZ30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHt6LnR5cGUuc3RvcmFnZX0sICR7ZypnfT47XG4gICR7QS5yZWdpc3RlclVuaWZvcm1zKFopLmRlY2xhcmVWYXJpYWJsZXMoLi4uVSwuLi5XKX1cbiAgJHtBLm1haW5TdGFydChbZyxnLDFdKX1cbiAgICAvLyB4IGhvbGRzIHRoZSBOIGFuZCB5IGhvbGRzIHRoZSBNXG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQga3ZIZWFkSWR4ID0gJHttPT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICAgbGV0IGt2X251bV9oZWFkcyA9ICR7bT09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFO1xuICAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkU7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk47XG4gICAgJHtqbihHLEIsITApfVxuICAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDtcbiAgICBsZXQgcU9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKyBtICogdW5pZm9ybXMuSztcbiAgICAke3YmJmM/XCJsZXQgcGFzdEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcIjpcIlwifTtcbiAgICBsZXQga09mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XG4gICAgJHtjP1wibGV0IHByZXNlbnRLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSztcIjpcIlwifVxuICAgIHZhciB2YWx1ZSA9ICR7RH0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAke3YmJmM/YFxuICAgICAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBwYXN0X2tleVtwYXN0S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH1gOmBcbiAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgIH1gfVxuICAgICAgJHtjP2BpZiAobiArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICBwcmVzZW50X2tleVtwcmVzZW50S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF0gPSB0aWxlS1tpZHhdO1xuICAgICAgfWA6XCJcIn1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJHtEfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpPT57c3dpdGNoKGIpe2Nhc2UgMTpyZXR1cm5cInZhbHVlXCI7Y2FzZSAyOnJldHVyblwidmFsdWUueCArIHZhbHVlLnlcIjtjYXNlIDQ6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Yn1gKX19KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke2VlLnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke28/XCJhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdXCI6XCIwLjBcIn07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1wiLHNoYWRlckNhY2hlOntoaW50OmAke2J9OyR7byE9PXZvaWQgMH07JHtyIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczokfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOl8scHJvZ3JhbVVuaWZvcm1zOnd9KSxnZXRTaGFkZXJTb3VyY2U6SX19LE5kPShlLHQsbixyLG8saSxzPXZvaWQgMCxhPXZvaWQgMCk9PntsZXQgdT1pK28ua3ZTZXF1ZW5jZUxlbmd0aCxkPW8ublJlcHM/by5uUmVwczoxLGw9by52SGlkZGVuU2l6ZSpkLGM9ZT4xJiZyLHA9by5rdk51bUhlYWRzP28ua3ZOdW1IZWFkczpvLm51bUhlYWRzLGY9Yz9bby5iYXRjaFNpemUscCx1LG8uaGVhZFNpemVdOnZvaWQgMCxtPVtvLmJhdGNoU2l6ZSxvLnNlcXVlbmNlTGVuZ3RoLGxdLGg9MTIsYj17eDpNYXRoLmNlaWwoby52SGVhZFNpemUvaCkseTpNYXRoLmNlaWwoby5zZXF1ZW5jZUxlbmd0aC9oKSx6Om8uYmF0Y2hTaXplKm8ubnVtSGVhZHN9LHk9W3t0eXBlOjEyLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTp1fSx7dHlwZToxMixkYXRhOm8udkhlYWRTaXplfSx7dHlwZToxMixkYXRhOm8ubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6by5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6by5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOmR9XSxnPWMmJnImJnguc2l6ZShyLmRpbXMpPjAsXz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2cmJl8ucHVzaChcInR5cGVcIikscyYmXy5wdXNoKFwidHlwZVwiKSxhJiZfLnB1c2goXCJ0eXBlXCIpO2xldCB3PVt7ZGltczptLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO2MmJncucHVzaCh7ZGltczpmLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCB2PSQ9PntsZXQgVD1TKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksST1TKFwidlwiLG4uZGF0YVR5cGUsbi5kaW1zKSxBPVtULEldO2cmJkEucHVzaChTKFwicGFzdF92YWx1ZVwiLHIuZGF0YVR5cGUsci5kaW1zKSk7bGV0IHo9cz9TKFwic2VxX2xlbnNcIixzLmRhdGFUeXBlLHMuZGltcyk6dm9pZCAwO3MmJkEucHVzaCh6KTtsZXQgTT1hP1MoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO2EmJkEucHVzaChNKTtsZXQgRz1bQyhcIm91dHB1dFwiLHQuZGF0YVR5cGUsbSldO2MmJkcucHVzaChDKFwicHJlc2VudF92YWx1ZVwiLHQuZGF0YVR5cGUsZikpO2xldCBCPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidl9oaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2h9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7VC50eXBlLnZhbHVlfSwgJHtoKmh9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7VC50eXBlLnZhbHVlfSwgJHtoKmh9PjtcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoQikuZGVjbGFyZVZhcmlhYmxlcyguLi5BLC4uLkcpfVxuICAkeyQubWFpblN0YXJ0KFtoLGgsMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7ZD09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7ZD09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7am4oeixNLCEwKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke2cmJmM/XCJsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcIjpcIlwifTtcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAke2M/XCJsZXQgcHJlc2VudFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1wiOlwiXCJ9XG4gICB2YXIgdmFsdWUgPSAke1QudHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAke2cmJmM/YFxuICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSBwYXN0X3ZhbHVlW3Bhc3RWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfSBlbHNlIGlmICh3ICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9XG4gICAgICBgOmBcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICAgICAgfWB9XG4gICAgICAgICR7Yz9gXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHByZXNlbnRfdmFsdWVbcHJlc2VudFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dID0gdGlsZVZbaWR4XTtcbiAgICAgICAgfWA6XCJcIn1cbiAgICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IGsrKykge1xuICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVWW1RJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54XTtcbiAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICB9XG5cbiAgIC8vIHdlIG5lZWQgdG8gdHJhbnNwb3NlIG91dHB1dCBmcm9tIEJOU0hfdiB0byBCU05EX3ZcbiAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICBsZXQgb3V0cHV0SWR4ID0gYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZSArIG0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplXG4gICAgICAgKyBoZWFkSWR4ICogdW5pZm9ybXMuTiArIG47XG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XG4gICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblNjb3JlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ciE9PXZvaWQgMH07JHtlfWAsaW5wdXREZXBlbmRlbmNpZXM6X30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOncsZGlzcGF0Y2hHcm91cDpiLHByb2dyYW1Vbmlmb3Jtczp5fSksZ2V0U2hhZGVyU291cmNlOnZ9fSxvdD0oZSx0LG4scixvLGkscyxhLHUsZCxsPXZvaWQgMCxjPXZvaWQgMCk9PntsZXQgcD1NYXRoLm1pbihlLm91dHB1dENvdW50LDErKHM/MTowKSsoYT8xOjApKSxmPXA+MT9kLnBhc3RTZXF1ZW5jZUxlbmd0aDowLG09ZitkLmt2U2VxdWVuY2VMZW5ndGgsaD11JiZ4LnNpemUodS5kaW1zKT4wP3U6dm9pZCAwLGI9W3Qsbl07cD4xJiZzJiZ4LnNpemUocy5kaW1zKT4wJiZiLnB1c2gocyksaCYmYi5wdXNoKGgpLGwmJmIucHVzaChsKSxjJiZiLnB1c2goYyk7bGV0IHk9ZS5jb21wdXRlKFZkKHAsdCxuLHMsaCxkLGYsbCxjKSx7aW5wdXRzOmIsb3V0cHV0czpwPjE/Wy0xLDFdOlstMV19KVswXTtlLmNvbXB1dGUoUmQoeSxkLmJhdGNoU2l6ZSxkLm51bUhlYWRzLGYsZC5zZXF1ZW5jZUxlbmd0aCxtLGwsYykse2lucHV0czpsJiZjP1t5LGwsY106W3ldLG91dHB1dHM6W119KTtsZXQgZz1beSxyXTtwPjEmJmEmJnguc2l6ZShhLmRpbXMpPjAmJmcucHVzaChhKSxsJiZnLnB1c2gobCksYyYmZy5wdXNoKGMpLGUuY29tcHV0ZShOZChwLHkscixhLGQsZixsLGMpLHtpbnB1dHM6ZyxvdXRwdXRzOnA+MT9bMCwyXTpbMF19KX0sTGQ9KGUsdCk9PntsZXQgbj1bdC5iYXRjaFNpemUsdC5udW1IZWFkcyx0LnNlcXVlbmNlTGVuZ3RoLHQuaGVhZFNpemVdLHI9dC5zZXF1ZW5jZUxlbmd0aCxvPXQuaW5wdXRIaWRkZW5TaXplLGk9dC5oZWFkU2l6ZSxzPTEyLGE9e3g6TWF0aC5jZWlsKHQuaGVhZFNpemUvcykseTpNYXRoLmNlaWwodC5zZXF1ZW5jZUxlbmd0aC9zKSx6OnQuYmF0Y2hTaXplKnQubnVtSGVhZHN9LHU9W2UuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxkPVt7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOnQubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6dC5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemV9LHt0eXBlOjEyLGRhdGE6dC5oaWRkZW5TaXplK3QuaGlkZGVuU2l6ZSt0LnZIaWRkZW5TaXplfV0sbD1jPT57bGV0IHA9QyhcIm91dHB1dF9xXCIsdVswXS5kYXRhVHlwZSxuKSxmPUMoXCJvdXRwdXRfa1wiLHVbMF0uZGF0YVR5cGUsbiksbT1DKFwib3V0cHV0X3ZcIix1WzBdLmRhdGFUeXBlLG4pLGg9UyhcImlucHV0XCIsdVswXS5kYXRhVHlwZSx1WzBdLmRpbXMpLGI9UyhcIndlaWdodFwiLHVbMV0uZGF0YVR5cGUsdVsxXS5kaW1zKSx5PVMoXCJiaWFzXCIsdVsyXS5kYXRhVHlwZSx1WzJdLmRpbXMpLGc9aC50eXBlLnN0b3JhZ2UsXz1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImxkYlwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtzfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHtnfSwgJHtzKnN9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFE6IGFycmF5PCR7Z30sICR7cypzfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRLOiBhcnJheTwke2d9LCAke3Mqc30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHtnfSwgJHtzKnN9PjtcbiAgJHtjLnJlZ2lzdGVyVW5pZm9ybXMoXykuZGVjbGFyZVZhcmlhYmxlcyhoLGIseSxwLGYsbSl9XG4gICR7Yy5tYWluU3RhcnQoW3MscywxXSl9XG4gICAgbGV0IGJhdGNoSW5kZXggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcblxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGJpYXNPZmZzZXRRID0gaGVhZE51bWJlciAqIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICBsZXQgYmlhc09mZnNldEsgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRRO1xuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XG5cbiAgICB2YXIgdmFsdWVRID0gJHtnfSgwKTtcbiAgICB2YXIgdmFsdWVLID0gJHtnfSgwKTtcbiAgICB2YXIgdmFsdWVWID0gJHtnfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVJbnB1dFtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBpbnB1dFtpbnB1dE9mZnNldCArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG4gKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMubGRiO1xuICAgICAgICB0aWxlV2VpZ2h0UVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFEgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0VltUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFYgKyBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8VElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICBsZXQgaW5wdXRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGs7XG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XG4gICAgICAgIHZhbHVlUSArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRRW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZUsgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0S1t3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIHZhbHVlUSArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0UV07XG4gICAgdmFsdWVLICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRLXTtcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xuXG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gb2Zmc2V0ICsgbSAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICAgb3V0cHV0X3Fbb3V0cHV0SWR4XSA9IHZhbHVlUTtcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XG4gICAgICBvdXRwdXRfdltvdXRwdXRJZHhdID0gdmFsdWVWO1xuICAgIH1cbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJBdHRlbnRpb25QcmVwYXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpuLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOm4sZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6YSxwcm9ncmFtVW5pZm9ybXM6ZH0pLGdldFNoYWRlclNvdXJjZTpsfSx7aW5wdXRzOnUsb3V0cHV0czpbLTEsLTEsLTFdfSl9LGVpPShlLHQpPT57bGV0IG49VWQoZS5pbnB1dHMsdCksW3IsbyxpXT1MZChlLG4pO3JldHVybiBvdChlLHIsbyxpLGUuaW5wdXRzWzRdLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGUuaW5wdXRzWzVdLG4pfX0pO3ZhciBXZCxHZCxIZCx0aSxuaT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtWKCk7cSgpO2llKCk7SygpO1dkPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHNcIik7bGV0IG49KHIsbyxpKT0+e2xldCBzPW8ubGVuZ3RoO2lmKHMhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYCR7aX06IG51bSBkaW1lbnNpb25zICE9ICR7c31gKTtvLmZvckVhY2goKGEsdSk9PntpZihhIT09clt1XSl0aHJvdyBuZXcgRXJyb3IoYCR7aX06IGRpbVske3V9XSBkbyBub3QgbWF0Y2hgKX0pfTtpZihlWzBdLmRpbXMubGVuZ3RoPjEpe2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCI/dC5zcGF0aWFsP2VbMF0uZGltcy5zbGljZSgtMSk6ZVswXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoZVswXS5kaW1zLnNsaWNlKDEsZVswXS5kaW1zLmxlbmd0aC0xKSk6ZVswXS5kaW1zLnNsaWNlKDEsdC5zcGF0aWFsPzI6dm9pZCAwKTtuKGVbMV0uZGltcyxyLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxuKGVbMl0uZGltcyxyLFwiSW52YWxpZCBpbnB1dCBCXCIpLG4oZVszXS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IG1lYW5cIiksbihlWzRdLmRpbXMscixcIkludmFsaWQgaW5wdXQgdmFyXCIpfWVsc2UgbihlWzFdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxuKGVbMl0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IEJcIiksbihlWzNdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLG4oZVs0XS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgdmFyXCIpfSxHZD0oZSx0KT0+e2xldHtlcHNpbG9uOm4sc3BhdGlhbDpyLGZvcm1hdDpvfT10LGk9ZVswXS5kaW1zLHM9cj9YKGlbaS5sZW5ndGgtMV0pOjEsYT1vPT09XCJOSFdDXCImJmkubGVuZ3RoPjE/czoxLHU9eC5zaXplKGkpL3MsZD1yLGw9ZD9pLmxlbmd0aDppLGM9UyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxzKSxwPVMoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLGEpLGY9UyhcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxhKSxtPVMoXCJpbnB1dE1lYW5cIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyxhKSxoPVMoXCJpbnB1dFZhclwiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLGEpLGI9QyhcInlcIixlWzBdLmRhdGFUeXBlLGwscykseT0oKT0+e2xldCBfPVwiXCI7aWYocilfPWBsZXQgY09mZnNldCA9ICR7aS5sZW5ndGg9PT0xP1wiMHVcIjpvPT09XCJOSFdDXCI/YG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV0gLyAke3N9YDpcIm91dHB1dEluZGljZXNbMV1cIn07YDtlbHNlIGlmKG89PT1cIk5DSFdcIilfPWBcbiAgICAgICAgICAgICR7Yi5pbmRpY2VzU2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiMFwiLFwiMFwiKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHtiLmluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIil9O2A7ZWxzZXtfPWB2YXIgY0luZGljZXMgPSAke3AudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7aS5sZW5ndGgtMX1dO2A7Zm9yKGxldCB3PTE7dzxwLnJhbms7dysrKV8rPWBjSW5kaWNlc1ske3d9XSA9IG91dHB1dEluZGljZXNbJHt3fV07YDtfKz1gbGV0IGNPZmZzZXQgPSAke3AuaW5kaWNlc1RvT2Zmc2V0KFwiY0luZGljZXNcIil9O2B9cmV0dXJuIF99LGc9Xz0+YFxuICBjb25zdCBlcHNpbG9uID0gJHtufTtcbiAgJHtfLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGMscCxmLG0saCxiKX1cbiAgJHtfLm1haW5TdGFydCgpfVxuICAke18uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke2Iub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtzfWApfTtcbiAgICAke3koKX1cbiAgICBsZXQgc2NhbGUgPSAke3AuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgYmlhcyA9ICR7Zi5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke20uZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2guZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgeCA9ICR7Yy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHtiLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gO3JldHVybntuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufV8ke3QuZm9ybWF0fV8ke3J9XyR7c31gLGlucHV0RGVwZW5kZW5jaWVzOmQ/W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXTp2b2lkIDB9LGdldFNoYWRlclNvdXJjZTpnLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh1LzY0KX0scHJvZ3JhbVVuaWZvcm1zOmQ/W3t0eXBlOjEyLGRhdGE6dX0sLi4uUChpKV06W3t0eXBlOjEyLGRhdGE6dX1dfSl9fSxIZD1lPT5OKGUpLHRpPShlLHQpPT57bGV0e2lucHV0czpuLG91dHB1dENvdW50OnJ9PWUsbz1IZCh7Li4udCxvdXRwdXRDb3VudDpyfSk7aWYodGUud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZXZChuLG8pLHQudHJhaW5pbmdNb2RlKXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2UuY29tcHV0ZShHZChuLG8pKX19KTt2YXIgcWQsRmQscmksb2k9aygoKT0+e1widXNlIHN0cmljdFwiO3EoKTtLKCk7cWQ9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sRmQ9ZT0+e2xldCB0PWVbMF0uZGltcyxuPWVbMF0uZGltc1syXSxyPXguc2l6ZSh0KS80LG89ZVswXS5kYXRhVHlwZSxpPVMoXCJpbnB1dFwiLG8sdCw0KSxzPVMoXCJiaWFzXCIsbyxbbl0sNCksYT1TKFwicmVzaWR1YWxcIixvLHQsNCksdT1DKFwib3V0cHV0XCIsbyx0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci82NCl9fSksZ2V0U2hhZGVyU291cmNlOmw9PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke259dSAvIDQ7XG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKGkscyxhLHUpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhyKX1cbiAgICBsZXQgdmFsdWUgPSAke2kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke3MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHthLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0scmk9ZT0+e3FkKGUuaW5wdXRzKSxlLmNvbXB1dGUoRmQoZS5pbnB1dHMpKX19KTt2YXIgS2QsSixpaSxzaSxhaSx1aSxkaSxsaSxjaSxwaSxtaSxqZCxmaSxoaSxnaSx5aSxndCxiaSx0bixfaSx3aSwkaSx2aSx4aSxTaSxUaSxJaSxDaSxBaSxFaSxraSxQaSx6aSxCaSxEaSxPaSxNaSxabixRbixVaSxSaSxWaSxaZCxRZCxOaSxubj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtLZD0oZSx0LG4scixvLGkscyk9PntsZXQgYT1NYXRoLmNlaWwodC80KSx1PVwiXCI7dHlwZW9mIG89PVwic3RyaW5nXCI/dT1gJHtvfShhKWA6dT1vKFwiYVwiKTtsZXQgZD1TKFwiaW5wdXREYXRhXCIsbixbYV0sNCksbD1DKFwib3V0cHV0RGF0YVwiLHIsW2FdLDQpLGM9W3tuYW1lOlwidmVjX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm4gcyYmYy5wdXNoKC4uLnMpLGBcbiAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGMpLmRlY2xhcmVWYXJpYWJsZXMoZCxsKX1cblxuICAke2k/P1wiXCJ9XG5cbiAgJHtlLm1haW5TdGFydCgpfVxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG5cbiAgICBsZXQgYSA9ICR7ZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix1KX1cbiAgfWB9LEo9KGUsdCxuLHIsbyxpPWUuZGF0YVR5cGUscyxhKT0+e2xldCB1PVt7dHlwZToxMixkYXRhOk1hdGguY2VpbCh4LnNpemUoZS5kaW1zKS80KX1dO3JldHVybiBzJiZ1LnB1c2goLi4ucykse25hbWU6dCxzaGFkZXJDYWNoZTp7aGludDpvLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTpkPT5LZChkLHguc2l6ZShlLmRpbXMpLGUuZGF0YVR5cGUsaSxuLHIsYSksZ2V0UnVuRGF0YTpkPT4oe291dHB1dHM6W3tkaW1zOmUuZGltcyxkYXRhVHlwZTppfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeC5zaXplKGRbMF0uZGltcykvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczp1fSl9fSxpaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LHNpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSxhaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSx1aT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sZGk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sbGk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LGNpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LHBpPWU9Pk4oZSksbWk9KGUsdCk9PntsZXQgbjtzd2l0Y2godC50byl7Y2FzZSAxMDpuPVwidmVjNDxmMTY+XCI7YnJlYWs7Y2FzZSAxOm49XCJ2ZWM0PGYzMj5cIjticmVhaztjYXNlIDEyOm49XCJ2ZWM0PHUzMj5cIjticmVhaztjYXNlIDY6bj1cInZlYzQ8aTMyPlwiO2JyZWFrO2Nhc2UgOTpuPVwidmVjNDxib29sPlwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHt0LnRvfWApfWUuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQ2FzdFwiLG4sdm9pZCAwLHQuY2FjaGVLZXksdC50bykpfSxqZD1lPT57bGV0IHQsbixyPWUubGVuZ3RoPj0yJiZlWzFdLmRhdGEhPT0wLG89ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YSE9PTA7c3dpdGNoKGVbMF0uZGF0YVR5cGUpe2Nhc2UgMTp0PXI/ZVsxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTotMzQwMjgyMzQ2NjM4NTI4ODZlMjIsbj1vP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MzQwMjgyMzQ2NjM4NTI4ODZlMjI7YnJlYWs7Y2FzZSAxMDp0PXI/ZVsxXS5nZXRVaW50MTZBcnJheSgpWzBdOjY0NTExLG49bz9lWzJdLmdldFVpbnQxNkFycmF5KClbMF06MzE3NDM7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnQgZGF0YSB0eXBlXCIpfXJldHVybiBOKHttaW46dCxtYXg6bn0pfSxmaT0oZSx0KT0+e2xldCBuPXR8fGpkKGUuaW5wdXRzKSxyPWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkNsaXBcIixvPT5gY2xhbXAoJHtvfSwgdmVjNDwke3J9Pih1bmlmb3Jtcy5taW4pLCB2ZWM0PCR7cn0+KHVuaWZvcm1zLm1heCkpYCx2b2lkIDAsbi5jYWNoZUtleSx2b2lkIDAsW3t0eXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGRhdGE6bi5taW59LHt0eXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGRhdGE6bi5tYXh9XSxbe25hbWU6XCJtaW5cIix0eXBlOnJ9LHtuYW1lOlwibWF4XCIsdHlwZTpyfV0pLHtpbnB1dHM6WzBdfSl9LGhpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkNlaWxcIixcImNlaWxcIikpfSxnaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LHlpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkNvc2hcIixcImNvc2hcIikpfSxndD1lPT5OKGUpLGJpPShlLHQpPT57bGV0IG49Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiRWx1XCIscj0+YGVsdV92ZjMyKCR7cn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke259KCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtufSkgLT4gJHtufSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7bn0+KSAtPiB2ZWM0PCR7bn0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSx0bj0oZT1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7ZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHtlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7ZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHtlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7ZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHtlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsX2k9ZT0+e2xldCB0PWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkVyZlwiLG49PmBlcmZfdmYzMigke259KWAsdG4odCkpKX0sd2k9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiRXhwXCIsXCJleHBcIikpfSwkaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSx2aT1lPT57bGV0IHQ9Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiR2VsdVwiLG49PmAwLjUgKiAke259ICogKDEuMCArIGVyZl92ZjMyKCR7bn0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsdG4odCkpKX0seGk9KGUsdCk9PntsZXQgbj1jZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJMZWFreVJlbHVcIixyPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtyfSwgJHtyfSwgJHtyfSA+PSB2ZWM0PCR7bn0+KDAuMCkpYCxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV8gPSAke259KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSxTaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LFRpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIk5lZ1wiLHQ9PmAtJHt0fWApKX0sSWk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiUmVjaXByb2NhbFwiLHQ9PmAxLjAvJHt0fWApKX0sQ2k9ZT0+e2xldCB0PWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlJlbHVcIixuPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtufSwgJHtufSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LEFpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlNpZ21vaWRcIix0PT5gKDEuMCAvICgxLjAgKyBleHAoLSR7dH0pKSlgKSl9LEVpPWU9Pk4oZSksa2k9KGUsdCk9PntsZXQgbj1jZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLHI9PmBtYXgodmVjNDwke259PigwLjApLCBtaW4odmVjNDwke259PigxLjApLCAke3QuYWxwaGF9ICogJHtyfSArIHZlYzQ8JHtufT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSxQaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJTaW5cIixcInNpblwiKSl9LHppPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSxCaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0sRGk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiVGFuXCIsXCJ0YW5cIikpfSxPaT1lPT5gc2lnbigke2V9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7ZX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2V9KSkpYCxNaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJUYW5oXCIsT2kpKX0sWm49KGU9XCJmMzJcIik9PmBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke2V9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7ZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHtlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIHJldHVybiAke09pKFwidlwiKX07XG59XG5gLFFuPWU9PmAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke2V9ICogKGZhc3RfZ2VsdV9jICogJHtlfSAqICR7ZX0gKyBmYXN0X2dlbHVfYikpKSAqICR7ZX1gLFVpPWU9PntsZXQgdD1jZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJGYXN0R2VsdVwiLFFuLFpuKHQpLHZvaWQgMCxlLmlucHV0c1swXS5kYXRhVHlwZSkpfSxSaT0oZSx0KT0+e2xldCBuPWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJUaHJlc2hvbGRlZFJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHtufT4oMC4wKSwgJHtyfSwgJHtyfSA+IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfKWAsYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke259Pigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKSwwfSxWaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJMb2dcIixcImxvZ1wiKSl9LFpkPShlLHQpPT5gXG5jb25zdCBhbHBoYSA9IHZlYzQ8JHtlfT4oJHt0fSk7XG5jb25zdCBvbmUgPSAke2V9KDEuMCk7XG5jb25zdCB6ZXJvID0gJHtlfSgwLjApO1xuXG5mbiBxdWlja19nZWx1X2ltcGwoeDogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIGxldCB2ID0geCAqYWxwaGE7XG4gIHZhciB4MSA6IHZlYzQ8JHtlfT47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSA9IGkgKyAxKSB7XG4gICAgaWYgKHZbaV0gPj0gemVybykge1xuICAgICAgeDFbaV0gPSBvbmUgLyAob25lICsgZXhwKC12W2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxW2ldID0gb25lIC0gb25lIC8gKG9uZSArIGV4cCh2W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4ICogeDE7XG59XG5gLFFkPWU9PmBxdWlja19nZWx1X2ltcGwoJHtlfSlgLE5pPShlLHQpPT57bGV0IG49Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiUXVpY2tHZWx1XCIsUWQsWmQobix0LmFscGhhKSx0LmNhY2hlS2V5LGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9fSk7dmFyIFhkLFlkLFdpLEdpPWsoKCk9PntcInVzZSBzdHJpY3RcIjtxKCk7SygpO25uKCk7WGQ9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzI1NjAsNTEyMCwxMDI0MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sWWQ9ZT0+e2xldCB0PWVbMF0uZGltcy5zbGljZSgpO3RbMl09dFsyXS8yO2xldCBuPVMoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLDQpLHI9UyhcImJpYXNcIixlWzBdLmRhdGFUeXBlLFtlWzBdLmRpbXNbMl1dLDQpLG89QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdCw0KSxpPXguc2l6ZSh0KS80LHM9cmUoZVswXS5kYXRhVHlwZSk7cmV0dXJue25hbWU6XCJCaWFzU3BsaXRHZWx1XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6dT0+YFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2VbMF0uZGltc1syXS80LzJ9dTtcblxuICAke3UuZGVjbGFyZVZhcmlhYmxlcyhuLHIsbyl9XG5cbiAgJHt0bihzKX1cblxuICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoaSl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVMZWZ0ICogZ2VsdVJpZ2h0XCIpfVxuICB9YH19LFdpPWU9PntYZChlLmlucHV0cyksZS5jb21wdXRlKFlkKGUuaW5wdXRzKSl9fSk7dmFyIEpkLGVsLE1lLEhpLHFpLEZpLEtpLGppLFppLFFpLFhpLFlpLEppLGVzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtKZD0oZSx0LG4scixvLGkscyxhLHUsZCxsLGMpPT57bGV0IHAsZjt0eXBlb2YgYT09XCJzdHJpbmdcIj9wPWY9KGcsXyk9PmAke2F9KCgke2d9KSwoJHtffSkpYDp0eXBlb2YgYT09XCJmdW5jdGlvblwiP3A9Zj1hOihwPWEuc2NhbGFyLGY9YS52ZWN0b3IpO2xldCBtPUMoXCJvdXRwdXREYXRhXCIsbCxyLmxlbmd0aCw0KSxoPVMoXCJhRGF0YVwiLHUsdC5sZW5ndGgsNCksYj1TKFwiYkRhdGFcIixkLG4ubGVuZ3RoLDQpLHk7aWYobylpZihpKXtsZXQgZz14LnNpemUodCk9PT0xLF89eC5zaXplKG4pPT09MSx3PXQubGVuZ3RoPjAmJnRbdC5sZW5ndGgtMV0lND09PTAsdj1uLmxlbmd0aD4wJiZuW24ubGVuZ3RoLTFdJTQ9PT0wO2d8fF8/eT1tLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGYoZz9gJHtoLnR5cGUudmFsdWV9KCR7aC5nZXRCeU9mZnNldChcIjBcIil9LngpYDpoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxfP2Ake2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOmIuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk6eT1gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4ICogNHVcIil9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEgPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsbSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsbSl9O1xuICAgICAgICAgICAgJHttLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGYoc3x8dz9oLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QSAvIDR1XCIpOmAke2gudHlwZS52YWx1ZX0oJHtoLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QSAvIDR1XCIpfVtvZmZzZXRBICUgNHVdKWAsc3x8dj9iLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QiAvIDR1XCIpOmAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QiAvIDR1XCIpfVtvZmZzZXRCICUgNHVdKWApKX1cbiAgICAgICAgICBgfWVsc2UgeT1tLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGYoaC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksYi5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2lmKCFpKXRocm93IG5ldyBFcnJvcihcIm5vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLlwiKTtsZXQgZz0oXyx3LHY9XCJcIik9PntsZXQgJD1gYURhdGFbaW5kZXhBJHt3fV1bY29tcG9uZW50QSR7d31dYCxUPWBiRGF0YVtpbmRleEIke3d9XVtjb21wb25lbnRCJHt3fV1gO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt3fSA9ICR7bS5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7d311YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke3d9ID0gJHtoLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt3fWAsbSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke3d9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt3fWAsbSl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7d30gPSBvZmZzZXRBJHt3fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7d30gPSBvZmZzZXRCJHt3fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3d9ID0gb2Zmc2V0QSR7d30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt3fSA9IG9mZnNldEIke3d9ICUgNHU7XG4gICAgICAgICAgICAke199WyR7d31dID0gJHt2fSgke3AoJCxUKX0pO1xuICAgICAgICAgIGB9O2w9PT05P3k9YFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke2coXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgICAgICR7ZyhcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtnKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2coXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDp5PWBcbiAgICAgICAgICAgICR7ZyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7ZyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cbiAgICAgICAgICAgICR7ZyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7ZyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhoLGIsbSl9XG5cbiAgICAgICAgJHtjPz9cIlwifVxuXG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHt5fVxuICAgICAgfWB9LGVsPShlLHQsbixyLG8saSxzPW4uZGF0YVR5cGUpPT57bGV0IGE9bi5kaW1zLm1hcChoPT5OdW1iZXIoaCk/PzEpLHU9ci5kaW1zLm1hcChoPT5OdW1iZXIoaCk/PzEpLGQ9IXguYXJlRXF1YWwoYSx1KSxsPWEsYz14LnNpemUoYSkscD0hMSxmPSExLG09W2RdO2lmKGQpe2xldCBoPVBlLmNhbGNTaGFwZShhLHUsITEpO2lmKCFoKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2w9aC5zbGljZSgpLGM9eC5zaXplKGwpO2xldCBiPXguc2l6ZShhKT09PTEseT14LnNpemUodSk9PT0xLGc9YS5sZW5ndGg+MCYmYVthLmxlbmd0aC0xXSU0PT09MCxfPXUubGVuZ3RoPjAmJnVbdS5sZW5ndGgtMV0lND09PTA7bS5wdXNoKGIpLG0ucHVzaCh5KSxtLnB1c2goZyksbS5wdXNoKF8pO2xldCB3PTE7Zm9yKGxldCB2PTE7djxsLmxlbmd0aDt2Kyspe2xldCAkPWFbYS5sZW5ndGgtdl0sVD11W3UubGVuZ3RoLXZdO2lmKCQ9PT1UKXcqPSQ7ZWxzZSBicmVha313JTQ9PT0wPyhmPSEwLHA9ITApOihifHx5fHxnfHxfKSYmKHA9ITApfWVsc2UgcD0hMDtyZXR1cm4gbS5wdXNoKHApLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6dCttLm1hcChoPT5oLnRvU3RyaW5nKCkpLmpvaW4oXCJfXCIpLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpoPT5KZChoLGEsdSxsLHAsZCxmLG8sbi5kYXRhVHlwZSxyLmRhdGFUeXBlLHMsaSksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChjLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKHguc2l6ZShsKS80KX0sLi4uUChhLHUsbCldfSl9fSxNZT0oZSx0LG4scixvLGkpPT57ZS5jb21wdXRlKGVsKHQsbz8/XCJcIixlLmlucHV0c1swXSxlLmlucHV0c1sxXSxuLHIsaSkpfSxIaT1lPT57TWUoZSxcIkFkZFwiLCh0LG4pPT5gJHt0fSske259YCl9LHFpPWU9PntNZShlLFwiRGl2XCIsKHQsbik9PmAke3R9LyR7bn1gKX0sRmk9ZT0+e01lKGUsXCJFcXVhbFwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fT09JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PT0ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LEtpPWU9PntNZShlLFwiTXVsXCIsKHQsbik9PmAke3R9KiR7bn1gKX0samk9ZT0+e2xldCB0PVMoXCJpbnB1dFwiLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGUuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7TWUoZSxcIlBvd1wiLHtzY2FsYXI6KHIsbyk9PmBwb3dfY3VzdG9tKCR7cn0sJHtvfSlgLHZlY3RvcjoocixvKT0+YHBvd192ZWN0b3JfY3VzdG9tKCR7cn0sJHtvfSlgfSxgXG4gICAgZm4gcG93X2N1c3RvbShhIDogJHt0fSwgYiA6ICR7dH0pIC0+ICR7dH0ge1xuICAgICAgaWYgKGIgPT0gJHt0fSgwLjApKSB7XG4gICAgICAgIHJldHVybiAke3R9KDEuMCk7XG4gICAgICB9IGVsc2UgaWYgKGEgPCAke3R9KDAuMCkgJiYgZjMyKGIpICE9IGZsb29yKGYzMihiKSkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0ocG93KGYzMihhKSwgZjMyKGIpKSk7IC8vIE5hTlxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdChzaWduKGEpLCAke3R9KDEuMCksIHJvdW5kKGYzMihhYnMoYikgJSAke3R9KDIuMCkpKSAhPSAxLjApICogJHt0fSgke3Q9PT1cImkzMlwiP1wicm91bmRcIjpcIlwifShwb3coZjMyKGFicyhhKSksIGYzMihiKSkpKTtcbiAgICB9XG4gICAgZm4gcG93X3ZlY3Rvcl9jdXN0b20oYSA6IHZlYzQ8JHt0fT4sIGIgOiB2ZWM0PCR7dH0+KSAtPiB2ZWM0PCR7dH0+IHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCB2ZWN0b3JpemVkIHBvd1xuICAgICAgcmV0dXJuIHZlYzQ8JHt0fT4ocG93X2N1c3RvbShhLngsIGIueCksIHBvd19jdXN0b20oYS55LCBiLnkpLCBwb3dfY3VzdG9tKGEueiwgYi56KSwgcG93X2N1c3RvbShhLncsIGIudykpO1xuICAgIH1cbiAgICAgIGApfSxaaT1lPT57TWUoZSxcIlN1YlwiLCh0LG4pPT5gJHt0fS0ke259YCl9LFFpPWU9PntNZShlLFwiR3JlYXRlclwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fT4ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH0+JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxYaT1lPT57TWUoZSxcIkxlc3NcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH08JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PCR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sWWk9ZT0+e01lKGUsXCJHcmVhdGVyT3JFcXVhbFwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fT49JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9Pj0ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LEppPWU9PntNZShlLFwiTGVzc09yRXF1YWxcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH08PSR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fTw9JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfX0pO3ZhciBubCxybCxvbCxpbCx0cyxucyxycz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtubD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2xldCBuPTAscj1lW25dLG89ci5kYXRhVHlwZSxpPXIuZGltcy5sZW5ndGg7ZS5mb3JFYWNoKChzLGEpPT57aWYoYSE9PW4pe2lmKHMuZGF0YVR5cGUhPT1vKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKHMuZGltcy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7cy5kaW1zLmZvckVhY2goKHUsZCk9PntpZihkIT09dCYmdSE9PXIuZGltc1tkXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX0pfX0pfSxybD0oZSx0KT0+YFxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7ZX11Pigke3R9KTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX07IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG4gIH1gLG9sPShlLHQpPT57bGV0IG49ZS5sZW5ndGgscj1bXTtmb3IobGV0IG89MDtvPG47KytvKXtsZXQgaT10LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGVbb10uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKSk7bj09PTE/ci5wdXNoKGkpOm89PT0wP3IucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtvfXUpIHsgJHtpfSB9YCk6bz09PW4tMT9yLnB1c2goYGVsc2UgeyAke2l9IH1gKTpyLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtvfSkgeyAke2l9IH1gKX1yZXR1cm4gci5qb2luKGBcbmApfSxpbD0oZSx0LG4scik9PntsZXQgbz14LnNpemUobiksaT1uZXcgQXJyYXkoZS5sZW5ndGgpLHM9bmV3IEFycmF5KGUubGVuZ3RoKSxhPTAsdT1bXSxkPVtdLGw9W3t0eXBlOjEyLGRhdGE6b31dO2ZvcihsZXQgaD0wO2g8ZS5sZW5ndGg7KytoKWErPWVbaF0uZGltc1t0XSxpW2hdPWEsZC5wdXNoKGVbaF0uZGltcy5sZW5ndGgpLHNbaF09UyhgaW5wdXQke2h9YCxyLGRbaF0pLHUucHVzaChcInJhbmtcIiksbC5wdXNoKHt0eXBlOjEyLGRhdGE6aVtoXX0pO2ZvcihsZXQgaD0wO2g8ZS5sZW5ndGg7KytoKWwucHVzaCguLi5QKGVbaF0uZGltcykpO2wucHVzaCguLi5QKG4pKTtsZXQgYz1DKFwib3V0cHV0XCIscixuLmxlbmd0aCkscD1jLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsdCksZj1BcnJheS5mcm9tKEFycmF5KGkubGVuZ3RoKS5rZXlzKCkpLm1hcChoPT5gdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7aH1gKS5qb2luKFwiLFwiKSxtPWg9PmBcblxuICAkeygoKT0+e2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpO2ZvcihsZXQgYj0wO2I8ZS5sZW5ndGg7YisrKWgucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtifWAsXCJ1MzJcIik7cmV0dXJuIGguZGVjbGFyZVZhcmlhYmxlcyguLi5zLGMpfSkoKX1cblxuICAke3JsKGkubGVuZ3RoLGYpfVxuXG4gICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7Yy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke3B9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7aS5sZW5ndGh9dT4oJHtmfSk7XG4gICAgICAke3B9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcbiAgICB9XG5cbiAgICAke29sKHMsYyl9XG4gIH1gO3JldHVybntuYW1lOlwiQ29uY2F0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOnV9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTpyfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3JtczpsfSksZ2V0U2hhZGVyU291cmNlOm19fSx0cz0oZSx0KT0+e2xldCBuPWUuaW5wdXRzLHI9blswXS5kaW1zLG89eC5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCk7bmwobixvKTtsZXQgaT1yLnNsaWNlKCk7aVtvXT1uLnJlZHVjZSgoYSx1KT0+YSsodS5kaW1zLmxlbmd0aD5vP3UuZGltc1tvXTowKSwwKTtsZXQgcz1uLmZpbHRlcihhPT54LnNpemUoYS5kaW1zKT4wKTtlLmNvbXB1dGUoaWwocyxvLGksblswXS5kYXRhVHlwZSkse2lucHV0czpzfSl9LG5zPWU9Pk4oe2F4aXM6ZS5heGlzfSl9KTt2YXIgSWUsQ2UsQWUscm4sRmU9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SWU9KGUsdCxuPVwiZjMyXCIpPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybmB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt0fSgwLjApKTtgO2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm5gdmFsdWUgPSAoJHt0fSgxLjApIC8gKCR7dH0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtjYXNlXCJDbGlwXCI6cmV0dXJuYHZhbHVlID0gY2xhbXAodmFsdWUsICR7dH0oJHtufSh1bmlmb3Jtcy5jbGlwX21pbikpLCAke3R9KCR7bn0odW5pZm9ybXMuY2xpcF9tYXgpKSk7YDtjYXNlXCJIYXJkU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9IG1heCgke3R9KDAuMCksIG1pbigke3R9KDEuMCksICR7bn0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke259KHVuaWZvcm1zLmJldGEpKSk7YDtjYXNlXCJMZWFreVJlbHVcIjpyZXR1cm5gdmFsdWUgPSBzZWxlY3QoJHtufSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dH0oMC4wKSk7YDtjYXNlXCJUYW5oXCI6cmV0dXJuYGxldCBlMnggPSBleHAoLTIuMCAqIGFicyh2YWx1ZSkpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHNpZ24odmFsdWUpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcbiAgICAgICAgYDtjYXNlXCJcIjpyZXR1cm5cIlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY3RpdmF0aW9uICR7ZS5hY3RpdmF0aW9ufWApfX0sQ2U9KGUsdCk9PntlLmFjdGl2YXRpb249PT1cIkNsaXBcIj90LnB1c2goe3R5cGU6MSxkYXRhOmUuY2xpcE1heH0se3R5cGU6MSxkYXRhOmUuY2xpcE1pbn0pOmUuYWN0aXZhdGlvbj09PVwiSGFyZFNpZ21vaWRcIj90LnB1c2goe3R5cGU6MSxkYXRhOmUuYWxwaGF9LHt0eXBlOjEsZGF0YTplLmJldGF9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe3R5cGU6MSxkYXRhOmUuYWxwaGF9KX0sQWU9KGUsdCk9PntlLmFjdGl2YXRpb249PT1cIkNsaXBcIj90LnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pOmUuYWN0aXZhdGlvbj09PVwiSGFyZFNpZ21vaWRcIj90LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJMZWFreVJlbHVcIiYmdC5wdXNoKHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9KX0scm49ZT0+e2xldCB0PWU/LmFjdGl2YXRpb258fFwiXCI7aWYodD09PVwiSGFyZFNpZ21vaWRcIil7bGV0W24scl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMiwuNV07cmV0dXJue2FjdGl2YXRpb246dCxhbHBoYTpuLGJldGE6cn19ZWxzZSBpZih0PT09XCJDbGlwXCIpe2xldFtuLHJdPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbbG8sY29dO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDpyLGNsaXBNaW46bn19ZWxzZSBpZih0PT09XCJMZWFreVJlbHVcIil7bGV0W25dPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbLjAxXTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOm59fXJldHVybnthY3RpdmF0aW9uOnR9fX0pO3ZhciBkZSxvcyxvbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZGU9KGUsdCk9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm5gdmVjMjwke3R9PmA7Y2FzZSAzOnJldHVybmB2ZWMzPCR7dH0+YDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt0fT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sb3M9ZT0+YFxuICAgICAgJHtlP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpO1wiOlwiXCJ9XG4gICAgICBgfSk7dmFyIGlzLHNzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtpcz1lPT5gXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xufVxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICBpMzIoJHtlfS54KSwgaTMyKCR7ZX0ueSksIGkzMigke2V9LnopLCAxKSk7XG59XG5gfSk7dmFyIHl0LHNuLGFuPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtGZSgpO3l0PShlLHQsbixyLG8pPT57bGV0IGk9ci1uO3JldHVybmBcbiAgICAgICR7QXJyYXkuZnJvbSh7bGVuZ3RoOm59KS5tYXAoKHMsYSk9PmBcbiAgICAgIGlmICgke08odC5zaGFwZSxhLHQucmFuayl9ICE9IDEpIHtcbiAgICAgICAgJHt0LmluZGljZXNTZXQoZSxhLE8obyxhK2kscikpfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHt0LmluZGljZXNTZXQoZSxhLDApfVxuICAgICAgfWApLmpvaW4oXCJcIil9XG5gfSxzbj0oZSx0LG4scixvPSExLGkpPT57bGV0IHM9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHU9c1tzLmxlbmd0aC0yXSxkPWFbYS5sZW5ndGgtMV0sbD1zW3MubGVuZ3RoLTFdLGM9WChkKSxwPVgobCksZj1YKHUpLG09eC5zaXplKG4pL2MvZixoPWUubGVuZ3RoPjIsYj1yP3Iuc2xpY2UoMCwtMik6bi5zbGljZSgwLC0yKSxnPVt4LnNpemUoYiksdSxkXSxfPVt7dHlwZToxMixkYXRhOm19LHt0eXBlOjEyLGRhdGE6dX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9XTtDZSh0LF8pLF8ucHVzaCguLi5QKGIscyxhKSksaCYmXy5wdXNoKC4uLlAoZVsyXS5kaW1zKSksXy5wdXNoKC4uLlAoZykpO2xldCB3PXY9PntsZXQgJD1YdChcImJhdGNoX2RpbXNcIixlWzBdLmRhdGFUeXBlLGIubGVuZ3RoKSxUPVMoXCJhXCIsZVswXS5kYXRhVHlwZSxzLmxlbmd0aCxwKSxJPVMoXCJiXCIsZVsxXS5kYXRhVHlwZSxhLmxlbmd0aCxjKSxBPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGcubGVuZ3RoLGMpLHo9cmUoQS50eXBlLnRlbnNvciksTT1JZSh0LEEudHlwZS52YWx1ZSx6KSxVPVtULEldLEc9XCJcIjtpZihoKXtsZXQgVz1vP2M6MTtVLnB1c2goUyhcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsVykpLEc9YCR7bz9gdmFsdWUgKz0gYmlhc1tjb2wgLyAke1d9XTtgOmB2YWx1ZSArPSAke0EudHlwZS52YWx1ZX0oYmlhc1tyb3cgKyBpXSk7YH1gfWxldCBCPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifV07QWUodCxCKTtsZXQgZWU9KCk9PntsZXQgVz1gdmFyIGFfZGF0YTogJHtULnR5cGUudmFsdWV9O2A7Zm9yKGxldCBEPTA7RDxwO0QrKylXKz1gXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke0R9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7RH0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2N9XTtgO2ZvcihsZXQgRD0wO0Q8ZjtEKyspe1crPWBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke0R9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7cH1dO2A7Zm9yKGxldCBaPTA7WjxwO1orKylXKz1gXG4gICAgICAgICAgICB2YWx1ZXNbJHtEfV0gPSBmbWEoJHtJLnR5cGUudmFsdWV9KGFfZGF0YSR7cD09PTE/XCJcIjpgWyR7Wn1dYH0pLCBiX2RhdGEke1p9LCB2YWx1ZXNbJHtEfV0pO1xuYH1yZXR1cm4gV307cmV0dXJuYFxuICAke3YucmVnaXN0ZXJVbmlmb3JtcyhCKS5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKCQpLmRlY2xhcmVWYXJpYWJsZXMoLi4uVSxBKX1cbiAgJHt2Lm1haW5TdGFydCgpfVxuICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGNvbCA9IChnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLk4gLyAke2N9KSkgKiAke2N9O1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLk4gLyAke2N9KTtcbiAgICBsZXQgc3RyaWRlMSA9IHVuaWZvcm1zLk0gLyAke2Z9O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke2Z9O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke24ubGVuZ3RoPT09Mj9cIlwiOmBsZXQgYmF0Y2hfaW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJiYXRjaFwiKX07YH1cblxuICAgIHZhciBhX2luZGljZXM6ICR7VC50eXBlLmluZGljZXN9O1xuICAgICR7eXQoXCJhX2luZGljZXNcIixULFQucmFuay0yLCQucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtULmluZGljZXNTZXQoXCJhX2luZGljZXNcIixULnJhbmstMiwwKX1cbiAgICAke1QuaW5kaWNlc1NldChcImFfaW5kaWNlc1wiLFQucmFuay0xLDApfVxuICAgIGxldCBhX29mZnNldCA9ICR7VC5pbmRpY2VzVG9PZmZzZXQoXCJhX2luZGljZXNcIil9O1xuXG4gICAgdmFyIGJfaW5kaWNlczogJHtJLnR5cGUuaW5kaWNlc307XG4gICAgJHt5dChcImJfaW5kaWNlc1wiLEksSS5yYW5rLTIsJC5yYW5rLFwiYmF0Y2hfaW5kaWNlc1wiKX1cbiAgICAke0kuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEkucmFuay0yLDApfVxuICAgICR7SS5pbmRpY2VzU2V0KFwiYl9pbmRpY2VzXCIsSS5yYW5rLTEsMCl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtJLmluZGljZXNUb09mZnNldChcImJfaW5kaWNlc1wiKX07XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtBLnR5cGUudmFsdWV9LCAke2Z9PjtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsgPSBrICsgJHtwfSkge1xuICAgICAgJHtlZSgpfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke2Z9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke0d9XG4gICAgICAke019XG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke0EudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke0EuaW5kaWNlc1RvT2Zmc2V0KFwiY3VyX2luZGljZXNcIil9O1xuICAgICAgJHtBLnNldEJ5T2Zmc2V0KGBvZmZzZXQgLyAke2N9YCxcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1cbiAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxOYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYWN0aXZhdGlvbn07JHtjfTske3B9OyR7Zn07JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6aD9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aT9pKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp3fX19KTt2YXIgc2wsYWwsWG4sYXMsdWwsWW4sZGwsYnQsdW49aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO0ZlKCk7YW4oKTtvbigpO3NsPShlLHQpPT5lP2BcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYDpgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgLGFsPShlLHQpPT5lP2BcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke3Q9PT0zP1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cbiAgICAgICAgfWA6YFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cbiAgICAgICAgfWAsWG49KGUsdCxuPVwiZjMyXCIscixvPSExLGk9MzIscz0hMSxhPTMyKT0+e2xldCB1PXRbMV0qZVsxXSxkPXRbMF0qZVswXSxsPW8/dTppLGM9bz9pOnUscD1sL3RbMF0sZj1pL3RbMV07aWYoISgobyYmcD09PTQmJmVbMV09PT00fHwhbyYmKHA9PT0zfHxwPT09NCkpJiZsJXRbMF09PT0wJiZpJXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7b30gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke3B9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7cH0gbXVzdCBiZSAzIG9yIDQuXG4gIHRpbGVBV2lkdGggJHtsfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfS4gdGlsZUlubmVyICR7aX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3RbMV19LiBjb2xQZXJUaHJlYWQgJHtlWzBdfSBtdXN0IGJlIDQuYCk7cmV0dXJuYFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHtwfTwke259PiwgJHtsL3B9PiwgJHtjfT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7bn0+LCAke2QvZVswXX0+LCAke2l9PjtcblxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtwfTtcbmNvbnN0IHRpbGVJbm5lciA9ICR7aX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3M/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICR7cj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7ci5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dX07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7cz9gJHtNYXRoLmNlaWwoYS9pKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgdmFyIGtTdGFydCA9ICR7cz9gaTMyKGdsb2JhbElkLnopICogJHthfWA6XCIwXCJ9O1xuXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHtufT4sIHJvd1BlclRocmVhZD47XG5cbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtmfTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICAke3NsKG8scil9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2Z9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7cj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke3A9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XG5cbiAgICAgICAgICAke2FsKG8scCl9XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XG4gIH1cbn1gfSxhcz0oZSx0KT0+ZT9gXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGA6YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgLHVsPWU9PmU/XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTtcIjpcImxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdO1wiLFluPShlLHQsbj1cImYzMlwiLHIsbz0hMSxpPTMyLHM9ITEsYT0zMix1PSExKT0+e2xldCBkPWVbMV0qdFsxXSxsPWVbMF0qdFswXSxjPW8/ZDppLHA9bz9pOmQ7aWYoIShwJXRbMV09PT0wJiZjJXRbMF09PT0wJiZpJXRbMV09PT0wKSl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHtwfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke2N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHtpfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2xldCBmPXAvdFsxXSxtPWMvdFswXSxoPWkvdFsxXSxiPXU/YFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7ZH07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHtsfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtwfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2N9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgICR7YXMobyxyKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2l9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2x9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtyP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7bn0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtvP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA6YFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5cbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtkfTtcblxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke2Z9O1xubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke219O1xubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke2h9O1xuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7Zn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7bX07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7YXMobyxyKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2h9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7cj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke259LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke3VsKG8pfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7bn0sICR7Y30+LCAke3B9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7bn0sICR7bH0+LCAke2l9PjtcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbiAgY29uc3QgdGlsZUlubmVyID0gJHtpfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7cz9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgICAke3I/YGxldCBiYXRjaEluZGljZXMgPSAke3Iub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICAgIGxldCBudW1fdGlsZXMgPSAke3M/YCR7TWF0aC5jZWlsKGEvaSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gICAgdmFyIGtTdGFydCA9ICR7cz9gaTMyKGdsb2JhbElkLnopICogJHthfWA6XCIwXCJ9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7bn0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG4gICAgJHtifVxuICB9XG5gfSxkbD0oZSx0LG4scixvPSExKT0+e2xldFtpLHMsYSx1XT1yLGQ9cmUoclswXS50eXBlLnRlbnNvcik7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7aS50eXBlLmluZGljZXN9KSAtPiAke2RlKGUsZCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7ZGUoZSxkKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBhSW5kaWNlczogJHtzLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7eXQoXCJhSW5kaWNlc1wiLHMscy5yYW5rLTIsaS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke3MuaW5kaWNlc1NldChcImFJbmRpY2VzXCIscy5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHtzLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLHMucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke3MuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7aS50eXBlLmluZGljZXN9KSAtPiAke2RlKGUsZCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7ZGUoZSxkKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBiSW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7eXQoXCJiSW5kaWNlc1wiLGEsYS5yYW5rLTIsaS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke2EuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsYS5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHthLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGEucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke2EuZ2V0QnlJbmRpY2VzKFwiYkluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke2RlKGUsZCl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke3Q/YHZhbHVlID0gdmFsdWUgKyAke28/XCJiaWFzW2NvbEluXVwiOmAke2RlKGUsZCl9KGJpYXNbcm93XSlgfTtgOlwiXCJ9XG4gICAgICAgICR7bn1cbiAgICAgICAgJHt1LnNldEJ5SW5kaWNlcyhcInZlYzM8dTMyPihjb29yZHMpXCIsXCJ2YWx1ZVwiKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYH0sYnQ9KGUsdCxuLHIsbz0hMSxpKT0+e2xldCBzPWVbMF0uZGltcyxhPWVbMV0uZGltcyx1PXMuc2xpY2UoMCwtMiksZD1hLnNsaWNlKDAsLTIpLGw9cj9yLnNsaWNlKDAsLTIpOm4uc2xpY2UoMCwtMiksYz14LnNpemUobCkscD1zW3MubGVuZ3RoLTJdLGY9c1tzLmxlbmd0aC0xXSxtPWFbYS5sZW5ndGgtMV0saD1mJTQ9PT0wJiZtJTQ9PT0wLGI9cDw9OD9bNCwxLDFdOls0LDQsMV0seT1bOCw4LDFdLGc9W01hdGguY2VpbChtL3lbMF0vYlswXSksTWF0aC5jZWlsKHAveVsxXS9iWzFdKSxNYXRoLmNlaWwoYy95WzJdL2JbMl0pXSxfPWg/NDoxLHc9Wy4uLnUscCxmL19dLHY9dy5sZW5ndGgsJD1bLi4uZCxmLG0vX10sVD0kLmxlbmd0aCxJPVtjLHAsbS9fXSxBPVt7dHlwZTo2LGRhdGE6cH0se3R5cGU6NixkYXRhOm19LHt0eXBlOjYsZGF0YTpmfV07Q2UodCxBKSxBLnB1c2goLi4uUChsLHcsJCkpO2xldCB6PVtcInJhbmtcIixcInJhbmtcIl0sTT1lLmxlbmd0aD4yO00mJihBLnB1c2goLi4uUChlWzJdLmRpbXMpKSx6LnB1c2goXCJyYW5rXCIpKSxBLnB1c2goLi4uUChJKSk7bGV0IFU9Rz0+e2xldCBCPWwubGVuZ3RoLGVlPVh0KFwiYmF0Y2hEaW1zXCIsZVswXS5kYXRhVHlwZSxCLDEpLFc9cmUoZVswXS5kYXRhVHlwZSksRD1TKFwiYVwiLGVbMF0uZGF0YVR5cGUsdixfKSxaPVMoXCJiXCIsZVsxXS5kYXRhVHlwZSxULF8pLFI9QyhcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsSS5sZW5ndGgsXyksUT1bRCxaXTtpZihNKXtsZXQgTD1vP186MTtRLnB1c2goUyhcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsTCkpfWxldCB3ZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTtBZSh0LHdlKTtsZXQgc2U9cmUoUi50eXBlLnRlbnNvciksSD1JZSh0LFIudHlwZS52YWx1ZSxzZSksRT1kbChfLE0sSCxbZWUsRCxaLFJdLG8pO3JldHVybmBcbiAgJHtHLnJlZ2lzdGVyVW5pZm9ybXMod2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoZWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uUSxSKX1cbiAgJHtFfVxuICAke2g/WG4oYix5LFcsZWUpOlluKGIseSxXLGVlKX1cbiAgICAgICAgICAgICAgICAgICBgfTtyZXR1cm57bmFtZTpcIk1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke2J9OyR7dC5hY3RpdmF0aW9ufTske2h9OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOnp9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aT9pKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6Z1swXSx5OmdbMV0sejpnWzJdfSxwcm9ncmFtVW5pZm9ybXM6QX0pLGdldFNoYWRlclNvdXJjZTpVfX19KTt2YXIgbGwsdXMsZHM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtrZSgpO0soKTtGZSgpO29uKCk7c3MoKTt1bigpO2xsPShlLHQsbixyLG89ITEsaSxzPTQsYT00LHU9NCxkPVwiZjMyXCIpPT57bGV0IGw9ej0+e3N3aXRjaCh6KXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHtkfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7en0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGM9ej0+e3N3aXRjaCh6KXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke3p9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxwPWU/YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYCxmPWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAsbT1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIixoPWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzNdKVwiLGI9ZT9cInJvd1wiOlwiY29sXCIseT1lP1wiY29sXCI6XCJyb3dcIixnPWBcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgbGV0IG91dFJvdyA9ICR7Yn0gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHtifSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAke3l9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHt5fSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7eX0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHtkZShzLGQpfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHttfSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7aH0pIHtcbiAgICAgICR7cH1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7bChzKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YCxfPWU/dCYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtzfTtcbiAgICAke2d9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtzfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke2d9XG4gICAgfVxuICAgIHJldHVybiAke2RlKHMsZCl9KDAuMCk7YDpyJiZuP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgICR7Z31gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7Z31cbiAgICB9XG4gICAgcmV0dXJuICR7ZGUocyxkKX0oMC4wKTtgLHc9ZT9yJiZuP2MoYSk6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHtjKGEpfVxuICAgIH1cbiAgICByZXR1cm4gJHtkZShhLGQpfSgwLjApO2A6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlcikge1xuICAgICAgJHtjKGEpfVxuICAgIH1cbiAgICByZXR1cm4gJHtkZShhLGQpfSgwLjApO2Asdj1kZSh1LGQpLCQ9ZT9kZShzLGQpOmRlKGEsZCksVD1lP2RlKGEsZCk6ZGUocyxkKSxJPUllKGksdixkKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHskfSB7XG4gICAgICAke2U/Xzp3fVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7VH0ge1xuICAgICAgJHtlP3c6X31cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHt2fSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHt1fTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgICAke2Z9XG4gICAgICAke29zKG8pfVxuICAgICAgJHtJfVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWB9LHVzPShlLHQsbixyLG8saSxzLGEsdSk9PntsZXQgZD10LmZvcm1hdD09PVwiTkhXQ1wiLGw9ZD9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGM9blswXSxwPWQ/blsyXTpuWzNdLGY9ZD9uWzFdOm5bMl0sbT1kP25bM106blsxXSxoPWQmJihsJTQ9PT0wfHxsJTM9PT0wKSYmbSU0PT09MCxiPWQ/bTpwKmYseT1kP3AqZjptLGc9WzgsOCwxXSxfPXI8PTg/WzQsMSwxXTpbNCw0LDFdLHc9W01hdGguY2VpbChiL2dbMF0vX1swXSksTWF0aC5jZWlsKHkvZ1sxXS9fWzFdKSxNYXRoLmNlaWwoYy9nWzJdL19bMl0pXTtqKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHt3fWApO2xldCB2PWg/ZCYmbCU0IT09MD8zOjQ6MSwkPWdbMV0qX1sxXSxUPWdbMF0qX1swXSxJPU1hdGgubWF4KGdbMF0qdixnWzFdKSxBPXIlJD09PTAsej1vJVQ9PT0wLE09aSVJPT09MCxVPWg/W3YsNCw0XTpbMSwxLDFdLEc9W3t0eXBlOjYsZGF0YTpyfSx7dHlwZTo2LGRhdGE6b30se3R5cGU6NixkYXRhOml9LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjYsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjYsZGF0YTp0LmRpbGF0aW9uc31dO0NlKHQsRyksRy5wdXNoKC4uLlAoZVswXS5kaW1zLGVbMV0uZGltcykpO2xldCBCPVtcInJhbmtcIixcInJhbmtcIl07cyYmKEcucHVzaCguLi5QKGVbMl0uZGltcykpLEIucHVzaChcInJhbmtcIikpLEcucHVzaCguLi5QKG4pKTtsZXQgZWU9Vz0+e2xldCBEPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07QWUodCxEKTtsZXQgWj1oPzQ6MSxSPXJlKGVbMF0uZGF0YVR5cGUpLFE9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHtoP2B2ZWM0PCR7Un0+YDpSfSkge1xuICAgICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7aD9gdmVjNDwke1J9PmA6Un0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHtoP2B2ZWM0PCR7Un0+YDpSfSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2g/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWAsd2U9UyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsdj09PTM/MTp2KSxzZT1TKFwid1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxaKSxIPVt3ZSxzZV0sRT1DKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCxaKTtpZihzKXtsZXQgTD1TKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxaKTtILnB1c2goTCksUSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2g/YHZlYzQ8JHtSfT5gOlJ9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtkP1wid1wiOlwieVwifSR7aD9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgfWB9cmV0dXJuYFxuICAgICAgICAke2lzKFwidW5pZm9ybXMucmVzdWx0X3N0cmlkZXNcIil9XG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxuICAgICAgICAvLyAgb3V0U2hhcGVTdHJpZGVzOiB2ZWMzPGkzMj4sIGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4sIHBhZCA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xuICAgICAgICAke1cucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLkgsRSl9XG4gICAgICAgICR7UX1cbiAgICAgICAgJHtsbChkLEEseixNLHMsdCxVWzBdLFVbMV0sVVsyXSxSKX1cbiAgICAgICAgJHtoP1huKF8sZyxSLHZvaWQgMCwhZCxJKTpZbihfLGcsUix2b2lkIDAsIWQsSSwhMSx2b2lkIDAsYSl9YH07cmV0dXJue25hbWU6XCJDb252MkRNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske3Z9OyR7aH07JHtBfTske3p9OyR7TX07JHskfTske1R9OyR7SX1gLGlucHV0RGVwZW5kZW5jaWVzOkJ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dT91KG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6d1swXSx5OndbMV0sejp3WzJdfSxwcm9ncmFtVW5pZm9ybXM6R30pLGdldFNoYWRlclNvdXJjZTplZX19fSk7dmFyIGNsLGxzLGRuLHBsLGNzLG1sLHBzLG1zLGZzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7a2UoKTtxKCk7SygpO0ZlKCk7b24oKTtjbD1lPT57bGV0IHQ9MTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl0Kj1lW25dO3JldHVybiB0fSxscz1lPT50eXBlb2YgZT09XCJudW1iZXJcIj9bZSxlLGVdOmUsZG49KGUsdCk9PnQ8PTE/ZTplKyhlLTEpKih0LTEpLHBsPShlLHQsbixyPTEpPT57bGV0IG89ZG4odCxyKTtyZXR1cm4gTWF0aC5mbG9vcigoZVswXSoobi0xKS1uK28pLzIpfSxjcz0oZSx0LG4scixvKT0+e289PW51bGwmJihvPXBsKGUsdFswXSxyWzBdKSk7bGV0IGk9WzAsMCwwLG5dO2ZvcihsZXQgcz0wO3M8MztzKyspZVtzXSsyKm8+PXRbc10mJihpW3NdPU1hdGgudHJ1bmMoKGVbc10tdFtzXSsyKm8pL3Jbc10rMSkpO3JldHVybiBpfSxtbD0oZSx0LG4scixvLGkscyxhLHUsZCk9PntsZXQgbCxjLHAsZjtpZihlPT09XCJWQUxJRFwiJiYoZT0wKSx0eXBlb2YgZT09XCJudW1iZXJcIil7bD17dG9wOmUsYm90dG9tOmUsbGVmdDplLHJpZ2h0OmUsZnJvbnQ6ZSxiYWNrOmV9O2xldCBtPWNzKFt0LG4sciwxXSxbYSx1LGRdLDEsW28saSxzXSxlKTtjPW1bMF0scD1tWzFdLGY9bVsyXX1lbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpe2lmKCFlLmV2ZXJ5KChoLGIseSk9Pmg9PT15WzBdKSl0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTtsPXt0b3A6ZVswXSxib3R0b206ZVsxXSxsZWZ0OmVbMl0scmlnaHQ6ZVszXSxmcm9udDplWzRdLGJhY2s6ZVs1XX07bGV0IG09Y3MoW3QsbixyLDFdLFthLHUsZF0sMSxbbyxpLHNdLGVbMF0pO2M9bVswXSxwPW1bMV0sZj1tWzJdfWVsc2UgaWYoZT09PVwiU0FNRV9VUFBFUlwiKXtjPU1hdGguY2VpbCh0L28pLHA9TWF0aC5jZWlsKG4vaSksZj1NYXRoLmNlaWwoci9zKTtsZXQgbT0oYy0xKSpvK2EtdCxoPShwLTEpKmkrdS1uLGI9KGYtMSkqcytkLXIseT1NYXRoLmZsb29yKG0vMiksZz1tLXksXz1NYXRoLmZsb29yKGgvMiksdz1oLV8sdj1NYXRoLmZsb29yKGIvMiksJD1iLXY7bD17dG9wOl8sYm90dG9tOncsbGVmdDp2LHJpZ2h0OiQsZnJvbnQ6eSxiYWNrOmd9fWVsc2UgdGhyb3cgRXJyb3IoYFVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTtyZXR1cm57cGFkSW5mbzpsLG91dERlcHRoOmMsb3V0SGVpZ2h0OnAsb3V0V2lkdGg6Zn19LHBzPShlLHQsbixyLG8saT0hMSxzPVwiY2hhbm5lbHNMYXN0XCIpPT57bGV0IGEsdSxkLGwsYztpZihzPT09XCJjaGFubmVsc0xhc3RcIilbYSx1LGQsbCxjXT1lO2Vsc2UgaWYocz09PVwiY2hhbm5lbHNGaXJzdFwiKVthLGMsdSxkLGxdPWU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke3N9YCk7bGV0W3AsLGYsbSxoXT10LFtiLHksZ109bHMobiksW18sdyx2XT1scyhyKSwkPWRuKGYsXyksVD1kbihtLHcpLEk9ZG4oaCx2KSx7cGFkSW5mbzpBLG91dERlcHRoOnosb3V0SGVpZ2h0Ok0sb3V0V2lkdGg6VX09bWwobyx1LGQsbCxiLHksZywkLFQsSSksRz1pP3AqYzpwLEI9WzAsMCwwLDAsMF07cmV0dXJuIHM9PT1cImNoYW5uZWxzRmlyc3RcIj9CPVthLEcseixNLFVdOnM9PT1cImNoYW5uZWxzTGFzdFwiJiYoQj1bYSx6LE0sVSxHXSkse2JhdGNoU2l6ZTphLGRhdGFGb3JtYXQ6cyxpbkRlcHRoOnUsaW5IZWlnaHQ6ZCxpbldpZHRoOmwsaW5DaGFubmVsczpjLG91dERlcHRoOnosb3V0SGVpZ2h0Ok0sb3V0V2lkdGg6VSxvdXRDaGFubmVsczpHLHBhZEluZm86QSxzdHJpZGVEZXB0aDpiLHN0cmlkZUhlaWdodDp5LHN0cmlkZVdpZHRoOmcsZmlsdGVyRGVwdGg6ZixmaWx0ZXJIZWlnaHQ6bSxmaWx0ZXJXaWR0aDpoLGVmZmVjdGl2ZUZpbHRlckRlcHRoOiQsZWZmZWN0aXZlRmlsdGVySGVpZ2h0OlQsZWZmZWN0aXZlRmlsdGVyV2lkdGg6SSxkaWxhdGlvbkRlcHRoOl8sZGlsYXRpb25IZWlnaHQ6dyxkaWxhdGlvbldpZHRoOnYsaW5TaGFwZTplLG91dFNoYXBlOkIsZmlsdGVyU2hhcGU6dH19LG1zPShlLHQsbixyLG8saSk9PntsZXQgcz1pPT09XCJjaGFubmVsc0xhc3RcIixhPXM/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSx1PSExLGQ9WzY0LDEsMV0sbD17eDpuLm1hcCgoZyxfKT0+Xyl9LGM9W01hdGguY2VpbChjbChsLngubWFwKGc9Pm5bZ10pKS9kWzBdKSwxLDFdO2ooXCJ2ZXJib3NlXCIsKCk9PmBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2N9YCk7bGV0IHA9dT9zJiZhJTQhPT0wPzM6NDoxLGY9eC5zaXplKG4pLG09W3t0eXBlOjEyLGRhdGE6Zn0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfV07Q2UodCxtKSxtLnB1c2goLi4uUChlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IGg9W1wicmFua1wiLFwicmFua1wiXSxiPWUubGVuZ3RoPT09MztiJiYobS5wdXNoKC4uLlAoZVsyXS5kaW1zKSksaC5wdXNoKFwicmFua1wiKSksbS5wdXNoKC4uLlAobikpO2xldCB5PWc9PntsZXQgXz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ci5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6by5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH1dO0FlKHQsXyk7bGV0IHc9dT80OjEsdj1yZShlWzBdLmRhdGFUeXBlKSwkPVMoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLHA9PT0zPzE6cCksVD1TKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCx3KSxJPVskLFRdLEE9QyhcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgsdyksej1cIlwiO2lmKGIpe2xldCBHPVMoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLHcpO0kucHVzaChHKSx6Kz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiBhcnJheTx1MzIsIDU+KSAtPiAke3U/YHZlYzQ8JHt2fT5gOnZ9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1ske3M/TyhcImNvb3Jkc1wiLDQsNSk6TyhcImNvb3Jkc1wiLDEsNSl9JHt1P1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1sZXQgTT1kZShwLHYpLFU9SWUodCxNLHYpO3JldHVybmBcbiAgICAgICAgICAgICR7en1cbiAgICAgICAgICAgIGZuIGdldFgoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAkeyQuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7VC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHtnLnJlZ2lzdGVyVW5pZm9ybXMoXykuZGVjbGFyZVZhcmlhYmxlcyguLi5JLEEpfVxuICAgICAgICAgICR7Zy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtBLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke08oXCJjb29yZHNcIiwwLCQucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke3M/TyhcImNvb3Jkc1wiLCQucmFuay0xLCQucmFuayk6TyhcImNvb3Jkc1wiLDEsJC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7cz9PKFwiY29vcmRzXCIsMSwkLnJhbmspOk8oXCJjb29yZHNcIiwyLCQucmFuayl9LFxuICAgICAgICAgICAgICAke3M/TyhcImNvb3Jkc1wiLDIsJC5yYW5rKTpPKFwiY29vcmRzXCIsMywkLnJhbmspfSxcbiAgICAgICAgICAgICAgJHtzP08oXCJjb29yZHNcIiwzLCQucmFuayk6TyhcImNvb3Jkc1wiLDQsJC5yYW5rKX0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHtzP08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSwkLnJhbmspOk8oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMiwkLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke3M/TyhcInVuaWZvcm1zLnhfc2hhcGVcIiwyLCQucmFuayk6TyhcInVuaWZvcm1zLnhfc2hhcGVcIiwzLCQucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7cz9PKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsJC5yYW5rKTpPKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsJC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHtzP08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCwkLnJhbmspOk8oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSwkLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtzP2BsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke3M/YHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2A6YHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2B9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICR7cz9gbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke3M/YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtiP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpXCI6XCJcIn07XG4gICAgICAgICAgICAgICR7VX1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDb252M0ROYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7c307JHtwfTske2J9YCxpbnB1dERlcGVuZGVuY2llczpofSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6Y1swXSx5OmNbMV0sejpjWzJdfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTp5fX19KTt2YXIgaHMsZ3MseXM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO0ZlKCk7aHM9KGUsdCxuLHIpPT57bGV0IG89ZS5sZW5ndGg+MixpPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLHM9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHU9dC5mb3JtYXQ9PT1cIk5IV0NcIixkPXU/blszXTpuWzFdLGw9ZC90Lmdyb3VwLGM9dSYmbD49ND9YKGQpOjEscD14LnNpemUobikvYyxmPVt7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOjEyLGRhdGE6W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dfSx7dHlwZToxMixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6MTIsZGF0YTpsfV07Q2UodCxmKSxmLnB1c2goLi4uUChzLFthWzBdLGFbMV0sYVsyXSxhWzNdL2NdKSk7bGV0IG09bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl07Zi5wdXNoKC4uLlAoW25bMF0sblsxXSxuWzJdLG5bM10vY10pKTtsZXQgaD1iPT57bGV0IHk9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgsYyksZz1yZSh5LnR5cGUudGVuc29yKSxfPUllKHQseS50eXBlLnZhbHVlLGcpLHc9UyhcInhcIixlWzBdLmRhdGFUeXBlLHMubGVuZ3RoKSx2PVMoXCJ3XCIsZVsxXS5kYXRhVHlwZSxhLmxlbmd0aCxjKSwkPVt3LHZdO28mJiQucHVzaChTKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGMpKTtsZXQgVD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dO0FlKHQsVCk7bGV0IEk9dT9gXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMF07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7dy5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHt2LmdldChcIndIZWlnaHRcIixcIndXaWR0aFwiLFwid0luQ2hhbm5lbFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgOmBcbiAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdIZWlnaHQrKykge1xuICAgICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbM107IHdXaWR0aCsrKSB7XG4gICAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbM10pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB4VmFsID0gJHt3LmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke3YuZ2V0KFwib3V0cHV0X2NoYW5uZWxcIixcIndJbkNoYW5uZWxcIixcIndIZWlnaHRcIixcIndXaWR0aFwiKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7cmV0dXJuYFxuICAke2IucmVnaXN0ZXJVbmlmb3JtcyhUKS5kZWNsYXJlVmFyaWFibGVzKC4uLiQseSl9XG5cbiAgJHtiLm1haW5TdGFydCgpfVxuICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7dT8zOjF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske3U/MToyfV0sIG91dHB1dEluZGljZXNbJHt1PzI6M31dKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgKiAke2N9IC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICB2YXIgaW5fY2hhbm5lbF9vZmZzZXQgPSBncm91cF9pZCAqIHVuaWZvcm1zLndfc2hhcGVbJHt1PzI6MX1dO1xuXG4gICAgdmFyIHZhbHVlOiAke3kudHlwZS52YWx1ZX0gPSAke3kudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtJfVxuICAgICR7aX1cbiAgICAke199XG4gICAgJHt5LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1fJHtjfWAsaW5wdXREZXBlbmRlbmNpZXM6bX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3Iobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOmh9fSxncz0oZSx0LG4scik9PntsZXQgbz1lLmxlbmd0aD4yLGk9WChuWzNdKSxzPVgoblsyXSksYT14LnNpemUobikvaS9zLHU9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdLGVbMF0uZGltc1szXS9pXSxkPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzFdLmRpbXNbM10vaV0sbD1bblswXSxuWzFdLG5bMl0sblszXS9pXSxjPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjYsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19XTtDZSh0LGMpLGMucHVzaCguLi5QKHUsZCxsKSk7bGV0IHA9KHMtMSkqdC5zdHJpZGVzWzFdK2RbMV0sZj1tPT57bGV0IGg9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbC5sZW5ndGgsaSksYj1yZShoLnR5cGUudGVuc29yKSx5PUllKHQsaC50eXBlLnZhbHVlLGIpLGc9UyhcInhcIixlWzBdLmRhdGFUeXBlLHUubGVuZ3RoLGkpLF89UyhcIndcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLGkpLHc9W2csX107byYmdy5wdXNoKFMoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaSkpO2xldCB2PW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLCQ9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07cmV0dXJuIEFlKHQsJCksYFxuICAke20ucmVnaXN0ZXJVbmlmb3JtcygkKS5kZWNsYXJlVmFyaWFibGVzKC4uLncsaCl9XG4gICR7bS5tYWluU3RhcnQoKX1cbiAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHtzfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtzfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7Zy50eXBlLnZhbHVlfSwgJHtwfT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtoLnR5cGUudmFsdWV9LCAke3N9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke2RbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtwfTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7Zy5nZXQoXCJiYXRjaFwiLFwidTMyKHhfaGVpZ2h0KVwiLFwidTMyKHhfd2lkdGgpXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHtnLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7ZFsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7Xy5nZXQoXCJ3X2hlaWdodFwiLFwid193aWR0aFwiLFwiMFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7c311OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3N9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke3Z9XG4gICAgICAke3l9XG4gICAgICAke2guc2V0KFwiYmF0Y2hcIixcInJvd1wiLFwiY29sICsgaVwiLFwib3V0cHV0X2NoYW5uZWxcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252LVZlY3Rvcml6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7aX07JHtzfTske3B9OyR7ZFswXX07JHtkWzFdfWAsaW5wdXREZXBlbmRlbmNpZXM6bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJ0eXBlXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cj9yKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Y30pLGdldFNoYWRlclNvdXJjZTpmfX19KTt2YXIgZmwsSm4saGwsZXIsdHIsYnMsZ2wseWwsbnIsX3M9aygoKT0+e1widXNlIHN0cmljdFwiO3EoKTtkcygpO2ZzKCk7dW4oKTt5cygpO0ZlKCk7YW4oKTtWZSgpO2ZsPShlLHQsbixyLG8saSk9PntsZXQgcz1lWzBdLGE9ZS5zbGljZShpPzE6MixpPzM6NCksdT1hLmxlbmd0aCxkPXRbMF0sYz10LnNsaWNlKDIpLm1hcCgobSxoKT0+bSsobS0xKSoobltoXS0xKSksZj1hLm1hcCgobSxoKT0+bStyW2hdK3JbaCt1XSkubWFwKChtLGgpPT5NYXRoLmZsb29yKChtLWNbaF0rb1toXSkvb1toXSkpO3JldHVybiBmLnNwbGljZSgwLDAscyksZi5zcGxpY2UoaT8zOjEsMCxkKSxmfSxKbj1bMiwzLDEsMF0saGw9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoXCJncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgbj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0scj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihuIT09cil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgbz1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtvfURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5wYWRzLmxlbmd0aCE9PW8qMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7byoyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSxlcj0oZSx0KT0+e2xldCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtuLmxlbmd0aDx0WzFdLmRpbXMubGVuZ3RoLTImJm4ucHVzaCguLi5BcnJheSh0WzFdLmRpbXMubGVuZ3RoLTItbi5sZW5ndGgpLmZpbGwoMCkpO2ZvcihsZXQgaT0yO2k8dFsxXS5kaW1zLmxlbmd0aDsrK2kpbltpLTJdPT09MCYmKG5baS0yXT10WzFdLmRpbXNbaV0pO2xldCByPWUucGFkcy5zbGljZSgpO1hlLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLG4scixlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IG89T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cn0pLG99LHRyPWU9PntsZXQgdD1ybihlKSxuPWUuZm9ybWF0LHI9W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxvPWUuZGlsYXRpb25zLGk9ZS5ncm91cCxzPWUua2VybmVsX3NoYXBlLGE9ZS5wYWRzLHU9ZS5zdHJpZGVzLGQ9ZS53X2lzX2NvbnN0KCk7cmV0dXJue2F1dG9QYWQ6cixmb3JtYXQ6bixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOnMscGFkczphLHN0cmlkZXM6dSx3SXNDb25zdDpkLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sYnM9KGUsdCxuLHIpPT57bGV0IG89bi5mb3JtYXQ9PT1cIk5IV0NcIixpPWZsKHRbMF0uZGltcyx0WzFdLmRpbXMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyxvKTtpZihuLmdyb3VwIT09MSl7bGV0ICQ9W3RbMF1dO2lmKG8pe2xldCBJPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKHBlKHRbMV0sSm4pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07bi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1JKSwkLnB1c2goSSl9ZWxzZSAkLnB1c2godFsxXSk7dC5sZW5ndGg9PT0zJiYkLnB1c2godFsyXSksIWUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJhbXBlcmVcIikmJm8mJnRbMV0uZGltc1swXT09PW4uZ3JvdXAmJnRbMV0uZGltc1sxXT09PTEmJm4uZGlsYXRpb25zWzBdPT09MSYmbi5kaWxhdGlvbnNbMV09PT0xP2UuY29tcHV0ZShncygkLG4saSxyKSx7aW5wdXRzOiR9KTplLmNvbXB1dGUoaHMoJCxuLGkscikse2lucHV0czokfSk7cmV0dXJufWxldCBzPXQubGVuZ3RoPT09MyxhPXRbMF0uZGltc1tvPzE6Ml0sdT10WzBdLmRpbXNbbz8yOjNdLGQ9dFswXS5kaW1zW28/MzoxXSxsPXRbMV0uZGltc1syXSxjPXRbMV0uZGltc1szXSxwPWlbbz8xOjJdLGY9aVtvPzI6M10sbT1pW28/MzoxXSxoPW8mJmw9PT1hJiZjPT09dSYmbi5wYWRzWzBdPT09MCYmbi5wYWRzWzFdPT09MDtpZihofHxsPT09MSYmYz09PTEmJm4uZGlsYXRpb25zWzBdPT09MSYmbi5kaWxhdGlvbnNbMV09PT0xJiZuLnN0cmlkZXNbMF09PT0xJiZuLnN0cmlkZXNbMV09PT0xJiZuLnBhZHNbMF09PT0wJiZuLnBhZHNbMV09PT0wKXtsZXQgJD1pWzBdLFQsSSxBLHo9W107aWYobyl7bGV0IEc9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUocGUodFsxXSxKbikse2lucHV0czpbMV0sb3V0cHV0czpbbi53SXNDb25zdD8tMjotMV19KVswXTtpZihuLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUcpLGgpe2xldCBCPWEqdSpkO1Q9dFswXS5yZXNoYXBlKFsxLCQsQl0pLEk9Ry5yZXNoYXBlKFsxLEIsbV0pLEE9WzEsJCxtXX1lbHNlIFQ9dFswXS5yZXNoYXBlKFskLGEqdSxkXSksST1HLnJlc2hhcGUoWzEsZCxtXSksQT1bJCxwKmYsbV07ei5wdXNoKFQpLHoucHVzaChJKX1lbHNlIFQ9dFswXS5yZXNoYXBlKFskLGQsYSp1XSksST10WzFdLnJlc2hhcGUoWzEsbSxkXSksQT1bJCxtLHAqZl0sei5wdXNoKEkpLHoucHVzaChUKTtzJiZ6LnB1c2godFsyXSk7bGV0IE09QVsyXSxVPXpbMF0uZGltc1t6WzBdLmRpbXMubGVuZ3RoLTFdO008OCYmVTw4P2UuY29tcHV0ZShzbih6LG4saSxBLG8scikse2lucHV0czp6fSk6ZS5jb21wdXRlKGJ0KHosbixpLEEsbyxyKSx7aW5wdXRzOnp9KTtyZXR1cm59bGV0IGI9ITAseT1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShwZSh0WzFdLEpuKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO24ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9eSk7bGV0IGc9W3RbMF0seV07cyYmZy5wdXNoKHRbMl0pO2xldCBfPW8/cCpmOm0sdz1vP206cCpmLHY9bCpjKmQ7ZS5jb21wdXRlKHVzKGcsbixpLF8sdyx2LHMsYixyKSx7aW5wdXRzOmd9KX0sZ2w9KGUsdCk9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLHI9W2UuaW5wdXRzWzBdLnJlc2hhcGUobj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJnIucHVzaChlLmlucHV0c1syXSk7bGV0IG89WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxpPVsxXS5jb25jYXQodC5zdHJpZGVzKSxzPVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLGE9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSx1PWVyKHsuLi50LHBhZHM6byxzdHJpZGVzOmksZGlsYXRpb25zOnMsa2VybmVsU2hhcGU6YX0scik7YnMoZSxyLHUsZD0+bj9bZFswXSxkWzJdLGRbM11dOltkWzBdLGRbMV0sZFszXV0pfSx5bD0oZSx0LG4pPT57bGV0IHI9bi5mb3JtYXQ9PT1cIk5IV0NcIj9cImNoYW5uZWxzTGFzdFwiOlwiY2hhbm5lbHNGaXJzdFwiLG89ZXIobix0KSxpPW4uYXV0b1BhZD09PVwiTk9UU0VUXCI/bi5wYWRzOm4uYXV0b1BhZCxzPXBzKHRbMF0uZGltcyx0WzFdLmRpbXMsbi5zdHJpZGVzLG4uZGlsYXRpb25zLGksITEscik7ZS5jb21wdXRlKG1zKHQsbyxzLm91dFNoYXBlLFtzLmZpbHRlckRlcHRoLHMuZmlsdGVySGVpZ2h0LHMuZmlsdGVyV2lkdGhdLFtzLnBhZEluZm8uZnJvbnQscy5wYWRJbmZvLnRvcCxzLnBhZEluZm8ubGVmdF0scikpfSxucj0oZSx0KT0+e2lmKGhsKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09MylnbChlLHQpO2Vsc2UgaWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXlsKGUsZS5pbnB1dHMsdCk7ZWxzZXtsZXQgbj1lcih0LGUuaW5wdXRzKTticyhlLGUuaW5wdXRzLG4pfX19KTt2YXIgd3MsJHM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtrZSgpO3EoKTtLKCk7d3M9KGUsdCxuKT0+e2xldCByPWUubGVuZ3RoPjIsbz10Lm91dHB1dFNoYXBlLGk9dC5mb3JtYXQ9PT1cIk5IV0NcIixzPXQuZ3JvdXAsYT1lWzFdLmRpbXMsdT1hWzJdL3MsZD1hWzNdLGw9aT9YKHUpOjEsYz1pJiZkPT09MSYmdT49NCxwPWM/TWF0aC5mbG9vcih1LzQpKjQ6TWF0aC5mbG9vcih1L2wpKmwsZj11LXAsbT1pP1goZCk6MSxoPWk/ZD09PTE/bDptOjEsYj14LnNpemUobykvbSx5PVtNYXRoLmNlaWwoYi82NCksMSwxXTtqKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHt5fWApO2xldCBnPVtcInJhbmtcIixcInJhbmtcIl0sXz1bdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV0sdz1bdC5rZXJuZWxTaGFwZVtpPzE6Ml0sdC5rZXJuZWxTaGFwZVtpPzI6M11dLHY9W3QuZGlsYXRpb25zWzBdLHQuZGlsYXRpb25zWzFdXSwkPVt3WzBdKyh0LmRpbGF0aW9uc1swXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2k/MToyXS0xKSoodC5kaWxhdGlvbnNbMF0tMSkpLHdbMV0rKHQuZGlsYXRpb25zWzFdPD0xPzA6KHQua2VybmVsU2hhcGVbaT8yOjNdLTEpKih0LmRpbGF0aW9uc1sxXS0xKSldLFQ9WyRbMF0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMF0rdC5wYWRzWzJdKS8yKSwkWzFdLTEtTWF0aC5mbG9vcigodC5wYWRzWzFdK3QucGFkc1szXSkvMildLEk9W3t0eXBlOjEyLGRhdGE6Yn0se3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnd9LHt0eXBlOjEyLGRhdGE6dn0se3R5cGU6MTIsZGF0YTokfSx7dHlwZTo2LGRhdGE6VH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6ZH0sLi4uUChlWzBdLmRpbXMsZVsxXS5kaW1zKV07ciYmKEkucHVzaCguLi5QKGVbMl0uZGltcykpLGcucHVzaChcInJhbmtcIikpLEkucHVzaCguLi5QKG8pKTtsZXQgQT16PT57bGV0IE09W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Xy5sZW5ndGh9LHtuYW1lOlwiZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOncubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dy5sZW5ndGh9LHtuYW1lOlwiZWZmZWN0aXZlX2ZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpULmxlbmd0aH0se25hbWU6XCJpbnB1dF9jaGFubmVsc19wZXJfZ3JvdXBfaW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV0sVT1yZShlWzBdLmRhdGFUeXBlKSxHPWk/MToyLEI9aT8yOjMsZWU9aT8zOjEsVz1TKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxoKSxEPVMoXCJEeVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxsKSxaPVtELFddO3ImJloucHVzaChTKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsW29bZWVdXS5sZW5ndGgsbSkpO2xldCBSPUMoXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLG0pLFE9KCk9PntsZXQgSD1cIlwiO2lmKGMpbD09PTQ/SCs9YFxuICAgICAgICBsZXQgeFZhbHVlID0gJHtELmdldEJ5T2Zmc2V0KFwieF9vZmZzZXRcIil9O1xuICAgICAgICBsZXQgd1ZhbHVlID0gJHtXLmdldEJ5T2Zmc2V0KFwid19vZmZzZXRcIil9O1xuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7XG4gICAgICAgIHhfb2Zmc2V0ICs9IDF1O1xuICAgICAgICB3X29mZnNldCArPSAxdTtgOmw9PT0yP0grPWBcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh2ZWM0PCR7VX0+KCR7RC5nZXRCeU9mZnNldChcInhfb2Zmc2V0XCIpfSwgJHtELmdldEJ5T2Zmc2V0KFwieF9vZmZzZXQgKyAxdVwiKX0pLCB2ZWM0PCR7VX0+KCR7Vy5nZXRCeU9mZnNldChcIndfb2Zmc2V0XCIpfSwgJHtXLmdldEJ5T2Zmc2V0KFwid19vZmZzZXQgKyAxdVwiKX0pKTtcbiAgICAgICAgICB4X29mZnNldCArPSAydTtcbiAgICAgICAgICB3X29mZnNldCArPSAydTtgOmw9PT0xJiYoSCs9YFxuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHZlYzQ8JHtVfT4oJHtELmdldEJ5T2Zmc2V0KFwieF9vZmZzZXRcIil9LCAke0QuZ2V0QnlPZmZzZXQoXCJ4X29mZnNldCArIDF1XCIpfSwgJHtELmdldEJ5T2Zmc2V0KFwieF9vZmZzZXQgKyAydVwiKX0sICR7RC5nZXRCeU9mZnNldChcInhfb2Zmc2V0ICsgM3VcIil9KSwgdmVjNDwke1V9Pigke1cuZ2V0QnlPZmZzZXQoXCJ3X29mZnNldFwiKX0sICR7Vy5nZXRCeU9mZnNldChcIndfb2Zmc2V0ICsgMXVcIil9LCAke1cuZ2V0QnlPZmZzZXQoXCJ3X29mZnNldCArIDJ1XCIpfSwgJHtXLmdldEJ5T2Zmc2V0KFwid19vZmZzZXQgKyAzdVwiKX0pKTtcbiAgICAgICAgICB4X29mZnNldCArPSA0dTtcbiAgICAgICAgICB3X29mZnNldCArPSA0dTtgKTtlbHNlIGlmKEgrPWBcbiAgICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke2k/RC5nZXRCeU9mZnNldChgJHtELmluZGljZXNUb09mZnNldChgJHtELnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke2x9YCk6RC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRDaGFubmVsXCIsXCJpZHlSXCIsXCJpZHlDXCIpfTtcbiAgICAgICAgYCxsPT09MSlIKz1gXG4gICAgICAgICAgbGV0IHdfb2Zmc2V0ID0gJHtXLmluZGljZXNUb09mZnNldChgJHtXLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfTtcbiAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtXLmdldEJ5T2Zmc2V0KGB3X29mZnNldCAvICR7aH1gKX07XG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7YDtlbHNlIGZvcihsZXQgRT0wO0U8bDtFKyspSCs9YFxuICAgICAgICAgICAgbGV0IHdWYWx1ZSR7RX0gPSAke1cuZ2V0QnlPZmZzZXQoYCR7Vy5pbmRpY2VzVG9PZmZzZXQoYCR7Vy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsICsgJHtFfSwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7RX1dICogd1ZhbHVlJHtFfTtgO3JldHVybiBIfSx3ZT0oKT0+e2lmKGY9PT0wKXJldHVyblwiXCI7aWYoIWMpdGhyb3cgbmV3IEVycm9yKGBwYWNrSW5wdXRBczQgJHtjfSBpcyBub3QgdHJ1ZS5gKTtsZXQgSD1cIlwiO2lmKGw9PT0xKXtIKz1cImRvdFByb2QgPSBkb3RQcm9kXCI7Zm9yKGxldCBFPTA7RTxmO0UrKylIKz1gXG4gICAgICAgICAgICArICR7RC5nZXRCeU9mZnNldChgeF9vZmZzZXQgKyAke0V9YCl9ICogJHtXLmdldEJ5T2Zmc2V0KGB3X29mZnNldCArICR7RX1gKX1gO0grPVwiO1wifWVsc2UgaWYobD09PTIpe2lmKGYhPT0yKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dENoYW5uZWxzUmVtYWluZGVyICR7Zn0uYCk7SCs9YFxuICAgICAgICAgIGxldCB4VmFsdWUgPSAke0QuZ2V0QnlPZmZzZXQoXCJ4X29mZnNldFwiKX07XG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vy5nZXRCeU9mZnNldChcIndfb2Zmc2V0XCIpfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7YH1yZXR1cm4gSH0sc2U9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Iub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHttfWApfTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7Ui5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLDApfTtcbiAgICAgICAgICAgIGxldCBkMSA9ICR7Ui5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGVlKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7Ui5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEcpfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtSLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsQil9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtSLnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICB2YXIgd1I6IHUzMiA9IDA7XG4gICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnggPT0gMSkge1xuICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdSID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5UkNvcm5lciArIHdSKSAlICh1bmlmb3Jtcy5zdHJpZGVzLngpID09IDBcbiAgICAgICAgICAgICAgd1IgPSB1MzIoKChkeVJDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSBkeVJDb3JuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3UiAlIHVuaWZvcm1zLmRpbGF0aW9ucy54ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlSID0gKCR7VX0oZHlSQ29ybmVyKSArICR7VX0od1IpKSAvICR7VX0odW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7VX0odW5pZm9ybXMuRHlfc2hhcGVbJHtHfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG4gICAgICAgICAgICAgIHZhciB3QzogdTMyID0gMDtcbiAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy55ID09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdDID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5Q0Nvcm5lciArIHdDKSAlICh1bmlmb3Jtcy5zdHJpZGVzLnkpID09IDBcbiAgICAgICAgICAgICAgICB3QyA9IHUzMigoKGR5Q0Nvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIGR5Q0Nvcm5lcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICg7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtVfShkeUNDb3JuZXIpICsgJHtVfSh3QykpIC8gJHtVfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtVfSh1bmlmb3Jtcy5EeV9zaGFwZVske0J9XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgICAgICR7Yz9gXG4gICAgICAgICAgICAgICAgdmFyIHhfb2Zmc2V0ID0gJHtELmluZGljZXNUb09mZnNldChgJHtELnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke2x9O1xuICAgICAgICAgICAgICAgIHZhciB3X29mZnNldCA9ICR7Vy5pbmRpY2VzVG9PZmZzZXQoYCR7Vy50eXBlLmluZGljZXN9KHdSUGVybSwgd0NQZXJtLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfSAvICR7aH07XG4gICAgICAgICAgICAgICAgICBgOlwiXCJ9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwX2ludDsgZDIgPSBkMiArICR7Yz80Omx9KSB7XG4gICAgICAgICAgICAgICAgICAke1EoKX1cbiAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbCA9IGlucHV0Q2hhbm5lbCArICR7Yz80Omx9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAke3dlKCl9XG4gICAgICAgICAgICAgICAgd0MgPSB3QyArIHVuaWZvcm1zLnN0cmlkZXMueSAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd1IgPSB3UiArIHVuaWZvcm1zLnN0cmlkZXNbMF0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7cj9gICsgYmlhc1tkMSAvICR7bX1dYDpcIlwifTtcbiAgICAgICAgICAgICR7Ui5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgICBgO3JldHVybmBcbiAgICAke3oucmVnaXN0ZXJVbmlmb3JtcyhNKS5kZWNsYXJlVmFyaWFibGVzKC4uLlosUil9XG4gICAgICAke3oubWFpblN0YXJ0KCl9XG4gICAgICAke3ouZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfTtcbiAgICAke3NlfX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7bH0ke2h9JHttfSR7Y30ke2Z9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6eVswXSx5OnlbMV0sejp5WzJdfSxvdXRwdXRzOlt7ZGltczpuP24obyk6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOkl9KSxnZXRTaGFkZXJTb3VyY2U6QX19fSk7dmFyIGJsLF9sLHdsLHZzLHhzLCRsLFNzLHZsLFRzLElzPWsoKCk9PntcInVzZSBzdHJpY3RcIjskcygpO0ZlKCk7VmUoKTtibD0oZSx0LG4scixvLGkpPT4oZS0xKSp0K24rKHItMSkqbysxLWksX2w9KGUsdCxuLHIsbyk9PntsZXQgaT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhuW3JdPWksbltvXT1lLWkpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKG5bcl09ZS1pLG5bb109aSl9LHdsPShlLHQsbixyLG8saSxzLGEsdSxkKT0+e2xldCBsPWUubGVuZ3RoLTIsYz1kLmxlbmd0aD09PTA7dS5sZW5ndGg8bCYmdS5wdXNoKC4uLkFycmF5KGwtdS5sZW5ndGgpLmZpbGwoMCkpO2xldCBwPWVbMF0sZj10W2E/MzoxXSpvO2ZvcihsZXQgbT0wLGg9ZS5sZW5ndGgtbC0oYT8xOjApO208bDsrK20sKytoKXtsZXQgYj1lW2hdLHk9Yz9iKnNbbV06ZFttXSxnPWJsKGIsc1ttXSxpW21dLHRbaF0sblttXSx5KTtfbChnLHIsaSxtLG0rbCksYyYmZC5wdXNoKHNbbV0qKGItMSkrdVttXSsodFtoXS0xKSpuW21dKzEtaVttXS1pW20rbF0pfWQuc3BsaWNlKDAsMCxwKSxkLnNwbGljZShhPzM6MSwwLGYpfSx2cz0oZSx0KT0+e2xldCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKChjLHApPT5jKnAsMSk9PT0wKXtuLmxlbmd0aD0wO2ZvcihsZXQgYz0yO2M8dFsxXS5kaW1zLmxlbmd0aDsrK2Mpbi5wdXNoKHRbMV0uZGltc1tjXSl9bGV0IHI9ZS5mb3JtYXQ9PT1cIk5IV0NcIjtuLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxuLnNwbGljZShyPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCksaT1lLm91dHB1dFNoYXBlLnNsaWNlKCkscz1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxhPXRbMF0uZGltcyx1PWUuZGlsYXRpb25zLnNsaWNlKCk7aWYodS5yZWR1Y2UoKGMscCk9PmMrcCwwKT09PTApe2xldCBjPXRbMF0uZGltcy5sZW5ndGgtMjt1PW5ldyBBcnJheShjKS5maWxsKDEpfWxldCBkPWUuc3RyaWRlcy5zbGljZSgpO2lmKGQucmVkdWNlKChjLHApPT5jK3AsMCk9PT0wKXtsZXQgYz10WzBdLmRpbXMubGVuZ3RoLTI7ZD1uZXcgQXJyYXkoYykuZmlsbCgxKX13bChhLG4sdSxlLmF1dG9QYWQsZS5ncm91cCxvLGQscixzLGkpO2xldCBsPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obCx7a2VybmVsU2hhcGU6bixwYWRzOm8sb3V0cHV0UGFkZGluZzpzLG91dHB1dFNoYXBlOmksZGlsYXRpb25zOnUsc3RyaWRlczpkfSksbH0seHM9ZT0+e2xldCB0PXJuKGUpLG49ZS5mb3JtYXQscj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG89ZS5kaWxhdGlvbnMsaT1lLmdyb3VwLHM9ZS5rZXJuZWxTaGFwZSxhPWUucGFkcyx1PWUuc3RyaWRlcyxkPWUud0lzQ29uc3QoKSxsPWUub3V0cHV0UGFkZGluZyxjPWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6cixmb3JtYXQ6bixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOnMsb3V0cHV0UGFkZGluZzpsLG91dHB1dFNoYXBlOmMscGFkczphLHN0cmlkZXM6dSx3SXNDb25zdDpkLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sJGw9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgbj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0scj1lWzFdLmRpbXNbMF07aWYobiE9PXIpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBpPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKGwsYyk9PmwrYywwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2l9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKGwsYyk9PmwrYywwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5wYWRzLnJlZHVjZSgobCxjKT0+bCtjLDApPjAmJnQucGFkcy5sZW5ndGghPT1pKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke2kqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PWkmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKGwsYyk9PmwrYywwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LFNzPShlLHQsbixyKT0+e2xldCBvPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKHBlKHRbMV0sWzIsMywwLDFdKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO24ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9byk7bGV0IGk9W3RbMF0sb107dC5sZW5ndGg9PT0zJiZpLnB1c2godFsyXSksZS5jb21wdXRlKHdzKGksbixyKSx7aW5wdXRzOml9KX0sdmw9KGUsdCk9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLHI9W2UuaW5wdXRzWzBdLnJlc2hhcGUobj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJnIucHVzaChlLmlucHV0c1syXSk7bGV0IG89dC5rZXJuZWxTaGFwZTsoby5sZW5ndGg9PT0wfHxvWzBdPT09MCkmJihvPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IGk9dC5kaWxhdGlvbnM7KGkubGVuZ3RoPT09MHx8aVswXT09PTApJiYoaT1bMV0pO2xldCBzPXQuc3RyaWRlczsocy5sZW5ndGg9PT0wfHxzWzBdPT09MCkmJihzPVsxXSk7bGV0IGE9dC5wYWRzO2EubGVuZ3RoPT09MCYmKGE9WzAsMF0pLGE9WzAsYVswXSwwLGFbMV1dLHM9WzFdLmNvbmNhdChzKSxpPVsxXS5jb25jYXQoaSksbz1bMV0uY29uY2F0KG8pO2xldCB1PXQub3V0cHV0UGFkZGluZzt1PVswXS5jb25jYXQodSk7bGV0IGQ9dnMoey4uLnQscGFkczphLHN0cmlkZXM6cyxkaWxhdGlvbnM6aSxrZXJuZWxTaGFwZTpvLG91dHB1dFBhZGRpbmc6dX0scik7U3MoZSxyLGQsbD0+bj9bbFswXSxsWzJdLGxbM11dOltsWzBdLGxbMV0sbFszXV0pfSxUcz0oZSx0KT0+e2lmKCRsKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Myl2bChlLHQpO2Vsc2V7bGV0IG49dnModCxlLmlucHV0cyk7U3MoZSxlLmlucHV0cyxuKX19fSk7dmFyIHhsLENzLEFzLEVzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO3hsPShlLHQsbixyKT0+e2xldCBvPXguc2l6ZSh0KSxpPXQubGVuZ3RoLHM9UyhcImlucHV0XCIsZSxpKSxhPUMoXCJvdXRwdXRcIixlLGkpLHU9bi5kYXRhVHlwZT09PTY/bi5nZXRJbnQzMkFycmF5KClbMF06TnVtYmVyKG4uZ2V0QmlnSW50NjRBcnJheSgpWzBdKSxkPXgubm9ybWFsaXplQXhpcyh1LGkpLGw9Yz0+e2xldCBwPWAgaTMyKCR7cy5pbmRpY2VzR2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSkgYCxmPU8oXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLGkpLG09ci5yZXZlcnNlP3ArKHIuZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLGg9ci5yZXZlcnNlP2Y6cCsoci5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7Yy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocyxhKX1cbiAgICAgICAgICAgICAgICAke2MubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke2MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7YS50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7bX07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7aH07XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHtzLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7cy5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHthLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDpyLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOmR9LC4uLlAodCx0KV19KSxnZXRTaGFkZXJTb3VyY2U6bH19LENzPShlLHQpPT57bGV0IG49ZS5pbnB1dHNbMF0uZGltcyxyPWUuaW5wdXRzWzBdLmRhdGFUeXBlLG89ZS5pbnB1dHNbMV07ZS5jb21wdXRlKHhsKHIsbixvLHQpLHtpbnB1dHM6WzBdfSl9LEFzPWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEsbj1lLnJldmVyc2U9PT0xO3JldHVybiBOKHtleGNsdXNpdmU6dCxyZXZlcnNlOm59KX19KTt2YXIgU2wsVGwsSWwsa3MsUHMsenM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7U2w9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC5cIil9LFRsPShlLHQsbixyKT0+e2xldCBvPVtdO28ucHVzaChgZm4gcGVybShpOiAke3IudHlwZS5pbmRpY2VzfSkgLT4gJHtuLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke24udHlwZS5pbmRpY2VzfTtgKTtmb3IobGV0IGk9MDtpPHQ7KytpKW8ucHVzaChuLmluZGljZXNTZXQoXCJhXCIsZVtpXSxgaVske2l9XWApKTtyZXR1cm4gby5wdXNoKFwicmV0dXJuIGE7fVwiKSxvLmpvaW4oYFxuYCl9LElsPShlLHQpPT57bGV0IG4scixvLGkscyxhLHU9dC5mb3JtYXQ9PT1cIk5IV0NcIixkPXQuYmxvY2tzaXplLGw9dC5tb2RlPT09XCJEQ1JcIjt1PyhbbixyLG8saV09ZS5kaW1zLHM9bD9bbixyLG8sZCxkLGkvZCoqMl06W24scixvLGkvZCoqMixkLGRdLGE9bD9bMCwxLDMsMiw0LDVdOlswLDEsNCwyLDUsM10pOihbbixyLG8saV09W2UuZGltc1swXSxlLmRpbXNbMl0sZS5kaW1zWzNdLGUuZGltc1sxXV0scz1sP1tuLGQsZCxpL2QqKjIscixvXTpbbixpL2QqKjIsZCxkLHIsb10sYT1sP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSk7bGV0IGM9ZS5yZXNoYXBlKHMpLHA9Yy5kaW1zLmxlbmd0aCxmPWUuZGF0YVR5cGUsbT1TKFwiYVwiLGYscCksaD1DKFwib3V0cHV0XCIsZixwKSxiPXk9PmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhtLGgpfVxuXG4gICR7VGwoYSxwLG0saCl9XG5cbiAgJHt5Lm1haW5TdGFydCgpfVxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7aC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtoLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLG0uZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YDtyZXR1cm57bmFtZTpcIkRlcHRoVG9TcGFjZVwiLHNoYWRlckNhY2hlOntoaW50OmAke2UuZGltc307JHt0LmJsb2Nrc2l6ZX07JHt0Lm1vZGV9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOnk9PntsZXQgZz11P1tuLHIqZCxvKmQsaS9kKioyXTpbbixpL2QqKjIscipkLG8qZF0sXz14LnNpemUoZyksdz1jLmRpbXMsdj14LnNvcnRCYXNlZE9uUGVybSh3LGEpO3JldHVybntvdXRwdXRzOlt7ZGltczpnLGRhdGFUeXBlOnlbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChfLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOl99LC4uLlAodyx2KV19fSxnZXRTaGFkZXJTb3VyY2U6Yn19LGtzPShlLHQpPT57U2woZS5pbnB1dHMpLGUuY29tcHV0ZShJbChlLmlucHV0c1swXSx0KSl9LFBzPWU9Pk4oe2Jsb2Nrc2l6ZTplLmJsb2Nrc2l6ZSxtb2RlOmUubW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciBycixsbixCcyxDbCxBbCxvcixpcixEcyxFbCxPcyxNcyxVcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtycj1cIlthLXpBLVpdfFxcXFwuXFxcXC5cXFxcLlwiLGxuPVwiKFwiK3JyK1wiKStcIixCcz1cIl5cIitsbitcIiRcIixDbD1cIihcIitsbitcIiwpKlwiK2xuLEFsPVwiXlwiK0NsK1wiJFwiLG9yPWNsYXNze2NvbnN0cnVjdG9yKHQ9LTEpe3RoaXMuc3ltYm9sVG9JbmRpY2VzPW5ldyBNYXAsdGhpcy5pbnB1dEluZGV4PXR9YWRkU3ltYm9sKHQsbil7bGV0IHI9dGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHQpO3I9PT12b2lkIDA/cj1bbl06ci5wdXNoKG4pLHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldCh0LHIpfX0saXI9Y2xhc3N7Y29uc3RydWN0b3IodCxuKXt0aGlzLmVxdWF0aW9uPW47dGhpcy5oYXNFbGxpcHNpcz0hMSx0aGlzLnN5bWJvbFRvSW5mbz1uZXcgTWFwLHRoaXMubGhzPW5ldyBBcnJheSx0aGlzLm91dHB1dERpbXM9W107bGV0W3Isb109bi5pbmNsdWRlcyhcIi0+XCIpP24uc3BsaXQoXCItPlwiLDIpOltuLFwiXCJdO2lmKCFyLm1hdGNoKFJlZ0V4cChBbCkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7aWYoci5zcGxpdChcIixcIikuZm9yRWFjaCgoYSx1KT0+e2xldCBkPXRbdV0uZGltcy5zbGljZSgpO2lmKCFhLm1hdGNoKFJlZ0V4cChCcykpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IGw9dGhpcy5wcm9jZXNzVGVybShhLCEwLGQsdSk7dGhpcy5saHMucHVzaChsKX0pLG89PT1cIlwiKW8rPVsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldLmZpbHRlcigoW2EsdV0pPT51LmNvdW50PT09MXx8YT09PVwiLi4uXCIpLm1hcCgoW2FdKT0+YSkuam9pbihcIlwiKTtlbHNlIGlmKCFvLm1hdGNoKFJlZ0V4cChsbikpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTXCIpO28ubWF0Y2goUmVnRXhwKHJyLFwiZ1wiKSk/LmZvckVhY2goYT0+e2lmKGE9PT1cIi4uLlwiKXRoaXMub3V0cHV0RGltcz10aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtlbHNle2xldCB1PXRoaXMuc3ltYm9sVG9JbmZvLmdldChhKTtpZih1PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTIHN5bWJvbFwiKTt0aGlzLm91dHB1dERpbXMucHVzaCh1LmRpbVZhbHVlKX19KSx0aGlzLnJocz10aGlzLnByb2Nlc3NUZXJtKG8sITEsdGhpcy5vdXRwdXREaW1zKX1hZGRTeW1ib2wodCxuLHIpe2xldCBvPXRoaXMuc3ltYm9sVG9JbmZvLmdldCh0KTtpZihvIT09dm9pZCAwKXtpZihvLmRpbVZhbHVlIT09biYmby5jb3VudCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc21hdGNoXCIpO28uY291bnQrKyxvLmlucHV0SW5kaWNlcy5wdXNoKHIpfWVsc2Ugbz17Y291bnQ6MSxkaW1WYWx1ZTpuLGlucHV0SW5kaWNlczpbcl19O3RoaXMuc3ltYm9sVG9JbmZvLnNldCh0LG8pfXByb2Nlc3NUZXJtKHQsbixyLG89LTEpe2xldCBpPXIubGVuZ3RoLHM9ITEsYT1bXSx1PTA7aWYoIXQubWF0Y2goUmVnRXhwKEJzKSkmJiFuJiZ0IT09XCJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBkPXQubWF0Y2goUmVnRXhwKHJyLFwiZ1wiKSksbD1uZXcgb3Iobyk7cmV0dXJuIGQ/LmZvckVhY2goKGMscCk9PntpZihjPT09XCIuLi5cIil7aWYocyl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtXCIpO3M9ITA7bGV0IGY9aS1kLmxlbmd0aCsxO2lmKGY8MCl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGE9ci5zbGljZSh1LHUrZiksdGhpcy5oYXNFbGxpcHNpcyl7aWYodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIT09YS5sZW5ndGh8fHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkhPT1hLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaFwiKX1lbHNlIGlmKG4pdGhpcy5oYXNFbGxpcHNpcz0hMCx0aGlzLmVsbGlwc2lzRGltcz1hO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIU1wiKTtmb3IobGV0IG09MDttPGEubGVuZ3RoO20rKyl7bGV0IGg9U3RyaW5nLmZyb21DaGFyQ29kZSg0OCttKTtsLmFkZFN5bWJvbChoLHArbSksdGhpcy5hZGRTeW1ib2woaCxyW3UrK10sbyl9fWVsc2UgbC5hZGRTeW1ib2woYyxwKyh0aGlzLmhhc0VsbGlwc2lzP3RoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aC0xOjApKSx0aGlzLmFkZFN5bWJvbChjLHJbdSsrXSxvKX0pLGx9fSxEcz1lPT5lK1wiX21heFwiLEVsPShlLHQsbixyKT0+e2xldCBpPWUubWFwKGw9PmwubGVuZ3RoKS5tYXAoKGwsYyk9PlMoYGlucHV0JHtjfWAsdCxsKSkscz14LnNpemUociksYT1DKFwib3V0cHV0XCIsdCxyLmxlbmd0aCksdT1bLi4ubi5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIobD0+IW4ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMobCkpLGQ9bD0+e2xldCBjPVtdLHA9XCJ2YXIgcHJvZCA9IDEuMDtcIixmPVwidmFyIHN1bSA9IDAuMDtcIixtPVwic3VtICs9IHByb2Q7XCIsaD1bXSxiPVtdLHk9W10sZz1bXSxfPW4uc3ltYm9sVG9JbmZvLnNpemU9PT1uLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtuLnN5bWJvbFRvSW5mby5mb3JFYWNoKCh2LCQpPT57aWYobi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcygkKSl7bGV0IFQ9bi5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldCgkKT8uWzBdO1QhPT12b2lkIDAmJm4ubGhzLmZvckVhY2goKEksQSk9PntpZih2LmlucHV0SW5kaWNlcy5pbmNsdWRlcyhBKSl7bGV0IHo9SS5zeW1ib2xUb0luZGljZXMuZ2V0KCQpO2lmKHo9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7ei5mb3JFYWNoKE09PntjLnB1c2goYCR7aVtBXS5pbmRpY2VzU2V0KGBpbnB1dCR7QX1JbmRpY2VzYCxNLGEuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixUKSl9YCl9KX19KX1lbHNlIG4ubGhzLmZvckVhY2goKFQsSSk9PntpZih2LmlucHV0SW5kaWNlcy5pbmNsdWRlcyhJKSl7bGV0IEE9VC5zeW1ib2xUb0luZGljZXMuZ2V0KCQpO2lmKEE9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7QS5mb3JFYWNoKHo9PntoLnB1c2goYCR7aVtJXS5pbmRpY2VzU2V0KGBpbnB1dCR7SX1JbmRpY2VzYCx6LGAkeyR9YCl9YCl9KSxnLnB1c2goYHByb2QgKj0gJHtpW0ldLmdldEJ5SW5kaWNlcyhgaW5wdXQke0l9SW5kaWNlc2ApfTtgKX19KSxiLnB1c2goYGZvcih2YXIgJHskfTogdTMyID0gMDsgJHskfSA8IHVuaWZvcm1zLiR7RHMoJCl9OyAkeyR9KyspIHtgKSx5LnB1c2goXCJ9XCIpfSk7bGV0IHc9Xz9bLi4uYyxgbGV0IHN1bSA9ICR7aS5tYXAoKHYsJCk9PnYuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7JH1JbmRpY2VzYCkpLmpvaW4oXCIgKiBcIil9O2BdOlsuLi5jLGYsLi4uYiwuLi5oLHAsLi4uZyxtLC4uLnldO3JldHVybmBcbiAgICAgICAgICAgICR7bC5yZWdpc3RlclVuaWZvcm1zKHUubWFwKHY9Pih7bmFtZTpgJHtEcyh2KX1gLHR5cGU6XCJ1MzJcIn0pKSkucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaSxhKX1cblxuICAgICAgICAgICAgJHtsLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtsLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAke2kubWFwKCh2LCQpPT5gdmFyIGlucHV0JHskfUluZGljZXM6ICR7aVskXS50eXBlLmluZGljZXN9O2ApLmpvaW4oYFxuYCl9XG4gICAgICAgICAgICAke3cuam9pbihgXG5gKX07XG4gICAgICAgICAgICAke2Euc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkVpbnN1bVwiLHNoYWRlckNhY2hlOntoaW50Om4uZXF1YXRpb24saW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKCk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+e2xldCBsPXUuZmlsdGVyKHA9Pm4uc3ltYm9sVG9JbmZvLmhhcyhwKSkubWFwKHA9Pih7dHlwZToxMixkYXRhOm4uc3ltYm9sVG9JbmZvLmdldChwKT8uZGltVmFsdWV8fDB9KSk7bC5wdXNoKHt0eXBlOjEyLGRhdGE6c30pO2xldCBjPWUubWFwKChwLGYpPT5bLi4uUChwKV0pLnJlZHVjZSgocCxmKT0+cC5jb25jYXQoZiksbCk7cmV0dXJuIGMucHVzaCguLi5QKHIpKSx7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTp0fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9LHByb2dyYW1Vbmlmb3JtczpjfX0sZ2V0U2hhZGVyU291cmNlOmR9fSxPcz0oZSx0KT0+e2xldCBuPW5ldyBpcihlLmlucHV0cyx0LmVxdWF0aW9uKSxyPW4ub3V0cHV0RGltcyxvPWUuaW5wdXRzLm1hcCgoaSxzKT0+aS5kaW1zKTtlLmNvbXB1dGUoRWwobyxlLmlucHV0c1swXS5kYXRhVHlwZSxuLHIpKX0sTXM9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxzKy9nLFwiXCIpO3JldHVybiBOKHtlcXVhdGlvbjp0fSl9fSk7dmFyIGtsLFJzLFBsLHpsLFZzLE5zPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtrbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgMiBpbnB1dC5cIik7bGV0IHQ9ZVswXS5kaW1zLG49QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLHI9bi5sZW5ndGg8dC5sZW5ndGg/MDpuLmxlbmd0aC10Lmxlbmd0aCxvPXQubGVuZ3RoPG4ubGVuZ3RoPzA6dC5sZW5ndGgtbi5sZW5ndGg7Zm9yKDtyPG4ubGVuZ3RoJiZvPHQubGVuZ3RoOysrciwrK28paWYobltyXSE9PXRbb10mJm5bcl0hPT0xJiZ0W29dIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dFwiKX0sUnM9KGUsdCk9PntsZXQgbj1lLmxlbmd0aC10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgbz0wO288bjsrK28pci5wdXNoKGVbb10pO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7KytvKXIucHVzaCh0W29dPT09MT9lW28rbl06dFtvXSk7cmV0dXJuIHJ9LFBsPShlLHQpPT5lLmxlbmd0aD50Lmxlbmd0aD9ScyhlLHQpOlJzKHQsZSksemw9ZT0+e2xldCB0PWVbMF0uZGltcyxuPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxyPVBsKHQsbiksbz1lWzBdLmRhdGFUeXBlLGk9bz09PTl8fHguc2l6ZSh0KT09PTEscz1vPT09OXx8dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MD80OjEsYT1pfHxyLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdJTQ9PT0wPzQ6MSx1PU1hdGguY2VpbCh4LnNpemUocikvYSksZD1jPT57bGV0IHA9UyhcImlucHV0XCIsbyx0Lmxlbmd0aCxzKSxmPUMoXCJvdXRwdXRcIixvLHIubGVuZ3RoLGEpLG07aWYobz09PTkpe2xldCBoPShiLHksZz1cIlwiKT0+YFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt5fSA9ICR7Zi5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eX11YCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3l9ID0gJHtwLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt5fWAsZil9O1xuICAgICAgICAgIGxldCBpbmRleCR7eX0gPSBvZmZzZXQke3l9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7eX0gPSBvZmZzZXQke3l9ICUgNHU7XG4gICAgICAgICAgJHtifVske3l9XSA9ICR7Z30oJHtwLmdldEJ5T2Zmc2V0KGBpbmRleCR7eX1gKX1bY29tcG9uZW50JHt5fV0pO1xuICAgICAgICBgO209YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7YX07XG4gICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke2goXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgJHtoKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7aChcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAke2goXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgJHtmLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGF0YVwiKX1cbiAgICAgIH1gfWVsc2UgbT1gXG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtmLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7YX1gKX07XG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7cC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIixmKX07XG4gICAgICAgIGxldCBkYXRhID0gJHtmLnR5cGUudmFsdWV9KCR7cC5nZXRCeU9mZnNldChgaW5wdXRPZmZzZXQgLyAke3N9YCl9KTtcbiAgICAgICAgJHtmLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGF0YVwiKX1cbiAgICAgIH1gO3JldHVybmBcbiAgICAke2MucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHAsZil9XG4gICAgJHtjLm1haW5TdGFydCgpfVxuICAgICR7Yy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgJHttfWB9LGw9W3t0eXBlOjEyLGRhdGE6dX0sLi4uUCh0LHIpXTtyZXR1cm57bmFtZTpcIkV4cGFuZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3IubGVuZ3RofTske3N9JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh1LzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KX19LFZzPWU9PntrbChlLmlucHV0cyksZS5jb21wdXRlKHpsKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBCbCxMcyxXcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7bm4oKTtCbD1lPT57bGV0IHQ9ZVswXS5kYXRhVHlwZSxuPXguc2l6ZShlWzBdLmRpbXMpLHI9eC5zaXplKGVbMV0uZGltcyksbz1yJTQ9PT0wLGk9cz0+e2xldCBhPVMoXCJ4XCIsdCxbMV0sNCksdT1TKFwiYmlhc1wiLHQsWzFdLDQpLGQ9QyhcInlcIix0LFsxXSw0KSxsPVt7bmFtZTpcIm91dHB1dF92ZWNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiaWFzX3NpemVcIix0eXBlOlwidTMyXCJ9XSxjPWY9PmBcbiAgICAgIGxldCBiaWFzJHtmfV9vZmZzZXQ6IHUzMiA9IChnbG9iYWxfaWR4ICogNCArICR7Zn0pICUgdW5pZm9ybXMuYmlhc19zaXplO1xuICAgICAgbGV0IGJpYXMke2Z9ID0gJHt1LmdldEJ5T2Zmc2V0KGBiaWFzJHtmfV9vZmZzZXQgLyA0YCl9W2JpYXMke2Z9X29mZnNldCAlIDRdO2AscD1vP2BcbiAgICAgIGxldCBiaWFzID0gJHt1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5iaWFzX3NpemUgLyA0KVwiKX07YDpgJHtjKDApfSR7YygxKX0ke2MoMil9JHtjKDMpfVxuICAgICAgbGV0IGJpYXMgPSAke2EudHlwZS52YWx1ZX0oYmlhczAsIGJpYXMxLCBiaWFzMiwgYmlhczMpO2A7cmV0dXJuYCR7cy5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXMoYSx1LGQpfVxuXG4gICAgJHtabihjZSh0KSl9XG5cbiAgICAke3MubWFpblN0YXJ0KFllKX1cbiAgICAgICR7cy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3ZlY19zaXplXCIpfVxuXG4gICAgICBsZXQgeCA9ICR7YS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHtwfVxuICAgICAgbGV0IHhfaW4gPSB4ICsgYmlhcztcbiAgICAgICR7ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixRbihcInhfaW5cIikpfVxuICAgIH1gfTtyZXR1cm57bmFtZTpcIkZhc3RHZWx1V2l0aEJpYXNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOmksZ2V0UnVuRGF0YTpzPT4oe291dHB1dHM6W3tkaW1zOnNbMF0uZGltcyxkYXRhVHlwZTpzWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChuLzQpfSx7dHlwZToxMixkYXRhOnJ9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuL1llLzQpfX0pfX0sTHM9ZT0+e2UuaW5wdXRzLmxlbmd0aDwyfHx4LnNpemUoZS5pbnB1dHNbMV0uZGltcyk9PT0wP1VpKGUpOmUuY29tcHV0ZShCbChlLmlucHV0cykpfX0pO3ZhciBEbCxPbCxHcyxIcyxxcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtEbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpfSxPbD0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMV0uZGltcyxvPW4ubGVuZ3RoLGk9eC5ub3JtYWxpemVBeGlzKHQuYXhpcyxvKSxzPW4uc2xpY2UoMCk7cy5zcGxpY2UoaSwxLC4uLnIpO2xldCBhPW5baV0sdT1lWzBdLmRhdGFUeXBlPT09OT80OjEsZD1NYXRoLmNlaWwoeC5zaXplKHMpL3UpLGw9W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6NixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6aX0sLi4uUChlWzBdLmRpbXMsZVsxXS5kaW1zLHMpXSxjPXA9PntsZXQgZj1TKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCx1KSxtPVMoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLGg9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUscy5sZW5ndGgsdSksYj1nPT57bGV0IF89ci5sZW5ndGgsdz1gdmFyIGluZGljZXNJbmRpY2VzJHtnfSAgPSAke20udHlwZS5pbmRpY2VzfSgwKTtgO2ZvcihsZXQgdj0wO3Y8Xzt2Kyspdys9YCR7Xz4xP2BpbmRpY2VzSW5kaWNlcyR7Z31bJHt2fV1gOmBpbmRpY2VzSW5kaWNlcyR7Z31gfSA9ICR7cy5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlcyR7Z31bdW5pZm9ybXMuYXhpcyArICR7dn1dYDpgb3V0cHV0SW5kaWNlcyR7Z31gfTtgO3crPWBcbiAgICAgICAgICB2YXIgaWR4JHtnfSA9ICR7bS5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHtnfWApfTtcbiAgICAgICAgICBpZiAoaWR4JHtnfSA8IDApIHtcbiAgICAgICAgICAgIGlkeCR7Z30gPSBpZHgke2d9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke2d9IDogJHtmLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGA7Zm9yKGxldCB2PTAsJD0wO3Y8bzt2Kyspdj09PWk/KHcrPWAke28+MT9gZGF0YUluZGljZXMke2d9WyR7dn1dYDpgZGF0YUluZGljZXMke2d9YH0gPSB1MzIoaWR4JHtnfSk7YCwkKz1fKToodys9YCR7bz4xP2BkYXRhSW5kaWNlcyR7Z31bJHt2fV1gOmBkYXRhSW5kaWNlcyR7Z31gfSA9ICR7cy5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlcyR7Z31bJHskfV1gOmBvdXRwdXRJbmRpY2VzJHtnfWB9O2AsJCsrKTtyZXR1cm4gd30seTtpZihlWzBdLmRhdGFUeXBlPT09OSl7bGV0IGc9KF8sdyx2PVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3d9ID0gJHtoLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHt3fXVgKX07XG4gICAgICAgICAgJHtiKHcpfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt3fSA9ICR7Zi5pbmRpY2VzVG9PZmZzZXQoYGRhdGFJbmRpY2VzJHt3fWApfTtcbiAgICAgICAgICBsZXQgaW5kZXgke3d9ID0gb2Zmc2V0JHt3fSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke3d9ID0gb2Zmc2V0JHt3fSAlIDR1O1xuICAgICAgICAgICR7X31bJHt3fV0gPSAke3Z9KCR7Zi5nZXRCeU9mZnNldChgaW5kZXgke3d9YCl9W2NvbXBvbmVudCR7d31dKTtcbiAgICAgICAgYDt5PWBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke3V9O1xuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7ZyhcInZhbHVlXCIsMCxcInUzMlwiKX1cbiAgICAgICAgJHtnKFwidmFsdWVcIiwxLFwidTMyXCIpfVxuICAgICAgICAke2coXCJ2YWx1ZVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcInZhbHVlXCIsMyxcInUzMlwiKX1cbiAgICAgICAgJHtoLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gICAgICBgfWVsc2UgeT1gXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7aC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICR7YihcIlwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAke2YuZ2V0QnlJbmRpY2VzKFwiZGF0YUluZGljZXNcIil9O1xuICAgICAgJHtoLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgYDtyZXR1cm5gXG4gICAgICAke3AucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNEaW1MaW1pdFwiLFwiaTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGYsbSxoKX1cbiAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAke3l9XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NCl9LHByb2dyYW1Vbmlmb3JtczpsfSksZ2V0U2hhZGVyU291cmNlOmN9fSxHcz1lPT5OKHtheGlzOmUuYXhpc30pLEhzPShlLHQpPT57bGV0IG49ZS5pbnB1dHM7RGwobiksZS5jb21wdXRlKE9sKGUuaW5wdXRzLHQpKX19KTt2YXIgTWwsRnMsS3MsanM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO01sPShlLHQsbixyLG8saSxzLGEsdSk9PntsZXQgZD1be3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp1fV0sbD1baV07ZC5wdXNoKC4uLlAodC5kaW1zLGwpKTtsZXQgYz1wPT57bGV0IGY9UyhcImluZGljZXNfZGF0YVwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksbT1DKFwiaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhXCIsMTIsMSwxKSxoPVtmLG1dLGI9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfZGltc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6bi5sZW5ndGh9LHtuYW1lOlwibnVtX3NsaWNlc19wZXJfYmF0Y2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfYmF0Y2hfc3RyaWRlXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9zbGljZV9kaW1zXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke3AucmVnaXN0ZXJVbmlmb3JtcyhiKS5kZWNsYXJlVmFyaWFibGVzKC4uLmgpfVxuICAke3AubWFpblN0YXJ0KCl9XG4gICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7by5sZW5ndGg9PT0xP1wiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpO1wiOlwiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pO1wifVxuICAgICAgfVxuICAgICAgJHtuLmxlbmd0aD09PTE/XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpO1wiOlwicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTtcIn1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJjb21wdXRlU2xpY2VPZmZzZXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9XyR7bi5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6ZS5pbnB1dHNbMV0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9KSxnZXRTaGFkZXJTb3VyY2U6Y30se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF19LEZzPShlLHQpPT57bGV0IG49ZS5pbnB1dHMscj1uWzBdLmRpbXMsbz1uWzBdLmRhdGFUeXBlLGk9blsxXS5kaW1zLHM9aVtpLmxlbmd0aC0xXSxhPXguc2l6ZVRvRGltZW5zaW9uKGksaS5sZW5ndGgtMSksdT14LnNpemVGcm9tRGltZW5zaW9uKHIsdC5iYXRjaERpbXMrcyksZD14LnNpemVUb0RpbWVuc2lvbihyLHQuYmF0Y2hEaW1zKSxsPXguc2l6ZUZyb21EaW1lbnNpb24ocix0LmJhdGNoRGltcyksYz1hL2QscD1uZXcgQXJyYXkocyksZj11O2ZvcihsZXQgdz0wO3c8czsrK3cpcFtzLTEtd109ZixmKj1yW3QuYmF0Y2hEaW1zK3MtMS13XTtsZXQgbT1NbChlLG5bMV0scCx0LmJhdGNoRGltcyxyLGEsYyxsLHMpLGg9dC5iYXRjaERpbXMrcztpZihoPnIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3JcIik7bGV0IGI9aS5zbGljZSgwLC0xKS5jb25jYXQoci5zbGljZShoKSkseT14LnNpemUoYiksZz1be3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOnV9LC4uLlAoblswXS5kaW1zLG0uZGltcyxiKV0sXz13PT57bGV0IHY9UyhcImRhdGFcIixuWzBdLmRhdGFUeXBlLG5bMF0uZGltcy5sZW5ndGgpLCQ9UyhcInNsaWNlX29mZnNldHNcIiwxMixtLmRpbXMubGVuZ3RoKSxUPUMoXCJvdXRwdXRcIixuWzBdLmRhdGFUeXBlLGIubGVuZ3RoKTtyZXR1cm5gXG4gICAgICAgICAgJHt3LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2xpY2Vfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModiwkLFQpfVxuICAgICAgICAgICAgJHt3Lm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHt3Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkdhdGhlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmIsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Z30pLGdldFNoYWRlclNvdXJjZTpffSx7aW5wdXRzOltuWzBdLG1dfSl9LEtzPWU9Pih7YmF0Y2hEaW1zOmUuYmF0Y2hfZGltcyxjYWNoZUtleTpcIlwifSl9KTt2YXIgVWwsUmwsWnMsUXMsWHM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7VWw9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIkdhdGhlckJsb2NrUXVhbnRpemVkIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMuXCIpO2xldCBuPXgubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxyPXQuYmxvY2tTaXplLG89ZVswXSxpPWVbMl0scz1lLmxlbmd0aD09PTQ/ZVszXTp2b2lkIDA7aWYoaS5kaW1zLmxlbmd0aCE9PW8uZGltcy5sZW5ndGh8fCFvLmRpbXMubWFwKChhLHUpPT51PT09bj9NYXRoLmNlaWwoYS9yKT09PWkuZGltc1t1XTphPT09aS5kaW1zW3VdKS5yZWR1Y2UoKGEsdSk9PmEmJnUsITApKXRocm93IG5ldyBFcnJvcihcIlNjYWxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIGdhdGhlckF4aXMuXCIpO2lmKHMpe2lmKHMuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihzLmRpbXMubGVuZ3RoIT09aS5kaW1zLmxlbmd0aHx8IXMuZGltcy5tYXAoKGEsdSk9PmE9PT1pLmRpbXNbdV0pLnJlZHVjZSgoYSx1KT0+YSYmdSwhMCkpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIHF1YW50aXplQXhpcy5cIil9fSxSbD0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMV0uZGltcyxvPW4ubGVuZ3RoLGk9eC5ub3JtYWxpemVBeGlzKHQuZ2F0aGVyQXhpcyxvKSxzPXgubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxvKSxhPW4uc2xpY2UoMCk7YS5zcGxpY2UoaSwxLC4uLnIpO2xldCB1PXguc2l6ZShhKSxkPWVbMl0uZGF0YVR5cGUsYz1lWzBdLmRhdGFUeXBlPT09MjIscD1be3R5cGU6MTIsZGF0YTp1fSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uUCguLi5lLm1hcCgobSxoKT0+bS5kaW1zKSxhKV0sZj1tPT57bGV0IGg9UyhcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLGI9UyhcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCkseT1TKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxnPWUubGVuZ3RoPjM/UyhcInplcm9Qb2ludFwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwLF89QyhcIm91dHB1dFwiLGQsYS5sZW5ndGgpLHc9W2gsYix5XTtnJiZ3LnB1c2goZyk7bGV0IHY9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicXVhbnRpemVfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJnYXRoZXJfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgICAke20ucmVnaXN0ZXJVbmlmb3Jtcyh2KS5kZWNsYXJlVmFyaWFibGVzKC4uLncsXyl9XG4gICAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5kaWNlc19pbmRpY2VzID0gJHtiLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICR7ci5sZW5ndGg+MT9gXG4gICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7Xy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzICsgaVwiKX07XG4gICAgICAgICAgICAke2IuaW5kaWNlc1NldChcImluZGljZXNfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICAgIH1gOmBpbmRpY2VzX2luZGljZXMgPSAke18uaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiKX07YH07XG4gICAgICAgIHZhciBkYXRhX2luZGljZXMgPSAke2gudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke18uaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAke2guaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleF9mcm9tX2luZGljZXMgPSAke2IuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc19pbmRpY2VzXCIpfTtcbiAgICAgICAgaWYgKGluZGV4X2Zyb21faW5kaWNlcyA8IDApIHtcbiAgICAgICAgICBpbmRleF9mcm9tX2luZGljZXMgKz0gJHtuW2ldfTtcbiAgICAgICAgfVxuICAgICAgICAke2guaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXNcIixcInUzMihpbmRleF9mcm9tX2luZGljZXMpXCIpfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHVuaWZvcm1zLmdhdGhlcl9heGlzICsgMTsgaSA8ICR7YS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke18uaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsYGkgKyAke3IubGVuZ3RofSAtIDFgKX07XG4gICAgICAgICAgJHtoLmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YV9vZmZzZXQgPSAke2guaW5kaWNlc1RvT2Zmc2V0KFwiZGF0YV9pbmRpY2VzXCIpfTtcbiAgICAgICAgbGV0IGRhdGFfaW5kZXggPSBkYXRhX29mZnNldCAlIDg7XG4gICAgICAgIC8vIENvbnZlcnQgNC1iaXQgcGFja2VkIGRhdGEgdG8gOC1iaXQgcGFja2VkIGRhdGEuXG4gICAgICAgIGxldCBwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA9ICR7aC5nZXRCeU9mZnNldChcImRhdGFfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgIGxldCBwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSA9IChwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA+PiAoNCAqIChkYXRhX2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke2M/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSkpO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGEgPSBxdWFudGl6ZWRfZGF0YV92ZWNbZGF0YV9pbmRleCAvIDJdO1xuICAgICAgICB2YXIgc2NhbGVfaW5kaWNlcyA9IGRhdGFfaW5kaWNlcztcbiAgICAgICAgbGV0IHF1YW50aXplX2F4aXNfaW5kZXggPSAke3kuaW5kaWNlc0dldChcImRhdGFfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAke3kuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLnF1YW50aXplX2F4aXNcIixcInF1YW50aXplX2F4aXNfaW5kZXhcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke3kuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICR7Zz9gXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGljZXMgPSBzY2FsZV9pbmRpY2VzO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke2cuaW5kaWNlc1RvT2Zmc2V0KFwiemVyb19wb2ludF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSB6ZXJvX3BvaW50X29mZnNldCAlIDg7XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA9ICR7Zy5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfOGJpdF96ZXJvX3BvaW50cyA9IChwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA+PiAoNCAqICh6ZXJvX3BvaW50X2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7Yz9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A6XCJ2YXIgemVyb19wb2ludCA9IDBcIn07XG4gICAgICAgIGxldCBkZXF1YW50aXplZF9kYXRhID0gJHtjZShkKX0ocXVhbnRpemVkX2RhdGEgLSB6ZXJvX3BvaW50KSAqIHNjYWxlO1xuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkZXF1YW50aXplZF9kYXRhXCIpfTtcbiAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7ZS5maWx0ZXIoKG0saCk9PmghPT0xKS5tYXAobT0+bS5kaW1zLmpvaW4oXCJfXCIpKS5qb2luKFwiO1wiKX1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5LmZyb20oe2xlbmd0aDplLmxlbmd0aH0sKG0saCk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmR9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh1LzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6Zn19LFpzPShlLHQpPT57bGV0IG49ZS5pbnB1dHM7VWwobix0KSxlLmNvbXB1dGUoUmwoZS5pbnB1dHMsdCkpfSxRcz1lPT5OKHtibG9ja1NpemU6ZS5ibG9ja1NpemUsZ2F0aGVyQXhpczplLmdhdGhlckF4aXMscXVhbnRpemVBeGlzOmUucXVhbnRpemVBeGlzfSl9KTt2YXIgVmwsTmwsWXMsSnMsZWE9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7Vmw9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKX0sTmw9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1lWzBdLmRhdGFUeXBlLG89bi5sZW5ndGgsaT1lWzFdLmRpbXMscz1lWzFdLmRhdGFUeXBlLGE9eC5ub3JtYWxpemVBeGlzKHQuYXhpcyxvKSx1PW5bYV0sZD1pLnNsaWNlKDApLGw9eC5zaXplKGQpLGM9UyhcImlucHV0XCIscixvKSxwPVMoXCJpbmRpY2VzSW5wdXRcIixzLGkubGVuZ3RoKSxmPUMoXCJvdXRwdXRcIixyLGQubGVuZ3RoKSxtPVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjYsZGF0YTp1fSx7dHlwZToxMixkYXRhOmF9XTtyZXR1cm4gbS5wdXNoKC4uLlAobixpLGQpKSx7bmFtZTpcIkdhdGhlckVsZW1lbnRzXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnk9PmBcbiAgICAgICR7eS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYyxwLGYpfVxuICAgICAgJHt5Lm1haW5TdGFydCgpfVxuICAgICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Zi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgdmFyIGlkeCA9ICR7cC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgaWR4ID0gaWR4ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7Yy50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtjLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpZHgpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Yy5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuXG4gICAgICAke2Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gIH1gfX0sWXM9ZT0+Tih7YXhpczplLmF4aXN9KSxKcz0oZSx0KT0+e2xldCBuPWUuaW5wdXRzO1ZsKG4pLGUuY29tcHV0ZShObChlLmlucHV0cyx0KSl9fSk7dmFyIExsLFdsLHRhLG5hLHJhPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtMbD1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sV2w9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMuc2xpY2UoKSxyPWVbMV0uZGltcy5zbGljZSgpLFtvLGksc109R3QuZ2V0U2hhcGVPZkdlbW1SZXN1bHQobix0LnRyYW5zQSxyLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxhPVtvLGldO2lmKCFhKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCB1PTE2LGQ9TWF0aC5jZWlsKGkvdSksbD1NYXRoLmNlaWwoby91KSxjPSEwLHA9eC5zaXplKGEpLGY9W3t0eXBlOjEyLGRhdGE6Yz9kOnB9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEsZGF0YTp0LmFscGhhfSx7dHlwZToxLGRhdGE6dC5iZXRhfV0sbT1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2UubGVuZ3RoPT09MyYmKGYucHVzaCguLi5QKGVbMl0uZGltcykpLG0ucHVzaChcInJhbmtcIikpLGYucHVzaCguLi5QKGEpKTtsZXQgaD15PT57bGV0IGc9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/Zz1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP2c9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj9nPVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYoZz1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIik7bGV0IF89dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiLHc9UyhcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksdj1TKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSwkPXcudHlwZS52YWx1ZSxUPW51bGwsST1bdyx2XTtlLmxlbmd0aD09PTMmJihUPVMoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxJLnB1c2goVCkpO2xldCBBPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoKTtJLnB1c2goQSk7bGV0IHo9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybXMoeikuZGVjbGFyZVZhcmlhYmxlcyguLi5JKX1cblxuICAke3kubWFpblN0YXJ0KCl9XG4gICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7JH0oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7Z31cbiAgICB9XG5cbiAgICAke199XG4gICAgJHtUIT1udWxsP2BsZXQgY09mZnNldCA9ICR7VC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIixBKX07IHZhbHVlICs9ICR7JH0odW5pZm9ybXMuYmV0YSkgKiAke1QuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCJ9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gIH1gfSxiPXk9PntsZXQgZz1TKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxfPVMoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLHc9bnVsbCx2PVtnLF9dO2UubGVuZ3RoPT09MyYmKHc9UyhcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLHYucHVzaCh3KSk7bGV0ICQ9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgpO3YucHVzaCgkKTtsZXQgVD1be25hbWU6XCJudW1fdGlsZV9uXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9XSxJPVwiXCIsQT1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj8oQT1gXG4gICAgICB2YXIgY29sID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLk0gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtnLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Xy50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsST1cInZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtcIik6dC50cmFuc0EmJiF0LnRyYW5zQj8oQT1gXG4gICAgICB2YXIgY29sID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLk0gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtnLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Xy50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsST1cInZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtcIik6IXQudHJhbnNBJiZ0LnRyYW5zQj8oQT1gXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtnLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Xy50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsST1cInZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtcIik6IXQudHJhbnNBJiYhdC50cmFuc0ImJihBPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2cudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtfLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxJPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTtsZXQgej10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCI7cmV0dXJuYFxuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhUKS5kZWNsYXJlVmFyaWFibGVzKC4uLnYpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlX2E6IGFycmF5PGFycmF5PCR7Zy50eXBlLnN0b3JhZ2V9LCAke3V9PiwgJHt1fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYjogYXJyYXk8YXJyYXk8JHtfLnR5cGUuc3RvcmFnZX0sICR7dX0+LCAke3V9PjtcbiAgJHt5Lm1haW5TdGFydChbdSx1LDFdKX1cbiAgICBsZXQgdGlsZV9jb2xfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke3V9O1xuICAgIGxldCB0aWxlX3Jvd19zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7dX07XG4gICAgbGV0IG51bV90aWxlcyA9ICh1bmlmb3Jtcy5LIC0gMSkgLyAke3V9ICsgMTtcbiAgICB2YXIga19zdGFydCA9IDB1O1xuICAgIHZhciB2YWx1ZSA9ICR7JC50eXBlLnZhbHVlfSgwKTtcbiAgICBmb3IgKHZhciB0OiB1MzIgPSAwdTsgdCA8IG51bV90aWxlczsgdCsrKSB7XG4gICAgICAke0F9XG4gICAgICBrX3N0YXJ0ID0ga19zdGFydCArICR7dX07XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgJHt1fTsgaysrKSB7XG4gICAgICAgICR7SX1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICAke3p9XG4gICAgbGV0IG0gPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgbGV0IG4gPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgJHt3IT1udWxsP2BsZXQgY09mZnNldCA9ICR7dy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIiwkKX07IHZhbHVlICs9ICR7JC50eXBlLnZhbHVlfSh1bmlmb3Jtcy5iZXRhKSAqICR7dy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIn1cbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIG91dHB1dFttICogdW5pZm9ybXMuTiArIG5dID0gdmFsdWU7XG4gICAgfVxuICB9YH07cmV0dXJuIGM/e25hbWU6XCJHZW1tU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOm19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpkKmx9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOmJ9OntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczptfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pLGdldFNoYWRlclNvdXJjZTpofX0sdGE9ZT0+e2xldCB0PWUudHJhbnNBLG49ZS50cmFuc0Iscj1lLmFscGhhLG89ZS5iZXRhO3JldHVybnt0cmFuc0E6dCx0cmFuc0I6bixhbHBoYTpyLGJldGE6byxjYWNoZUtleTpgJHtlLnRyYW5zQX07JHtlLnRyYW5zQn07JHtlLmFscGhhPT09MX1gfX0sbmE9KGUsdCk9PntMbChlLmlucHV0cyksZS5jb21wdXRlKFdsKGUuaW5wdXRzLHQpKX19KTt2YXIgTmUsS2UsaXQsc3QsR2wsSGwscWwsRmwsS2wsamwsWmwsUWwsb2EsaWEsc2E9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7W05lLEtlLGl0LHN0XT1bMCwxLDIsM10sR2w9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIm9ubHkgNC1EIHRlbnNvciBpcyBzdXBwb3J0ZWQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImlucHV0IGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCB0byBncmlkIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zLmxlbmd0aC0yIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMV0pdGhyb3cgbmV3IEVycm9yKGBsYXN0IGRpbWVuc2lvbiBvZiBncmlkIG11c3QgYmUgZXF1YWwgdG8gJHtlWzBdLmRpbXMubGVuZ3RoLTJ9YCk7aWYoZVswXS5kaW1zWzBdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImdyaWQgYmF0Y2ggc2l6ZSBtdXN0IG1hdGNoIGlucHV0IGJhdGNoIHNpemVcIil9LEhsPWBcbiAgZm4gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4OiBmMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgbGV0IGN1YmljX2FscGhhID0gLTAuNzVmO1xuICAgIGxldCB4X2FicyA9IGFicyh4KTtcbiAgICB2YXIgY29lZmZzOiB2ZWM0PGYzMj47XG4gICAgY29lZmZzWzBdID0gKCgoY3ViaWNfYWxwaGEgKiAoeF9hYnMgKyAxKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSArIDggKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgY29lZmZzWzFdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqIHhfYWJzIC0gKGN1YmljX2FscGhhICsgMykpICogeF9hYnMgKiB4X2FicyArIDEpO1xuICAgIGNvZWZmc1syXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiAoMSAtIHhfYWJzKSAtIChjdWJpY19hbHBoYSArIDMpKSAqICgxIC0geF9hYnMpICogKDEgLSB4X2FicykgKyAxKTtcbiAgICBjb2VmZnNbM10gPSAoKChjdWJpY19hbHBoYSAqICgyIC0geF9hYnMpIC0gNSAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpICsgOCAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5gLHFsPWU9PmBcbiAgZm4gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwOiBtYXQ0eDQ8JHtlfT4sIHg6IGYzMiwgeTogZjMyKSAtPiAke2V9IHtcbiAgICB2YXIgdjogdmVjNDxmMzI+O1xuICAgIHZhciBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB2W2ldID0gY29lZmZzWzBdICogcFtpXVswXSArIGNvZWZmc1sxXSAqIHBbaV1bMV0gKyBjb2VmZnNbMl0gKiBwW2ldWzJdICsgY29lZmZzWzNdICogcFtpXVszXTtcbiAgICB9XG4gICAgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh5KTtcbiAgICBsZXQgcGl4ZWwgPSAke2V9KGNvZWZmc1swXSAqIHZbMF0gKyBjb2VmZnNbMV0gKiB2WzFdICsgY29lZmZzWzJdICogdlsyXSArIGNvZWZmc1szXSAqIHZbM10pO1xuICAgIHJldHVybiBwaXhlbDtcbiAgfVxuYCxGbD1lPT5gXG4gIGZuIGdzX2Rlbm9ybWFsaXplKG46IGYzMiwgbGVuZ3RoOiBpMzIpIC0+IGYzMiB7XG4gICAgJHtlLmFsaWduQ29ybmVycz09PTA/YFxuICAgIC8vIGFsaWduQ29ybmVyczogZmFsc2UgPT4gWy0xLCAxXSB0byBbLTAuNSwgbGVuZ3RoIC0gMC41XVxuICAgIHJldHVybiAoKG4gKyAxLjApICogZjMyKGxlbmd0aCkgLSAxLjApIC8gMi4wO1xuICAgIGA6YFxuICAgIC8vIGFsaWduQ29ybmVyczogdHJ1ZSA9PiBbLTEsIDFdIHRvIFswLCBsZW5ndGggLSAxXVxuICAgIHJldHVybiAobiArIDEuMCkgLyAyLjAgKiAoZjMyKGxlbmd0aCAtIDEpKTtcbiAgICBgfVxuICB9XG5gLEtsPWU9PmBcbiAgJHtlLnBhZGRpbmdNb2RlPT09XCJyZWZsZWN0aW9uXCI/YFxuICAgICAgZm4gZ3NfcmVmbGVjdCh4OiBpMzIsIHhfbWluOiBmMzIsIHhfbWF4OiBmMzIpIC0+IHUzMiB7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGZ4ID0gZjMyKHgpO1xuICAgICAgICBsZXQgcmFuZ2UgPSB4X21heCAtIHhfbWluO1xuICAgICAgICBpZiAoZnggPCB4X21pbikge1xuICAgICAgICAgIGR4ID0geF9taW4gLSBmeDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnggPiB4X21heCkge1xuICAgICAgICAgIGR4ID0gZnggLSB4X21heDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUzMihmeCk7XG4gICAgICB9YDpcIlwifVxuYCxqbD0oZSx0LG4pPT5gXG4gIGZuIHBpeGVsX2F0X2dyaWQocjogaTMyLCBjOiBpMzIsIEg6IGkzMiwgVzogaTMyLCBiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGJvcmRlcjogdmVjNDxmMzI+KSAtPiAke3R9IHtcbiAgICAgdmFyIHBpeGVsID0gJHt0fSgwKTtcbiAgICAgdmFyIGluZGljZXMgPSB2ZWM0PHUzMj4oMCk7XG4gICAgIGluZGljZXNbJHtOZX1dID0gYmF0Y2g7XG4gICAgIGluZGljZXNbJHtLZX1dID0gY2hhbm5lbDtgKygoKT0+e3N3aXRjaChuLnBhZGRpbmdNb2RlKXtjYXNlXCJ6ZXJvc1wiOnJldHVybmBcbiAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBIICYmIGMgPj0wICYmIGMgPCBXKSB7XG4gICAgICAgICAgICBpbmRpY2VzWyR7aXR9XSA9IHUzMihyKTtcbiAgICAgICAgICAgIGluZGljZXNbJHtzdH1dID0gdTMyKGMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHt0fSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7Y2FzZVwiYm9yZGVyXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtpdH1dID0gdTMyKGNsYW1wKHIsIDAsIEggLSAxKSk7XG4gICAgICAgICAgaW5kaWNlc1ske3N0fV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcbiAgICAgICAgYDtjYXNlXCJyZWZsZWN0aW9uXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtpdH1dID0gZ3NfcmVmbGVjdChyLCBib3JkZXJbMV0sIGJvcmRlclszXSk7XG4gICAgICAgICAgaW5kaWNlc1ske3N0fV0gPSBnc19yZWZsZWN0KGMsIGJvcmRlclswXSwgYm9yZGVyWzJdKTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcGFkZGluZyBtb2RlICR7bi5wYWRkaW5nTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYFxuICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKX07XG4gIH1cbmAsWmw9KGUsdCxuKT0+KCgpPT57c3dpdGNoKG4ubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcGl4ZWxfYXRfZ3JpZChpMzIocm91bmQoeSkpLCBpMzIocm91bmQoeCkpLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7TmV9XSwgaW5kaWNlc1ske0tlfV0sIGJvcmRlcik7XG4gICAgICAgIGA7Y2FzZVwiYmlsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgxID0gaTMyKGZsb29yKHgpKTtcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcbiAgICAgICAgICBsZXQgeTIgPSB5MSArIDE7XG5cbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtOZX1dLCBpbmRpY2VzWyR7S2V9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtOZX1dLCBpbmRpY2VzWyR7S2V9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIxID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtOZX1dLCBpbmRpY2VzWyR7S2V9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtOZX1dLCBpbmRpY2VzWyR7S2V9XSwgYm9yZGVyKTtcblxuICAgICAgICAgIGxldCBkeDIgPSAke3R9KGYzMih4MikgLSB4KTtcbiAgICAgICAgICBsZXQgZHgxID0gJHt0fSh4IC0gZjMyKHgxKSk7XG4gICAgICAgICAgbGV0IGR5MiA9ICR7dH0oZjMyKHkyKSAtIHkpO1xuICAgICAgICAgIGxldCBkeTEgPSAke3R9KHkgLSBmMzIoeTEpKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZHkyICogKGR4MiAqIHAxMSArIGR4MSAqIHAxMikgKyBkeTEgKiAoZHgyICogcDIxICsgZHgxICogcDIyKTtcbiAgICAgICAgYDtjYXNlXCJiaWN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MCA9IGkzMihmbG9vcih4KSkgLSAxO1xuICAgICAgICAgIGxldCB5MCA9IGkzMihmbG9vcih5KSkgLSAxO1xuICAgICAgICAgIHZhciBwOiBtYXQ0eDQ8JHt0fT47XG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA0OyBoKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7TmV9XSwgaW5kaWNlc1ske0tlfV0sIGJvcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xuICAgICAgICAgIGxldCBkeSA9IHkgLSBmMzIoeTAgKyAxKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBtb2RlICR7bi5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgJHtlLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwicmVzdWx0XCIpfWAsUWw9KGUsdCk9PntsZXQgbj1TKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCkscj1bZVsxXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dLG89UyhcImdyaWRcIixlWzFdLmRhdGFUeXBlLHIubGVuZ3RoLDIpLGk9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV07dC5mb3JtYXQ9PT1cIk5IV0NcIiYmKGk9W2VbMF0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMF0uZGltc1szXV0sW05lLEtlLGl0LHN0XT1bMCwzLDEsMl0pO2xldCBzPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGkubGVuZ3RoKSxhPW4udHlwZS52YWx1ZSx1PXguc2l6ZShpKSxkPVt7dHlwZToxMixkYXRhOnV9LC4uLlAoZVswXS5kaW1zLHIsaSldLGw9Yz0+YFxuICAke2MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG4sbyxzKX1cbiAgJHtIbH1cbiAgJHtxbChhKX1cbiAgJHtGbCh0KX1cbiAgJHtLbCh0KX1cbiAgJHtqbChuLGEsdCl9XG5cbiAgJHtjLm1haW5TdGFydCgpfVxuICAgICR7Yy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7aXR9XSk7XG4gICAgICBsZXQgV19pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7c3R9XSk7XG5cbiAgICAgICR7dC5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAwLjU7XG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xuICAgICAgYDpgXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XG4gICAgICBsZXQgeV9taW4gPSAwLjA7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XG4gICAgICBgfTtcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xuXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7cy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske05lfV0sIGluZGljZXNbJHtpdH1dLCBpbmRpY2VzWyR7c3R9XSk7XG4gICAgICBsZXQgbnh5ID0gJHtvLmdldEJ5SW5kaWNlcyhcImdyaWRfaW5kaWNlc1wiKX07XG4gICAgICB2YXIgeCA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMF0pLCBXX2luKTtcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xuXG4gICAgICAke1psKHMsYSx0KX1cbiAgfWA7cmV0dXJue25hbWU6XCJHcmlkU2FtcGxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6Yz0+e2xldCBwPXguc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTpjWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczpkfX0sZ2V0U2hhZGVyU291cmNlOmx9fSxvYT0oZSx0KT0+e0dsKGUuaW5wdXRzKSxlLmNvbXB1dGUoUWwoZS5pbnB1dHMsdCkpfSxpYT1lPT5OKHthbGlnbkNvcm5lcnM6ZS5hbGlnbl9jb3JuZXJzLG1vZGU6ZS5tb2RlLHBhZGRpbmdNb2RlOmUucGFkZGluZ19tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIGdlLEpsLHVhLGFhLGVjLF90LGRhLHNyPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7WnQoKTtlbigpO0soKTtWZSgpO2dlPShlLHQpPT5lLmxlbmd0aD50JiZlW3RdLmRpbXMubGVuZ3RoPjA/ZVt0XTp2b2lkIDAsSmw9KGUsdCk9PntsZXQgbj1lWzBdLHI9Z2UoZSwxKSxvPWdlKGUsMiksaT1nZShlLDMpLHM9Z2UoZSw0KSxhPWdlKGUsNSksdT1nZShlLDYpLGQ9Z2UoZSw3KTtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9uc1wiKTtsZXQgbD1uLmRpbXNbMF0sYz1uLmRpbXNbMV0scD1uLmRpbXMubGVuZ3RoPT09Mz9uLmRpbXNbMl06dC5udW1IZWFkcypuLmRpbXNbNF0sZj1jLG09MCxoPTAsYj1NYXRoLmZsb29yKHAvdC5udW1IZWFkcyk7aWYodSYmZCYmeC5zaXplKHUuZGltcykmJnguc2l6ZShkLmRpbXMpKXtpZih1LmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKHUuZGltc1swXSE9PWx8fHUuZGltc1sxXSE9PXQubnVtSGVhZHN8fHUuZGltc1szXSE9PWIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtpZihkLmRpbXNbMF0hPT1sfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbM10hPT1iKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtpZih1LmRpbXNbMl0hPT1kLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAocGFzdF9zZXF1ZW5jZV9sZW5ndGgpJyk7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO209dS5kaW1zWzJdLGg9dS5kaW1zWzJdfWVsc2UgaWYodSYmeC5zaXplKHUuZGltcyl8fGQmJnguc2l6ZShkLmRpbXMpKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgeTtpZihyJiZ4LnNpemUoci5kaW1zKT4wKXtpZihuLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO2lmKHIuZGltcy5sZW5ndGg8M3x8ci5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PXIuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7aWYoci5kaW1zLmxlbmd0aD09PTMpe2lmKHIuZGltc1syXSE9PW4uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKScpO3k9MixmPXIuZGltc1sxXX1lbHNlIGlmKHIuZGltcy5sZW5ndGg9PT01KXtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0yfHxyLmRpbXNbNF0hPT1iKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtpZihvKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTt5PTUsZj1yLmRpbXNbMV19ZWxzZXtpZihyLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT1iKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO3k9MCxmPXIuZGltc1syXX19ZWxzZXtpZihuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTMpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7eT0zfWlmKGkmJnguc2l6ZShpLmRpbXMpPjApe2lmKGkuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO2lmKHImJnIuZGltcy5sZW5ndGg9PT01JiZyLmRpbXNbM109PT0yKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi5cIil9bGV0IGc9bStmLF89MDtpZihzJiZ4LnNpemUocy5kaW1zKT4wKXtfPTg7bGV0IFQ9cy5kaW1zO3Rocm93IFQubGVuZ3RoPT09MT9UWzBdPT09bD9fPTE6VFswXT09PTMqbCsyJiYoXz0zKTpULmxlbmd0aD09PTImJlRbMF09PT1sJiZUWzFdPT09ZyYmKF89NSksXz09PTg/bmV3IEVycm9yKCdJbnB1dCBcImtleV9wYWRkaW5nX21hc2tcIiBzaGFwZSBzaGFsbCBiZSAoYmF0Y2hfc2l6ZSkgb3IgKGJhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTpuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIil9bGV0IHc9ITEsdj1wO2lmKG8mJnguc2l6ZShvLmRpbXMpPjApe2lmKG8uZGltcy5sZW5ndGghPT0zJiZvLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09by5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO2lmKG8uZGltcy5sZW5ndGg9PT0zKXtpZihmIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTt2PW8uZGltc1syXX1lbHNle2lmKGYhPT1vLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO3Y9by5kaW1zWzFdKm8uZGltc1szXSx3PSEwfX1sZXQgJD0hMTtpZihzJiZ4LnNpemUocy5kaW1zKT4wKXRocm93IG5ldyBFcnJvcihcIktleSBwYWRkaW5nIG1hc2sgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihhJiZ4LnNpemUoYS5kaW1zKT4wKXtpZihhLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGEuZGltc1swXSE9PWx8fGEuZGltc1sxXSE9PXQubnVtSGVhZHN8fGEuZGltc1syXSE9PWN8fGEuZGltc1szXSE9PWcpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpfXJldHVybntiYXRjaFNpemU6bCxzZXF1ZW5jZUxlbmd0aDpjLHBhc3RTZXF1ZW5jZUxlbmd0aDptLGt2U2VxdWVuY2VMZW5ndGg6Zix0b3RhbFNlcXVlbmNlTGVuZ3RoOmcsbWF4U2VxdWVuY2VMZW5ndGg6aCxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOnAsdkhpZGRlblNpemU6dixoZWFkU2l6ZTpiLHZIZWFkU2l6ZTpNYXRoLmZsb29yKHYvdC5udW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxpc1VuaWRpcmVjdGlvbmFsOiExLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza0ZpbHRlclZhbHVlOnQubWFza0ZpbHRlclZhbHVlLG1hc2tUeXBlOl8sc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOiQscGFzc1Bhc3RJbkt2OncscWt2Rm9ybWF0Onl9fSx1YT1lPT5OKHsuLi5lfSksYWE9Tih7cGVybTpbMCwyLDEsM119KSxlYz0oZSx0LG4scixvLGkscyk9PntsZXQgYT1bcixvLGldLHU9eC5zaXplKGEpLGQ9W3t0eXBlOjEyLGRhdGE6dX0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOml9XSxsPWM9PntsZXQgcD1DKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsYSksZj1TKFwicWt2XCIsdC5kYXRhVHlwZSxhKSxtPVMoXCJiaWFzXCIsbi5kYXRhVHlwZSxhKSxoPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2MucmVnaXN0ZXJVbmlmb3JtcyhoKS5kZWNsYXJlVmFyaWFibGVzKGYsbSxwKX1cbiAgJHtjLm1haW5TdGFydCgpfVxuICAgICR7Yy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pLGdldFNoYWRlclNvdXJjZTpsfSx7aW5wdXRzOlt0LG5dLG91dHB1dHM6Wy0xXX0pWzBdfSxfdD0oZSx0LG4scixvLGkscyxhKT0+e2xldCB1PWk7aWYocyYmeC5zaXplKHMuZGltcyk+MCl7aWYocj09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiB1PWVjKGUsaSxzLHQscixuKm8sYSksdT11LnJlc2hhcGUoW3QscixuLG9dKSxuPT09MXx8cj09PTE/dTplLmNvbXB1dGUocGUodSxhYS5wZXJtKSx7aW5wdXRzOlt1XSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBpLmRpbXMubGVuZ3RoPT09MyYmKHU9aS5yZXNoYXBlKFt0LHIsbixvXSkpLG49PT0xfHxyPT09MT91OmUuY29tcHV0ZShwZSh1LGFhLnBlcm0pLHtpbnB1dHM6W3VdLG91dHB1dHM6Wy0xXX0pWzBdfSxkYT0oZSx0KT0+e2xldCBuPUpsKGUuaW5wdXRzLHQpLHI9ZS5pbnB1dHNbMF0sbz1nZShlLmlucHV0cywxKSxpPWdlKGUuaW5wdXRzLDIpLHM9Z2UoZS5pbnB1dHMsMyksYT1nZShlLmlucHV0cyw0KSx1PWdlKGUuaW5wdXRzLDUpLGQ9Z2UoZS5pbnB1dHMsNiksbD1nZShlLmlucHV0cyw3KTtpZihyLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihvPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgYz1vJiZpJiZvLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zLmxlbmd0aD09PTQscD1fdChlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5zZXF1ZW5jZUxlbmd0aCxuLmhlYWRTaXplLHIscywwKTtpZihjKXJldHVybiBvdChlLHAsbyxpLGEsdm9pZCAwLGQsbCx1LG4pO2lmKCFvfHwhaSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWRcIik7bGV0IGY9X3QoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4ua3ZTZXF1ZW5jZUxlbmd0aCxuLmhlYWRTaXplLG8scyxuLmhpZGRlblNpemUpLG09X3QoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4ua3ZTZXF1ZW5jZUxlbmd0aCxuLnZIZWFkU2l6ZSxpLHMsMipuLmhpZGRlblNpemUpO290KGUscCxmLG0sYSx2b2lkIDAsZCxsLHUsbil9fSk7dmFyIHRjLG5jLHJjLG9jLGFyLGxhLGNhLHVyPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO3RjPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sbmM9KGUsdCk9PntsZXQgbj1bXSxyPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89Pm4ucHVzaChOdW1iZXIobykpKSxyPW4ubGVuZ3RoKSxOKHtudW1PdXRwdXRzOnIsYXhpczp0LmF4aXMsc3BsaXRTaXplczpufSl9LHJjPWU9PmBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcbiAgICBpZiAoaW5kZXggPCAke08oXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcImlcIixlKX0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG59YCxvYz1lPT57bGV0IHQ9ZS5sZW5ndGgsbj1bXTtmb3IobGV0IHI9MDtyPHQ7KytyKXtsZXQgbz1lW3JdLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP24ucHVzaChvKTpyPT09MD9uLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7cn11KSB7ICR7b30gfWApOnI9PT10LTE/bi5wdXNoKGBlbHNlIHsgJHtvfSB9YCk6bi5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7cn0pIHsgJHtvfSB9YCl9cmV0dXJuYFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXI6IHUzMiwgaW5kaWNlczogJHtlWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xuICAgICAgICAke24uam9pbihgXG5gKX1cbiAgICAgIH1gfSxhcj0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPXguc2l6ZShuKSxvPWVbMF0uZGF0YVR5cGUsaT14Lm5vcm1hbGl6ZUF4aXModC5heGlzLG4ubGVuZ3RoKSxzPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLGE9UyhcImlucHV0XCIsbyxuLmxlbmd0aCksdT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxkPVtdLGw9W10sYz0wLHA9W3t0eXBlOjEyLGRhdGE6cn1dO2ZvcihsZXQgbT0wO208dC5udW1PdXRwdXRzO20rKyl7Yys9dC5zcGxpdFNpemVzW21dLHVbbV09YztsZXQgaD1uLnNsaWNlKCk7aFtpXT10LnNwbGl0U2l6ZXNbbV0sbC5wdXNoKGgpLHNbbV09Qyhgb3V0cHV0JHttfWAsbyxoLmxlbmd0aCksZC5wdXNoKHtkaW1zOmxbbV0sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfXAucHVzaCh7dHlwZToxMixkYXRhOnV9LC4uLlAobiwuLi5sKSk7bGV0IGY9bT0+YFxuICAke20ucmVnaXN0ZXJVbmlmb3JtKFwiaW5wdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNpemVfaW5fc3BsaXRfYXhpc1wiLFwidTMyXCIsdS5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoYSwuLi5zKX1cbiAgJHtyYyh1Lmxlbmd0aCl9XG4gICR7b2Mocyl9XG5cbiAgJHttLm1haW5TdGFydCgpfVxuICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMuaW5wdXRfc2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIHZhciBpbmRleCA9ICR7YS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGkpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke08oXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcIm91dHB1dF9udW1iZXIgLSAxdVwiLHUubGVuZ3RoKX07XG4gICAgICAke2EuaW5kaWNlc1NldChcImluZGljZXNcIixpLFwiaW5kZXhcIil9O1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO3JldHVybntuYW1lOlwiU3BsaXRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpmLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpkLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pfX0sbGE9KGUsdCk9Pnt0YyhlLmlucHV0cyk7bGV0IG49ZS5pbnB1dHMubGVuZ3RoPT09MT90Om5jKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShhcihlLmlucHV0cyxuKSx7aW5wdXRzOlswXX0pfSxjYT1lPT57bGV0IHQ9ZS5heGlzLG49ZS5zcGxpdFNpemVzLHI9ZS5udW1PdXRwdXRzPDA/bi5sZW5ndGg6ZS5udW1PdXRwdXRzO2lmKHIhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmd0aCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiBOKHtheGlzOnQsbnVtT3V0cHV0czpyLHNwbGl0U2l6ZXM6bn0pfX0pO3ZhciBpYyxjbixwYSxkcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtpYz0oZSx0KT0+e2xldFtuLHIsbyxpXT1lLHtudW1IZWFkczpzLHJvdGFyeUVtYmVkZGluZ0RpbTphfT10O2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICd4JyBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zLCBnb3QgJHtuLmRpbXMubGVuZ3RofWApO2lmKCF4LmFyZUVxdWFsKHIuZGltcyxbXSkmJiF4LmFyZUVxdWFsKHIuZGltcyxbMV0pJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMCwgMSwgb3IgMiBkaW1lbnNpb25zLCBnb3QgJHtyLmRpbXMubGVuZ3RofWApO2lmKG8uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke28uZGltcy5sZW5ndGh9YCk7aWYoaS5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7aS5kaW1zLmxlbmd0aH1gKTtpZigheC5hcmVFcXVhbChvLmRpbXMsaS5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dHMgJ2Nvc19jYWNoZScgYW5kICdzaW5fY2FjaGUnIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO2lmKGE+MCYmcz09PTApdGhyb3cgbmV3IEVycm9yKFwibnVtX2hlYWRzIG11c3QgYmUgcHJvdmlkZWQgaWYgcm90YXJ5X2VtYmVkZGluZ19kaW0gaXMgc3BlY2lmaWVkXCIpO2xldCB1PW4uZGltc1swXSxkPW4uZGltc1tuLmRpbXMubGVuZ3RoLTJdLGw9by5kaW1zWzBdLGM9eC5zaXplRnJvbURpbWVuc2lvbihuLmRpbXMsMSkvZCxwPWE9PT0wP28uZGltc1sxXSoyOmMvcztpZihhPnApdGhyb3cgbmV3IEVycm9yKFwicm90YXJ5X2VtYmVkZGluZ19kaW0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGVhZF9zaXplXCIpO2lmKHIuZGltcy5sZW5ndGg9PT0yKXtpZih1IT09ci5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDAgc2hvdWxkIGJlIG9mIHNpemUgYmF0Y2hfc2l6ZSwgZ290ICR7ci5kaW1zWzBdfWApO2lmKGQhPT1yLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgb2Ygc2l6ZSBzZXF1ZW5jZV9sZW5ndGgsIGdvdCAke3IuZGltc1sxXX1gKX1pZihwLzIhPT1vLmRpbXNbMV0mJmEvMiE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBzYW1lIGFzIGhlYWRfc2l6ZSAvIDIgb3Igcm90YXJ5X2VtYmVkZGluZ19kaW0gLyAyLCBnb3QgJHtvLmRpbXNbMV19YCk7aWYoZD5sKXRocm93IG5ldyBFcnJvcihcIlVwZGF0aW5nIGNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGluIFJvdGFyeUVtYmVkZGluZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFwiKX0sY249KGUsdCk9PntsZXR7aW50ZXJsZWF2ZWQ6bixudW1IZWFkczpyLHJvdGFyeUVtYmVkZGluZ0RpbTpvLHNjYWxlOml9PXQscz1lWzBdLmRpbXNbMF0sYT14LnNpemVGcm9tRGltZW5zaW9uKGVbMF0uZGltcywxKSx1PWVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTJdLGQ9YS91LGw9ZVsyXS5kaW1zWzFdLGM9bz09PTA/bCoyOmQvcixwPW5ldyBBcnJheShzLHUsZC9jLGMtbCksZj14LmNvbXB1dGVTdHJpZGVzKHApLG09W3t0eXBlOjEsZGF0YTppfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6Zn0sLi4uZVswXS5kaW1zLmxlbmd0aD09PTM/bmV3IEFycmF5KHt0eXBlOjEyLGRhdGE6W2EsZCxjLDFdfSk6W10sLi4uZVswXS5kaW1zLmxlbmd0aD09PTQ/bmV3IEFycmF5KHt0eXBlOjEyLGRhdGE6W2EsYyx1KmMsMV19KTpbXSwuLi5QKGVbMF0uZGltcyxlWzFdLmRpbXMsZVsyXS5kaW1zLGVbM10uZGltcyxlWzBdLmRpbXMpXSxoPWI9PntsZXQgeT1TKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLGc9UyhcInBvc2l0aW9uX2lkc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksXz1TKFwiY29zX2NhY2hlXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSx3PVMoXCJzaW5fY2FjaGVcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcy5sZW5ndGgpLHY9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCk7cmV0dXJuIGIucmVnaXN0ZXJVbmlmb3Jtcyhbe25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJnbG9iYWxfc2hhcGVcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnAubGVuZ3RofSx7bmFtZTpcImdsb2JhbF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpmLmxlbmd0aH0se25hbWU6XCJpbnB1dF9vdXRwdXRfc3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Zi5sZW5ndGh9XSksYFxuICAgICAgICAke2IuZGVjbGFyZVZhcmlhYmxlcyh5LGcsXyx3LHYpfVxuXG4gICAgICAgICR7Yi5tYWluU3RhcnQoWWUpfVxuICAgICAgICAgIGxldCBoYWxmX3JvdGFyeV9lbWJfZGltID0gdW5pZm9ybXMuJHtfLm5hbWV9X3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBic25oID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzICUgdW5pZm9ybXMuZ2xvYmFsX3NoYXBlO1xuICAgICAgICAgIGxldCBzaXplID0gdW5pZm9ybXMuZ2xvYmFsX3NoYXBlWzBdICogdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXNbMF07XG4gICAgICAgICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJzaXplXCIpfVxuXG4gICAgICAgICAgaWYgKGJzbmhbM10gPCBoYWxmX3JvdGFyeV9lbWJfZGltKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWRzX2lkeCA9XG4gICAgICAgICAgICAgICAgJHtnLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwiYnNuaC54eVwiLEMoXCJcIixnLnR5cGUudGVuc29yLDIpKX07XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWQgPVxuICAgICAgICAgICAgICAgIHUzMigke2cuZ2V0QnlPZmZzZXQoXCJwb3NpdGlvbl9pZHNfaWR4XCIpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcbiAgICAgICAgICAgIGxldCBpID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIHNlbGVjdCgwLCBic25oWzNdLCAke259KTtcbiAgICAgICAgICAgIGxldCBqID0gaSArIHNlbGVjdChoYWxmX3JvdGFyeV9lbWJfZGltLCAxLCAke259KTtcbiAgICAgICAgICAgIGxldCByZSA9ICR7eS5nZXRCeU9mZnNldChcImlcIil9ICogJHtfLmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSAtXG4gICAgICAgICAgICAgICAgJHt5LmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke3cuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHt2LnNldEJ5T2Zmc2V0KFwiaVwiLFwicmVcIil9XG4gICAgICAgICAgICBsZXQgaW0gPSAke3kuZ2V0QnlPZmZzZXQoXCJpXCIpfSAqICR7dy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX0gK1xuICAgICAgICAgICAgICAgICR7eS5nZXRCeU9mZnNldChcImpcIil9ICogJHtfLmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfTtcbiAgICAgICAgICAgICR7di5zZXRCeU9mZnNldChcImpcIixcImltXCIpfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgayA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBoYWxmX3JvdGFyeV9lbWJfZGltO1xuICAgICAgICAgICAgJHt2LnNldEJ5T2Zmc2V0KFwia1wiLHkuZ2V0QnlPZmZzZXQoXCJrXCIpKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJvdGFyeUVtYmVkZGluZ1wiLHNoYWRlckNhY2hlOntoaW50Ok4oe2ludGVybGVhdmVkOm59KS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6aCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeC5zaXplKHApL1llKX0scHJvZ3JhbVVuaWZvcm1zOm19KX19LHBhPShlLHQpPT57aWMoZS5pbnB1dHMsdCksZS5jb21wdXRlKGNuKGUuaW5wdXRzLHQpKX19KTt2YXIgc2MsYWMsbWEsdWMsZmEsaGE9aygoKT0+e1widXNlIHN0cmljdFwiO2llKCk7VigpO2VuKCk7c3IoKTt1cigpO1ZlKCk7ZHIoKTtLKCk7c2M9KGUsdCk9PntpZih0LmRvUm90YXJ5JiZlLmxlbmd0aDw9Nyl0aHJvdyBuZXcgRXJyb3IoXCJjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbnB1dHMgYXJlIHJlcXVpcmVkIGlmIGRvX3JvdGFyeSBpcyBzcGVjaWZpZWRcIik7bGV0IG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9ZVszXSxzPWVbNF07aWYodC5kb1JvdGFyeSE9PTAmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYXN0IGFuZCBzaW5fY2FjaGUgYXJlIGV4cGVjdGVkIGlmIGRvX3JvdGFyeSBhdHRyaWJ1dGUgaXMgbm9uLXplcm9cIik7aWYodC5sb2NhbFdpbmRvd1NpemUhPT0tMSl0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBhdHRlbnRpb24gaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LnNvZnRjYXAhPT0wKXRocm93IG5ldyBFcnJvcihcIlNvZnRjYXAgaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LnJvdGFyeUludGVybGVhdmVkIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSb3RhcnkgaW50ZXJsZWF2ZWQgaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LnNtb290aFNvZnRtYXgpdGhyb3cgbmV3IEVycm9yKFwiU21vb3RoIHNvZnRtYXggaXMgbm90IHN1cHBvcnRlZFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9uc1wiKTtsZXQgYT0hMSx1PW4uZGltc1swXSxkPW4uZGltc1sxXSxsPW4uZGltcy5sZW5ndGg9PT0zP2E/bi5kaW1zWzJdLzM6bi5kaW1zWzJdOnQubnVtSGVhZHMqbi5kaW1zWzRdLGM9ZCxwPTAsZj0hcnx8ci5kaW1zLmxlbmd0aD09PTAsbT1NYXRoLmZsb29yKGY/bC8odC5udW1IZWFkcysyKnQua3ZOdW1IZWFkcyk6bC90Lm51bUhlYWRzKTtmJiYobD1tKnQubnVtSGVhZHMpO2xldCBoPWkmJmkuZGltcy5sZW5ndGghPT0wLGI9cyYmcy5kaW1zLmxlbmd0aCE9PTA7aWYoaCYmaS5kaW1zLmxlbmd0aD09PTQmJmkuZGltc1swXT09PXUmJmkuZGltc1sxXSE9PXQua3ZOdW1IZWFkcyYmaS5kaW1zWzJdPT09dC5rdk51bUhlYWRzJiZpLmRpbXNbM109PT1tKXRocm93IG5ldyBFcnJvcihcIkJTTkggcGFzdEtleS9wYXN0VmFsdWUgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihoJiZiKXtpZihpLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKHMuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtwPWkuZGltc1syXX1lbHNlIGlmKGh8fGIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO2xldCBnPTE7aWYociYmci5kaW1zLmxlbmd0aD4wKXtpZihuLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO2lmKHIuZGltcy5sZW5ndGg8M3x8ci5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PXIuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7aWYoci5kaW1zLmxlbmd0aD09PTMpe2lmKG4uZGltc1syXSVyLmRpbXNbMl0hPT0wKXRocm93IG5ldyBFcnJvcignRGltZW5zaW9uIDIgb2YgXCJxdWVyeVwiIHNob3VsZCBiZSBhIG11bHRpcGxlIG9mIFwia2V5XCInKTtjPXIuZGltc1sxXX1lbHNlIGlmKHIuZGltcy5sZW5ndGg9PT01KXtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0yfHxyLmRpbXNbNF0hPT1tKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtpZihvKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtjPXIuZGltc1sxXX1lbHNle2lmKHIuZGltc1sxXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PW0pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7Yz1yLmRpbXNbMl19fWVsc2V7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihuLmRpbXMubGVuZ3RoPT09NSYmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTMpKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2c9M31sZXQgXz0wLHc9ITEsdj10Lmt2TnVtSGVhZHM/bSp0Lmt2TnVtSGVhZHM6bDtpZihvJiZvLmRpbXMubGVuZ3RoPjApe2lmKG8uZGltcy5sZW5ndGghPT0zJiZvLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09by5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO2lmKG8uZGltcy5sZW5ndGg9PT0zKXtpZihjIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTt2PW8uZGltc1syXX1lbHNle2lmKGMhPT1vLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTt2PW8uZGltc1sxXSpvLmRpbXNbM10sdz0hMH19bGV0ICQ9ZS5sZW5ndGg+ND9lWzVdOnZvaWQgMDtpZigkJiYkLmRpbXMubGVuZ3RoIT09MSYmJC5kaW1zWzBdIT09dSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwic2VxbGVuc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24gYW5kIHRoZSBzYW1lIGRpbSAwIGFzIGJhdGNoX3NpemUnKTtyZXR1cm57YmF0Y2hTaXplOnUsc2VxdWVuY2VMZW5ndGg6ZCxwYXN0U2VxdWVuY2VMZW5ndGg6cCxrdlNlcXVlbmNlTGVuZ3RoOmMsdG90YWxTZXF1ZW5jZUxlbmd0aDotMSxtYXhTZXF1ZW5jZUxlbmd0aDotMSxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOmwsdkhpZGRlblNpemU6dixoZWFkU2l6ZTptLHZIZWFkU2l6ZTpNYXRoLmZsb29yKHYvdC5rdk51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGt2TnVtSGVhZHM6dC5rdk51bUhlYWRzLG5SZXBzOnQubnVtSGVhZHMvdC5rdk51bUhlYWRzLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza1R5cGU6XyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ITEscGFzc1Bhc3RJbkt2OncscWt2Rm9ybWF0Omd9fSxhYz1OKHtwZXJtOlswLDIsMSwzXX0pLG1hPShlLHQsbik9PntsZXQgcj10LG89bi5rdk51bUhlYWRzO3JldHVybiB0LmRpbXMubGVuZ3RoPT09MyYmbi5rdlNlcXVlbmNlTGVuZ3RoIT09MCYmKHI9dC5yZXNoYXBlKFtuLmJhdGNoU2l6ZSxuLmt2U2VxdWVuY2VMZW5ndGgsbyxuLmhlYWRTaXplXSkscj1lLmNvbXB1dGUocGUocixhYy5wZXJtKSx7aW5wdXRzOltyXSxvdXRwdXRzOlstMV19KVswXSkscn0sdWM9KGUsdCxuLHIpPT57bGV0IG89NyxpPVtcInR5cGVcIixcInR5cGVcIl0scz1bZSp0XSxhPWUqdCx1PVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6dH0se3R5cGU6MTIsZGF0YTplfV0sZD1sPT57bGV0IGM9UyhcInNlcV9sZW5zXCIsbi5kYXRhVHlwZSxuLmRpbXMpLHA9UyhcInRvdGFsX3NlcV9sZW5zXCIsci5kYXRhVHlwZSxyLmRpbXMpLGY9QyhcInBvc19pZHNcIixvLHMpLG09W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7bC5yZWdpc3RlclVuaWZvcm1zKG0pLmRlY2xhcmVWYXJpYWJsZXMoYyxwLGYpfVxuICAke2wubWFpblN0YXJ0KCl9XG4gICAgJHtsLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7cC5nZXRCeU9mZnNldChcIjBcIil9KTtcbiAgICBsZXQgaXNfc3Vic2VxdWVudF9wcm9tcHQgPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGggPiAxICYmIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCAhPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgbGV0IGlzX2ZpcnN0X3Byb21wdCA9ICFpc19zdWJzZXF1ZW50X3Byb21wdCAmJiB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGggPT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoO1xuICAgIGxldCBzZXF1ZW5jZV9pZHggPSBpMzIoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCk7XG4gICAgdmFyIHBvc19pZDogaTMyID0gMDtcbiAgICBsZXQgc2VxbGVuID0gJHtjLmdldEJ5T2Zmc2V0KFwiYmF0Y2hfaWR4XCIpfTtcbiAgICBsZXQgdG90YWxfc2VxbGVuID0gc2VxbGVuICsgMTtcbiAgICBpZiAoaXNfZmlyc3RfcHJvbXB0KSB7XG4gICAgICBpZiAoc2VxdWVuY2VfaWR4IDwgdG90YWxfc2VxbGVuKSB7XG4gICAgICAgIHBvc19pZCA9IHNlcXVlbmNlX2lkeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc19pZCA9IDE7XG4gICAgICB9XG4gICAgICAke2Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJwb3NfaWRcIil9XG4gICAgfSBlbHNlIGlmIChpc19zdWJzZXF1ZW50X3Byb21wdCkge1xuICAgICAgbGV0IHBhc3Rfc2VxbGVuID0gdG90YWxfc2VxbGVuIC0gaTMyKHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCk7XG4gICAgICBpZiAocGFzdF9zZXFsZW4gKyBzZXF1ZW5jZV9pZHggPCB0b3RhbF9zZXFsZW4pIHtcbiAgICAgICAgcG9zX2lkID0gcGFzdF9zZXFsZW4gKyBzZXF1ZW5jZV9pZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NfaWQgPSAxO1xuICAgICAgfVxuICAgICAgJHtmLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwicG9zX2lkXCIpfVxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsX2lkeCA8IHVuaWZvcm1zLmJhdGNoX3NpemUpIHtcbiAgICAgICR7Zi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInNlcWxlblwiKX1cbiAgICB9O1xuICB9XG4gIGB9O3JldHVybntuYW1lOlwiR2VuZXJhdGVQb3NpdGlvbklkc1wiLHNoYWRlckNhY2hlOntoaW50OmAke2V9OyR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOml9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3Jtczp1fSksZ2V0U2hhZGVyU291cmNlOmR9fSxmYT0oZSx0KT0+e2xldCBuPXNjKGUuaW5wdXRzLHQpO2lmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihlLmlucHV0c1sxXT8uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7bGV0IHI9ZS5pbnB1dHNbMF0sbz1lLmlucHV0c1sxXSYmZS5pbnB1dHNbMV0uZGltcy5sZW5ndGg+MD9lLmlucHV0c1sxXTp2b2lkIDAsaT1lLmlucHV0c1syXSYmZS5pbnB1dHNbMl0uZGltcy5sZW5ndGg+MD9lLmlucHV0c1syXTp2b2lkIDAscz1lLmlucHV0c1szXSYmZS5pbnB1dHNbM10uZGltcy5sZW5ndGghPT0wP2UuaW5wdXRzWzNdOnZvaWQgMCxhPWUuaW5wdXRzWzRdJiZlLmlucHV0c1s0XS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbNF06dm9pZCAwLHU9ZS5pbnB1dHMubGVuZ3RoPjQ/ZS5pbnB1dHNbNV06dm9pZCAwLGQ9ZS5pbnB1dHMubGVuZ3RoPjU/ZS5pbnB1dHNbNl06dm9pZCAwLGw9bi5rdk51bUhlYWRzP24ua3ZOdW1IZWFkczpuLm51bUhlYWRzLGM9Tih7YXhpczoyLG51bU91dHB1dHM6MyxzcGxpdFNpemVzOltuLm51bUhlYWRzKm4uaGVhZFNpemUsbCpuLmhlYWRTaXplLGwqbi5oZWFkU2l6ZV19KSxbcCxmLG1dPSFvJiYhaT9lLmNvbXB1dGUoYXIoW3JdLGMpLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xLC0xLC0xXX0pOltyLG8saV0saCxiO2lmKHQuZG9Sb3Rhcnkpe2xldCB3PWUuY29tcHV0ZSh1YyhuLmJhdGNoU2l6ZSxuLnNlcXVlbmNlTGVuZ3RoLHUsZCkse2lucHV0czpbdSxkXSxvdXRwdXRzOlstMV19KVswXSx2PWUuaW5wdXRzWzddLCQ9ZS5pbnB1dHNbOF0sVD1OKHtpbnRlcmxlYXZlZDp0LnJvdGFyeUludGVybGVhdmVkIT09MCxudW1IZWFkczpuLm51bUhlYWRzLHJvdGFyeUVtYmVkZGluZ0RpbTowLHNjYWxlOnQuc2NhbGV9KSxJPVtwLHcsdiwkXSxBPVstMV07aD1lLmNvbXB1dGUoY24oSSxUKSx7aW5wdXRzOkksb3V0cHV0czpBfSlbMF0sSS5zcGxpY2UoMCwxLGYpO2xldCB6PU4oe2ludGVybGVhdmVkOnQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wLG51bUhlYWRzOm4ua3ZOdW1IZWFkcyxyb3RhcnlFbWJlZGRpbmdEaW06MCxzY2FsZTp0LnNjYWxlfSk7Yj1lLmNvbXB1dGUoY24oSSx6KSx7aW5wdXRzOkksb3V0cHV0czpBfSlbMF19bGV0IHk9X3QoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4uc2VxdWVuY2VMZW5ndGgsbi5oZWFkU2l6ZSx0LmRvUm90YXJ5P2g6cCx2b2lkIDAsMCksZz1tYShlLHQuZG9Sb3Rhcnk/YjpmLG4pLF89bWEoZSxtLG4pO290KGUseSxnLF8sdm9pZCAwLHZvaWQgMCxzLGEsdm9pZCAwLG4sdSxkKX19KTt2YXIgZ2EsZGMsbGMseWEsYmE9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7VmUoKTtLKCk7Z2E9KGUsdCxuLHIsbyxpLHMsYSk9PntsZXQgdT1YKGkpLGQ9dT09PTE/XCJmMzJcIjpgdmVjJHt1fWZgLGw9dT09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7dX1mYCxjPW8qcyxwPTY0O2M9PT0xJiYocD0yNTYpO2xldCBmPVtvLHMsaS91XSxtPVtvLHMsMl0saD1bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdLGI9W107Yi5wdXNoKC4uLlAoZixtKSk7bGV0IHk9Zz0+e2xldCBfPVMoXCJ4XCIsdC5kYXRhVHlwZSwzLHUpLHc9UyhcInNjYWxlXCIsbi5kYXRhVHlwZSxuLmRpbXMpLHY9UyhcImJpYXNcIixyLmRhdGFUeXBlLHIuZGltcyksJD1DKFwib3V0cHV0XCIsMSwzLDIpLFQ9W18sdyx2LCRdO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZCA6IGFycmF5PCR7bH0sICR7cH0+O1xuICBjb25zdCB3b3JrZ3JvdXBfc2l6ZSA9ICR7cH11O1xuICAke2cuZGVjbGFyZVZhcmlhYmxlcyguLi5UKX1cbiAgJHtnLm1haW5TdGFydChwKX1cbiAgICBsZXQgYmF0Y2ggPSB3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBjaGFubmVsID0gd29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgaGlnaHQgPSB1bmlmb3Jtcy54X3NoYXBlWzJdO1xuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxuICAgIHZhciBzdW0gPSAke2R9KDApO1xuICAgIHZhciBzcXVhcmVkX3N1bSA9ICR7ZH0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsX2lkeDsgaCA8IGhpZ2h0OyBoICs9IHdvcmtncm91cF9zaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke2R9KCR7Xy5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0pO1xuICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgc3F1YXJlZF9zdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gJHtsfShzdW0sIHNxdWFyZWRfc3VtKTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cF9zaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9IHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSArIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxfaWR4ID09IDApIHtcbiAgICAgIGxldCBzdW1fZmluYWwgPSAke1RlKFwid29ya2dyb3VwX3NoYXJlZFswXVswXVwiLHUpfSAvIGYzMihoaWdodCAqICR7dX0pO1xuICAgICAgbGV0IHNxdWFyZWRfc3VtX2ZpbmFsID0gJHtUZShcIndvcmtncm91cF9zaGFyZWRbMF1bMV1cIix1KX0gLyBmMzIoaGlnaHQgKiAke3V9KTtcblxuICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZF9zdW1fZmluYWwgLSBzdW1fZmluYWwgKiBzdW1fZmluYWwgKyBmMzIoJHthfSkpO1xuICAgICAgbGV0IGNoYW5uZWxfc2NhbGUgPSBpbnZfc3RkX2RldiAqIGYzMihzY2FsZVtjaGFubmVsXSk7XG4gICAgICBsZXQgY2hhbm5lbF9zaGlmdCA9IGYzMihiaWFzW2NoYW5uZWxdKSAtIHN1bV9maW5hbCAqIGNoYW5uZWxfc2NhbGU7XG4gICAgICBvdXRwdXRbd29ya2dyb3VwX2luZGV4XSA9IHZlYzJmKGNoYW5uZWxfc2NhbGUsIGNoYW5uZWxfc2hpZnQpO1xuICAgIH1cbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt1fTske2F9OyR7cH1gLGlucHV0RGVwZW5kZW5jaWVzOmh9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpjfSxwcm9ncmFtVW5pZm9ybXM6Yn0pLGdldFNoYWRlclNvdXJjZTp5fSx7aW5wdXRzOlt0LG4scl0sb3V0cHV0czpbLTFdfSlbMF19LGRjPShlLHQsbik9PntsZXQgcj10WzBdLmRpbXMsbz1yLGk9MixzPXJbMF0sYT1yWzFdLHU9eC5zaXplRnJvbURpbWVuc2lvbihyLGkpLGQ9WCh1KSxsPXguc2l6ZShvKS9kLGM9Z2EoZSx0WzBdLHRbMV0sdFsyXSxzLHUsYSxuLmVwc2lsb24pLHA9W3MsYSx1L2RdLGY9W3MsYV0sbT1bXCJ0eXBlXCIsXCJub25lXCJdLGg9Yj0+e2xldCB5PVMoXCJ4XCIsdFswXS5kYXRhVHlwZSxwLmxlbmd0aCxkKSxnPVMoXCJzY2FsZV9zaGlmdFwiLDEsZi5sZW5ndGgsMiksXz1DKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxwLmxlbmd0aCxkKSx3PVt5LGcsX107cmV0dXJuYFxuICAke2IucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLncpfVxuICAke2IubWFpblN0YXJ0KCl9XG4gICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke2cuZ2V0QnlJbmRpY2VzKFwidmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAke3kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfSAqICR7Xy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7Xy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC55KTtcbiAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke2R9YCxpbnB1dERlcGVuZGVuY2llczptfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bH0sLi4uUChwLGYscCldfSksZ2V0U2hhZGVyU291cmNlOmh9LHtpbnB1dHM6W3RbMF0sY119KX0sbGM9KGUsdCxuKT0+e2xldCByPXRbMF0uZGltcyxvPXIsaT1yWzBdLHM9cltyLmxlbmd0aC0xXSxhPXguc2l6ZUZyb21EaW1lbnNpb24ociwxKS9zLHU9WChzKSxkPXguc2l6ZShvKS91LGw9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKHMvdSl9XSxjPVtcInR5cGVcIixcInR5cGVcIl0scD0hMSxmPVswLHIubGVuZ3RoLTFdO2ZvcihsZXQgeT0wO3k8ci5sZW5ndGgtMjt5KyspcD1wfHxyW3krMV0hPT0xLGYucHVzaCh5KzEpO3A9cCYmcltyLmxlbmd0aC0xXSE9PTE7bGV0IG09cD9lLmNvbXB1dGUocGUoZS5pbnB1dHNbMF0sZikse2lucHV0czpbZS5pbnB1dHNbMF1dLG91dHB1dHM6Wy0xXX0pWzBdOmUuaW5wdXRzWzBdLnJlc2hhcGUoQXJyYXkuZnJvbSh7bGVuZ3RoOnIubGVuZ3RofSwoeSxnKT0+cltmW2ddXSkpLGg9Z2EoZSxtLHRbMV0sdFsyXSxpLGEscyxuLmVwc2lsb24pLGI9eT0+e2xldCBnPXJlKHRbMF0uZGF0YVR5cGUpLF89dT09PTE/XCJ2ZWMyZlwiOmBtYXQke3V9eDJmYCx3PVQ9PntsZXQgST1UPT09MD9cInhcIjpcInlcIixBPXU9PT0xP1wiZjMyXCI6YHZlYyR7dX1mYDtzd2l0Y2godSl7Y2FzZSAxOnJldHVybmAke2d9KCR7QX0oc2NhbGUuJHtJfSkpYDtjYXNlIDI6cmV0dXJuYHZlYzI8JHtnfT4oJHtBfShzY2FsZVswXS4ke0l9LCBzY2FsZVsxXS4ke0l9KSlgO2Nhc2UgNDpyZXR1cm5gdmVjNDwke2d9Pigke0F9KHNjYWxlWzBdLiR7SX0sIHNjYWxlWzFdLiR7SX0sIHNjYWxlWzJdLiR7SX0sIHNjYWxlWzNdLiR7SX0pKWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgY29tcG9lbnRzICR7dX1gKX19LHY9UyhcImlucHV0XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsdSksJD1DKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxvLHUpO3JldHVybmBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7di50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7X30+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7JC50eXBlLnN0b3JhZ2V9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHtIOiB1MzIsIEMgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAke3kubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XG4gICAgbGV0IGN1cnJlbnRfY2hhbm5lbF9udW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlX2lucHV0W3NjYWxlX29mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke3coMCl9LCAke3coMSl9KTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbk5IV0NcIixzaGFkZXJDYWNoZTp7aGludDpgJHt1fWAsaW5wdXREZXBlbmRlbmNpZXM6Y30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6Yn0se2lucHV0czpbdFswXSxoXX0pfSx5YT0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/bGMoZSxlLmlucHV0cyx0KTpkYyhlLGUuaW5wdXRzLHQpfX0pO3ZhciBjYyxwYyxfYSx3YT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7Y2M9ZT0+e2lmKCFlfHxlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy5cIil9LHBjPShlLHQsbik9PntsZXQgcj10LnNpbXBsaWZpZWQsbz1lWzBdLmRpbXMsaT1lWzFdLHM9IXImJmVbMl0sYT1vLHU9eC5ub3JtYWxpemVBeGlzKHQuYXhpcyxvLmxlbmd0aCksZD14LnNpemVUb0RpbWVuc2lvbihvLHUpLGw9eC5zaXplRnJvbURpbWVuc2lvbihvLHUpLGM9eC5zaXplKGkuZGltcykscD1zP3guc2l6ZShzLmRpbXMpOjA7aWYoYyE9PWx8fHMmJnAhPT1sKXRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7bH0uXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke2N9IGFuZCBiaWFzIHNpemUgb2YgJHtwfWApO2xldCBmPVtdO2ZvcihsZXQgdj0wO3Y8by5sZW5ndGg7Kyt2KXY8dT9mLnB1c2gob1t2XSk6Zi5wdXNoKDEpO2xldCBtPVgobCksaD1bXCJ0eXBlXCIsXCJ0eXBlXCJdLGI9W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MSxkYXRhOmx9LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihsL20pfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV07cyYmaC5wdXNoKFwidHlwZVwiKTtsZXQgeT1uPjEsZz1uPjIsXz12PT57bGV0ICQ9cmUoZVswXS5kYXRhVHlwZSksVD1bUyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxtKSxTKFwic2NhbGVcIixpLmRhdGFUeXBlLGkuZGltcyxtKV07cyYmVC5wdXNoKFMoXCJiaWFzXCIscy5kYXRhVHlwZSxzLmRpbXMsbSkpLFQucHVzaChDKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLG0pKSx5JiZULnB1c2goQyhcIm1lYW5fZGF0YV9vdXRwdXRcIiwxLGYpKSxnJiZULnB1c2goQyhcImludl9zdGRfb3V0cHV0XCIsMSxmKSk7bGV0IEk9W3tuYW1lOlwibm9ybV9jb3VudFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJub3JtX3NpemVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwibm9ybV9zaXplX3ZlY3Rvcml6ZWRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoSSkuZGVjbGFyZVZhcmlhYmxlcyguLi5UKX1cbiAgJHt2Lm1haW5TdGFydCgpfVxuICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMubm9ybV9jb3VudFwiKX1cbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkO1xuICAgIHZhciBtZWFuX3ZlY3RvciA9ICR7cW4oXCJmMzJcIixtKX07XG4gICAgdmFyIG1lYW5fc3F1YXJlX3ZlY3RvciA9ICR7cW4oXCJmMzJcIixtKX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7SmUoJCxtLFwieFtoICsgb2Zmc2V0XVwiKX07XG4gICAgICBtZWFuX3ZlY3RvciArPSB2YWx1ZTtcbiAgICAgIG1lYW5fc3F1YXJlX3ZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7VGUoXCJtZWFuX3ZlY3RvclwiLG0pfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZTtcbiAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke1RlKFwibWVhbl9zcXVhcmVfdmVjdG9yXCIsbSl9IC8gdW5pZm9ybXMubm9ybV9zaXplICR7cj9cIlwiOlwiLSBtZWFuICogbWVhblwifSArIHVuaWZvcm1zLmVwc2lsb24pO1xuXG4gICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBqKyspIHtcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7SmUoJCxtLFwieFtqICsgb2Zmc2V0XVwiKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke0plKCQsbSxcInNjYWxlW2pdXCIpfTtcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7VFswXS50eXBlLnZhbHVlfSgoZjMyaW5wdXQgJHtyP1wiXCI6XCItIG1lYW5cIn0pICogaW52X3N0ZF9kZXYgKiBmMzJzY2FsZVxuICAgICAgICAke3M/YCsgJHtKZSgkLG0sXCJiaWFzW2pdXCIpfWA6XCJcIn1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgJHt5P1wibWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW5cIjpcIlwifTtcbiAgICAke2c/XCJpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2XCI6XCJcIn07XG4gIH1gfSx3PVt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4geSYmdy5wdXNoKHtkaW1zOmYsZGF0YVR5cGU6MX0pLGcmJncucHVzaCh7ZGltczpmLGRhdGFUeXBlOjF9KSx7bmFtZTpcIkxheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke219OyR7bn07JHtyfWAsaW5wdXREZXBlbmRlbmNpZXM6aH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOncsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NCl9LHByb2dyYW1Vbmlmb3JtczpifSksZ2V0U2hhZGVyU291cmNlOl99fSxfYT0oZSx0KT0+e2NjKGUuaW5wdXRzKSxlLmNvbXB1dGUocGMoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50KSl9fSk7dmFyIG1jLCRhLHZhPWsoKCk9PntcInVzZSBzdHJpY3RcIjtxKCk7YW4oKTt1bigpO21jPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sJGE9ZT0+e21jKGUuaW5wdXRzKTtsZXQgdD1QZS5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBuPXRbdC5sZW5ndGgtMV0scj1lLmlucHV0c1swXS5kaW1zW2UuaW5wdXRzWzBdLmRpbXMubGVuZ3RoLTFdO2lmKG48OCYmcjw4KWUuY29tcHV0ZShzbihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSk7ZWxzZXtsZXQgbz10W3QubGVuZ3RoLTJdLGk9eC5zaXplKGUuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwtMikpLHM9eC5zaXplKGUuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwtMikpO2lmKGkhPT0xJiZvPT09MSYmcz09PTEpe2xldCBhPWUuaW5wdXRzWzBdLnJlc2hhcGUoWzEsaSxyXSksdT1lLmlucHV0c1sxXS5yZXNoYXBlKFsxLHIsbl0pLGQ9WzEsaSxuXSxsPVthLHVdO2UuY29tcHV0ZShidChsLHthY3RpdmF0aW9uOlwiXCJ9LHQsZCkse2lucHV0czpsfSl9ZWxzZSBlLmNvbXB1dGUoYnQoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX19KTt2YXIgZmMsaGMsZ2MseGEsU2EsVGE9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7ZmM9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIk1hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHNcIik7bGV0IG49ZVswXSxyPW4uZGltcy5sZW5ndGg7aWYobi5kaW1zW3ItMV0hPT10LmspdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlXCIpO2xldCBvPU1hdGguZmxvb3IoKHQuayt0LmJsb2NrU2l6ZS0xKS90LmJsb2NrU2l6ZSksaT10LmJsb2NrU2l6ZS84KnQuYml0cyxzPWVbMV07aWYoIXguYXJlRXF1YWwocy5kaW1zLFt0Lm4sbyxpXSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplXCIpO2xldCB1PWVbMl0uZGltcztpZih4LnNpemUodSkhPT10Lm4qbyl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci5cIik7aWYoZS5sZW5ndGg9PT00KXtsZXQgbD1lWzNdLmRpbXMsYz10Lm4qKHQuYml0cz09PTg/bzpNYXRoLmZsb29yKChvKnQuYml0cys3KS84KSk7aWYoeC5zaXplKGwpIT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJ6ZXJvUG9pbnRzIGlucHV0IHNpemUgZXJyb3IuXCIpfX0saGM9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1uLmxlbmd0aCxvPW5bci0yXSxpPXQuayxzPXQubixhPW4uc2xpY2UoMCxyLTIpLHU9eC5zaXplKGEpLGw9ZVsxXS5kaW1zWzJdLzQsYz1lWzBdLmRhdGFUeXBlLHA9WCh0LmspLGY9WChsKSxtPVgocyksaD1hLmNvbmNhdChbbyxzXSksYj1vPjEmJnMvbSUyPT09MD8yOjEseT14LnNpemUoaCkvbS9iLGc9NjQsXz1bXSx3PVt1LG8saS9wXSx2PXguY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTt2LnNwbGljZSgtMSwxLGwvZiksXy5wdXNoKC4uLlAodykpLF8ucHVzaCguLi5QKHYpKSxfLnB1c2goLi4uUChlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJl8ucHVzaCguLi5QKHguY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgJD1bdSxvLHMvbV07Xy5wdXNoKC4uLlAoJCkpO2xldCBUPUk9PntsZXQgQT13Lmxlbmd0aCx6PVMoXCJhXCIsZVswXS5kYXRhVHlwZSxBLHApLE09UyhcImJcIiwxMix2Lmxlbmd0aCxmKSxVPVMoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEc9W3osTSxVXSxCPWUubGVuZ3RoPT09ND9TKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7QiYmRy5wdXNoKEIpO2xldCBlZT0kLmxlbmd0aCxXPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGVlLG0pLEQ9cmUoZVswXS5kYXRhVHlwZSksWj0oKCk9Pntzd2l0Y2gocCl7Y2FzZSAxOnJldHVybmBhcnJheTwke0R9LCA4PmA7Y2FzZSAyOnJldHVybmBtYXQ0eDI8JHtEfT5gO2Nhc2UgNDpyZXR1cm5gbWF0Mng0PCR7RH0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtwfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19KSgpLFI9KCk9PntsZXQgc2U9YFxuICAgICAgICAgIC8vIHJldXNlIGEgZGF0YVxuICAgICAgICAgICAgdmFyIGlucHV0X29mZnNldCA9ICR7ei5pbmRpY2VzVG9PZmZzZXQoYCR7ei50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIHdvcmRfb2Zmc2V0KWApfTtcbiAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7Wn07XG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4L3B9OyBqKyspIHtcbiAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHt6LmdldEJ5T2Zmc2V0KFwiaW5wdXRfb2Zmc2V0XCIpfTtcbiAgICAgICAgICAgICAgaW5wdXRfb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYDtmb3IobGV0IEg9MDtIPG0qYjtIKyspc2UrPWBcbiAgICAgICAgICAgIGJfdmFsdWUgPSAke2Y9PT0xP2BiJHtIfV9kYXRhYDpgYiR7SH1fZGF0YVtpXWB9O1xuICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke1p9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChFLEwpPT5gJHtEfShiX3ZhbHVlX2xvd2VyWyR7TH1dKSwgJHtEfShiX3ZhbHVlX3VwcGVyWyR7TH1dKWApLmpvaW4oXCIsIFwiKX0pO1xuICAgICAgICAgICAgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAke3A9PT0xP2Ake1p9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjh9LChFLEwpPT5gKGJfcXVhbnRpemVkX3ZhbHVlc1ske0x9XSAtICR7Qj9gemVyb19wb2ludCR7SH1gOlwiemVyb19wb2ludFwifSkgKiBzY2FsZSR7SH1gKS5qb2luKFwiLCBcIil9KTtgOmAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtafSgke0FycmF5KDgpLmZpbGwoYCR7Qj9gemVyb19wb2ludCR7SH1gOlwiemVyb19wb2ludFwifWApLmpvaW4oXCIsXCIpfSkpICogc2NhbGUke0h9O2B9O1xuICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZC54ICogJHtifSArICR7TWF0aC5mbG9vcihIL20pfV0ke20+MT9gWyR7SCVtfV1gOlwiXCJ9ICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjgvcH0sKEUsTCk9PmAke3A9PT0xP2BhX2RhdGFbJHtMfV0gKiBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske0x9XWA6YGRvdChhX2RhdGFbJHtMfV0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7TH1dKWB9YCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICAgYDtyZXR1cm4gc2V9LFE9KCk9PntsZXQgc2U9YFxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7bX07XG4gICAgICAgICAgICAke0I/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuQmxvY2tzUGVyQ29sICsgMSkgLyAyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9jb3VudDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZF9pbmRleDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkOiB1MzI7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtEfSg4KTtgfVxuICAgICAgICAgICAgYDtmb3IobGV0IEg9MDtIPG0qYjtIKyspc2UrPWBcbiAgICAgICAgICAgIGxldCBzY2FsZSR7SH0gPSAke1UuZ2V0QnlPZmZzZXQoXCJjb2xfaW5kZXggKiBuQmxvY2tzUGVyQ29sICsgYmxvY2tcIil9O1xuICAgICAgICAgICAgJHtCP2BcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGNvbF9pbmRleCAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkID0gJHtCLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF93b3JkX2luZGV4XCIpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQke0h9ID0gJHtEfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6XCJcIn1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuIHNlfSx3ZT0oKT0+e2xldCBzZT1gY29sX2luZGV4ID0gY29sICogJHttfTtgO2ZvcihsZXQgSD0wO0g8bSpiO0grKylzZSs9YFxuICAgICAgICAgICAgbGV0IGIke0h9X2RhdGEgPSAke00uZ2V0QnlJbmRpY2VzKGAke00udHlwZS5pbmRpY2VzfShjb2xfaW5kZXgsIGJsb2NrLCB3b3JkKWApfTtcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuIHNlKz1gXG4gICAgICAgICAgICB2YXIgYl92YWx1ZTogdTMyO1xuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gMHgwRjBGMEYwRnU7XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfdXBwZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3F1YW50aXplZF92YWx1ZXM6ICR7Wn07XG4gICAgICAgICAgICB2YXIgYl9kZXF1YW50aXplZF92YWx1ZXM6ICR7Wn07YCxzZX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkOiBhcnJheTwke1cudHlwZS52YWx1ZX0sICR7YipnfT47XG4gICAgICAgICR7SS5kZWNsYXJlVmFyaWFibGVzKC4uLkcsVyl9XG4gICAgICAgICR7SS5tYWluU3RhcnQoW2csMSwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtXLm9mZnNldFRvSW5kaWNlcyhgKGdsb2JhbF9pZHggLyAke2d9KSAqICR7Yn1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHtnfSkge1xuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7dC5ibG9ja1NpemUvcH07XG4gICAgICAgICAgICAke1EoKX1cbiAgICAgICAgICAgIGZvciAodmFyIHdvcmQ6IHUzMiA9IDA7IHdvcmQgPCAke2x9OyB3b3JkICs9ICR7Zn0pIHtcbiAgICAgICAgICAgICAgJHt3ZSgpfVxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtmfTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJHtSKCl9XG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L3B9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHtifSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtXLnR5cGUudmFsdWV9ID0gJHtXLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBsb2NhbF9pZC54O1xuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke2d9dTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHtifTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7Vy5zZXRCeUluZGljZXMoYCR7Vy50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCxcIm91dHB1dF92YWx1ZVwiKX07XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJNYXRNdWxOQml0c1wiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3QuYml0c307JHtwfTske2Z9OyR7bX07JHtifTske2d9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aCxkYXRhVHlwZTpjfV0sZGlzcGF0Y2hHcm91cDp7eDp5fSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpUfX0sZ2M9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1uLmxlbmd0aCxvPW5bci0yXSxpPXQuayxzPXQubixhPW4uc2xpY2UoMCxyLTIpLHU9eC5zaXplKGEpLGw9ZVsxXS5kaW1zWzJdLzQsYz1lWzBdLmRhdGFUeXBlLHA9WCh0LmspLGY9WChsKSxtPWEuY29uY2F0KFtvLHNdKSxoPTEyOCxiPXMlOD09PTA/ODpzJTQ9PT0wPzQ6MSx5PWgvYixnPXkqZio4LF89Zy9wLHc9Zy90LmJsb2NrU2l6ZSx2PXguc2l6ZShtKS9iLCQ9W10sVD1bdSxvLGkvcF0sST14LmNvbnZlcnRTaGFwZShlWzFdLmRpbXMpLnNsaWNlKCk7SS5zcGxpY2UoLTEsMSxsL2YpLCQucHVzaCguLi5QKFQpKSwkLnB1c2goLi4uUChJKSksJC5wdXNoKC4uLlAoZVsyXS5kaW1zKSksZS5sZW5ndGg9PT00JiYkLnB1c2goLi4uUCh4LmNvbnZlcnRTaGFwZShlWzNdLmRpbXMpKSk7bGV0IEE9W3UsbyxzXTskLnB1c2goLi4uUChBKSk7bGV0IHo9TT0+e2xldCBVPVQubGVuZ3RoLEc9UyhcImFcIixlWzBdLmRhdGFUeXBlLFUscCksQj1TKFwiYlwiLDEyLEkubGVuZ3RoLGYpLGVlPVMoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFc9W0csQixlZV0sRD1lLmxlbmd0aD09PTQ/UyhcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO0QmJlcucHVzaChEKTtsZXQgWj1BLmxlbmd0aCxSPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLFopLFE9cmUoZVswXS5kYXRhVHlwZSksd2U9KCk9Pntzd2l0Y2gocCl7Y2FzZSAxOnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtRfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdLCBzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtRfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtjYXNlIDI6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke1F9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke1F9PihzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtgO2Nhc2UgNDpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSBzdWJfYVt3b3JkX29mZnNldF07XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSBzdWJfYVt3b3JkX29mZnNldCArIDFdO2A7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7cH0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fTtyZXR1cm5gXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1Yl9hOiBhcnJheTwke0cudHlwZS52YWx1ZX0sICR7X30+O1xuICAgICAgICB2YXI8d29ya2dyb3VwPiBpbnRlcl9yZXN1bHRzOiBhcnJheTxhcnJheTwke1IudHlwZS52YWx1ZX0sICR7eX0+LCAke2J9PjtcbiAgICAgICAgJHtNLmRlY2xhcmVWYXJpYWJsZXMoLi4uVyxSKX1cbiAgICAgICAgJHtNLm1haW5TdGFydChbeSxiLDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Iub2Zmc2V0VG9JbmRpY2VzKGB3b3JrZ3JvdXBfaW5kZXggKiAke2J9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5fYmxvY2tzX3Blcl9jb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBudW1fdGlsZXMgPSAgKG5fYmxvY2tzX3Blcl9jb2wgLSAxKSAvICR7d30gKyAxO1xuXG4gICAgICAgICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgICAgICAgZm9yICh2YXIgdGlsZTogdTMyID0gMDsgdGlsZSA8IG51bV90aWxlczsgdGlsZSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgYV9jb2xfc3RhcnQgPSB0aWxlICogJHtffTtcbiAgICAgICAgICAgIC8vIGxvYWQgb25lIHRpbGUgQSBkYXRhIGludG8gc2hhcmVkIG1lbW9yeS5cbiAgICAgICAgICAgIGZvciAodmFyIGFfb2Zmc2V0ID0gbG9jYWxfaWR4OyBhX29mZnNldCA8ICR7X307IGFfb2Zmc2V0ICs9ICR7aH0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBhX2NvbCA9IGFfY29sX3N0YXJ0ICsgYV9vZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChhX2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMl0pXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke0cuZ2V0QnlJbmRpY2VzKGAke0cudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBhX2NvbClgKX07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHtHLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICAgIC8vIGVhY2ggdGhyZWFkIHByb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICBsZXQgYl9yb3cgPSBjb2wgKyBsb2NhbF9pZC55O1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGlsZSAqICR7d30gKyBsb2NhbF9pZC54O1xuICAgICAgICAgICAgJHtEP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBiX3JvdyAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZCA9ICR7RC5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtRfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6YFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7UX0oOCk7YH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7ZWUuZ2V0QnlPZmZzZXQoXCJiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtCLmdldEJ5SW5kaWNlcyhgJHtCLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke3QuYmxvY2tTaXplL3B9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7Zn07IGkrKykge1xuICAgICAgICAgICAgICAke3dlKCl9XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtmPT09MT9cImJfZGF0YVwiOlwiYl9kYXRhW2ldXCJ9O1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7UX0+KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChzZSxIKT0+YCR7UX0oYl92YWx1ZV9sb3dlclske0h9XSksICR7UX0oYl92YWx1ZV91cHBlclske0h9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke1F9Pigke0FycmF5KDgpLmZpbGwoXCJ6ZXJvX3BvaW50XCIpLmpvaW4oXCIsXCIpfSkpICogc2NhbGU7XG4gICAgICAgICAgICAgIGludGVyX3Jlc3VsdHNbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gKz0gJHtBcnJheS5mcm9tKHtsZW5ndGg6Mn0sKHNlLEgpPT5gJHtgZG90KGFfZGF0YSR7SH0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7SH1dKWB9YCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OC9wfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgJHtifSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtSLnR5cGUudmFsdWV9ID0gJHtSLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHt5fTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke1Iuc2V0QnlJbmRpY2VzKGAke1IudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZHgpYCxcIm91dHB1dF92YWx1ZVwiKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkJsb2Nrd2lzZU1hdE11bE5CaXRzMzJcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmJsb2NrU2l6ZX07JHtwfTske2Z9OyR7eX07JHtifWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkoZS5sZW5ndGgpLmZpbGwoXCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6Y31dLGRpc3BhdGNoR3JvdXA6e3g6dn0scHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6en19LHhhPShlLHQpPT57ZmMoZS5pbnB1dHMsdCksdC5ibG9ja1NpemU9PT0zMiYmZS5hZGFwdGVySW5mby5pc1ZlbmRvcihcImludGVsXCIpJiZlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiZ2VuLTEybHBcIik/ZS5jb21wdXRlKGdjKGUuaW5wdXRzLHQpKTplLmNvbXB1dGUoaGMoZS5pbnB1dHMsdCkpfSxTYT1lPT5OKGUpfSk7dmFyIHljLGJjLF9jLHdjLCRjLHZjLHhjLFNjLElhLENhPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTt5Yz1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxiYz0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7TyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtPKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7ZS50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtyfVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sX2M9KGUsdCxuKT0+e2xldCByPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbylyKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtPKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtPKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke08oXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtyfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSx3Yz0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke08oXCJ1bmlmb3Jtcy5wYWRzXCIsbyxuKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7TyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtPKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7TyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3J9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LCRjPShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7TyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7TyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7TyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7TyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3J9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHZjPShlLHQsbik9Pntzd2l0Y2gobi5tb2RlKXtjYXNlIDA6cmV0dXJuIGJjKGUsdCxuLnBhZHMubGVuZ3RoKTtjYXNlIDE6cmV0dXJuIF9jKGUsdCxuLnBhZHMubGVuZ3RoKTtjYXNlIDI6cmV0dXJuIHdjKGUsdCxuLnBhZHMubGVuZ3RoKTtjYXNlIDM6cmV0dXJuICRjKGUsdCxuLnBhZHMubGVuZ3RoKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHhjPShlLHQpPT57bGV0IG49eC5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpLHI9ZVswXS5kaW1zLG89eC5zaXplKG4pLGk9W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6NixkYXRhOnQucGFkc31dLHM9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YTt0Lm1vZGU9PT0wJiZpLnB1c2goe3R5cGU6cz9lWzJdLmRhdGFUeXBlOjEsZGF0YTp0LnZhbHVlfSksaS5wdXNoKC4uLlAoZVswXS5kaW1zLG4pKTtsZXQgYT1bXCJyYW5rXCJdLHU9ZD0+e2xldCBsPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoKSxjPVMoXCJ4XCIsZVswXS5kYXRhVHlwZSxyLmxlbmd0aCkscD1jLnR5cGUudmFsdWUsZj12YyhsLHIubGVuZ3RoLHQpLG09W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZtLnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6cz9wOlwiZjMyXCJ9KSxgXG4gICAgICAgICAgICAke2QucmVnaXN0ZXJVbmlmb3JtcyhtKS5kZWNsYXJlVmFyaWFibGVzKGMsbCl9XG4gICAgICAgICAgICAke2QubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke2QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtwfSgwKTtcbiAgICAgICAgICAgICR7Zn1cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9JHtzfWAsaW5wdXREZXBlbmRlbmNpZXM6YX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh4LnNpemUobikvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aX0pLGdldFNoYWRlclNvdXJjZTp1fX0sU2M9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgbj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxyPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5kYXRhVHlwZT09PTEwP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTplWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbz1lWzBdLmRpbXMubGVuZ3RoLGk9bmV3IEludDMyQXJyYXkoMipvKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgYT1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IHU9MDt1PGEubGVuZ3RoO3UrKylpW051bWJlcihhW3VdKV09TnVtYmVyKG5bdV0pLGlbTnVtYmVyKGFbdV0pK29dPU51bWJlcihuW3UrYS5sZW5ndGhdKX1lbHNlIG4uZm9yRWFjaCgoYSx1KT0+aVtOdW1iZXIodSldPU51bWJlcihhKSk7bGV0IHM9W107cmV0dXJuIGkuZm9yRWFjaChhPT5zLnB1c2goYSkpLHttb2RlOnQubW9kZSx2YWx1ZTpyLHBhZHM6c319ZWxzZSByZXR1cm4gdH0sSWE9KGUsdCk9Pnt5YyhlLmlucHV0cyk7bGV0IG49U2MoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHhjKGUuaW5wdXRzLG4pLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHBuLEFhLEVhLGthLFBhLFRjLEljLHphLEJhLERhLE9hLE1hLFVhLFJhLFZhLE5hLExhLFdhLEdhLEhhPWsoKCk9PntcInVzZSBzdHJpY3RcIjt5ZSgpO1YoKTtxKCk7SygpO3BuPWU9PntpZih0ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJighZXx8ZS5sZW5ndGghPT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKX0sQWE9KGUsdCxuKT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1lLmRpbXMuc2xpY2UoKTtyJiZvLnNwbGljZSgxLDAsby5wb3AoKSk7bGV0IGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxzPXQua2VybmVsU2hhcGUuc2xpY2UoKSxhPXQuc3RyaWRlcy5zbGljZSgpLHU9aT90LmRpbGF0aW9ucy5zbGljZSgpOltdLGQ9dC5wYWRzLnNsaWNlKCk7WGUuYWRqdXN0UG9vbEF0dHJpYnV0ZXMobixvLHMsYSx1LGQpO2xldCBsPVhlLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixvLGEsdSxzLGQsdC5hdXRvUGFkKSxjPU9iamVjdC5hc3NpZ24oe30sdCk7aT9PYmplY3QuYXNzaWduKGMse2tlcm5lbFNoYXBlOnMsc3RyaWRlczphLHBhZHM6ZCxkaWxhdGlvbnM6dSxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbihjLHtrZXJuZWxTaGFwZTpzLHN0cmlkZXM6YSxwYWRzOmQsY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCBwPWwuc2xpY2UoKTtyZXR1cm4gcC5wdXNoKHAuc3BsaWNlKDEsMSlbMF0pLFtjLHI/cDpsXX0sRWE9KGUsdCk9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLHI9eC5zaXplKGUpLG89eC5zaXplKHQua2VybmVsU2hhcGUpLGk9W3t0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfV0scz1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwidTMyXCJ9XTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IGE9dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0xXSx1PXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTFdLGQ9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0xXSxsPXQucGFkc1t0LnBhZHMubGVuZ3RoLTFdLGM9ISEoZCtsKTtpLnB1c2goe3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSkscy5wdXNoKHtuYW1lOlwia3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd0VuZFwiLHR5cGU6XCJ1MzJcIn0pO2xldCBwPSExO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IGY9dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxtPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLGg9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSxiPXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdO3A9ISEoaCtiKSxpLnB1c2goe3R5cGU6MTIsZGF0YTpmfSx7dHlwZToxMixkYXRhOm19LHt0eXBlOjEyLGRhdGE6aH0se3R5cGU6MTIsZGF0YTpifSkscy5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVybltpLHMsITAsYyxwXX1lbHNle2lmKG4pdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBhPXguY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7aS5wdXNoKHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp0LnBhZHN9LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSkscy5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6YS5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IHU9dC5wYWRzLnJlZHVjZSgoZCxsKT0+ZCtsKTtyZXR1cm5baSxzLCEhdSwhMSwhMV19fSxrYT0oZSx0LG4scixvLGkscyxhLHUsZCxsLGMpPT57bGV0IHA9by5mb3JtYXQ9PT1cIk5IV0NcIixmPXQudHlwZS52YWx1ZSxtPUMoXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLHIpO2lmKG8ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgaD1cIlwiLGI9XCJcIix5PVwiXCIsZz1uLShwPzI6MSk7aWYobD9oPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Z31dID0gaW5kaWNlc1ske2d9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtnfV0gPCAwIHx8IHhJbmRpY2VzWyR7Z31dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske2d9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgICAgIH1gOmg9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtnfV0gPSBpbmRpY2VzWyR7Z31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWAsby5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgdz1uLShwPzM6Mik7Yz9iPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7d31dID0gaW5kaWNlc1ske3d9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHt3fV0gPCAwIHx8IHhJbmRpY2VzWyR7d31dID49IHVuaWZvcm1zLnhfc2hhcGVbJHt3fV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOmI9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt3fV0gPSBpbmRpY2VzWyR7d31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgLHk9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKHUpLmRlY2xhcmVWYXJpYWJsZXModCxtKX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2Z9KCR7YX0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtifVxuICAgICAgICAgICAgICAke2h9XG4gICAgICAgICAgICAgICR7eX1cbiAgICAgICAgICAgICAgJHtzfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZihwKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgaD1vLmtlcm5lbFNoYXBlLmxlbmd0aCxiPW8ucGFkcy5sZW5ndGgseT1cIlwiO3JldHVybiBkP3k9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgIH1gOnk9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXModSkuZGVjbGFyZVZhcmlhYmxlcyh0LG0pfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke2h9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2Z9KCR7YX0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke2gtMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke08oXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsaCl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke08oXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsaCl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7aC0xfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke24taH11OyBqIDwgJHtufXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtPKFwidW5pZm9ybXMuc3RyaWRlc1wiLGBqIC0gJHtuLWh9dWAsaCl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtuLWh9dV0gLSAke08oXCJ1bmlmb3Jtcy5wYWRzXCIsXCJqIC0gMnVcIixiKX07XG4gICAgICAgICAgICAgICAgICAke3l9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtzfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9fSxQYT1lPT5gJHtlLmZvcm1hdH07JHtlLmNlaWxNb2RlfTske2UuYXV0b1BhZH07JHtlLmtlcm5lbFNoYXBlLmxlbmd0aH1gLFRjPWU9PmAke1BhKGUpfTske2UuY291bnRJbmNsdWRlUGFkfWAsSWM9ZT0+YCR7UGEoZSl9OyR7ZS5zdG9yYWdlT3JkZXJ9OyR7ZS5kaWxhdGlvbnN9YCx6YT1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxCYT0oZSx0LG4scik9PntsZXRbbyxpXT1BYSh0LHIsbikscz1TKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksYT1zLnR5cGUudmFsdWUsdT1cInZhbHVlICs9IHhfdmFsO1wiLGQ9XCJcIjtvLmNvdW50SW5jbHVkZVBhZD9kKz1gdmFsdWUgLz0gJHthfSh1bmlmb3Jtcy5rZXJuZWxTaXplKTtgOmQrPWB2YWx1ZSAvPSAke2F9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtsZXRbbCxjLHAsZixtXT1FYShpLG8pO2wucHVzaCguLi5QKHQuZGltcyxpKSk7bGV0IGg9W1wicmFua1wiXTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3IuY2FjaGVLZXl9OyR7cH07JHtmfTske219YCxpbnB1dERlcGVuZGVuY2llczpofSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHguc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczpsfSksZ2V0U2hhZGVyU291cmNlOmI9PmthKGIscyx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8sdSxkLDAsYyxwLGYsbSl9fSxEYT1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAsbj16YShlKTtpZihuLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO2xldCByPXtjb3VudEluY2x1ZGVQYWQ6dCwuLi5uLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5yLGNhY2hlS2V5OlRjKHIpfX0sT2E9KGUsdCk9PntwbihlLmlucHV0cyksZS5jb21wdXRlKEJhKFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LE1hPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXX0sVWE9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5NYSxjYWNoZUtleTp0fX0sUmE9KGUsdCk9PntwbihlLmlucHV0cyksZS5jb21wdXRlKEJhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LFZhPShlLHQsbixyKT0+e2xldFtvLGldPUFhKHQscixuKSxzPWBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYCxhPVwiXCIsdT1TKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksZD1bXCJyYW5rXCJdLFtsLGMscCxmLG1dPUVhKGksbyk7cmV0dXJuIGwucHVzaCguLi5QKHQuZGltcyxpKSkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtyLmNhY2hlS2V5fTske3B9OyR7Zn07JHttfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh4LnNpemUoaSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bH0pLGdldFNoYWRlclNvdXJjZTpoPT5rYShoLHUsdC5kaW1zLmxlbmd0aCxpLmxlbmd0aCxvLHMsYSx0LmRhdGFUeXBlPT09MTA/LTY1NTA0Oi0xZTUsYyxwLGYsbSl9fSxOYT0oZSx0KT0+e3BuKGUuaW5wdXRzKSxlLmNvbXB1dGUoVmEoXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxMYT1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLG49ZS5kaWxhdGlvbnMscj16YShlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7bGV0IG89e3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpuLC4uLnIsY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm8sY2FjaGVLZXk6SWMobyl9fSxXYT1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLk1hLGNhY2hlS2V5OnR9fSxHYT0oZSx0KT0+e3BuKGUuaW5wdXRzKSxlLmNvbXB1dGUoVmEoXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBBYyxFYyxxYSxGYSxLYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtBYz0oZSx0KT0+e2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMV0uZGltcz09PWVbMl0uZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJ4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlPT09NiYmZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTAmJmVbMV0uZGltcy5sZW5ndGghPT0xJiZlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGUubGVuZ3RoPjIpe2lmKGVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuXCIpO2lmKCFlWzFdLmRpbXMubWFwKChuLHIpPT5uPT09ZVsyXS5kaW1zW3JdKS5yZWR1Y2UoKG4scik9Pm4mJnIsITApKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpfWlmKHQuYmxvY2tTaXplPjApe2lmKGVbMV0uZGltcy5sZW5ndGg9PT0wfHxlWzFdLmRpbXMubGVuZ3RoPT09MSYmZVsxXS5kaW1zWzBdPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobyxpKT0+aT09PXQuYXhpc3x8bz09PWVbMF0uZGltc1tpXSkucmVkdWNlKChvLGkpPT5vJiZpLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpc1wiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay5cIik7bGV0IG49ZVswXS5kaW1zW3QuYXhpc10scj1lWzFdLmRpbXNbdC5heGlzXTtpZih0LmJsb2NrU2l6ZTxNYXRoLmNlaWwobi9yKXx8dC5ibG9ja1NpemU+TWF0aC5jZWlsKG4vKHItMSktMSkpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS5cIil9fSxFYz0oZSx0KT0+e2xldCBuPXgubm9ybWFsaXplQXhpcyh0LmF4aXMsZVswXS5kaW1zLmxlbmd0aCkscj1lWzBdLmRhdGFUeXBlLG89cj09PTMsaT1lWzBdLmRpbXMscz1lWzFdLmRhdGFUeXBlLGE9eC5zaXplKGkpLHU9cj09PTN8fHI9PT0yLGQ9dT9bTWF0aC5jZWlsKHguc2l6ZShlWzBdLmRpbXMpLzQpXTplWzBdLmRpbXMsbD1lWzFdLmRpbXMsYz1lLmxlbmd0aD4yP2VbMl06dm9pZCAwLHA9Yz91P1tNYXRoLmNlaWwoeC5zaXplKGMuZGltcykvNCldOmMuZGltczp2b2lkIDAsZj1sLmxlbmd0aD09PTB8fGwubGVuZ3RoPT09MSYmbFswXT09PTEsbT1mPT09ITEmJmwubGVuZ3RoPT09MSxoPVgoYSksYj1mJiYoIXV8fGg9PT00KSx5PWI/aDoxLGc9YiYmIXU/aDoxLF89UyhcImlucHV0XCIsdT8xMjpyLGQubGVuZ3RoLGcpLHc9UyhcInNjYWxlXCIscyxsLmxlbmd0aCksdj1jP1MoXCJ6ZXJvX3BvaW50XCIsdT8xMjpyLHAubGVuZ3RoKTp2b2lkIDAsJD1DKFwib3V0cHV0XCIscyxpLmxlbmd0aCx5KSxUPVtfLHddO3YmJlQucHVzaCh2KTtsZXQgST1bZCxsXTtjJiZJLnB1c2gocCk7bGV0IEE9W3t0eXBlOjEyLGRhdGE6YS95fSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6dC5ibG9ja1NpemV9LC4uLlAoLi4uSSxpKV0sej1NPT57bGV0IFU9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgJHtNLnJlZ2lzdGVyVW5pZm9ybXMoVSkuZGVjbGFyZVZhcmlhYmxlcyguLi5ULCQpfVxuICAgICAgJHtNLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7TS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgLy8gU2V0IGlucHV0IHhcbiAgICAgICAgICAke3U/YFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtfLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAvIDRcIil9O1xuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtvP1widW5wYWNrNHhJOChpbnB1dClcIjpcInVucGFjazR4VTgoaW5wdXQpXCJ9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAke3k9PT0xP1wieF92ZWNbZ2xvYmFsX2lkeCAlIDRdXCI6XCJ4X3ZlY1wifTtgOmBsZXQgeF92YWx1ZSA9ICR7Xy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O2B9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHtmP2BsZXQgc2NhbGVfdmFsdWU9ICR7dy5nZXRCeU9mZnNldChcIjBcIil9YDptP2BcbiAgICAgICAgICAgIGxldCBzY2FsZV9pbmRleCA9ICR7JC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke3cuZ2V0QnlPZmZzZXQoXCJzY2FsZV9pbmRleFwiKX07YDpgXG4gICAgICAgICAgICB2YXIgc2NhbGVfaW5kaWNlczogJHt3LnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7dy5pbmRpY2VzR2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAgICAgJHt3LmluZGljZXNTZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7dy5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgfTtcblxuICAgICAgICAgIC8vIFNldCB6ZXJvLXBvaW50IGlucHV0XG4gICAgICAgICAgJHt2P2Y/dT9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3YuZ2V0QnlPZmZzZXQoXCIwXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7di5nZXRCeU9mZnNldChcIjBcIil9YDptP3U/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHskLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGV4IC8gNFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4ICUgNF1gOmBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7JC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt2LmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleFwiKX07YDp1P2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3cuaW5kaWNlc1RvT2Zmc2V0KFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X29mZnNldCAlIDRdO2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt2LmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt1P28/XCJpMzJcIjpcInUzMlwiOl8udHlwZS52YWx1ZX0oMCk7YH07XG4gICAgICAvLyBDb21wdXRlIGFuZCB3cml0ZSBvdXRwdXRcbiAgICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixgJHskLnR5cGUudmFsdWV9KHhfdmFsdWUgLSB6ZXJvX3BvaW50X3ZhbHVlKSAqIHNjYWxlX3ZhbHVlYCl9O1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiRGVxdWFudGl6ZUxpbmVhclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6dj9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp6LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS95LzY0KSx5OjEsejoxfSxwcm9ncmFtVW5pZm9ybXM6QX0pfX0scWE9KGUsdCk9PntBYyhlLmlucHV0cyx0KSxlLmNvbXB1dGUoRWMoZS5pbnB1dHMsdCkpfSxGYT1lPT5OKHtheGlzOmUuYXhpcyxibG9ja1NpemU6ZS5ibG9ja1NpemV9KX0pO3ZhciBrYyxQYyxqYSxaYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtWKCk7SygpO2tjPShlLHQsbik9PntsZXQgcj1lPT09dCxvPWU8dCYmbjwwLGk9ZT50JiZuPjA7aWYocnx8b3x8aSl0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHMnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKX0sUGM9KGUsdCxuLHIpPT57bGV0IG89TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL24pKSxpPVtvXSxzPW8sYT1be3R5cGU6MTIsZGF0YTpzfSx7dHlwZTpyLGRhdGE6ZX0se3R5cGU6cixkYXRhOm59LC4uLlAoaSldLHU9ZD0+e2xldCBsPUMoXCJvdXRwdXRcIixyLGkubGVuZ3RoKSxjPWwudHlwZS52YWx1ZSxwPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRcIix0eXBlOmN9LHtuYW1lOlwiZGVsdGFcIix0eXBlOmN9XTtyZXR1cm5gXG4gICAgICAgICR7ZC5yZWdpc3RlclVuaWZvcm1zKHApLmRlY2xhcmVWYXJpYWJsZXMobCl9XG4gICAgICAgICR7ZC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtkLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7Y30oZ2xvYmFsX2lkeCkgKiB1bmlmb3Jtcy5kZWx0YTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJhbmdlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gfSxnZXRTaGFkZXJTb3VyY2U6dSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6cn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfSxwcm9ncmFtVW5pZm9ybXM6YX0pfX0samE9ZT0+e2xldCB0PTAsbj0wLHI9MDtlLmlucHV0c1swXS5kYXRhVHlwZT09PTY/KHQ9ZS5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdKTplLmlucHV0c1swXS5kYXRhVHlwZT09PTEmJih0PWUuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0scj1lLmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSksdGUud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZrYyh0LG4sciksZS5jb21wdXRlKFBjKHQsbixyLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSx7aW5wdXRzOltdfSl9fSk7dmFyIHpjLEJjLFFhLFhhLFlhPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO3pjPShlLHQsbixyKT0+e2lmKGUhPT1cIm5vbmVcIiYmciE9PVwiaTMyXCImJnIhPT1cInUzMlwiJiZyIT09XCJmMzJcIil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7cn0gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHJlZHVjdGlvbiAke2V9LmApO2xldCBvPWB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBsb29wIHtcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZUYzMiA9YCxpPWA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBiaXRjYXN0PGkzMj4obmV3VmFsdWVGMzIpO1xuICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsoJiR7dH0sIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiByZXMuZXhjaGFuZ2VkIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlcy5vbGRfdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9YDtzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybmAke3R9PSR7bn07YDtjYXNlXCJhZGRcIjpyZXR1cm4gcj09PVwiaTMyXCJ8fHI9PT1cInUzMlwiP2BhdG9taWNBZGQoJiR7dH0sIGJpdGNhc3Q8JHtyfT4oJHtufSkpO2A6YFxuICAgICAgICAgICAgICAke299Yml0Y2FzdDwke3J9PihvbGRWYWx1ZSkgKyAoJHtufSkke2l9YDtjYXNlXCJtYXhcIjpyZXR1cm4gcj09PVwiaTMyXCJ8fHI9PT1cInUzMlwiP2BhdG9taWNNYXgoJiR7dH0sIGJpdGNhc3Q8JHtyfT4oJHtufSkpO2A6YFxuICAgICAgICAgICAgICAgICR7b31tYXgoYml0Y2FzdDxmMzI+KG9sZFZhbHVlKSwgKCR7bn0pKSR7aX1gO2Nhc2VcIm1pblwiOnJldHVybiByPT09XCJpMzJcInx8cj09PVwidTMyXCI/YGF0b21pY01pbigmJHt0fSwgYml0Y2FzdDwke3J9Pigke259KSk7YDpgJHtvfW1pbihiaXRjYXN0PCR7cn0+KG9sZFZhbHVlKSwgKCR7bn0pKSR7aX1gO2Nhc2VcIm11bFwiOnJldHVybmAke299KGJpdGNhc3Q8JHtyfT4ob2xkVmFsdWUpICogKCR7bn0pKSR7aX1gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBSZWR1Y3Rpb24gJHtlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sQmM9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1lWzFdLmRpbXMsbz1uLGk9MSxzPU1hdGguY2VpbCh4LnNpemVUb0RpbWVuc2lvbihyLHIubGVuZ3RoLTEpL2kpLGE9cltyLmxlbmd0aC0xXSx1PXguc2l6ZUZyb21EaW1lbnNpb24obixhKSxkPVt7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp1fSwuLi5QKGVbMV0uZGltcyxlWzJdLmRpbXMsbyldLGw9Yz0+e2xldCBwPVMoXCJpbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxmPVMoXCJ1cGRhdGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGkpLG09dC5yZWR1Y3Rpb24hPT1cIm5vbmVcIiYmdC5yZWR1Y3Rpb24hPT1cIlwiP1NvKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCk6QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsaSk7cmV0dXJuYFxuICAgICAgJHtjLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibGFzdF9pbmRleF9kaW1lbnNpb25cIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJudW1fdXBkYXRlc19lbGVtZW50c1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocCxmLG0pfVxuICAgICAgJHtjLm1haW5TdGFydCgpfVxuICAgICAgICAke2MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtlWzBdLmRpbXMubGVuZ3RoPT09MT9gXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZTtgOmBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlc1tpIC0gaW5kaWNlc19zdGFydF07XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydF07YH1cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaWYgKGluZGV4ID49IGkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gaTMyKGRpbV92YWx1ZSAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5kZXggPCAtaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggKz0gaTMyKGRpbV92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRhdGFfb2Zmc2V0ICs9IHUzMigodTMyKGluZGV4KSAqIGVsZW1lbnRfY291bnRfZGltKSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMHU7IGkgPCB1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50czsgaSsrKSB7XG4gICAgbGV0IHZhbHVlID0gdXBkYXRlc1t1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50cyAqIGdsb2JhbF9pZHggKyBpXTtcbiAgICAke3pjKHQucmVkdWN0aW9uLFwib3V0cHV0W2RhdGFfb2Zmc2V0ICsgaV1cIixcInZhbHVlXCIsbS50eXBlLnZhbHVlKX1cbiAgfVxuXG4gICAgICB9YH07cmV0dXJue25hbWU6XCJTY2F0dGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fV8ke3QucmVkdWN0aW9ufWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9KSxnZXRTaGFkZXJTb3VyY2U6bH19LFFhPWU9Pk4oe3JlZHVjdGlvbjplLnJlZHVjdGlvbn0pLFhhPShlLHQpPT57ZS5jb21wdXRlKEJjKGUuaW5wdXRzLHQpLHtpbnB1dHM6W2UuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxvdXRwdXRzOltdfSl9fSk7dmFyIERjLE9jLE1jLEphLFVjLFJjLFZjLE5jLExjLFdjLEdjLEhjLGV1LHFjLEZjLEtjLGpjLFpjLHR1LG51LHJ1PWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO0RjPShlLHQpPT57aWYoZS5ldmVyeShuPT5uPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSxPYz0oZSx0LG4pPT57dC5ldmVyeShvPT5vPj0wJiZvPG58fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IHI9bmV3IEFycmF5KG4pLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobyxpKT0+cltvXT1lW2ldKSxyfSxNYz0oZSx0LG4scixvLGkpPT57bGV0W3MsYSx1XT1uPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0sZD1lWzBdLmRpbXMubGVuZ3RoO2lmKHM+MCYmZS5sZW5ndGg+cyYmZVtzXS5kaW1zLmxlbmd0aD4wKWVbc10uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChsPT5pLnB1c2gobCkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoYT4wJiZlLmxlbmd0aD5hJiZlW2FdLmRpbXMubGVuZ3RoPT09MSYmZVthXS5kaW1zWzBdPjApe2lmKGVbYV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChsPT5yLnB1c2gobCkpLHIubGVuZ3RoIT09MCYmci5sZW5ndGghPT1kJiZuPj0xOCYmci5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7RGMocix0KSx0LmF4ZXMubGVuZ3RoPjAmJk9jKHIsdC5heGVzLGQpLmZvckVhY2goKGwsYyk9PnJbY109bCl9aWYodT4wJiZlLmxlbmd0aD51JiZlW3VdLmRpbXMubGVuZ3RoPT09MSYmZVt1XS5kaW1zWzBdPjAmJihlW3VdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKGw9Pm8ucHVzaChOdW1iZXIobCkpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09ZCYmbj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYoci5sZW5ndGghPT0wJiZyLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgcjxcInVcIiYmdHlwZW9mIG88XCJ1XCImJnIubGVuZ3RoPjAmJm8ubGVuZ3RoPmQpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sSmE9KGUsdCxuLHIpPT5gXG4gIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgbGV0IGJpZyA9ICgke2V9KSAqICgke3R9KTtcbiAgbGV0IHdob2xlID0gJHtyfShiaWcgLyAoJHtufSkpO1xuICBsZXQgZnJhY3QgPSAke3J9KGJpZyAlICgke259KSkgLyAke3J9KCR7bn0pO1xuICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbmAsVWM9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7dH0geyBgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuYFxuICAgICAgICAgIGlmICh4U2NhbGUgPCAxLjAgfHwgZmxvb3IoeFNjYWxlKSAhPSB4U2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAke3R9KHhSZXNpemVkKSAvICR7dH0oeFNjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHtKYShcInhSZXNpemVkXCIsXCJsZW5ndGhPcmlnaW5hbFwiLFwibGVuZ3RoUmVzaXplZFwiLHQpfVxuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpIC0gMC41O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCI6cmV0dXJuYHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpO2A7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAke0phKFwieFJlc2l6ZWRcIixcImxlbmd0aE9yaWdpbmFsIC0gMVwiLFwibGVuZ3RoUmVzaXplZCAtIDFcIix0KX1cbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7dH0ocm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke3R9KHhSZXNpemVkKSAqICR7dH0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke3R9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHt0fShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHt0fShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuYHJldHVybiAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLFJjPShlLHQsbik9PmBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke259LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7bn0ge2ArKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsVmM9KGUsdCxuKT0+e2xldCByPW5ldyBBcnJheShuKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkobikuZmlsbCgxKSksbz1lLmxlbmd0aD09PTA/cjplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgoaSxzKT0+e3JbaV09b1tzXSxyW3Mrbl09b1t0Lmxlbmd0aCtzXX0pLHIpOm99LE5jPShlLHQsbixyKT0+e2xldCBvPVtdO2lmKG4ubGVuZ3RoPjApaWYoci5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKGk9Pm8ucHVzaChpKSksTWF0aC5tYXgoLi4ucik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7ci5mb3JFYWNoKChpLHMpPT5vW2ldPW5bc10pfWVsc2Ugbi5mb3JFYWNoKGk9Pm8ucHVzaChpKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO289ZS5tYXAoKGkscyk9Pk1hdGgucm91bmQoaSp0W3NdKSl9cmV0dXJuIG99LExjPShlLHQsbik9PntsZXQgcj0oKCk9Pntzd2l0Y2gobi5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gbi5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLm4uYXhlcy5tYXAoaT0+dFtpXSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4udCxOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiBuLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4ubi5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi50LE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtuLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7dC5maWxsKDEsMCx0Lmxlbmd0aCk7bGV0IG89ZS5zbGljZSgpO3JldHVybiBuLmF4ZXMubGVuZ3RoPjA/KG4uYXhlcy5mb3JFYWNoKGk9PnRbaV09ciksbi5heGVzLmZvckVhY2goaT0+b1tpXT1NYXRoLnJvdW5kKGVbaV0qdFtpXSkpKToodC5maWxsKHIsMCx0Lmxlbmd0aCksby5mb3JFYWNoKChpLHMpPT5vW3NdPU1hdGgucm91bmQoaSp0W3NdKSkpLG99LFdjPShlLHQsbixyLG8pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7bi5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke24ubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke24ubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtPKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIscil9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7TyhcInVuaWZvcm1zLnJvaVwiLFwiaVwiLG8pfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7TyhcInVuaWZvcm1zLnJvaVwiLGBpICsgJHt0Lmxlbmd0aH1gLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke2UudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7TyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke08oXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCxHYz0oZSx0LG4scixvLGkscyk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtPKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke08oXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixpKX07XG4gICAgICAgICAgdmFyIHJvaV9oaSA9ICR7TyhcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtuLmxlbmd0aH1gLGkpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7TyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke08oXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHtzfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gLEhjPShlLHQpPT5gXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcImlucHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7TyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWAsZXU9KGUsdCxuLHIpPT5lLnJhbms+cj9gXG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdCxcImNoYW5uZWxcIil9O1xuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLG4sXCJiYXRjaFwiKX07XG5gOlwiXCIscWM9KGUsdCxuLHIsbyk9PntsZXRbcyxhLHUsZF09bi5sZW5ndGg9PT0yP1stMSwwLDEsLTFdOlswLDIsMywxXSxsPWUudHlwZS52YWx1ZTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHtsfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixhLGBtYXgoMCwgbWluKHJvdywgJHtuW2FdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHUsYG1heCgwLCBtaW4oY29sLCAke25bdV19IC0gMSkpYCl9O1xuICAgICAgJHtldShlLGQscywyKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtsfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIHJvdzoke2x9ID0gb3JpZ2luYWxJbmRpY2VzWyR7YX1dO1xuICAgICAgdmFyIGNvbDoke2x9ID0gb3JpZ2luYWxJbmRpY2VzWyR7dX1dO1xuICAgICAgJHtyP2BpZiAocm93IDwgMCB8fCByb3cgPiAoJHtuW2FdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7blt1XX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtvfTtcbiAgICAgIH1gOlwiXCJ9O1xuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7blthXX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtuW3VdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7bi5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2R9XSlgOlwiMFwifTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7bi5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske3N9XSlgOlwiMFwifTtcbiAgICAgIHZhciB4MTE6ICR7bH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7bH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6ICR7bH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6ICR7bH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7bH0gPSBhYnMocm93IC0gJHtsfShyb3cxKSk7XG4gICAgICB2YXIgZHgyOiAke2x9ID0gYWJzKCR7bH0ocm93MikgLSByb3cpO1xuICAgICAgdmFyIGR5MTogJHtsfSA9IGFicyhjb2wgLSAke2x9KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7bH0gPSBhYnMoJHtsfShjb2wyKSAtIGNvbCk7XG4gICAgICBpZiAocm93MSA9PSByb3cyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YH0sRmM9KGUsdCxuLHIsbyxpLHMsYSx1LGQpPT57bGV0IGw9bi5sZW5ndGg9PT0yLGM9ITAsW3AsZl09bD9bMCwxXTpjP1syLDNdOlsxLDJdLG09ZS50eXBlLnZhbHVlLGg9Yj0+e2xldCB5PWI9PT1wP1wicm93XCI6XCJjb2xcIjtyZXR1cm5gXG4gICAgICBmbiAke3l9Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7bX0ge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLGIpfTtcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiAke219ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtvW2JdfSxcbiAgICAgICAgJHtyW2JdfSwgJHtuW2JdfSwgJHtpW2JdfSwgJHtpW2JdfSArICR7bi5sZW5ndGh9KTtcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6ICR7bX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7YX0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke25bYl19IC0gMSkpKSB7XG4gICAgICAgICAgcmV0dXJuICR7dX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7bX0sIDQ+ID0gYXJyYXk8JHttfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHt5fTogJHttfSA9IG9yaWdpbmFsSWR4ICsgJHttfShpKTtcbiAgICAgICAgICBpZiAoJHt5fSA8IDAgfHwgJHt5fSA+PSAke25bYl19KSB7XG4gICAgICAgICAgICAke2Q/YGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A6YT9gcmV0dXJuICR7dX07YDpgJHt5fSA9IG1heCgwLCBtaW4oJHt5fSwgJHtuW2JdfSAtIDEpKTtgfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNfY29weVwiLGIsYHUzMigke3l9KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7Yj09PXA/ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIik6XCJyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcylcIn07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHtoKHApfTtcbiAgICAke2goZil9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAke219KSAtPiBhcnJheTwke219LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHttfSwgND4gPSBhcnJheTwke219LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7bX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7bX0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHttfSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke3N9ICogb25lUGx1c0Fic1MgLSA1ICogJHtzfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke3N9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7c307XG4gICAgY29lZmZzWzFdID0gKCgke3N9ICsgMikgKiBhYnNTIC0gKCR7c30gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke3N9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHtzfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke3N9ICogdHdvTWludXNBYnNTIC0gNSAqICR7c30pICogdHdvTWludXNBYnNTICsgOCAqICR7c30pICogdHdvTWludXNBYnNTIC0gNCAqICR7c307XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7bX0sIDQ+LCBjb2VmczogYXJyYXk8JHttfSwgND4pIC0+ICR7bX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHttfSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgfSxLYz0oZSx0LG4scixvKT0+e2xldFtzLGEsdSxkLGxdPW4ubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLGM9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHtjfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixhLGBtYXgoMCwgbWluKGRlcHRoLCAke25bYV19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdSxgbWF4KDAsIG1pbihoZWlnaHQsICR7blt1XX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKHdpZHRoLCAke25bZF19IC0gMSkpYCl9O1xuICAgICAgJHtldShlLGwscywzKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7Y30ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke2N9ID0gb3JpZ2luYWxJbmRpY2VzWyR7YX1dO1xuICAgICAgdmFyIGhlaWdodDoke2N9ID0gb3JpZ2luYWxJbmRpY2VzWyR7dX1dO1xuICAgICAgdmFyIHdpZHRoOiR7Y30gPSBvcmlnaW5hbEluZGljZXNbJHtkfV07XG4gICAgICAke3I/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtuW2FdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7blt1XX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtuW2RdfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgfWA6XCJcIn07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7blthXX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtuW3VdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtuW2RdfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtuLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7bH1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtuLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7c31dKWA6XCIwXCJ9O1xuXG4gICAgICB2YXIgeDExMTogJHtjfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2N9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7Y30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHtjfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2N9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7Y30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHtjfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2N9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHtjfSA9IGFicyhkZXB0aCAtICR7Y30oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2N9ID0gYWJzKCR7Y30oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7Y30gPSBhYnMoaGVpZ2h0IC0gJHtjfShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke2N9ID0gYWJzKCR7Y30oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtjfSA9IGFicyh3aWR0aCAtICR7Y30od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke2N9ID0gYWJzKCR7Y30od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gfSxqYz0oZSx0LG4scixvLGkpPT57bGV0IHM9ZS5kaW1zLGE9VmMoaSx0LmF4ZXMscy5sZW5ndGgpLHU9TmMocyxyLG8sdC5heGVzKSxkPXIuc2xpY2UoKTtyLmxlbmd0aD09PTAmJihkPXMubWFwKChnLF8pPT5nPT09MD8xOnVbX10vZyksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKHU9TGMocyxkLHQpKSk7bGV0IGw9QyhcIm91dHB1dFwiLGUuZGF0YVR5cGUsdS5sZW5ndGgpLGM9UyhcImlucHV0XCIsZS5kYXRhVHlwZSxzLmxlbmd0aCkscD14LnNpemUodSksZj1zLmxlbmd0aD09PXUubGVuZ3RoJiZzLmV2ZXJ5KChnLF8pPT5nPT09dVtfXSksbT10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixoPXQuZXh0cmFwb2xhdGlvblZhbHVlLGI9Yy50eXBlLnZhbHVlLHk9Zz0+YFxuICAgICAgJHtmP1wiXCI6YFxuICAgICAgJHtVYyh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLGIpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtIYyhjLHMpfTtcbiAgICAgICAgICAgICAgJHtSYyh0Lm5lYXJlc3RNb2RlLG4sYil9O1xuICAgICAgICAgICAgICAke0djKGMsbCxzLHUsZC5sZW5ndGgsYS5sZW5ndGgsbSl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtXYyhsLHMsdSxkLmxlbmd0aCxhLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKT0+e2lmKHMubGVuZ3RoPT09Mnx8cy5sZW5ndGg9PT00KXJldHVybmAke3FjKGMsbCxzLG0saCl9YDtpZihzLmxlbmd0aD09PTN8fHMubGVuZ3RoPT09NSlyZXR1cm5gJHtLYyhjLGwscyxtLGgpfWA7dGhyb3cgRXJyb3IoXCJMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7KCgpPT57aWYocy5sZW5ndGg9PT0yfHxzLmxlbmd0aD09PTQpcmV0dXJuYCR7RmMoYyxsLHMsdSxkLGEsdC5jdWJpY0NvZWZmQSxtLHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfWA7dGhyb3cgRXJyb3IoXCJDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNjYWxlc1wiLFwiZjMyXCIsZC5sZW5ndGgpLnJlZ2lzdGVyVW5pZm9ybShcInJvaVwiLFwiZjMyXCIsYS5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoYyxsKX1cbiAgICAgICR7Zy5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgJHtmP1wib3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XCI6YFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2MudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2MuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3MubGVuZ3RoPT09Mnx8cy5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuYH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtufXwke2QubGVuZ3RoPjA/dC5tb2RlPT09XCJjdWJpY1wiP2Q6ZC5sZW5ndGg6XCJcIn18JHtvLmxlbmd0aD4wP286XCJcIn18JHthLmxlbmd0aD4wP2E6XCJcIn18JHtmfXwke3QubW9kZT09PVwibmVhcmVzdFwiP3MubGVuZ3RoOnN9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6eSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6cH0se3R5cGU6MSxkYXRhOmR9LHt0eXBlOjEsZGF0YTphfSwuLi5QKHMsdSldfSl9fSxaYz1lPT57bGV0IHQ9ZS5jdXN0b21EYXRhQnVmZmVyO3JldHVybiBuZXcgVWludDMyQXJyYXkodCx0LmJ5dGVPZmZzZXQsMSlbMF19LHR1PShlLHQpPT57bGV0IG49W10scj1bXSxvPVtdLGk9WmMoZSk7aWYodC5hbnRpYWxpYXMhPT0wKXRocm93IEVycm9yKFwiT25seSBkZWZhdWx0IHZhbHVlICgwKSBmb3IgQW50aWFsaWFzIGF0dHJpYnV0ZSBpcyBzdXBwb3J0ZWRcIik7TWMoZS5pbnB1dHMsdCxpLG4scixvKSxlLmNvbXB1dGUoamMoZS5pbnB1dHNbMF0sdCxpLG4scixvKSx7aW5wdXRzOlswXX0pfSxudT1lPT57bGV0IHQ9ZS5hbnRpYWxpYXMsbj1lLmF4ZXMscj1lLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLG89ZS5jdWJpY0NvZWZmQSxpPWUuZXhjbHVkZU91dHNpZGUhPT0wLHM9ZS5leHRyYXBvbGF0aW9uVmFsdWUsYT1lLmtlZXBBc3BlY3RSYXRpb1BvbGljeSx1PWUubW9kZSxkPWUubmVhcmVzdE1vZGU9PT1cIlwiP1wic2ltcGxlXCI6ZS5uZWFyZXN0TW9kZTtyZXR1cm4gTih7YW50aWFsaWFzOnQsYXhlczpuLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnIsY3ViaWNDb2VmZkE6byxleGNsdWRlT3V0c2lkZTppLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGtlZXBBc3BlY3RSYXRpb1BvbGljeTphLG1vZGU6dSxuZWFyZXN0TW9kZTpkfSl9fSk7dmFyIFFjLFhjLG91LGl1PWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtRYz1lPT57aWYoIWV8fGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLlwiKTtsZXQgdD1lWzBdLG49ZVsxXSxyPWVbMl07aWYodC5kYXRhVHlwZSE9PW4uZGF0YVR5cGV8fHQuZGF0YVR5cGUhPT1yLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZVwiKTtpZih0LmRpbXMubGVuZ3RoIT09MyYmdC5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSAyRCBvciAzRFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGJlIDJEIG9yIDNEXCIpO2xldCBvPXQuZGltc1t0LmRpbXMubGVuZ3RoLTFdLGk9dC5kaW1zW3QuZGltcy5sZW5ndGgtMl07aWYobi5kaW1zW24uZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTJdIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXRcIik7aWYoci5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBiZSAxRFwiKTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKGUubGVuZ3RoPjMpe2xldCBzPWVbM107aWYocy5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGJlIDFEXCIpO2lmKHMuZGltc1tzLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX1pZihlLmxlbmd0aD40KXtsZXQgcz1lWzRdO2lmKHMuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBiZSAxRFwiKTtpZihzLmRpbXNbcy5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9fSxYYz0oZSx0LG4scik9PntsZXQgbz10LnNpbXBsaWZpZWQsaT1lWzBdLmRpbXMscz14LnNpemUoaSksYT1pLHU9cyxkPWkuc2xpY2UoLTEpWzBdLGw9cj9pLnNsaWNlKDAsLTEpLmNvbmNhdCgxKTpbXSxjPSFvJiZlLmxlbmd0aD4zLHA9ZS5sZW5ndGg+NCxmPXImJm4+MSxtPXImJm4+MixoPW4+MyxiPTY0LHk9WChkKSxnPVt7dHlwZToxMixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV0sXz12PT57bGV0ICQ9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sVD1bUyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx5KSxTKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLHkpLFMoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLHkpXTtjJiZULnB1c2goUyhcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyx5KSkscCYmVC5wdXNoKFMoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMseSkpLFQucHVzaChDKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLHkpKSxmJiZULnB1c2goQyhcIm1lYW5fb3V0cHV0XCIsMSxsKSksbSYmVC5wdXNoKEMoXCJpbnZfc3RkX291dHB1dFwiLDEsbCkpLGgmJlQucHVzaChDKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsYSx5KSk7bGV0IEk9cmUoZVswXS5kYXRhVHlwZSksQT1yZSgxLHkpO3JldHVybmBcblxuICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoJCkuZGVjbGFyZVZhcmlhYmxlcyguLi5UKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke0F9LCAke2J9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7QX0sICR7Yn0+O1xuXG4gICAgICAke3YubWFpblN0YXJ0KFtiLDEsMV0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7Yn07XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke2J9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHtiLTF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7cD9cImJpYXNbb2Zmc2V0MWQgKyBpXVwiOkkrXCIoMC4wKVwifTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtoP1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7SmUoSSx5LFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHtifTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtUZShcInN1bVwiLHkpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7VGUoXCJzcXVhcmVfc3VtXCIseSl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke28/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtmP1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7bT9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7XCI6XCJcIn1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7bz9cIlwiOmAtICR7SX0obWVhbilgfSkgKlxuICAgICAgICAgICAgJHtJfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke2M/XCIrIGJldGFbb2Zmc2V0MWQgKyBpXVwiOlwiXCJ9O1xuICAgICAgICB9XG4gICAgICB9YH0sdz1be2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIG4+MSYmdy5wdXNoKHtkaW1zOmwsZGF0YVR5cGU6MX0pLG4+MiYmdy5wdXNoKHtkaW1zOmwsZGF0YVR5cGU6MX0pLG4+MyYmdy5wdXNoKHtkaW1zOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3l9OyR7Zn07JHttfTske2h9YCxpbnB1dERlcGVuZGVuY2llczplLm1hcCgodiwkKT0+XCJ0eXBlXCIpfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6dyxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh1L2QpfSxwcm9ncmFtVW5pZm9ybXM6Z30pfX0sb3U9KGUsdCk9PntRYyhlLmlucHV0cyk7bGV0IHI9WzBdO2Uub3V0cHV0Q291bnQ+MSYmci5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJnIucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZyLnB1c2goMyksZS5jb21wdXRlKFhjKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6cn0pfX0pO3ZhciBZYyxtbixKYyxzdSxlcCx0cCxhdSx1dSxkdT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtZYz0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChuLHIpPT57aWYoZVtyKzFdLmRhdGFUeXBlIT09NiYmZVtyKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7cn0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LG1uPShlLHQpPT57bGV0IG49W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKHI9Pm4ucHVzaChOdW1iZXIocikpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gocj0+bi5wdXNoKE51bWJlcihyKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gbn0sSmM9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgbj1tbihlLDEpLHI9bW4oZSwyKSxvPW1uKGUsMyk7cmV0dXJuIG8ubGVuZ3RoPT09MCYmKG89Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLE4oe3N0YXJ0czpuLGVuZHM6cixheGVzOm99KX1lbHNlIHJldHVybiB0fSxzdT0oZSx0LG4scixvKT0+e2xldCBpPWU7cmV0dXJuIGU8MCYmKGkrPW5bclt0XV0pLG9bdF08MD9NYXRoLm1heCgwLE1hdGgubWluKGksbltyW3RdXS0xKSk6TWF0aC5tYXgoMCxNYXRoLm1pbihpLG5bclt0XV0pKX0sZXA9KGUsdCxuKT0+YGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7bi5sZW5ndGgtMX07IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfc2hhcGVfaSA9ICR7TyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGVwc19pID0gJHtPKFwidW5pZm9ybXMuc3RlcHNcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHNpZ25zX2kgPSAke08oXCJ1bmlmb3Jtcy5zaWduc1wiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RhcnRzX2kgPSAke08oXCJ1bmlmb3Jtcy5zdGFydHNcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4ICogc3RlcHNfaSArIHN0YXJ0c19pICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0X2luZGV4IC8gaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaWYgKHNpZ25zX2kgPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIGlucHV0X2luZGV4IC0gMXUgKyBzdGFydHNfaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfaW5kZXhcIil9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICAgIH1gLHRwPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9eC5zaXplKG4pLG89dC5heGVzLmxlbmd0aD4wP3gubm9ybWFsaXplQXhlcyh0LmF4ZXMsbi5sZW5ndGgpOlsuLi5BcnJheShuLmxlbmd0aCkua2V5cygpXSxpPW1uKGUsNCk7aS5mb3JFYWNoKHk9PnkhPT0wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJzdGVwIGNhbm5vdCBiZSAwXCIpfSkpLGkubGVuZ3RoPT09MCYmKGk9QXJyYXkoby5sZW5ndGgpLmZpbGwoMSkpO2xldCBzPXQuc3RhcnRzLm1hcCgoeSxnKT0+c3UoeSxnLG4sbyxpKSksYT10LmVuZHMubWFwKCh5LGcpPT5zdSh5LGcsbixvLGkpKTtpZihvLmxlbmd0aCE9PXMubGVuZ3RofHxvLmxlbmd0aCE9PWEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0LCBlbmRzIGFuZCBheGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1wiKTtpZihvLmxlbmd0aCE9PW4ubGVuZ3RoKWZvcihsZXQgeT0wO3k8bi5sZW5ndGg7Kyt5KW8uaW5jbHVkZXMoeSl8fChzLnNwbGljZSh5LDAsMCksYS5zcGxpY2UoeSwwLG5beV0pLGkuc3BsaWNlKHksMCwxKSk7bGV0IHU9aS5tYXAoeT0+TWF0aC5zaWduKHkpKTtpLmZvckVhY2goKHksZyxfKT0+e2lmKHk8MCl7bGV0IHc9KGFbZ10tc1tnXSkveSx2PXNbZ10sJD12K3cqaVtnXTtzW2ddPSQsYVtnXT12LF9bZ109LXl9fSk7bGV0IGQ9bi5zbGljZSgwKTtvLmZvckVhY2goKHksZyk9PntkW3ldPU1hdGguY2VpbCgoYVt5XS1zW3ldKS9pW3ldKX0pO2xldCBsPXtkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0sYz1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCkscD1TKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLGY9eC5zaXplKGQpLG09W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnMubGVuZ3RofSx7bmFtZTpcInNpZ25zXCIsdHlwZTpcImkzMlwiLGxlbmd0aDp1Lmxlbmd0aH0se25hbWU6XCJzdGVwc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6aS5sZW5ndGh9XSxoPVt7dHlwZToxMixkYXRhOmZ9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6NixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6aX0sLi4uUChlWzBdLmRpbXMsZCldLGI9eT0+YFxuICAgICAgJHt5LnJlZ2lzdGVyVW5pZm9ybXMobSkuZGVjbGFyZVZhcmlhYmxlcyhwLGMpfVxuICAgICAgICAke2VwKHAsYyxuKX1cbiAgICAgICAgJHt5Lm1haW5TdGFydCgpfVxuICAgICAgICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICR7Yy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixwLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJTbGljZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3UubGVuZ3RofV8ke3MubGVuZ3RofV8ke2kubGVuZ3RofWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltsXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChyLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KX19LGF1PShlLHQpPT57WWMoZS5pbnB1dHMsdCk7bGV0IG49SmMoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHRwKGUuaW5wdXRzLG4pLHtpbnB1dHM6WzBdfSl9LHV1PWU9PntsZXQgdD1lLnN0YXJ0cyxuPWUuZW5kcyxyPWUuYXhlcztyZXR1cm4gTih7c3RhcnRzOnQsZW5kczpuLGF4ZXM6cn0pfX0pO3ZhciBucCxycCxsdSxjdSxwdT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO1ZlKCk7SygpO25wPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LHJwPShlLHQpPT57bGV0IG49ZS5pbnB1dHNbMF0scj1uLmRpbXMsbz14LnNpemUociksaT1yLmxlbmd0aCxzPXgubm9ybWFsaXplQXhpcyh0LmF4aXMsaSksYT1zPHIubGVuZ3RoLTEsdSxkPVtdO2E/KGQ9QXJyYXkuZnJvbSh7bGVuZ3RoOml9LChULEkpPT5JKSxkW3NdPWktMSxkW2ktMV09cyx1PWUuY29tcHV0ZShwZShuLGQpLHtpbnB1dHM6W25dLG91dHB1dHM6Wy0xXX0pWzBdKTp1PW47bGV0IGw9dS5kaW1zLGM9bFtpLTFdLHA9by9jLGY9WChjKSxtPWMvZixoPTY0O3A9PT0xJiYoaD0yNTYpO2xldCBiPShULEkpPT5JPT09ND9gbWF4KG1heCgke1R9LngsICR7VH0ueSksIG1heCgke1R9LnosICR7VH0udykpYDpJPT09Mj9gbWF4KCR7VH0ueCwgJHtUfS55KWA6ST09PTM/YG1heChtYXgoJHtUfS54LCAke1R9LnkpLCAke1R9LnopYDpULHk9UyhcInhcIix1LmRhdGFUeXBlLHUuZGltcyxmKSxnPUMoXCJyZXN1bHRcIix1LmRhdGFUeXBlLHUuZGltcyxmKSxfPXkudHlwZS52YWx1ZSx3PXJlKHUuZGF0YVR5cGUpPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7X30oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke199KC02NTUwNC4waCk7YCx2PVQ9PmBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7X307XG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke199O1xuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHtffSwgJHtofT47XG5cbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke199IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7X30pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcInBhY2tlZENvbHNcIixcImkzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHksZyl9XG4gICAgICAke1QubWFpblN0YXJ0KGgpfVxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZHgpO1xuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkeCk7XG4gICAgICAgIGNvbnN0IHdnID0gJHtofTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3d9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7X30oJHtiKFwidGhyZWFkU2hhcmVkWzBdXCIsZil9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7X30oMC4wKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7X30oJHtUZShcInRocmVhZFNoYXJlZFswXVwiLGYpfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICAvLyBtYXggb3BlcmF0aW9uIHByb3RlY3RzIGFnYWluc3QgTmFOIHNpbmNlIGFsbCB2YWx1ZXMgc2hvdWxkIGJlID49MFxuICAgICAgICAgIHZhbHVlID0gbWF4KHZhbHVlLCAke199KDAuMCkpO1xuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1gLCQ9ZS5jb21wdXRlKHtuYW1lOlwiU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke2Z9OyR7aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTp1LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpwfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjYsZGF0YTptfV19KSxnZXRTaGFkZXJTb3VyY2U6dn0se2lucHV0czpbdV0sb3V0cHV0czpbYT8tMTowXX0pWzBdO2EmJmUuY29tcHV0ZShwZSgkLGQpLHtpbnB1dHM6WyRdfSl9LGx1PShlLHQpPT57bnAoZS5pbnB1dHMpLHJwKGUsdCl9LGN1PWU9Pk4oe2F4aXM6ZS5heGlzfSl9KTt2YXIgbXUsb3AsaXAsc3AsZnUsaHU9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO211PWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxvcD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihtdShlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LGlwPShlLHQpPT57bGV0IG49W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5wdXNoKGVbcl0qdFtyXSk7cmV0dXJuIG59LHNwPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9dD8/bXUoZVsxXSksbz1pcChuLHIpLGk9eC5zaXplKG8pLHM9ZVswXS5kYXRhVHlwZSxhPVMoXCJpbnB1dFwiLHMsbi5sZW5ndGgpLHU9QyhcIm91dHB1dFwiLHMsby5sZW5ndGgpLGQ9bD0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7YS5pbmRpY2VzKC4uLm4pfTtcbiAgICAgICR7bC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYSx1KX1cbiAgICAgICR7bC5tYWluU3RhcnQoKX1cbiAgICAgICR7bC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke3Uub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHthLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke3UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2EuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7dS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixhLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3J9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6aX0sLi4uUChlWzBdLmRpbXMsbyldfSksZ2V0U2hhZGVyU291cmNlOmR9fSxmdT1lPT57b3AoZS5pbnB1dHMpLGUuY29tcHV0ZShzcChlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgYXAsdXAsZ3UseXU9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO2FwPShlLHQsbixyLG8pPT57bGV0IGk9QyhcIm91dHB1dF9kYXRhXCIsbyxuLmxlbmd0aCw0KSxzPVMoXCJhX2RhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcy5sZW5ndGgsNCksYT1TKFwiYl9kYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMubGVuZ3RoLDQpLHU9UyhcImNfZGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCw0KSxkLGw9KGMscCxmKT0+YHNlbGVjdCgke3B9LCAke2N9LCAke2Z9KWA7aWYoIXIpZD1pLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGwocy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksYS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksdS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCBjPShwLGYsbT1cIlwiKT0+e2xldCBoPWBhX2RhdGFbaW5kZXhfYSR7Zn1dW2NvbXBvbmVudF9hJHtmfV1gLGI9YGJfZGF0YVtpbmRleF9iJHtmfV1bY29tcG9uZW50X2Ike2Z9XWAseT1gYm9vbChjX2RhdGFbaW5kZXhfYyR7Zn1dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7Zn0gKiA4KSkpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke2Z9ID0gJHtpLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtmfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke2Z9ID0gJHtzLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7Zn1gLGkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7Zn0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtmfWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtmfSA9ICR7dS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke2Z9YCxpKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7Zn0gPSBvZmZzZXRfYSR7Zn0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHtmfSA9IG9mZnNldF9iJHtmfSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke2Z9ID0gb2Zmc2V0X2Mke2Z9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke2Z9ID0gb2Zmc2V0X2Eke2Z9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike2Z9ID0gb2Zmc2V0X2Ike2Z9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke2Z9ID0gb2Zmc2V0X2Mke2Z9ICUgNHU7XG4gICAgICAgICAgICAke3B9WyR7Zn1dID0gJHttfSgke2woaCxiLHkpfSk7XG4gICAgICAgICAgYH07bz09PTk/ZD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7YyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtjKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2MoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7YyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpkPWBcbiAgICAgICAgICAgICR7YyhcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke2MoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHtjKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7YyhcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModSxzLGEsaSl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHtkfVxuICAgICAgfWB9LHVwPWU9PntsZXQgdD1lWzFdLmRpbXMsbj1lWzJdLmRpbXMscj1lWzBdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLGk9ISh4LmFyZUVxdWFsKHQsbikmJnguYXJlRXF1YWwobixyKSkscz10LGE9eC5zaXplKHQpO2lmKGkpe2xldCBkPVBlLmNhbGNTaGFwZShQZS5jYWxjU2hhcGUodCxuLCExKSxyLCExKTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO3M9ZCxhPXguc2l6ZShzKX1sZXQgdT1NYXRoLmNlaWwoYS80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpkPT5hcChkLGUscyxpLG8pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnV9LC4uLlAocix0LG4scyldfSl9fSxndT1lPT57ZS5jb21wdXRlKHVwKGUuaW5wdXRzKSl9fSk7dmFyIGJ1LF91PWsoKCk9PntcInVzZSBzdHJpY3RcIjtKbygpO2VuKCk7bmkoKTtvaSgpO0dpKCk7ZXMoKTtycygpO19zKCk7SXMoKTtFcygpO3pzKCk7VXMoKTtOcygpO1dzKCk7cXMoKTtqcygpO1hzKCk7ZWEoKTtyYSgpO3NhKCk7aGEoKTtiYSgpO3dhKCk7dmEoKTtUYSgpO3NyKCk7Q2EoKTtIYSgpO0thKCk7WmEoKTtZYSgpO1l0KCk7cnUoKTtkcigpO2l1KCk7ZHUoKTtwdSgpO3VyKCk7aHUoKTtWZSgpO25uKCk7eXUoKTtidT1uZXcgTWFwKFtbXCJBYnNcIixbaWldXSxbXCJBY29zXCIsW3NpXV0sW1wiQWNvc2hcIixbYWldXSxbXCJBZGRcIixbSGldXSxbXCJBcmdNYXhcIixbWW8sS25dXSxbXCJBcmdNaW5cIixbWG8sS25dXSxbXCJBc2luXCIsW3VpXV0sW1wiQXNpbmhcIixbZGldXSxbXCJBdGFuXCIsW2xpXV0sW1wiQXRhbmhcIixbY2ldXSxbXCJBdHRlbnRpb25cIixbZWldXSxbXCJBdmVyYWdlUG9vbFwiLFtPYSxEYV1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFt0aV1dLFtcIkJpYXNBZGRcIixbcmldXSxbXCJCaWFzU3BsaXRHZWx1XCIsW1dpXV0sW1wiQ2FzdFwiLFttaSxwaV1dLFtcIkNlaWxcIixbaGldXSxbXCJDbGlwXCIsW2ZpXV0sW1wiQ29uY2F0XCIsW3RzLG5zXV0sW1wiQ29udlwiLFtucix0cl1dLFtcIkNvbnZUcmFuc3Bvc2VcIixbVHMseHNdXSxbXCJDb3NcIixbZ2ldXSxbXCJDb3NoXCIsW3lpXV0sW1wiQ3VtU3VtXCIsW0NzLEFzXV0sW1wiRGVwdGhUb1NwYWNlXCIsW2tzLFBzXV0sW1wiRGVxdWFudGl6ZUxpbmVhclwiLFtxYSxGYV1dLFtcIkRpdlwiLFtxaV1dLFtcIkVpbnN1bVwiLFtPcyxNc11dLFtcIkVsdVwiLFtiaSxndF1dLFtcIkVxdWFsXCIsW0ZpXV0sW1wiRXJmXCIsW19pXV0sW1wiRXhwXCIsW3dpXV0sW1wiRXhwYW5kXCIsW1ZzXV0sW1wiRmFzdEdlbHVcIixbTHNdXSxbXCJGbG9vclwiLFskaV1dLFtcIkZ1c2VkQ29udlwiLFtucix0cl1dLFtcIkdhdGhlclwiLFtIcyxHc11dLFtcIkdhdGhlckVsZW1lbnRzXCIsW0pzLFlzXV0sW1wiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixbWnMsUXNdXSxbXCJHYXRoZXJORFwiLFtGcyxLc11dLFtcIkdlbHVcIixbdmldXSxbXCJHZW1tXCIsW25hLHRhXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbUmEsVWFdXSxbXCJHbG9iYWxNYXhQb29sXCIsW0dhLFdhXV0sW1wiR3JlYXRlclwiLFtRaV1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW1lpXV0sW1wiR3JpZFNhbXBsZVwiLFtvYSxpYV1dLFtcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixbZmFdXSxbXCJIYXJkU2lnbW9pZFwiLFtraSxFaV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFt5YV1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtfYV1dLFtcIkxlYWt5UmVsdVwiLFt4aSxndF1dLFtcIkxlc3NcIixbWGldXSxbXCJMZXNzT3JFcXVhbFwiLFtKaV1dLFtcIkxvZ1wiLFtWaV1dLFtcIk1hdE11bFwiLFskYV1dLFtcIk1hdE11bE5CaXRzXCIsW3hhLFNhXV0sW1wiTWF4UG9vbFwiLFtOYSxMYV1dLFtcIk11bFwiLFtLaV1dLFtcIk11bHRpSGVhZEF0dGVudGlvblwiLFtkYSx1YV1dLFtcIk5lZ1wiLFtUaV1dLFtcIk5vdFwiLFtTaV1dLFtcIlBhZFwiLFtJYV1dLFtcIlBvd1wiLFtqaV1dLFtcIlF1aWNrR2VsdVwiLFtOaSxndF1dLFtcIlJhbmdlXCIsW2phXV0sW1wiUmVjaXByb2NhbFwiLFtJaV1dLFtcIlJlZHVjZU1pblwiLFtxb11dLFtcIlJlZHVjZU1lYW5cIixbTm9dXSxbXCJSZWR1Y2VNYXhcIixbSG9dXSxbXCJSZWR1Y2VTdW1cIixbS29dXSxbXCJSZWR1Y2VQcm9kXCIsW0ZvXV0sW1wiUmVkdWNlTDFcIixbTG9dXSxbXCJSZWR1Y2VMMlwiLFtXb11dLFtcIlJlZHVjZUxvZ1N1bVwiLFtab11dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFtHb11dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtqb11dLFtcIlJlbHVcIixbQ2ldXSxbXCJSZXNpemVcIixbdHUsbnVdXSxbXCJSb3RhcnlFbWJlZGRpbmdcIixbcGFdXSxbXCJTY2F0dGVyTkRcIixbWGEsUWFdXSxbXCJTaWdtb2lkXCIsW0FpXV0sW1wiU2luXCIsW1BpXV0sW1wiU2luaFwiLFt6aV1dLFtcIlNsaWNlXCIsW2F1LHV1XV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtvdV1dLFtcIlNwbGl0XCIsW2xhLGNhXV0sW1wiU3FydFwiLFtCaV1dLFtcIlNvZnRtYXhcIixbbHUsY3VdXSxbXCJTdWJcIixbWmldXSxbXCJUYW5cIixbRGldXSxbXCJUYW5oXCIsW01pXV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW1JpLGd0XV0sW1wiVGlsZVwiLFtmdV1dLFtcIlRyYW5zcG9zZVwiLFtDbyxBb11dLFtcIldoZXJlXCIsW2d1XV1dKX0pO3ZhciBmbix3dT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtrZSgpO0soKTtmbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LG4pe3RoaXMucmVwby5zZXQodCxuKX1ydW4odCxuLHIsbyxpKXtoZSh0LnByb2dyYW1JbmZvLm5hbWUpO2xldCBzPXRoaXMuYmFja2VuZC5kZXZpY2UsYT10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMik7bGV0IHU9W107Zm9yKGxldCBsIG9mIG4pdS5wdXNoKHtiaW5kaW5nOnUubGVuZ3RoLHJlc291cmNlOntidWZmZXI6bC5idWZmZXJ9fSk7Zm9yKGxldCBsIG9mIHIpdS5wdXNoKHtiaW5kaW5nOnUubGVuZ3RoLHJlc291cmNlOntidWZmZXI6bC5idWZmZXJ9fSk7aSYmdS5wdXNoKHtiaW5kaW5nOnUubGVuZ3RoLHJlc291cmNlOml9KTtsZXQgZD1zLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOnUsbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7aWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiKXtsZXQgbD17a2VybmVsSWQ6dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCxjb21wdXRlUGlwZWxpbmU6dC5jb21wdXRlUGlwZWxpbmUsYmluZEdyb3VwOmQsZGlzcGF0Y2hHcm91cDpvfTt0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpLnB1c2gobCl9YS5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSksYS5zZXRCaW5kR3JvdXAoMCxkKSxhLmRpc3BhdGNoV29ya2dyb3VwcyguLi5vKSx0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKywodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLmJhY2tlbmQucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5iYWNrZW5kLmZsdXNoKCksZmUodC5wcm9ncmFtSW5mby5uYW1lKX1kaXNwb3NlKCl7fWJ1aWxkKHQsbil7aGUodC5uYW1lKTtsZXQgcj10aGlzLmJhY2tlbmQuZGV2aWNlLG89W107W3tmZWF0dXJlOlwic2hhZGVyLWYxNlwiLGV4dGVuc2lvbjpcImYxNlwifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwc1wiLGV4dGVuc2lvbjpcInN1Ymdyb3Vwc1wifV0uZm9yRWFjaChjPT57ci5mZWF0dXJlcy5oYXMoYy5mZWF0dXJlKSYmby5wdXNoKGBlbmFibGUgJHtjLmV4dGVuc2lvbn07YCl9KTtsZXQgcz1UbyhuLHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKSxhPXQuZ2V0U2hhZGVyU291cmNlKHMpLHU9YCR7by5qb2luKGBcbmApfVxuJHtzLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke2F9YCxkPXIuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOnUsbGFiZWw6dC5uYW1lfSk7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdICR7dC5uYW1lfSBzaGFkZXIgY29kZTogJHt1fWApO2xldCBsPXIuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6ZCxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJuIGZlKHQubmFtZSkse3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOmwsdW5pZm9ybVZhcmlhYmxlc0luZm86cy52YXJpYWJsZXNJbmZvfX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgbj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxyPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEsaT10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihuPD1pJiZyPD1pJiZvPD1pKXJldHVybltuLHIsb107bGV0IHM9bipyKm8sYT1NYXRoLmNlaWwoTWF0aC5zcXJ0KHMpKTtpZihhPmkpe2lmKGE9TWF0aC5jZWlsKE1hdGguY2JydChzKSksYT5pKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2EsYSxhXX1lbHNlIHJldHVyblthLGEsMV19fX0pO3ZhciAkdT17fTtudCgkdSx7V2ViR3B1QmFja2VuZDooKT0+Y3J9KTt2YXIgZHAsbHAsbHIsY3IsdnU9aygoKT0+e1widXNlIHN0cmljdFwiO3llKCk7VigpO2tlKCk7T24oKTt4bygpO191KCk7d3UoKTtkcD0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IG49W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipe2xldCBvPWVbcl0uZGF0YVR5cGU7c3dpdGNoKHRbcl0pe2Nhc2VcIm5vbmVcIjp7bi5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7bi5wdXNoKGAke299YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgaT1lW3JdLmRpbXMubGVuZ3RoO24ucHVzaChgJHtvfTske2l9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgaT1lW3JdLmRpbXMuam9pbihcIixcIik7bi5wdXNoKGAke299OyR7aX1gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W3JdfWApfX1yZXR1cm4gbi5qb2luKFwifFwiKX0sbHA9KGUsdCxuKT0+e2xldCByPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKHIrPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIikscis9XCI6XCIrbitgOiR7ZHAodCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxyfSxscj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0JiYodGhpcy5hcmNoaXRlY3R1cmU9dC5hcmNoaXRlY3R1cmUsdGhpcy52ZW5kb3I9dC52ZW5kb3IpfWlzQXJjaGl0ZWN0dXJlKHQpe3JldHVybiB0aGlzLmFyY2hpdGVjdHVyZT09PXR9aXNWZW5kb3IodCl7cmV0dXJuIHRoaXMudmVuZG9yPT09dH19LGNyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPW51bGw7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLm1heERpc3BhdGNoTnVtYmVyPTE2O3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5wZW5kaW5nS2VybmVscz1bXTt0aGlzLnBlbmRpbmdRdWVyaWVzPW5ldyBNYXA7dGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwiO3RoaXMuY2FwdHVyZWRDb21tYW5kTGlzdD1uZXcgTWFwO3RoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0LG4pe3RoaXMuZW52PXQ7bGV0IHI9W10sbz17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOm4ubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOm4ubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOm4ubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpyfSxpPXM9Pm4uZmVhdHVyZXMuaGFzKHMpJiZyLnB1c2gocykmJiEwO2koXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIil8fGkoXCJ0aW1lc3RhbXAtcXVlcnlcIiksaShcInNoYWRlci1mMTZcIiksaShcInN1Ymdyb3Vwc1wiKSx0aGlzLmRldmljZT1hd2FpdCBuLnJlcXVlc3REZXZpY2UobyksdGhpcy5hZGFwdGVySW5mbz1uZXcgbHIobi5pbmZvfHxhd2FpdCBuLnJlcXVlc3RBZGFwdGVySW5mbygpKSx0aGlzLmdwdURhdGFNYW5hZ2VyPXZvKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IGZuKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCxXdCh0LmxvZ0xldmVsLCEhdC5kZWJ1ZyksdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3I9cz0+e3MuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3ImJmNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7cy5lcnJvci5tZXNzYWdlfWApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiZGV2aWNlXCIse3ZhbHVlOnRoaXMuZGV2aWNlLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImFkYXB0ZXJcIix7dmFsdWU6bix3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLHRoaXMuc2V0UXVlcnlUeXBlKCl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLG49e307dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiJiYobi50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLGVuZE9mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dC5iZWdpbkNvbXB1dGVQYXNzKG4pfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXtpZighdGhpcy5jb21tYW5kRW5jb2RlcilyZXR1cm47aGUoKSx0aGlzLmVuZENvbXB1dGVQYXNzKCk7bGV0IHQ7dGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmKHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMucXVlcnlTZXQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDApLHQ9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pLHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHQsdGhpcy5wZW5kaW5nS2VybmVscyksdGhpcy5wZW5kaW5nS2VybmVscz1bXSx0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwLHQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgpKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnQubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IG49bmV3IEJpZ1VpbnQ2NEFycmF5KHQuZ2V0TWFwcGVkUmFuZ2UoKSkscj10aGlzLnBlbmRpbmdRdWVyaWVzLmdldCh0KTtmb3IobGV0IG89MDtvPG4ubGVuZ3RoLzI7bysrKXtsZXQgaT1yW29dLHM9aS5rZXJuZWxJZCxhPXRoaXMua2VybmVscy5nZXQocyksdT1hLmtlcm5lbFR5cGUsZD1hLmtlcm5lbE5hbWUsbD1pLnByb2dyYW1OYW1lLGM9aS5pbnB1dFRlbnNvclZpZXdzLHA9aS5vdXRwdXRUZW5zb3JWaWV3cyxmPW5bbyoyXSxtPW5bbyoyKzFdO3R5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLnF1ZXJ5VGltZUJhc2U9Zik7bGV0IGg9TnVtYmVyKGYtdGhpcy5xdWVyeVRpbWVCYXNlKSxiPU51bWJlcihtLXRoaXMucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGgpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoYikpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO2lmKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSl0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7dmVyc2lvbjoxLGlucHV0c01ldGFkYXRhOmMubWFwKHk9Pih7ZGltczp5LmRpbXMsZGF0YVR5cGU6RWUoeS5kYXRhVHlwZSl9KSksb3V0cHV0c01ldGFkYXRhOnAubWFwKHk9Pih7ZGltczp5LmRpbXMsZGF0YVR5cGU6RWUoeS5kYXRhVHlwZSl9KSksa2VybmVsSWQ6cyxrZXJuZWxUeXBlOnUsa2VybmVsTmFtZTpkLHByb2dyYW1OYW1lOmwsc3RhcnRUaW1lOmgsZW5kVGltZTpifSk7ZWxzZXtsZXQgeT1cIlwiO2MuZm9yRWFjaCgoXyx3KT0+e3krPWBpbnB1dFske3d9XTogWyR7Xy5kaW1zfV0gfCAke0VlKF8uZGF0YVR5cGUpfSwgYH0pO2xldCBnPVwiXCI7cC5mb3JFYWNoKChfLHcpPT57Zys9YG91dHB1dFske3d9XTogWyR7Xy5kaW1zfV0gfCAke0VlKF8uZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke3N9fCR7dX18JHtkfXwke2x9XCIgJHt5fSR7Z31zdGFydCB0aW1lOiAke2h9IG5zLCBleGVjdXRpb24gdGltZTogJHtiLWh9IG5zYCl9Y3QoXCJHUFVcIixgJHtsfTo6JHtmfTo6JHttfWApfXQudW5tYXAoKSx0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZSh0KX0pLGZlKCl9cnVuKHQsbixyLG8saSxzKXtoZSh0Lm5hbWUpO2xldCBhPVtdO2ZvcihsZXQgXz0wO188bi5sZW5ndGg7KytfKXtsZXQgdz1uW19dLmRhdGE7aWYodz09PTApY29udGludWU7bGV0IHY9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodyk7aWYoIXYpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7d31gKTthLnB1c2godil9bGV0e291dHB1dHM6dSxkaXNwYXRjaEdyb3VwOmQscHJvZ3JhbVVuaWZvcm1zOmx9PXQuZ2V0UnVuRGF0YShuKSxjPXIubGVuZ3RoPT09MD91Lm1hcCgoXyx3KT0+dyk6cjtpZihjLmxlbmd0aCE9PXUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHtjLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke3UubGVuZ3RofS5gKTtsZXQgcD1bXSxmPVtdO2ZvcihsZXQgXz0wO188dS5sZW5ndGg7KytfKXtpZighTnVtYmVyLmlzSW50ZWdlcihjW19dKXx8Y1tfXTwtM3x8Y1tfXT49cyl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke2NbX119YCk7aWYoY1tfXT09PS0zKWNvbnRpbnVlO2xldCB3PWNbX109PT0tMSx2PWNbX109PT0tMiwkPXd8fHY/aSh1W19dLmRhdGFUeXBlLHVbX10uZGltcyk6byhjW19dLHVbX10uZGF0YVR5cGUsdVtfXS5kaW1zKTtpZihwLnB1c2goJCksJC5kYXRhPT09MCljb250aW51ZTtsZXQgVD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCgkLmRhdGEpO2lmKCFUKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHskLmRhdGF9YCk7aWYodyYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goVCksdil7bGV0IEk9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO0l8fChJPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLEkpKSxJLnB1c2goVCl9Zi5wdXNoKFQpfWlmKGEubGVuZ3RoIT09bi5sZW5ndGh8fGYubGVuZ3RoIT09cC5sZW5ndGgpe2lmKGYubGVuZ3RoPT09MClyZXR1cm4gZmUodC5uYW1lKSxwO3Rocm93IG5ldyBFcnJvcihgUHJvZ3JhbSAke3QubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmApfWxldCBtO2lmKGwpe2xldCBfPTAsdz1bXTtsLmZvckVhY2goST0+e2xldCBBPXR5cGVvZiBJLmRhdGE9PVwibnVtYmVyXCI/W0kuZGF0YV06SS5kYXRhO2lmKEEubGVuZ3RoPT09MClyZXR1cm47bGV0IHo9SS50eXBlPT09MTA/Mjo0LE0sVTtJLnR5cGU9PT0xMD8oVT1BLmxlbmd0aD40PzE2OkEubGVuZ3RoPjI/ODpBLmxlbmd0aCp6LE09QS5sZW5ndGg+ND8xNjp6KkEubGVuZ3RoKTooVT1BLmxlbmd0aDw9Mj9BLmxlbmd0aCp6OjE2LE09MTYpLF89TWF0aC5jZWlsKF8vVSkqVSx3LnB1c2goXyk7bGV0IEc9SS50eXBlPT09MTA/ODo0O18rPUEubGVuZ3RoPjQ/TWF0aC5jZWlsKEEubGVuZ3RoL0cpKk06QS5sZW5ndGgqen0pO2xldCB2PTE2O189TWF0aC5jZWlsKF8vdikqdjtsZXQgJD1uZXcgQXJyYXlCdWZmZXIoXyk7bC5mb3JFYWNoKChJLEEpPT57bGV0IHo9d1tBXSxNPXR5cGVvZiBJLmRhdGE9PVwibnVtYmVyXCI/W0kuZGF0YV06SS5kYXRhO2lmKEkudHlwZT09PTYpbmV3IEludDMyQXJyYXkoJCx6LE0ubGVuZ3RoKS5zZXQoTSk7ZWxzZSBpZihJLnR5cGU9PT0xMiluZXcgVWludDMyQXJyYXkoJCx6LE0ubGVuZ3RoKS5zZXQoTSk7ZWxzZSBpZihJLnR5cGU9PT0xMCluZXcgVWludDE2QXJyYXkoJCx6LE0ubGVuZ3RoKS5zZXQoTSk7ZWxzZSBpZihJLnR5cGU9PT0xKW5ldyBGbG9hdDMyQXJyYXkoJCx6LE0ubGVuZ3RoKS5zZXQoTSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZTogJHtFZShJLnR5cGUpfWApfSk7bGV0IFQ9dGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoXyxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTt0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihULmJ1ZmZlciwwLCQsMCxfKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoVC5pZCksbT17b2Zmc2V0OjAsc2l6ZTpfLGJ1ZmZlcjpULmJ1ZmZlcn19bGV0IGg9dGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShkKSxiPWhbMV09PT0xJiZoWzJdPT09MSx5PWxwKHQsbixiKSxnPXRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3QoeSk7aWYoZ3x8KGc9dGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZCh0LGgpLHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3QoeSxnKSxqKFwiaW5mb1wiLCgpPT5gW2FydGlmYWN0XSBrZXk6ICR7eX0sIHByb2dyYW1OYW1lOiAke3QubmFtZX1gKSksbCYmZy51bmlmb3JtVmFyaWFibGVzSW5mbyl7aWYobC5sZW5ndGghPT1nLnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGVzIGNvdW50IG1pc21hdGNoOiBleHBlY3QgJHtnLnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aH0sIGdvdCAke2wubGVuZ3RofSBpbiBwcm9ncmFtIFwiJHtnLnByb2dyYW1JbmZvLm5hbWV9XCIuYCk7Zm9yKGxldCBfPTA7XzxsLmxlbmd0aDtfKyspe2xldCB3PWxbX10sdj13LnR5cGUsJD10eXBlb2Ygdy5kYXRhPT1cIm51bWJlclwiPzE6dy5kYXRhLmxlbmd0aCxbVCxJXT1nLnVuaWZvcm1WYXJpYWJsZXNJbmZvW19dO2lmKHYhPT1UfHwkIT09SSl0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGUgJHtffSBtaXNtYXRjaDogZXhwZWN0IHR5cGUgJHtUfSB3aXRoIHNpemUgJHtJfSwgZ290IHR5cGUgJHt2fSB3aXRoIHNpemUgJHskfSBpbiBwcm9ncmFtIFwiJHtnLnByb2dyYW1JbmZvLm5hbWV9XCIuYCl9fWlmKGooXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHt5fSkgd2l0aCAke2hbMF19eCR7aFsxXX14JHtoWzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCJ8fHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBfPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTpnLnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpuLG91dHB1dFRlbnNvclZpZXdzOnB9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChfKSx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkucHVzaChfKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4oZyxhLGYsaCxtKSxmZSh0Lm5hbWUpLHB9dXBsb2FkKHQsbil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxuKX1tZW1jcHkodCxuKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LG4pfWFzeW5jIGRvd25sb2FkKHQsbil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LG4pfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQsbixyLG8pe2xldCBpPWJ1LmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgcz17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6byxrZXJuZWxFbnRyeTppWzBdLGF0dHJpYnV0ZXM6W2lbMV0scl19O3RoaXMua2VybmVscy5zZXQobixzKX1yZWxlYXNlS2VybmVsKHQpe2xldCBuPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKG4pe2ZvcihsZXQgciBvZiBuKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShyLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LG4scil7bGV0IG89dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCBpPW8ua2VybmVsVHlwZSxzPW8ua2VybmVsTmFtZSxhPW8ua2VybmVsRW50cnksdT1vLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7aX1dICR7c31cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LHVbMF0mJih1WzFdPXVbMF0odVsxXSksdVswXT12b2lkIDApLGooXCJpbmZvXCIsKCk9PmBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7aX1dICR7c31cIi4uLmApO2xldCBkPXRoaXMuZW52LmRlYnVnO3RoaXMudGVtcG9yYXJ5RGF0YT1bXTt0cnl7cmV0dXJuIGQmJnRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKSxhKG4sdVsxXSksMH1jYXRjaChsKXtyZXR1cm4gci5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7aX1dICR7c31cIiBmYWlsZWQuICR7bH1gKSksMX1maW5hbGx5e2QmJnIucHVzaCh0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbihsPT5sP2BHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7aX1dICR7c31cIjogJHtsLm1lc3NhZ2V9YDpudWxsKSk7Zm9yKGxldCBsIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UobC5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fXJlZ2lzdGVyQnVmZmVyKHQsbixyLG8pe2xldCBpPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO2l8fChpPW5ldyBNYXAsdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQodCxpKSk7bGV0IHM9aS5nZXQobiksYT10aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIocixvLHMpO3JldHVybiBpLnNldChuLFthLHJdKSxhfXVucmVnaXN0ZXJCdWZmZXJzKHQpe2xldCBuPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO24mJihuLmZvckVhY2gocj0+dGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoclswXSkpLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHQpKX1nZXRCdWZmZXIodCl7bGV0IG49dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke3R9YCk7cmV0dXJuIG4uYnVmZmVyfWNyZWF0ZURvd25sb2FkZXIodCxuLHIpe3JldHVybiBhc3luYygpPT57bGV0IG89YXdhaXQgTG4odGhpcyx0LG4pO3JldHVybiBIdChvLmJ1ZmZlcixyKX19d3JpdGVUaW1lc3RhbXAodCl7dGhpcy5xdWVyeVR5cGU9PT1cImluc2lkZS1wYXNzZXNcIiYmdGhpcy5jb21wdXRlUGFzc0VuY29kZXIud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCx0KX1zZXRRdWVyeVR5cGUoKXt0aGlzLnF1ZXJ5VHlwZT1cIm5vbmVcIiwodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ubW9kZT09PVwiZGVmYXVsdFwifHwodHlwZW9mIHRoaXMuZW52LnRyYWNlPlwidVwiP3RoaXMuZW52Lndhc20udHJhY2U6dGhpcy5lbnYudHJhY2UpKSYmKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKT90aGlzLnF1ZXJ5VHlwZT1cImluc2lkZS1wYXNzZXNcIjp0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJih0aGlzLnF1ZXJ5VHlwZT1cImF0LXBhc3Nlc1wiKSx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0eXBlb2YgdGhpcy5xdWVyeVNldD5cInVcIiYmKHRoaXMucXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjJ9KSx0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlcj10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRX0pKSl9Y2FwdHVyZUJlZ2luKCl7aihcImluZm9cIixcImNhcHR1cmVCZWdpblwiKSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCl8fHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkLFtdKSx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCl8fHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkLFtdKSx0aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiY2FwdHVyaW5nXCJ9Y2FwdHVyZUVuZCgpe2ooXCJpbmZvXCIsXCJjYXB0dXJlRW5kXCIpLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9cmVwbGF5KCl7aihcImluZm9cIixcInJlcGxheVwiKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJyZXBsYXlpbmdcIjtsZXQgdD10aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCksbj10aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkscj10Lmxlbmd0aDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO2ZvcihsZXQgbz0wO288cjtvKyspe2xldCBpPXRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCkscz10W29dO3RoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMiksaS5zZXRQaXBlbGluZShzLmNvbXB1dGVQaXBlbGluZSksaS5zZXRCaW5kR3JvdXAoMCxzLmJpbmRHcm91cCksaS5kaXNwYXRjaFdvcmtncm91cHMoLi4ucy5kaXNwYXRjaEdyb3VwKSx0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMSksdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKyx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2gobltvXSksKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmVuZENvbXB1dGVQYXNzKCksdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuZmx1c2goKX10aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwifW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuZ3B1RGF0YU1hbmFnZXIub25DcmVhdGVTZXNzaW9uKCl9b25SZWxlYXNlU2Vzc2lvbih0KXt0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHQpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModCkmJnRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5kZWxldGUodCksdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyh0KSYmdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmRlbGV0ZSh0KSx0aGlzLmdwdURhdGFNYW5hZ2VyLm9uUmVsZWFzZVNlc3Npb24odCl9b25SdW5TdGFydCh0KXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9dCx0aGlzLnNldFF1ZXJ5VHlwZSgpfX19KTt2YXIgeHU9e307bnQoeHUse2luaXQ6KCk9PmNwfSk7dmFyIHd0LHByLGNwLFN1PWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7a2UoKTtxKCk7Ym8oKTt3dD1jbGFzcyBle2NvbnN0cnVjdG9yKHQsbixyLG8pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1uO3RoaXMuZGF0YT1yO3RoaXMuZGltcz1vfWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PXguc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9eC5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PXguc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldFVpbnQxNkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEwJiZ0aGlzLmRhdGFUeXBlIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD14LnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IFVpbnQxNkFycmF5Om5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoeC5zaXplKHQpIT09eC5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0scHI9Y2xhc3N7Y29uc3RydWN0b3IodCxuLHIpe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPW47dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO3RoaXMuYWRhcHRlckluZm89bi5hZGFwdGVySW5mbztsZXQgbz10LlBUUl9TSVpFLGk9ci90LlBUUl9TSVpFLHM9bz09PTQ/XCJpMzJcIjpcImk2NFwiO3RoaXMub3BLZXJuZWxDb250ZXh0PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLHMpKTtsZXQgYT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxzKSk7dGhpcy5vdXRwdXRDb3VudD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxzKSksdGhpcy5jdXN0b21EYXRhT2Zmc2V0PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLFwiKlwiKSksdGhpcy5jdXN0b21EYXRhU2l6ZT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxzKSk7bGV0IHU9W107Zm9yKGxldCBkPTA7ZDxhO2QrKyl7bGV0IGw9TnVtYmVyKHQuZ2V0VmFsdWUobyppKysscykpLGM9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssXCIqXCIpKSxwPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLHMpKSxmPVtdO2ZvcihsZXQgbT0wO208cDttKyspZi5wdXNoKE51bWJlcih0LmdldFZhbHVlKG8qaSsrLHMpKSk7dS5wdXNoKG5ldyB3dCh0LGwsYyxmKSl9dGhpcy5pbnB1dHM9dX1nZXQga2VybmVsQ3VzdG9tRGF0YSgpe3JldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGF9Z2V0IGN1c3RvbURhdGFCdWZmZXIoKXtyZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCx0aGlzLmN1c3RvbURhdGFPZmZzZXQrdGhpcy5jdXN0b21EYXRhU2l6ZSl9Y29tcHV0ZSh0LG4pe2xldCByPW4/LmlucHV0cz8ubWFwKGE9PnR5cGVvZiBhPT1cIm51bWJlclwiP3RoaXMuaW5wdXRzW2FdOmEpPz90aGlzLmlucHV0cyxvPW4/Lm91dHB1dHM/P1tdLGk9KGEsdSxkKT0+bmV3IHd0KHRoaXMubW9kdWxlLHUsdGhpcy5vdXRwdXQoYSxkKSxkKSxzPShhLHUpPT57bGV0IGQ9cWUoYSx1KTtpZighZCl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHthfWApO2xldCBsPWQ+MD90aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGQpLmlkOjA7cmV0dXJuIG5ldyB3dCh0aGlzLm1vZHVsZSxhLGwsdSl9O3JldHVybiB0aGlzLmJhY2tlbmQucnVuKHQscixvLGkscyx0aGlzLm91dHB1dENvdW50KX1vdXRwdXQodCxuKXtsZXQgcj10aGlzLm1vZHVsZS5zdGFja1NhdmUoKTt0cnl7bGV0IG89dGhpcy5tb2R1bGUuUFRSX1NJWkUsaT1vPT09ND9cImkzMlwiOlwiaTY0XCIscz10aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxK24ubGVuZ3RoKSpvKTt0aGlzLm1vZHVsZS5zZXRWYWx1ZShzLG4ubGVuZ3RoLGkpO2ZvcihsZXQgYT0wO2E8bi5sZW5ndGg7YSsrKXRoaXMubW9kdWxlLnNldFZhbHVlKHMrbyooYSsxKSxuW2FdLGkpO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCx0LHMpfWNhdGNoKG8pe3Rocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske3R9XSB3aXRoIGRpbXMgWyR7bn1dLiBJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gRXJyb3I6ICR7b31gKX1maW5hbGx5e3RoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShyKX19fSxjcD1hc3luYyhlLHQsbixyKT0+e2xldCBvPXQuanNlcEluaXQ7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuXCIpO2lmKGU9PT1cIndlYmdwdVwiKXtsZXQgaT0odnUoKSxkdCgkdSkpLldlYkdwdUJhY2tlbmQscz1uZXcgaTthd2FpdCBzLmluaXRpYWxpemUobixyKSxvKFwid2ViZ3B1XCIsW3MsYT0+cy5hbGxvYyhOdW1iZXIoYSkpLGE9PnMuZnJlZShhKSwoYSx1LGQsbD0hMSk9PntpZihsKWooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtOdW1iZXIoYSl9LCBkc3Q9JHtOdW1iZXIodSl9LCBzaXplPSR7TnVtYmVyKGQpfWApLHMubWVtY3B5KE51bWJlcihhKSxOdW1iZXIodSkpO2Vsc2V7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtOdW1iZXIoYSl9LCBncHVEYXRhSWQ9JHtOdW1iZXIodSl9LCBzaXplPSR7TnVtYmVyKGQpfWApO2xldCBjPXQuSEVBUFU4LnN1YmFycmF5KE51bWJlcihhPj4+MCksTnVtYmVyKGE+Pj4wKStOdW1iZXIoZCkpO3MudXBsb2FkKE51bWJlcih1KSxjKX19LGFzeW5jKGEsdSxkKT0+e2ooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHthfSwgZGF0YU9mZnNldD0ke3V9LCBzaXplPSR7ZH1gKSxhd2FpdCBzLmRvd25sb2FkKE51bWJlcihhKSwoKT0+dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKHUpPj4+MCxOdW1iZXIodStkKT4+PjApKX0sKGEsdSxkKT0+cy5jcmVhdGVLZXJuZWwoYSxOdW1iZXIodSksZCx0LlVURjhUb1N0cmluZyh0Ll9Kc2VwR2V0Tm9kZU5hbWUoTnVtYmVyKHUpKSkpLGE9PnMucmVsZWFzZUtlcm5lbChhKSwoYSx1LGQsbCk9PntqKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke2R9LCBrZXJuZWw9JHthfSwgY29udGV4dERhdGFPZmZzZXQ9JHt1fWApO2xldCBjPW5ldyBwcih0LHMsTnVtYmVyKHUpKTtyZXR1cm4gcy5jb21wdXRlS2VybmVsKE51bWJlcihhKSxjLGwpfSwoKT0+cy5jYXB0dXJlQmVnaW4oKSwoKT0+cy5jYXB0dXJlRW5kKCksKCk9PnMucmVwbGF5KCldKX1lbHNle2xldCBpPW5ldyBqdChuKTtvKFwid2Vibm5cIixbaSwoKT0+aS5yZXNlcnZlVGVuc29ySWQoKSxzPT5pLnJlbGVhc2VUZW5zb3JJZChzKSxhc3luYyhzLGEsdSxkLGwpPT5pLmVuc3VyZVRlbnNvcihzLGEsdSxkLGwpLChzLGEpPT57aS51cGxvYWRUZW5zb3IocyxhKX0sYXN5bmMocyxhKT0+aS5kb3dubG9hZFRlbnNvcihzLGEpLChzLGEpPT5pLnJlZ2lzdGVyTUxDb250ZXh0KHMsYSksISFuLnRyYWNlXSl9fX0pO3ZhciBwcCxFdCxrdCxldCxtcCxUdSxwdCxQdCx6dCxJdSxCdCxEdCxPdCxBbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtvbygpO3NvKCk7VigpO0dlKCk7UnQoKTtCbigpO3BwPShlLHQpPT57bmUoKS5fT3J0SW5pdChlLHQpIT09MCYmWShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxFdD1hc3luYyBlPT57cHAoZS53YXNtLm51bVRocmVhZHMsZnQoZS5sb2dMZXZlbCkpfSxrdD1hc3luYyhlLHQpPT57bmUoKS5hc3luY0luaXQ/LigpO2xldCBuPWUud2ViZ3B1LmFkYXB0ZXI7aWYodD09PVwid2ViZ3B1XCIpe2lmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7aWYobil7aWYodHlwZW9mIG4ubGltaXRzIT1cIm9iamVjdFwifHx0eXBlb2Ygbi5mZWF0dXJlcyE9XCJvYmplY3RcInx8dHlwZW9mIG4ucmVxdWVzdERldmljZSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR1BVIGFkYXB0ZXIgc2V0IGluIGBlbnYud2ViZ3B1LmFkYXB0ZXJgLiBJdCBtdXN0IGJlIGEgR1BVQWRhcHRlciBvYmplY3QuXCIpfWVsc2V7bGV0IHI9ZS53ZWJncHUucG93ZXJQcmVmZXJlbmNlO2lmKHIhPT12b2lkIDAmJnIhPT1cImxvdy1wb3dlclwiJiZyIT09XCJoaWdoLXBlcmZvcm1hbmNlXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBvd2VyUHJlZmVyZW5jZSBzZXR0aW5nOiBcIiR7cn1cImApO2xldCBvPWUud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO2lmKG8hPT12b2lkIDAmJnR5cGVvZiBvIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke299XCJgKTtpZihuPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoe3Bvd2VyUHJlZmVyZW5jZTpyLGZvcmNlRmFsbGJhY2tBZGFwdGVyOm99KSwhbil0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuIFlvdSBtYXkgbmVlZCB0byBlbmFibGUgZmxhZyBcIi0tZW5hYmxlLXVuc2FmZS13ZWJncHVcIiBpZiB5b3UgYXJlIHVzaW5nIENocm9tZS4nKX19aWYodD09PVwid2Vibm5cIiYmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IubWwpKXRocm93IG5ldyBFcnJvcihcIldlYk5OIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTt7bGV0IHI9KFN1KCksZHQoeHUpKS5pbml0O3Q9PT1cIndlYmdwdVwiJiZhd2FpdCByKFwid2ViZ3B1XCIsbmUoKSxlLG4pLHQ9PT1cIndlYm5uXCImJmF3YWl0IHIoXCJ3ZWJublwiLG5lKCksZSl9fSxldD1uZXcgTWFwLG1wPWU9PntsZXQgdD1uZSgpLG49dC5zdGFja1NhdmUoKTt0cnl7bGV0IHI9dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKnIpO3QuX09ydEdldElucHV0T3V0cHV0Q291bnQoZSxvLG8rcikhPT0wJiZZKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgcz1yPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKG8scykpLE51bWJlcih0LmdldFZhbHVlKG8rcixzKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobil9fSxUdT0oZSx0KT0+e2xldCBuPW5lKCkscj1uLnN0YWNrU2F2ZSgpLG89MDt0cnl7bGV0IGk9bi5QVFJfU0laRSxzPW4uc3RhY2tBbGxvYygyKmkpO24uX09ydEdldElucHV0T3V0cHV0TWV0YWRhdGEoZSx0LHMscytpKSE9PTAmJlkoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgbWV0YWRhdGEuXCIpO2xldCB1PU51bWJlcihuLmdldFZhbHVlKHMsXCIqXCIpKTtvPU51bWJlcihuLmdldFZhbHVlKHMraSxcIipcIikpO2xldCBkPW4uSEVBUDMyW28vNF07aWYoZD09PTApcmV0dXJuW3UsMF07bGV0IGw9bi5IRUFQVTMyW28vNCsxXSxjPVtdO2ZvcihsZXQgcD0wO3A8bDtwKyspe2xldCBmPU51bWJlcihuLmdldFZhbHVlKG8rOCtwKmksXCIqXCIpKTtjLnB1c2goZiE9PTA/bi5VVEY4VG9TdHJpbmcoZik6TnVtYmVyKG4uZ2V0VmFsdWUobys4KyhwK2wpKmksXCIqXCIpKSl9cmV0dXJuW3UsZCxjXX1maW5hbGx5e24uc3RhY2tSZXN0b3JlKHIpLG8hPT0wJiZuLl9PcnRGcmVlKG8pfX0scHQ9ZT0+e2xldCB0PW5lKCksbj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihuPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsbiksW24sZS5ieXRlTGVuZ3RoXX0sUHQ9YXN5bmMoZSx0KT0+e2xldCBuLHIsbz1uZSgpO0FycmF5LmlzQXJyYXkoZSk/W24scl09ZTplLmJ1ZmZlcj09PW8uSEVBUFU4LmJ1ZmZlcj9bbixyXT1bZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aF06W24scl09cHQoZSk7bGV0IGk9MCxzPTAsYT0wLHU9W10sZD1bXSxsPVtdO3RyeXtpZihbcyx1XT1hd2FpdCBpbyh0KSx0Py5leHRlcm5hbERhdGEmJm8ubW91bnRFeHRlcm5hbERhdGEpe2xldCB3PVtdO2ZvcihsZXQgdiBvZiB0LmV4dGVybmFsRGF0YSl7bGV0ICQ9dHlwZW9mIHY9PVwic3RyaW5nXCI/djp2LnBhdGg7dy5wdXNoKGh0KHR5cGVvZiB2PT1cInN0cmluZ1wiP3Y6di5kYXRhKS50aGVuKFQ9PntvLm1vdW50RXh0ZXJuYWxEYXRhKCQsVCl9KSl9YXdhaXQgUHJvbWlzZS5hbGwodyl9Zm9yKGxldCB3IG9mIHQ/LmV4ZWN1dGlvblByb3ZpZGVycz8/W10paWYoKHR5cGVvZiB3PT1cInN0cmluZ1wiP3c6dy5uYW1lKT09PVwid2Vibm5cIil7aWYoby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITEsdHlwZW9mIHchPVwic3RyaW5nXCIpe2xldCAkPXcsVD0kPy5jb250ZXh0LEk9JD8uZ3B1RGV2aWNlLEE9JD8uZGV2aWNlVHlwZSx6PSQ/LnBvd2VyUHJlZmVyZW5jZTtUP28uY3VycmVudENvbnRleHQ9VDpJP28uY3VycmVudENvbnRleHQ9YXdhaXQgby53ZWJubkNyZWF0ZU1MQ29udGV4dChJKTpvLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8ud2Vibm5DcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6QSxwb3dlclByZWZlcmVuY2U6en0pfWVsc2Ugby5jdXJyZW50Q29udGV4dD1hd2FpdCBvLndlYm5uQ3JlYXRlTUxDb250ZXh0KCk7YnJlYWt9aT1hd2FpdCBvLl9PcnRDcmVhdGVTZXNzaW9uKG4scixzKSxvLndlYmdwdU9uQ3JlYXRlU2Vzc2lvbj8uKGkpLGk9PT0wJiZZKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIiksby5qc2VwT25DcmVhdGVTZXNzaW9uPy4oKSxvLmN1cnJlbnRDb250ZXh0JiYoby53ZWJublJlZ2lzdGVyTUxDb250ZXh0KGksby5jdXJyZW50Q29udGV4dCksby5jdXJyZW50Q29udGV4dD12b2lkIDAsby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITApO2xldFtjLHBdPW1wKGkpLGY9ISF0Py5lbmFibGVHcmFwaENhcHR1cmUsbT1bXSxoPVtdLGI9W10seT1bXSxnPVtdO2ZvcihsZXQgdz0wO3c8Yzt3Kyspe2xldFt2LCQsVF09VHUoaSx3KTt2PT09MCYmWShcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxkLnB1c2godik7bGV0IEk9by5VVEY4VG9TdHJpbmcodik7bS5wdXNoKEkpLGIucHVzaCgkPT09MD97bmFtZTpJLGlzVGVuc29yOiExfTp7bmFtZTpJLGlzVGVuc29yOiEwLHR5cGU6RWUoJCksc2hhcGU6VH0pfWZvcihsZXQgdz0wO3c8cDt3Kyspe2xldFt2LCQsVF09VHUoaSx3K2MpO3Y9PT0wJiZZKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxsLnB1c2godik7bGV0IEk9by5VVEY4VG9TdHJpbmcodik7aC5wdXNoKEkpLHkucHVzaCgkPT09MD97bmFtZTpJLGlzVGVuc29yOiExfTp7bmFtZTpJLGlzVGVuc29yOiEwLHR5cGU6RWUoJCksc2hhcGU6VH0pO3tpZihmJiZ0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09PXZvaWQgMCl7Zy5wdXNoKFwiZ3B1LWJ1ZmZlclwiKTtjb250aW51ZX1sZXQgQT10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW0ldPz9cImNwdVwiLHo9by53ZWJubklzR3JhcGhPdXRwdXQ7aWYoQT09PVwiY3B1XCImJnomJnooaSxJKSl7Zy5wdXNoKFwibWwtdGVuc29yLWNwdS1vdXRwdXRcIik7Y29udGludWV9aWYoQSE9PVwiY3B1XCImJkEhPT1cImNwdS1waW5uZWRcIiYmQSE9PVwiZ3B1LWJ1ZmZlclwiJiZBIT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS5gKTtpZihmJiZBIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO2cucHVzaChBKX19bGV0IF89bnVsbDtyZXR1cm4gZy5zb21lKHc9Pnc9PT1cImdwdS1idWZmZXJcInx8dz09PVwibWwtdGVuc29yXCJ8fHc9PT1cIm1sLXRlbnNvci1jcHUtb3V0cHV0XCIpJiYoYT1vLl9PcnRDcmVhdGVCaW5kaW5nKGkpLGE9PT0wJiZZKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpLF89e2hhbmRsZTphLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpnLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6Zy5tYXAodz0+dz09PVwibWwtdGVuc29yLWNwdS1vdXRwdXRcIj9cIm1sLXRlbnNvclwiOncpLm1hcCh3PT56bih3KSl9KSxldC5zZXQoaSxbaSxkLGwsXyxmLCExXSksW2ksbSxoLGIseV19Y2F0Y2goYyl7dGhyb3cgZC5mb3JFYWNoKHA9Pm8uX09ydEZyZWUocCkpLGwuZm9yRWFjaChwPT5vLl9PcnRGcmVlKHApKSxhIT09MCYmby5fT3J0UmVsZWFzZUJpbmRpbmcoYSkhPT0wJiZZKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKSxpIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb24oaSkhPT0wJiZZKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSxjfWZpbmFsbHl7by5fZnJlZShuKSxzIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHMpIT09MCYmWShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSx1LmZvckVhY2goYz0+by5fZnJlZShjKSksby51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKX19LHp0PWU9PntsZXQgdD1uZSgpLG49ZXQuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W3IsbyxpLHMsYV09bjtzJiYoYSYmdC5fT3J0Q2xlYXJCb3VuZE91dHB1dHMocy5oYW5kbGUpIT09MCYmWShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHQuX09ydFJlbGVhc2VCaW5kaW5nKHMuaGFuZGxlKSE9PTAmJlkoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksdC53ZWJubk9uUmVsZWFzZVNlc3Npb24/LihlKSx0LndlYmdwdU9uUmVsZWFzZVNlc3Npb24/LihlKSxvLmZvckVhY2godT0+dC5fT3J0RnJlZSh1KSksaS5mb3JFYWNoKHU9PnQuX09ydEZyZWUodSkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKHIpIT09MCYmWShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksZXQuZGVsZXRlKGUpfSxJdT1hc3luYyhlLHQsbixyLG8saSxzPSExKT0+e2lmKCFlKXt0LnB1c2goMCk7cmV0dXJufWxldCBhPW5lKCksdT1hLlBUUl9TSVpFLGQ9ZVswXSxsPWVbMV0sYz1lWzNdLHA9YyxmLG07aWYoZD09PVwic3RyaW5nXCImJihjPT09XCJncHUtYnVmZmVyXCJ8fGM9PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihzJiZjIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7aX0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihjPT09XCJncHUtYnVmZmVyXCIpe2xldCB5PWVbMl0uZ3B1QnVmZmVyO209cWUoSGUoZCksbCk7e2xldCBnPWEuanNlcFJlZ2lzdGVyQnVmZmVyO2lmKCFnKXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7Zj1nKHIsaSx5LG0pfX1lbHNlIGlmKGM9PT1cIm1sLXRlbnNvclwiKXtsZXQgeT1lWzJdLm1sVGVuc29yO209cWUoSGUoZCksbCk7bGV0IGc9YS53ZWJublJlZ2lzdGVyTUxUZW5zb3I7aWYoIWcpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7Zj1nKHIseSxIZShkKSxsKX1lbHNle2xldCB5PWVbMl07aWYoQXJyYXkuaXNBcnJheSh5KSl7bT11KnkubGVuZ3RoLGY9YS5fbWFsbG9jKG0pLG4ucHVzaChmKTtmb3IobGV0IGc9MDtnPHkubGVuZ3RoO2crKyl7aWYodHlwZW9mIHlbZ10hPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtnfSBpcyBub3QgYSBzdHJpbmdgKTthLnNldFZhbHVlKGYrZyp1LF9lKHlbZ10sbiksXCIqXCIpfX1lbHNle2xldCBnPWEud2Vibm5Jc0dyYXBoSW5wdXQsXz1hLndlYm5uSXNHcmFwaE91dHB1dDtpZihkIT09XCJzdHJpbmdcIiYmZyYmXyl7bGV0IHc9YS5VVEY4VG9TdHJpbmcobyk7aWYoZyhyLHcpfHxfKHIsdykpe2xldCB2PUhlKGQpO209cWUodixsKSxwPVwibWwtdGVuc29yXCI7bGV0ICQ9YS53ZWJubkNyZWF0ZVRlbXBvcmFyeVRlbnNvcixUPWEud2Vibm5VcGxvYWRUZW5zb3I7aWYoISR8fCFUKXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2xldCBJPWF3YWl0ICQocix2LGwpO1QoSSxuZXcgVWludDhBcnJheSh5LmJ1ZmZlcix5LmJ5dGVPZmZzZXQseS5ieXRlTGVuZ3RoKSksZj1JfWVsc2UgbT15LmJ5dGVMZW5ndGgsZj1hLl9tYWxsb2MobSksbi5wdXNoKGYpLGEuSEVBUFU4LnNldChuZXcgVWludDhBcnJheSh5LmJ1ZmZlcix5LmJ5dGVPZmZzZXQsbSksZil9ZWxzZSBtPXkuYnl0ZUxlbmd0aCxmPWEuX21hbGxvYyhtKSxuLnB1c2goZiksYS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHkuYnVmZmVyLHkuYnl0ZU9mZnNldCxtKSxmKX19bGV0IGg9YS5zdGFja1NhdmUoKSxiPWEuc3RhY2tBbGxvYyg0KmwubGVuZ3RoKTt0cnl7bC5mb3JFYWNoKChnLF8pPT5hLnNldFZhbHVlKGIrXyp1LGcsdT09PTQ/XCJpMzJcIjpcImk2NFwiKSk7bGV0IHk9YS5fT3J0Q3JlYXRlVGVuc29yKEhlKGQpLGYsbSxiLGwubGVuZ3RoLHpuKHApKTt5PT09MCYmWShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7cn0sIGluZGV4PSR7aX0uYCksdC5wdXNoKHkpfWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoaCl9fSxCdD1hc3luYyhlLHQsbixyLG8saSk9PntsZXQgcz1uZSgpLGE9cy5QVFJfU0laRSx1PWV0LmdldChlKTtpZighdSl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXQgZD11WzBdLGw9dVsxXSxjPXVbMl0scD11WzNdLGY9dVs0XSxtPXVbNV0saD10Lmxlbmd0aCxiPXIubGVuZ3RoLHk9MCxnPVtdLF89W10sdz1bXSx2PVtdLCQ9cy5zdGFja1NhdmUoKSxUPXMuc3RhY2tBbGxvYyhoKmEpLEk9cy5zdGFja0FsbG9jKGgqYSksQT1zLnN0YWNrQWxsb2MoYiphKSx6PXMuc3RhY2tBbGxvYyhiKmEpO3RyeXtbeSxnXT1ybyhpKSxVZShcIndhc20gcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yXCIpO2ZvcihsZXQgQj0wO0I8aDtCKyspYXdhaXQgSXUobltCXSxfLHYsZSxsW3RbQl1dLHRbQl0sZik7Zm9yKGxldCBCPTA7QjxiO0IrKylhd2FpdCBJdShvW0JdLHcsdixlLGNbcltCXV0saCtyW0JdLGYpO1JlKFwid2FzbSBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3JcIik7Zm9yKGxldCBCPTA7QjxoO0IrKylzLnNldFZhbHVlKFQrQiphLF9bQl0sXCIqXCIpLHMuc2V0VmFsdWUoSStCKmEsbFt0W0JdXSxcIipcIik7Zm9yKGxldCBCPTA7QjxiO0IrKylzLnNldFZhbHVlKEErQiphLHdbQl0sXCIqXCIpLHMuc2V0VmFsdWUoeitCKmEsY1tyW0JdXSxcIipcIik7aWYocCYmIW0pe2xldHtoYW5kbGU6QixvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6ZWUsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDpXfT1wO2lmKGwubGVuZ3RoIT09aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7aH0pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbCdzIGlucHV0IGNvdW50ICgke2wubGVuZ3RofSkuYCk7VWUoXCJ3YXNtIGJpbmRJbnB1dHNPdXRwdXRzXCIpO2ZvcihsZXQgRD0wO0Q8aDtEKyspe2xldCBaPXRbRF07YXdhaXQgcy5fT3J0QmluZElucHV0KEIsbFtaXSxfW0RdKSE9PTAmJlkoYENhbid0IGJpbmQgaW5wdXRbJHtEfV0gZm9yIHNlc3Npb249JHtlfS5gKX1mb3IobGV0IEQ9MDtEPGI7RCsrKXtsZXQgWj1yW0RdO29bRF0/LlszXT9zLl9PcnRCaW5kT3V0cHV0KEIsY1taXSx3W0RdLDApIT09MCYmWShgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske0R9XSBmb3Igc2Vzc2lvbj0ke2V9LmApOnMuX09ydEJpbmRPdXRwdXQoQixjW1pdLDAsV1taXSkhPT0wJiZZKGBDYW4ndCBiaW5kIG91dHB1dFske0R9XSB0byAke2VlW0RdfSBmb3Igc2Vzc2lvbj0ke2V9LmApfVJlKFwid2FzbSBiaW5kSW5wdXRzT3V0cHV0c1wiKSxldC5zZXQoZSxbZCxsLGMscCxmLCEwXSl9cy5qc2VwT25SdW5TdGFydD8uKGQpLHMud2Vibm5PblJ1blN0YXJ0Py4oZCk7bGV0IE07cD9NPWF3YWl0IHMuX09ydFJ1bldpdGhCaW5kaW5nKGQscC5oYW5kbGUsYixBLHkpOk09YXdhaXQgcy5fT3J0UnVuKGQsSSxULGgseixiLEEseSksTSE9PTAmJlkoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IFU9W10sRz1bXTtVZShcIndhc20gUHJvY2Vzc091dHB1dFRlbnNvclwiKTtmb3IobGV0IEI9MDtCPGI7QisrKXtsZXQgZWU9TnVtYmVyKHMuZ2V0VmFsdWUoQStCKmEsXCIqXCIpKTtpZihlZT09PXdbQl0pe1UucHVzaChvW0JdKTtjb250aW51ZX1sZXQgVz1zLnN0YWNrU2F2ZSgpLEQ9cy5zdGFja0FsbG9jKDQqYSksWj0hMSxSLFE9MDt0cnl7cy5fT3J0R2V0VGVuc29yRGF0YShlZSxELEQrYSxEKzIqYSxEKzMqYSkhPT0wJiZZKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7Qn0uYCk7bGV0IHNlPWE9PT00P1wiaTMyXCI6XCJpNjRcIixIPU51bWJlcihzLmdldFZhbHVlKEQsc2UpKTtRPXMuZ2V0VmFsdWUoRCthLFwiKlwiKTtsZXQgRT1zLmdldFZhbHVlKEQrYSoyLFwiKlwiKSxMPU51bWJlcihzLmdldFZhbHVlKEQrYSozLHNlKSksb2U9W107Zm9yKGxldCB1ZT0wO3VlPEw7dWUrKylvZS5wdXNoKE51bWJlcihzLmdldFZhbHVlKEUrdWUqYSxzZSkpKTtzLl9PcnRGcmVlKEUpIT09MCYmWShcIkNhbid0IGZyZWUgbWVtb3J5IGZvciB0ZW5zb3IgZGltcy5cIik7bGV0ICRlPW9lLnJlZHVjZSgodWUsYWUpPT51ZSphZSwxKTtSPUVlKEgpO2xldCBTZT1wPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbcltCXV07aWYoUj09PVwic3RyaW5nXCIpe2lmKFNlPT09XCJncHUtYnVmZmVyXCJ8fFNlPT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQgdWU9W107Zm9yKGxldCBhZT0wO2FlPCRlO2FlKyspe2xldCBMZT1zLmdldFZhbHVlKFErYWUqYSxcIipcIiksdnQ9cy5nZXRWYWx1ZShRKyhhZSsxKSphLFwiKlwiKSxncj1hZT09PSRlLTE/dm9pZCAwOnZ0LUxlO3VlLnB1c2gocy5VVEY4VG9TdHJpbmcoTGUsZ3IpKX1VLnB1c2goW1Isb2UsdWUsXCJjcHVcIl0pfWVsc2UgaWYoU2U9PT1cImdwdS1idWZmZXJcIiYmJGU+MCl7bGV0IHVlPXMuanNlcEdldEJ1ZmZlcjtpZighdWUpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO2xldCBhZT11ZShRKSxMZT1xZShILCRlKTtpZihMZT09PXZvaWQgMHx8IU50KFIpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke1J9YCk7Wj0hMCxVLnB1c2goW1Isb2Use2dwdUJ1ZmZlcjphZSxkb3dubG9hZDpzLmpzZXBDcmVhdGVEb3dubG9hZGVyKGFlLExlLFIpLGRpc3Bvc2U6KCk9PntzLl9PcnRSZWxlYXNlVGVuc29yKGVlKSE9PTAmJlkoXCJDYW4ndCByZWxlYXNlIHRlbnNvci5cIil9fSxcImdwdS1idWZmZXJcIl0pfWVsc2UgaWYoU2U9PT1cIm1sLXRlbnNvclwiJiYkZT4wKXtsZXQgdWU9cy53ZWJubkVuc3VyZVRlbnNvcixhZT1zLndlYm5uSXNHcmFwaElucHV0T3V0cHV0VHlwZVN1cHBvcnRlZDtpZighdWV8fCFhZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2lmKHFlKEgsJGUpPT09dm9pZCAwfHwhTHQoUikpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7Un1gKTtpZighYWUoZSxSLCExKSl0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgZm9yICR7Un0gb3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3VycmVudCBXZWJOTiBDb250ZXh0LmApO2xldCB2dD1hd2FpdCB1ZShlLFEsSCxvZSwhMSk7Wj0hMCxVLnB1c2goW1Isb2Use21sVGVuc29yOnZ0LGRvd25sb2FkOnMud2Vibm5DcmVhdGVNTFRlbnNvckRvd25sb2FkZXIoUSxSKSxkaXNwb3NlOigpPT57cy53ZWJublJlbGVhc2VUZW5zb3JJZChRKSxzLl9PcnRSZWxlYXNlVGVuc29yKGVlKX19LFwibWwtdGVuc29yXCJdKX1lbHNlIGlmKFNlPT09XCJtbC10ZW5zb3ItY3B1LW91dHB1dFwiJiYkZT4wKXtsZXQgdWU9cy53ZWJubkNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihRLFIpKCksYWU9VS5sZW5ndGg7Wj0hMCxHLnB1c2goKGFzeW5jKCk9PntsZXQgTGU9W2FlLGF3YWl0IHVlXTtyZXR1cm4gcy53ZWJublJlbGVhc2VUZW5zb3JJZChRKSxzLl9PcnRSZWxlYXNlVGVuc29yKGVlKSxMZX0pKCkpLFUucHVzaChbUixvZSxbXSxcImNwdVwiXSl9ZWxzZXtsZXQgdWU9cnQoUiksYWU9bmV3IHVlKCRlKTtuZXcgVWludDhBcnJheShhZS5idWZmZXIsYWUuYnl0ZU9mZnNldCxhZS5ieXRlTGVuZ3RoKS5zZXQocy5IRUFQVTguc3ViYXJyYXkoUSxRK2FlLmJ5dGVMZW5ndGgpKSxVLnB1c2goW1Isb2UsYWUsXCJjcHVcIl0pfX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKFcpLFI9PT1cInN0cmluZ1wiJiZRJiZzLl9mcmVlKFEpLFp8fHMuX09ydFJlbGVhc2VUZW5zb3IoZWUpfX1wJiYhZiYmKHMuX09ydENsZWFyQm91bmRPdXRwdXRzKHAuaGFuZGxlKSE9PTAmJlkoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSxldC5zZXQoZSxbZCxsLGMscCxmLCExXSkpO2ZvcihsZXRbQixlZV1vZiBhd2FpdCBQcm9taXNlLmFsbChHKSlVW0JdWzJdPWVlO3JldHVybiBSZShcIndhc20gUHJvY2Vzc091dHB1dFRlbnNvclwiKSxVfWZpbmFsbHl7cy53ZWJubk9uUnVuRW5kPy4oZCkscy5zdGFja1Jlc3RvcmUoJCksXy5mb3JFYWNoKE09PnMuX09ydFJlbGVhc2VUZW5zb3IoTSkpLHcuZm9yRWFjaChNPT5zLl9PcnRSZWxlYXNlVGVuc29yKE0pKSx2LmZvckVhY2goTT0+cy5fZnJlZShNKSkseSE9PTAmJnMuX09ydFJlbGVhc2VSdW5PcHRpb25zKHkpLGcuZm9yRWFjaChNPT5zLl9mcmVlKE0pKX19LER0PWU9PntsZXQgdD1uZSgpLG49ZXQuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtsZXQgcj1uWzBdLG89dC5fT3J0RW5kUHJvZmlsaW5nKHIpO289PT0wJiZZKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG8pfSxPdD1lPT57bGV0IHQ9W107Zm9yKGxldCBuIG9mIGUpe2xldCByPW5bMl07IUFycmF5LmlzQXJyYXkocikmJlwiYnVmZmVyXCJpbiByJiZ0LnB1c2goci5idWZmZXIpfXJldHVybiB0fX0pO3ZhciB0dCx4ZSwkdCxnbix5bixobixtcixmcixhdCx1dCxocCxDdSxBdSxFdSxrdSxQdSx6dSxCdSxocj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtBbigpO0dlKCk7Q3QoKTt0dD0oKT0+ISF0ZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIsJHQ9ITEsZ249ITEseW49ITEsZnI9bmV3IE1hcCxhdD0oZSx0KT0+e2xldCBuPWZyLmdldChlKTtuP24ucHVzaCh0KTpmci5zZXQoZSxbdF0pfSx1dD0oKT0+e2lmKCR0fHwhZ258fHlufHwheGUpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0saHA9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6JHQ9ITEsZS5kYXRhLmVycj8oeW49ITAsbXJbMV0oZS5kYXRhLmVycikpOihnbj0hMCxtclswXSgpKSxobiYmKFVSTC5yZXZva2VPYmplY3RVUkwoaG4pLGhuPXZvaWQgMCk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOmNhc2VcImNvcHktZnJvbVwiOmNhc2VcImNyZWF0ZVwiOmNhc2VcInJlbGVhc2VcIjpjYXNlXCJydW5cIjpjYXNlXCJlbmQtcHJvZmlsaW5nXCI6e2xldCB0PWZyLmdldChlLmRhdGEudHlwZSk7ZS5kYXRhLmVycj90LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrfWRlZmF1bHQ6fX0sQ3U9YXN5bmMoKT0+e2lmKCFnbil7aWYoJHQpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZih5bil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2lmKCR0PSEwLHR0KCkpcmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57eGU/LnRlcm1pbmF0ZSgpLGVvKCkudGhlbigoW24scl0pPT57dHJ5e3hlPXIseGUub25lcnJvcj1pPT50KGkpLHhlLm9ubWVzc2FnZT1ocCxtcj1bZSx0XTtsZXQgbz17dHlwZTpcImluaXQtd2FzbVwiLGluOnRlfTtpZighby5pbi53YXNtLndhc21QYXRocyYmbil7bGV0IGk9TXQoKTtpJiYoby5pbi53YXNtLndhc21QYXRocz1pKX14ZS5wb3N0TWVzc2FnZShvKSxobj1ufWNhdGNoKG8pe3Qobyl9fSx0KX0pO3RyeXthd2FpdCBBdCh0ZS53YXNtKSxhd2FpdCBFdCh0ZSksZ249ITB9Y2F0Y2goZSl7dGhyb3cgeW49ITAsZX1maW5hbGx5eyR0PSExfX19LEF1PWFzeW5jIGU9PntpZih0dCgpKXJldHVybiB1dCgpLG5ldyBQcm9taXNlKCh0LG4pPT57YXQoXCJpbml0LWVwXCIsW3Qsbl0pO2xldCByPXt0eXBlOlwiaW5pdC1lcFwiLGluOntlcE5hbWU6ZSxlbnY6dGV9fTt4ZS5wb3N0TWVzc2FnZShyKX0pO2F3YWl0IGt0KHRlLGUpfSxFdT1hc3luYyBlPT50dCgpPyh1dCgpLG5ldyBQcm9taXNlKCh0LG4pPT57YXQoXCJjb3B5LWZyb21cIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJjb3B5LWZyb21cIixpbjp7YnVmZmVyOmV9fTt4ZS5wb3N0TWVzc2FnZShyLFtlLmJ1ZmZlcl0pfSkpOnB0KGUpLGt1PWFzeW5jKGUsdCk9PntpZih0dCgpKXtpZih0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbil0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtyZXR1cm4gdXQoKSxuZXcgUHJvbWlzZSgobixyKT0+e2F0KFwiY3JlYXRlXCIsW24scl0pO2xldCBvPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOmUsb3B0aW9uczp7Li4udH19fSxpPVtdO2UgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZpLnB1c2goZS5idWZmZXIpLHhlLnBvc3RNZXNzYWdlKG8saSl9KX1lbHNlIHJldHVybiBQdChlLHQpfSxQdT1hc3luYyBlPT57aWYodHQoKSlyZXR1cm4gdXQoKSxuZXcgUHJvbWlzZSgodCxuKT0+e2F0KFwicmVsZWFzZVwiLFt0LG5dKTtsZXQgcj17dHlwZTpcInJlbGVhc2VcIixpbjplfTt4ZS5wb3N0TWVzc2FnZShyKX0pO3p0KGUpfSx6dT1hc3luYyhlLHQsbixyLG8saSk9PntpZih0dCgpKXtpZihuLnNvbWUocz0+c1szXSE9PVwiY3B1XCIpKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO2lmKG8uc29tZShzPT5zKSl0aHJvdyBuZXcgRXJyb3IoXCJwcmUtYWxsb2NhdGVkIG91dHB1dCB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO3JldHVybiB1dCgpLG5ldyBQcm9taXNlKChzLGEpPT57YXQoXCJydW5cIixbcyxhXSk7bGV0IHU9bixkPXt0eXBlOlwicnVuXCIsaW46e3Nlc3Npb25JZDplLGlucHV0SW5kaWNlczp0LGlucHV0czp1LG91dHB1dEluZGljZXM6cixvcHRpb25zOml9fTt4ZS5wb3N0TWVzc2FnZShkLE90KHUpKX0pfWVsc2UgcmV0dXJuIEJ0KGUsdCxuLHIsbyxpKX0sQnU9YXN5bmMgZT0+e2lmKHR0KCkpcmV0dXJuIHV0KCksbmV3IFByb21pc2UoKHQsbik9PnthdChcImVuZC1wcm9maWxpbmdcIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsaW46ZX07eGUucG9zdE1lc3NhZ2Uocil9KTtEdChlKX19KTt2YXIgRHUsZ3AsYm4sT3U9aygoKT0+e1widXNlIHN0cmljdFwiO3llKCk7aHIoKTtWKCk7SXQoKTtCbigpO0R1PShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybltlLnR5cGUsZS5kaW1zLGUuZGF0YSxcImNwdVwiXTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse2dwdUJ1ZmZlcjplLmdwdUJ1ZmZlcn0sXCJncHUtYnVmZmVyXCJdO2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHttbFRlbnNvcjplLm1sVGVuc29yfSxcIm1sLXRlbnNvclwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2UubG9jYXRpb259IGZvciAke3QoKX1gKX19LGdwPWU9Pntzd2l0Y2goZVszXSl7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyB2ZShlWzBdLGVbMl0sZVsxXSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOntsZXQgdD1lWzBdO2lmKCFOdCh0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtsZXR7Z3B1QnVmZmVyOm4sZG93bmxvYWQ6cixkaXNwb3NlOm99PWVbMl07cmV0dXJuIHZlLmZyb21HcHVCdWZmZXIobix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6cixkaXNwb3NlOm99KX1jYXNlXCJtbC10ZW5zb3JcIjp7bGV0IHQ9ZVswXTtpZighTHQodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBNTFRlbnNvciB0ZW5zb3JgKTtsZXR7bWxUZW5zb3I6bixkb3dubG9hZDpyLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gdmUuZnJvbU1MVGVuc29yKG4se2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOnIsZGlzcG9zZTpvfSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlWzNdfWApfX0sYm49Y2xhc3N7YXN5bmMgZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCl7cmV0dXJuIEV1KGF3YWl0IGh0KHQpKX1hc3luYyBsb2FkTW9kZWwodCxuKXtoZSgpO2xldCByO3R5cGVvZiB0PT1cInN0cmluZ1wiP3I9YXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KTpyPXQsW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzLHRoaXMuaW5wdXRNZXRhZGF0YSx0aGlzLm91dHB1dE1ldGFkYXRhXT1hd2FpdCBrdShyLG4pLGZlKCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybiBQdSh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQsbixyKXtoZSgpO2xldCBvPVtdLGk9W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaChwPT57bGV0IGY9cFswXSxtPXBbMV0saD10aGlzLmlucHV0TmFtZXMuaW5kZXhPZihmKTtpZihoPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke2Z9J2ApO28ucHVzaChtKSxpLnB1c2goaCl9KTtsZXQgcz1bXSxhPVtdO09iamVjdC5lbnRyaWVzKG4pLmZvckVhY2gocD0+e2xldCBmPXBbMF0sbT1wWzFdLGg9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKGYpO2lmKGg9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke2Z9J2ApO3MucHVzaChtKSxhLnB1c2goaCl9KTtsZXQgdT1vLm1hcCgocCxmKT0+RHUocCwoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaVtmXV19XCJgKSksZD1zLm1hcCgocCxmKT0+cD9EdShwLCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2FbZl1dfVwiYCk6bnVsbCksbD1hd2FpdCB6dSh0aGlzLnNlc3Npb25JZCxpLHUsYSxkLHIpLGM9e307Zm9yKGxldCBwPTA7cDxsLmxlbmd0aDtwKyspY1t0aGlzLm91dHB1dE5hbWVzW2FbcF1dXT1zW3BdPz9ncChsW3BdKTtyZXR1cm4gZmUoKSxjfXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe0J1KHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIFV1PXt9O250KFV1LHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZDooKT0+X24saW5pdGlhbGl6ZUZsYWdzOigpPT5NdSx3YXNtQmFja2VuZDooKT0+eXB9KTt2YXIgTXUsX24seXAsUnU9aygoKT0+e1widXNlIHN0cmljdFwiO3llKCk7aHIoKTtPdSgpO011PSgpPT57KHR5cGVvZiB0ZS53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHx0ZS53YXNtLmluaXRUaW1lb3V0PDApJiYodGUud2FzbS5pbml0VGltZW91dD0wKTtsZXQgZT10ZS53YXNtLnNpbWQ7aWYodHlwZW9mIGUhPVwiYm9vbGVhblwiJiZlIT09dm9pZCAwJiZlIT09XCJmaXhlZFwiJiZlIT09XCJyZWxheGVkXCImJihjb25zb2xlLndhcm4oYFByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byB1bmtub3duIHZhbHVlIFwiJHtlfVwiLiBSZXNldCBpdCB0byBcXGBmYWxzZVxcYCBhbmQgaWdub3JlIFNJTUQgZmVhdHVyZSBjaGVja2luZy5gKSx0ZS53YXNtLnNpbWQ9ITEpLHR5cGVvZiB0ZS53YXNtLnByb3h5IT1cImJvb2xlYW5cIiYmKHRlLndhc20ucHJveHk9ITEpLHR5cGVvZiB0ZS53YXNtLnRyYWNlIT1cImJvb2xlYW5cIiYmKHRlLndhc20udHJhY2U9ITEpLHR5cGVvZiB0ZS53YXNtLm51bVRocmVhZHMhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHRlLndhc20ubnVtVGhyZWFkcyl8fHRlLndhc20ubnVtVGhyZWFkczw9MClpZih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCl0ZS53YXNtLm51bVRocmVhZHM9MTtlbHNle2xldCB0PXR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCI/JG4oXCJub2RlOm9zXCIpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7dGUud2FzbS5udW1UaHJlYWRzPU1hdGgubWluKDQsTWF0aC5jZWlsKCh0fHwxKS8yKSl9fSxfbj1jbGFzc3thc3luYyBpbml0KHQpe011KCksYXdhaXQgQ3UoKSxhd2FpdCBBdSh0KX1hc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih0LG4pe2xldCByPW5ldyBibjtyZXR1cm4gYXdhaXQgci5sb2FkTW9kZWwodCxuKSxyfX0seXA9bmV3IF9ufSk7dmFyIF9wPXt9O250KF9wLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5OcixUUkFDRTooKT0+Y3QsVFJBQ0VfRVZFTlRfQkVHSU46KCk9PlVlLFRSQUNFX0VWRU5UX0VORDooKT0+UmUsVFJBQ0VfRlVOQ19CRUdJTjooKT0+aGUsVFJBQ0VfRlVOQ19FTkQ6KCk9PmZlLFRlbnNvcjooKT0+dmUsZGVmYXVsdDooKT0+YnAsZW52OigpPT50ZSxyZWdpc3RlckJhY2tlbmQ6KCk9PldlfSk7eWUoKTt5ZSgpO3llKCk7dmFyIEZyPVwiMS4yMy4yXCI7dmFyIGJwPUNuO3tsZXQgZT0oUnUoKSxkdChVdSkpLndhc21CYWNrZW5kO1dlKFwid2ViZ3B1XCIsZSw1KSxXZShcIndlYm5uXCIsZSw1KSxXZShcImNwdVwiLGUsMTApLFdlKFwid2FzbVwiLGUsMTApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0ZS52ZXJzaW9ucyxcIndlYlwiLHt2YWx1ZTpGcixlbnVtZXJhYmxlOiEwfSk7cmV0dXJuIGR0KF9wKTt9KSgpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudHlwZW9mIGV4cG9ydHM9PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGU9PVwib2JqZWN0XCImJihtb2R1bGUuZXhwb3J0cz1vcnQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0Lm1pbi5qcy5tYXBcbiIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gKCkgPT4gKFtdKTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gNjg3O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Nik7XG4iXSwibmFtZXMiOlsib3duS2V5cyIsIl9fY3JlYXRlQmluZGluZyIsInRoaXMiLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiYXIiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJsZW5ndGgiLCJtb2QiLCJyZXN1bHQiLCJpIiwiZXhwb3J0cyIsIm9ydCIsImFzeW5jIiwic2Vzc2lvbiIsIkluZmVyZW5jZVNlc3Npb24iLCJleGVjdXRpb25Qcm92aWRlcnMiLCJjb25zb2xlIiwibG9nIiwiaW5wdXQiLCJUZW5zb3IiLCJGbG9hdDMyQXJyYXkiLCJvdXRwdXRUZW5zb3IiLCJydW4iLCJvdXRwdXROYW1lcyIsImRhdGEiLCJlcnIiLCJlcnJvciIsInJ1bk1vZGVsIiwieHQiLCJqZSIsIldlIiwiR3UiLCJ5ciIsIl9yIiwiJHIiLCJsZSIsInRlIiwieHIiLCJTciIsIlNuIiwiSXIiLCJDciIsIkFyIiwiRXIiLCJrciIsIlplIiwibHQiLCJ6ciIsIkJyIiwiT3IiLCJNciIsIm1lIiwidmUiLCJjdCIsIlJyIiwiaGUiLCJmZSIsIlVlIiwiUmUiLCJUdCIsIk5yIiwid24iLCJWdSIsIk51IiwiTHUiLCIkbiIsImUiLCJ0IiwibnQiLCJuIiwiZHQiLCJyIiwiV3UiLCJ2biIsIk1hcCIsImluaXQiLCJjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciIsInNldCIsImJhY2tlbmQiLCJwcmlvcml0eSIsIkVycm9yIiwiaW5kZXhPZiIsInNwbGljZSIsInB1c2giLCJUeXBlRXJyb3IiLCJpbml0aWFsaXplZCIsImFib3J0ZWQiLCJpbml0UHJvbWlzZSIsIm1hcCIsInUiLCJuYW1lIiwicyIsIlNldCIsImQiLCJhZGQiLCJqb2luIiwiaW5jbHVkZXMiLCJ3YXJuIiwiYSIsImZpbHRlciIsImhhcyIsIlByb3h5IiwiUmVmbGVjdCIsImJyIiwid3IiLCJ4biIsIndhc20iLCJ3ZWJnbCIsIndlYmdwdSIsInZlcnNpb25zIiwiY29tbW9uIiwibG9nTGV2ZWwiLCJ2ciIsIlRyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiT2Zmc2NyZWVuQ2FudmFzIiwid2lkdGgiLCJkaW1zIiwiaGVpZ2h0IiwiZ2V0Q29udGV4dCIsInRlbnNvckxheW91dCIsImZvcm1hdCIsIm5vcm0iLCJtZWFuIiwiYmlhcyIsImwiLCJjIiwicCIsImYiLCJoIiwiYiIsInkiLCJnIiwiXyIsInciLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRvRGF0YVVSTCIsImNyZWF0ZUltYWdlRGF0YSIsIlByIiwiU3QiLCJ0ZW5zb3JGb3JtYXQiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSW1hZ2VEYXRhIiwiSW1hZ2VCaXRtYXAiLCJIVE1MQ2FudmFzRWxlbWVudCIsInJlc2l6ZWRIZWlnaHQiLCJyZXNpemVkV2lkdGgiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJQcm9taXNlIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsInNyYyIsIm9ubG9hZCIsInB1dEltYWdlRGF0YSIsImRvd25sb2FkIiwiZGlzcG9zZSIsImxvY2F0aW9uIiwidHlwZSIsInRleHR1cmUiLCJkYXRhVHlwZSIsImdwdUJ1ZmZlciIsIm1sVGVuc29yIiwiRHIiLCJVaW50OEFycmF5IiwiSW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsImZyb20iLCJCaWdVaW50NjRBcnJheSIsImdsb2JhbFRoaXMiLCJGbG9hdDE2QXJyYXkiLCJVciIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJSYW5nZUVycm9yIiwiY29uc3RydWN0b3IiLCJkYXRhTG9jYXRpb24iLCJjcHVEYXRhIiwiZ3B1VGV4dHVyZURhdGEiLCJkb3dubG9hZGVyIiwiZGlzcG9zZXIiLCJncHVCdWZmZXJEYXRhIiwibWxUZW5zb3JEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiQmlnSW50IiwiVWludDhDbGFtcGVkQXJyYXkiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiTWF0aCIsImNlaWwiLCJzaXplIiwiZnJvbUltYWdlIiwiZnJvbVRleHR1cmUiLCJmcm9tR3B1QnVmZmVyIiwiZnJvbU1MVGVuc29yIiwiZnJvbVBpbm5lZEJ1ZmZlciIsInRvSW1hZ2VEYXRhIiwiZW5zdXJlVmFsaWQiLCJnZXREYXRhIiwiaXNEb3dubG9hZGluZyIsInJlc2hhcGUiLCJUbiIsIkluIiwidHJhY2UiLCJ0aW1lU3RhbXAiLCJzdGFjayIsInNwbGl0IiwidHJpbSIsInRpbWUiLCJ0aW1lRW5kIiwiVnIiLCJoYW5kbGVyIiwiaW5wdXROYW1lcyIsInJlbGVhc2UiLCJBcnJheUJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsInN0YXJ0UHJvZmlsaW5nIiwiZW5kUHJvZmlsaW5nIiwiaW5wdXRNZXRhZGF0YSIsIm91dHB1dE1ldGFkYXRhIiwiTHIiLCJXciIsIkdyIiwiSHIiLCJxciIsIkNuIiwiVFJBQ0UiLCJUUkFDRV9FVkVOVF9CRUdJTiIsIlRSQUNFX0VWRU5UX0VORCIsIlRSQUNFX0ZVTkNfQkVHSU4iLCJUUkFDRV9GVU5DX0VORCIsImVudiIsInJlZ2lzdGVyQmFja2VuZCIsInllIiwiSXQiLCJaciIsImRlZmF1bHQiLCJIdSIsIktyIiwianIiLCJxdSIsImJlIiwiTXQiLCJFbiIsIkt1IiwianUiLCJKciIsIlp1IiwiWHIiLCJlbyIsIllyIiwidG8iLCJrbiIsIlBuIiwiVXQiLCJubyIsIlF1IiwiWHUiLCJZdSIsIkF0IiwibmUiLCJfZSIsIm10IiwiWSIsInJvIiwiSnUiLCJlZCIsInRkIiwiVnQiLCJuZCIsImlvIiwiSGUiLCJFZSIsInFlIiwicnQiLCJmdCIsIk50IiwiTHQiLCJ6biIsImh0IiwicmQiLCJvZCIsImFvIiwidW8iLCJXdCIsImlkIiwiaiIsIkRuIiwiUGUiLCJ4IiwiWGUiLCJHdCIsImxvIiwiY28iLCJIdCIsIm1vIiwiVW4iLCJmbyIsInNkIiwicG8iLCJhZCIsImhvIiwicXQiLCJGdCIsIk1uIiwiZ28iLCJLdCIsInVkIiwianQiLCJfbyIsIlJuIiwiVm4iLCJkZCIsImxkIiwid28iLCJMbiIsIk5uIiwidm8iLCJXbiIsIk4iLCJZZSIsIkhuIiwicmUiLCJjZSIsIlAiLCJYIiwicW4iLCJKZSIsIlRlIiwiTyIsIlF0IiwiUyIsIkMiLCJTbyIsIlh0IiwiR24iLCJUbyIsImNkIiwiSW8iLCJwZCIsIm1kIiwiZmQiLCJoZCIsInBlIiwiQ28iLCJBbyIsImdkIiwieWQiLCJiZCIsIl9kIiwid2QiLCIkZCIsInZkIiwieGQiLCJTZCIsIlRkIiwiemUiLCJFbyIsImtvIiwiUG8iLCJ6byIsIkJvIiwiRG8iLCJPbyIsIk1vIiwiVW8iLCJSbyIsIkJlIiwiSWQiLCJKdCIsIkZuIiwiRGUiLCJDZCIsIkFkIiwiRWQiLCJrZCIsIlBkIiwiemQiLCJCZCIsIkRkIiwiT2QiLCJNZCIsIk9lIiwiTm8iLCJMbyIsIldvIiwiR28iLCJIbyIsInFvIiwiRm8iLCJLbyIsImpvIiwiWm8iLCJRbyIsIlhvIiwiWW8iLCJLbiIsIlVkIiwiam4iLCJSZCIsIlZkIiwiTmQiLCJvdCIsIkxkIiwiZWkiLCJXZCIsIkdkIiwiSGQiLCJ0aSIsInFkIiwiRmQiLCJyaSIsIktkIiwiSiIsImlpIiwic2kiLCJhaSIsInVpIiwiZGkiLCJsaSIsImNpIiwicGkiLCJtaSIsImpkIiwiZmkiLCJoaSIsImdpIiwieWkiLCJndCIsImJpIiwidG4iLCJfaSIsIndpIiwiJGkiLCJ2aSIsInhpIiwiU2kiLCJUaSIsIklpIiwiQ2kiLCJBaSIsIkVpIiwia2kiLCJQaSIsInppIiwiQmkiLCJEaSIsIk9pIiwiTWkiLCJabiIsIlFuIiwiVWkiLCJSaSIsIlZpIiwiWmQiLCJRZCIsIk5pIiwiWGQiLCJZZCIsIldpIiwiSmQiLCJlbCIsIk1lIiwiSGkiLCJxaSIsIkZpIiwiS2kiLCJqaSIsIlppIiwiUWkiLCJYaSIsIllpIiwiSmkiLCJubCIsInJsIiwib2wiLCJpbCIsInRzIiwibnMiLCJJZSIsIkNlIiwiQWUiLCJybiIsImRlIiwib3MiLCJpcyIsInl0Iiwic24iLCJzbCIsImFsIiwiWG4iLCJhcyIsInVsIiwiWW4iLCJkbCIsImJ0IiwibGwiLCJ1cyIsImNsIiwibHMiLCJkbiIsInBsIiwiY3MiLCJtbCIsInBzIiwibXMiLCJocyIsImdzIiwiZmwiLCJKbiIsImhsIiwiZXIiLCJ0ciIsImJzIiwiZ2wiLCJ5bCIsIm5yIiwid3MiLCJibCIsIl9sIiwid2wiLCJ2cyIsInhzIiwiJGwiLCJTcyIsInZsIiwiVHMiLCJ4bCIsIkNzIiwiQXMiLCJTbCIsIlRsIiwiSWwiLCJrcyIsIlBzIiwicnIiLCJsbiIsIkJzIiwiQWwiLCJvciIsImlyIiwiRHMiLCJFbCIsIk9zIiwiTXMiLCJrbCIsIlJzIiwiUGwiLCJ6bCIsIlZzIiwiQmwiLCJMcyIsIkRsIiwiT2wiLCJHcyIsIkhzIiwiTWwiLCJGcyIsIktzIiwiVWwiLCJSbCIsIlpzIiwiUXMiLCJWbCIsIk5sIiwiWXMiLCJKcyIsIkxsIiwiV2wiLCJ0YSIsIm5hIiwiTmUiLCJLZSIsIml0Iiwic3QiLCJHbCIsInFsIiwiRmwiLCJLbCIsImpsIiwiWmwiLCJRbCIsIm9hIiwiaWEiLCJnZSIsIkpsIiwidWEiLCJhYSIsImVjIiwiX3QiLCJkYSIsInRjIiwibmMiLCJyYyIsIm9jIiwibGEiLCJjYSIsImljIiwiY24iLCJwYSIsInNjIiwiYWMiLCJtYSIsInVjIiwiZmEiLCJnYSIsImRjIiwibGMiLCJ5YSIsImNjIiwicGMiLCJfYSIsIm1jIiwiJGEiLCJmYyIsImhjIiwiZ2MiLCJ4YSIsIlNhIiwieWMiLCJiYyIsIl9jIiwid2MiLCIkYyIsInZjIiwieGMiLCJTYyIsIklhIiwicG4iLCJBYSIsIkVhIiwia2EiLCJQYSIsIlRjIiwiSWMiLCJ6YSIsIkJhIiwiRGEiLCJPYSIsIk1hIiwiVWEiLCJSYSIsIlZhIiwiTmEiLCJMYSIsIldhIiwiR2EiLCJBYyIsIkVjIiwicWEiLCJGYSIsImtjIiwiUGMiLCJqYSIsInpjIiwiQmMiLCJRYSIsIlhhIiwiRGMiLCJPYyIsIk1jIiwiSmEiLCJVYyIsIlJjIiwiVmMiLCJOYyIsIkxjIiwiV2MiLCJHYyIsIkhjIiwiZXUiLCJxYyIsIkZjIiwiS2MiLCJqYyIsIlpjIiwidHUiLCJudSIsIlFjIiwiWGMiLCJvdSIsIlljIiwibW4iLCJKYyIsInN1IiwiZXAiLCJ0cCIsImF1IiwidXUiLCJucCIsInJwIiwibHUiLCJjdSIsIm11Iiwib3AiLCJpcCIsInNwIiwiZnUiLCJhcCIsInVwIiwiZ3UiLCJidSIsImZuIiwiUXIiLCJBbiIsIkdlIiwiQ3QiLCJzZWxmIiwib25tZXNzYWdlIiwiaW4iLCJ0aGVuIiwiRXQiLCJwb3N0TWVzc2FnZSIsImVwTmFtZSIsImt0IiwicHQiLCJvdXQiLCJtb2RlbCIsIm9wdGlvbnMiLCJQdCIsInp0Iiwic2Vzc2lvbklkIiwiaW5wdXRJbmRpY2VzIiwiaW5wdXRzIiwib3V0cHV0SW5kaWNlcyIsIkJ0IiwiZmlsbCIsInNvbWUiLCJPdCIsIkR0IiwiV29ya2VyIiwib3JpZ2luIiwiY3VycmVudFNjcmlwdCIsImhyZWYiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJVUkwiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiYmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsImltcG9ydCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJXZWJBc3NlbWJseSIsInZhbGlkYXRlIiwicmVzb2x2ZSIsImluaXRUaW1lb3V0IiwibnVtVGhyZWFkcyIsInNpbWQiLCJjcm9zc09yaWdpbklzb2xhdGVkIiwid2FzbVBhdGhzIiwibWpzIiwid2FzbUJpbmFyeSIsInNldFRpbWVvdXQiLCJsb2NhdGVGaWxlIiwicmV2b2tlT2JqZWN0VVJMIiwicmFjZSIsIlJ0IiwibGVuZ3RoQnl0ZXNVVEY4IiwiX21hbGxvYyIsInN0cmluZ1RvVVRGOCIsImVudHJpZXMiLCJmb3JFYWNoIiwidG9TdHJpbmciLCJzdGFja1NhdmUiLCJQVFJfU0laRSIsInN0YWNrQWxsb2MiLCJfT3J0R2V0TGFzdEVycm9yIiwiZ2V0VmFsdWUiLCJVVEY4VG9TdHJpbmciLCJzdGFja1Jlc3RvcmUiLCJvbyIsImxvZ1NldmVyaXR5TGV2ZWwiLCJpc0ludGVnZXIiLCJsb2dWZXJib3NpdHlMZXZlbCIsInRlcm1pbmF0ZSIsInRhZyIsIl9PcnRDcmVhdGVSdW5PcHRpb25zIiwiZXh0cmEiLCJXZWFrU2V0IiwiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5IiwiX09ydFJlbGVhc2VSdW5PcHRpb25zIiwiX2ZyZWUiLCJzbyIsInVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkiLCJlbmFibGVNZW1QYXR0ZXJuIiwiX09ydEFkZFNlc3Npb25Db25maWdFbnRyeSIsImRldmljZVR5cGUiLCJwcmVmZXJyZWRMYXlvdXQiLCJzZXRWYWx1ZSIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwibG9nSWQiLCJvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJlbmFibGVQcm9maWxpbmciLCJlbmFibGVHcmFwaENhcHR1cmUiLCJmcmVlRGltZW5zaW9uT3ZlcnJpZGVzIiwiX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJWIiwicmVkdWNlIiwiQm4iLCJvayIsImhlYWRlcnMiLCJwYXJzZUludCIsImFycmF5QnVmZmVyIiwiYm9keSIsImdldFJlYWRlciIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwiZG9uZSIsInJlYWQiLCJCbG9iIiwia2UiLCJEYXRlIiwidG9JU09TdHJpbmciLCJxIiwiY2FsY01hdE11bFNoYXBlIiwiY2FsY1NoYXBlIiwibWF4IiwiaXNWYWxpZEJyb2FkY2FzdCIsImdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UiLCJjb252ZXJ0U2hhcGUiLCJzaXplRnJvbURpbWVuc2lvbiIsInNpemVUb0RpbWVuc2lvbiIsImNvbXB1dGVTdHJpZGVzIiwibm9ybWFsaXplQXhpcyIsIm5vcm1hbGl6ZUF4ZXMiLCJzb3J0QmFzZWRPblBlcm0iLCJzbGljZSIsInJldmVyc2UiLCJwYWRTaGFwZSIsImFyZUVxdWFsIiwiZXZlcnkiLCJhZGp1c3RQb29sQXR0cmlidXRlcyIsImFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCIsImFkanVzdFBhZEFuZFJldHVyblNoYXBlIiwiY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSIsImNvbXB1dGVTaGFwZUhlbHBlciIsImNvbXB1dGVDb252T3V0cHV0U2hhcGUiLCJmbG9vciIsImdldFNoYXBlT2ZHZW1tUmVzdWx0IiwiT24iLCJ5byIsImlzRGF0YUNvbnZlcnRlZCIsImNvbnRleHQiLCJ0ZW5zb3IiLCJzaGFwZSIsImZhbGxiYWNrRGF0YVR5cGUiLCJtbENvbnRleHQiLCJ0ZW5zb3JTaGFwZSIsImZhbGxiYWNrVHlwZSIsImRlc3Ryb3kiLCJ3cml0ZSIsIndyaXRlVGVuc29yIiwicmVhZFRlbnNvciIsImNhblJldXNlVGVuc29yIiwic2V0SXNEYXRhQ29udmVydGVkIiwidGVuc29yTWFuYWdlciIsIndyYXBwZXIiLCJ0ZW5zb3JXcmFwcGVyIiwicmVsZWFzZVRlbnNvciIsImVuc3VyZVRlbnNvciIsImdldE1MQ29udGV4dCIsIm9wU3VwcG9ydExpbWl0cyIsImRhdGFUeXBlcyIsImFjdGl2ZVVwbG9hZCIsIk1MVGVuc29yVXNhZ2UiLCJSRUFEIiwiV1JJVEUiLCJnZXRDYWNoZWRUZW5zb3IiLCJ1cGxvYWQiLCJ0ZW5zb3JUcmFja2Vyc0J5SWQiLCJmcmVlVGVuc29ycyIsImV4dGVybmFsVGVuc29ycyIsInJlc2VydmVUZW5zb3JJZCIsInJlbGVhc2VUZW5zb3JJZCIsImRlbGV0ZSIsInJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbiIsInJlZ2lzdGVyVGVuc29yIiwiY3JlYXRlVGVuc29yIiwiZGltZW5zaW9ucyIsInVzYWdlIiwicmVhZGFibGUiLCJibyIsImtleXMiLCJzb3J0IiwibWxDb250ZXh0QnlTZXNzaW9uSWQiLCJzZXNzaW9uSWRzQnlNTENvbnRleHQiLCJtbENvbnRleHRDYWNoZSIsInNlc3Npb25HcmFwaElucHV0cyIsInNlc3Npb25HcmFwaE91dHB1dHMiLCJ0ZW1wb3JhcnlHcmFwaElucHV0cyIsInRlbXBvcmFyeUdyYXBoT3V0cHV0cyIsInRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMiLCJkZWJ1ZyIsImN1cnJlbnRTZXNzaW9uSWQiLCJhY3RpdmVTZXNzaW9uSWQiLCJvblJ1blN0YXJ0Iiwib25SdW5FbmQiLCJjcmVhdGVNTENvbnRleHQiLCJHUFVEZXZpY2UiLCJmaW5kSW5kZXgiLCJncHVEZXZpY2UiLCJuYXZpZ2F0b3IiLCJjcmVhdGVDb250ZXh0IiwicmVnaXN0ZXJNTENvbnRleHQiLCJvblJlbGVhc2VTZXNzaW9uIiwiY3JlYXRlVGVtcG9yYXJ5VGVuc29yIiwidXBsb2FkVGVuc29yIiwic2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIiwiZG93bmxvYWRUZW5zb3IiLCJjcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJyZWdpc3Rlck1MVGVuc29yIiwicmVnaXN0ZXJNTENvbnN0YW50IiwiY29uc3RhbnQiLCJyZWdpc3RlckdyYXBoSW5wdXQiLCJyZWdpc3RlckdyYXBoT3V0cHV0IiwiaXNHcmFwaElucHV0IiwiaXNHcmFwaE91dHB1dCIsImlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQiLCJvdXRwdXQiLCJmbHVzaCIsIlp0IiwieG8iLCJkZXZpY2UiLCJjcmVhdGVCdWZmZXIiLCJHUFVCdWZmZXJVc2FnZSIsIkNPUFlfRFNUIiwiTUFQX1JFQUQiLCJnZXRDb21tYW5kRW5jb2RlciIsImVuZENvbXB1dGVQYXNzIiwiY29weUJ1ZmZlclRvQnVmZmVyIiwibWFwQXN5bmMiLCJHUFVNYXBNb2RlIiwiZ2V0TWFwcGVkUmFuZ2UiLCJzdG9yYWdlQ2FjaGUiLCJmcmVlQnVmZmVycyIsImZyZWVVbmlmb3JtQnVmZmVycyIsImJ1ZmZlcnNQZW5kaW5nIiwiY2FwdHVyZWRQZW5kaW5nQnVmZmVycyIsInNlc3Npb25Db3VudCIsIm9yaWdpbmFsU2l6ZSIsIm1hcHBlZEF0Q3JlYXRpb24iLCJNQVBfV1JJVEUiLCJDT1BZX1NSQyIsInVubWFwIiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJncHVEYXRhIiwicXVldWUiLCJzdWJtaXQiLCJmaW5pc2giLCJtZW1jcHkiLCJyZWdpc3RlckV4dGVybmFsQnVmZmVyIiwiY2FwdHVyZWRDb21tYW5kTGlzdCIsInVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlciIsIlNUT1JBR0UiLCJVTklGT1JNIiwicG9wIiwicmVmcmVzaFBlbmRpbmdCdWZmZXJzIiwic2Vzc2lvblN0YXR1cyIsIm9uQ3JlYXRlU2Vzc2lvbiIsImllIiwiYXNzaWduIiwiY2FjaGVLZXkiLCJrZXkiLCJLIiwiaW5kaWNlcyIsInN0b3JhZ2UiLCJFIiwib2Zmc2V0VG9JbmRpY2VzIiwiaW5kaWNlc1RvT2Zmc2V0IiwiYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQiLCJzZXRCeUluZGljZXMiLCJnZXRCeUluZGljZXMiLCIkIiwiSSIsIkEiLCJMIiwiTSIsIkciLCJCIiwiZWUiLCJXIiwib2UiLCJSIiwiUSIsImltcGwiLCJ2YWx1ZXMiLCJ1bnNoaWZ0IiwiJGUiLCJTZSIsInVlIiwiaW5kaWNlc0dldCIsInJhbmsiLCJpbmRpY2VzU2V0Iiwic2V0QnlPZmZzZXQiLCJnZXRCeU9mZnNldCIsInN0cmlkZXMiLCJub3JtYWxpemVkRGlzcGF0Y2hHcm91cCIsImxpbWl0cyIsImludGVybmFsVmFyaWFibGVzIiwidmFyaWFibGVzIiwidW5pZm9ybXMiLCJ2YXJpYWJsZUluZGV4IiwiZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyIsIm1haW5TdGFydCIsIm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCIsIm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSIsIm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWiIsIm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCIsImFwcGVuZFZhcmlhYmxlVW5pZm9ybXMiLCJyZXBsYWNlIiwiZGVjbGFyZVZhcmlhYmxlIiwiZGVjbGFyZVZhcmlhYmxlcyIsInJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSIsInJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMiLCJyZWdpc3RlclVuaWZvcm0iLCJyZWdpc3RlclVuaWZvcm1zIiwiY29uY2F0IiwidW5pZm9ybURlY2xhcmF0aW9uIiwiYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyIsInZhcmlhYmxlc0luZm8iLCJWZSIsIm5ld1NoYXBlIiwibmV3UGVybSIsInNoYWRlckNhY2hlIiwiaW5wdXREZXBlbmRlbmNpZXMiLCJnZXRSdW5EYXRhIiwib3V0cHV0cyIsImRpc3BhdGNoR3JvdXAiLCJwcm9ncmFtVW5pZm9ybXMiLCJnZXRTaGFkZXJTb3VyY2UiLCJoaW50IiwicGVybSIsImNvbXB1dGUiLCJWbyIsIll0IiwibWluIiwic3VtIiwicHJvZCIsInN1bVNxdWFyZSIsImxvZ1N1bUV4cCIsImwxIiwibDIiLCJsb2dTdW0iLCJheGVzIiwibm9vcFdpdGhFbXB0eUF4ZXMiLCJrZWVwRGltcyIsIlQiLCJnZXRCaWdJbnQ2NEFycmF5IiwiSm8iLCJzZWxlY3RMYXN0SW5kZXgiLCJheGlzIiwiZW4iLCJxa3ZIaWRkZW5TaXplcyIsIm51bUhlYWRzIiwicGFzdFByZXNlbnRTaGFyZUJ1ZmZlciIsImJhdGNoU2l6ZSIsInNlcXVlbmNlTGVuZ3RoIiwicGFzdFNlcXVlbmNlTGVuZ3RoIiwia3ZTZXF1ZW5jZUxlbmd0aCIsInRvdGFsU2VxdWVuY2VMZW5ndGgiLCJtYXhTZXF1ZW5jZUxlbmd0aCIsImlucHV0SGlkZGVuU2l6ZSIsImhpZGRlblNpemUiLCJ2SGlkZGVuU2l6ZSIsImhlYWRTaXplIiwidkhlYWRTaXplIiwiaXNVbmlkaXJlY3Rpb25hbCIsIm1hc2tGaWx0ZXJWYWx1ZSIsIm1hc2tUeXBlIiwic2NhbGUiLCJicm9hZGNhc3RSZXNQb3NCaWFzIiwicGFzc1Bhc3RJbkt2IiwicWt2Rm9ybWF0IiwieiIsImt2TnVtSGVhZHMiLCJuUmVwcyIsInNxcnQiLCJncHVEYXRhVHlwZSIsIlUiLCJEIiwib3V0cHV0Q291bnQiLCJuaSIsInNwYXRpYWwiLCJlcHNpbG9uIiwidmFsaWRhdGVJbnB1dENvbnRlbnQiLCJ0cmFpbmluZ01vZGUiLCJvaSIsIm5uIiwiZ2V0RmxvYXQzMkFycmF5IiwiZ2V0VWludDE2QXJyYXkiLCJhbHBoYSIsImJldGEiLCJHaSIsImVzIiwic2NhbGFyIiwidmVjdG9yIiwicnMiLCJGZSIsImFjdGl2YXRpb24iLCJjbGlwTWF4IiwiY2xpcE1pbiIsImFjdGl2YXRpb25fcGFyYW1zIiwib24iLCJzcyIsImFuIiwiWiIsInVuIiwid2UiLCJzZSIsIkgiLCJkcyIsInBhZHMiLCJkaWxhdGlvbnMiLCJmcyIsInRydW5jIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiZnJvbnQiLCJiYWNrIiwicGFkSW5mbyIsIm91dERlcHRoIiwib3V0SGVpZ2h0Iiwib3V0V2lkdGgiLCJkYXRhRm9ybWF0IiwiaW5EZXB0aCIsImluSGVpZ2h0IiwiaW5XaWR0aCIsImluQ2hhbm5lbHMiLCJvdXRDaGFubmVscyIsInN0cmlkZURlcHRoIiwic3RyaWRlSGVpZ2h0Iiwic3RyaWRlV2lkdGgiLCJmaWx0ZXJEZXB0aCIsImZpbHRlckhlaWdodCIsImZpbHRlcldpZHRoIiwiZWZmZWN0aXZlRmlsdGVyRGVwdGgiLCJlZmZlY3RpdmVGaWx0ZXJIZWlnaHQiLCJlZmZlY3RpdmVGaWx0ZXJXaWR0aCIsImRpbGF0aW9uRGVwdGgiLCJkaWxhdGlvbkhlaWdodCIsImRpbGF0aW9uV2lkdGgiLCJpblNoYXBlIiwib3V0U2hhcGUiLCJmaWx0ZXJTaGFwZSIsInlzIiwiZ3JvdXAiLCJfcyIsImtlcm5lbFNoYXBlIiwiYXV0b1BhZCIsImF1dG9fcGFkIiwia2VybmVsX3NoYXBlIiwid0lzQ29uc3QiLCJ3X2lzX2NvbnN0Iiwia2VybmVsQ3VzdG9tRGF0YSIsIndUIiwiYWRhcHRlckluZm8iLCJpc0FyY2hpdGVjdHVyZSIsIiRzIiwib3V0cHV0U2hhcGUiLCJJcyIsIm91dHB1dFBhZGRpbmciLCJFcyIsImdldEludDMyQXJyYXkiLCJleGNsdXNpdmUiLCJ6cyIsImJsb2Nrc2l6ZSIsIm1vZGUiLCJVcyIsInN5bWJvbFRvSW5kaWNlcyIsImlucHV0SW5kZXgiLCJhZGRTeW1ib2wiLCJlcXVhdGlvbiIsImhhc0VsbGlwc2lzIiwic3ltYm9sVG9JbmZvIiwibGhzIiwib3V0cHV0RGltcyIsIm1hdGNoIiwiUmVnRXhwIiwicHJvY2Vzc1Rlcm0iLCJjb3VudCIsImVsbGlwc2lzRGltcyIsImRpbVZhbHVlIiwicmhzIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiTnMiLCJXcyIsInFzIiwianMiLCJiYXRjaERpbXMiLCJiYXRjaF9kaW1zIiwiWHMiLCJxdWFudGl6ZUF4aXMiLCJibG9ja1NpemUiLCJnYXRoZXJBeGlzIiwiZWEiLCJyYSIsInRyYW5zQSIsInRyYW5zQiIsInNhIiwiYWxpZ25Db3JuZXJzIiwicGFkZGluZ01vZGUiLCJhbGlnbl9jb3JuZXJzIiwicGFkZGluZ19tb2RlIiwic3IiLCJ1ciIsIm51bU91dHB1dHMiLCJzcGxpdFNpemVzIiwiZHIiLCJyb3RhcnlFbWJlZGRpbmdEaW0iLCJpbnRlcmxlYXZlZCIsImhhIiwiZG9Sb3RhcnkiLCJsb2NhbFdpbmRvd1NpemUiLCJzb2Z0Y2FwIiwicm90YXJ5SW50ZXJsZWF2ZWQiLCJzbW9vdGhTb2Z0bWF4IiwiYmEiLCJ3YSIsInNpbXBsaWZpZWQiLCJ2YSIsIlRhIiwiYml0cyIsImlzVmVuZG9yIiwiQ2EiLCJIYSIsImNlaWxNb2RlIiwiY291bnRJbmNsdWRlUGFkIiwic3RvcmFnZU9yZGVyIiwiY2VpbF9tb2RlIiwiY291bnRfaW5jbHVkZV9wYWQiLCJzdG9yYWdlX29yZGVyIiwiS2EiLCJaYSIsImFicyIsIllhIiwicmVkdWN0aW9uIiwicnUiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsInJvdW5kIiwia2VlcEFzcGVjdFJhdGlvUG9saWN5IiwiTUFYX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiZXh0cmFwb2xhdGlvblZhbHVlIiwibmVhcmVzdE1vZGUiLCJjdWJpY0NvZWZmQSIsImV4Y2x1ZGVPdXRzaWRlIiwiY3VzdG9tRGF0YUJ1ZmZlciIsImFudGlhbGlhcyIsIml1IiwiZHUiLCJzdGFydHMiLCJlbmRzIiwic2lnbiIsInB1IiwiaHUiLCJ5dSIsIl91Iiwid3UiLCJyZXBvIiwiYXR0cmlidXRlc0JvdW5kIiwiZ2V0QXJ0aWZhY3QiLCJzZXRBcnRpZmFjdCIsInByb2dyYW1JbmZvIiwiZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyIiwid3JpdGVUaW1lc3RhbXAiLCJwZW5kaW5nRGlzcGF0Y2hOdW1iZXIiLCJiaW5kaW5nIiwicmVzb3VyY2UiLCJjcmVhdGVCaW5kR3JvdXAiLCJsYXlvdXQiLCJjb21wdXRlUGlwZWxpbmUiLCJnZXRCaW5kR3JvdXBMYXlvdXQiLCJsYWJlbCIsImtlcm5lbElkIiwiY3VycmVudEtlcm5lbElkIiwiYmluZEdyb3VwIiwic2V0UGlwZWxpbmUiLCJzZXRCaW5kR3JvdXAiLCJkaXNwYXRjaFdvcmtncm91cHMiLCJtYXhEaXNwYXRjaE51bWJlciIsInF1ZXJ5VHlwZSIsImJ1aWxkIiwiZmVhdHVyZSIsImV4dGVuc2lvbiIsImZlYXR1cmVzIiwiY3JlYXRlU2hhZGVyTW9kdWxlIiwiY29kZSIsImNyZWF0ZUNvbXB1dGVQaXBlbGluZSIsIm1vZHVsZSIsImVudHJ5UG9pbnQiLCJ1bmlmb3JtVmFyaWFibGVzSW5mbyIsIm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplIiwibWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24iLCJjYnJ0IiwiJHUiLCJXZWJHcHVCYWNrZW5kIiwiY3IiLCJkcCIsImxwIiwibHIiLCJ2dSIsImFyY2hpdGVjdHVyZSIsInZlbmRvciIsImNvbW1hbmRFbmNvZGVyIiwiY29tcHV0ZVBhc3NFbmNvZGVyIiwicGVuZGluZ0tlcm5lbHMiLCJwZW5kaW5nUXVlcmllcyIsImNhcHR1cmVkUGVuZGluZ0tlcm5lbHMiLCJzZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZyIsImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhIiwiaW5pdGlhbGl6ZSIsInJlcXVpcmVkTGltaXRzIiwibWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplIiwibWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplIiwibWF4QnVmZmVyU2l6ZSIsInJlcXVpcmVkRmVhdHVyZXMiLCJyZXF1ZXN0RGV2aWNlIiwiaW5mbyIsInJlcXVlc3RBZGFwdGVySW5mbyIsImdwdURhdGFNYW5hZ2VyIiwicHJvZ3JhbU1hbmFnZXIiLCJrZXJuZWxzIiwia2VybmVsUGVyc2lzdGVudERhdGEiLCJvbnVuY2FwdHVyZWRlcnJvciIsIkdQVVZhbGlkYXRpb25FcnJvciIsIm1lc3NhZ2UiLCJzZXRRdWVyeVR5cGUiLCJxdWVyeVNldCIsInRpbWVzdGFtcFdyaXRlcyIsImJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXgiLCJlbmRPZlBhc3NXcml0ZUluZGV4IiwiYmVnaW5Db21wdXRlUGFzcyIsImVuZCIsInJlc29sdmVRdWVyeVNldCIsInF1ZXJ5UmVzb2x2ZUJ1ZmZlciIsImtlcm5lbFR5cGUiLCJrZXJuZWxOYW1lIiwicHJvZ3JhbU5hbWUiLCJpbnB1dFRlbnNvclZpZXdzIiwib3V0cHV0VGVuc29yVmlld3MiLCJxdWVyeVRpbWVCYXNlIiwicHJvZmlsaW5nIiwib25kYXRhIiwidmVyc2lvbiIsImlucHV0c01ldGFkYXRhIiwib3V0cHV0c01ldGFkYXRhIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRlbXBvcmFyeURhdGEiLCJ3cml0ZUJ1ZmZlciIsIm9mZnNldCIsImFsbG9jIiwiZnJlZSIsImNyZWF0ZUtlcm5lbCIsImtlcm5lbEVudHJ5IiwiYXR0cmlidXRlcyIsInJlbGVhc2VLZXJuZWwiLCJjb21wdXRlS2VybmVsIiwicHVzaEVycm9yU2NvcGUiLCJwb3BFcnJvclNjb3BlIiwicmVnaXN0ZXJCdWZmZXIiLCJ1bnJlZ2lzdGVyQnVmZmVycyIsImdldEJ1ZmZlciIsImNyZWF0ZURvd25sb2FkZXIiLCJjcmVhdGVRdWVyeVNldCIsIlFVRVJZX1JFU09MVkUiLCJjYXB0dXJlQmVnaW4iLCJjYXB0dXJlRW5kIiwicmVwbGF5IiwieHUiLCJjcCIsInd0IiwicHIiLCJwcCIsImV0IiwibXAiLCJUdSIsIkl1IiwidHQiLCJ4ZSIsIiR0IiwiZ24iLCJ5biIsImhuIiwibXIiLCJmciIsImF0IiwidXQiLCJocCIsIkN1IiwiQXUiLCJFdSIsImt1IiwiUHUiLCJ6dSIsIkJ1IiwiRHUiLCJncCIsImJuIiwiU3UiLCJIRUFQOCIsImN1c3RvbURhdGFPZmZzZXQiLCJjdXN0b21EYXRhU2l6ZSIsIm9wS2VybmVsQ29udGV4dCIsIkhFQVBVOCIsInN1YmFycmF5IiwiX0pzZXBPdXRwdXQiLCJqc2VwSW5pdCIsIl9Kc2VwR2V0Tm9kZU5hbWUiLCJfT3J0SW5pdCIsImFzeW5jSW5pdCIsImFkYXB0ZXIiLCJncHUiLCJwb3dlclByZWZlcmVuY2UiLCJmb3JjZUZhbGxiYWNrQWRhcHRlciIsInJlcXVlc3RBZGFwdGVyIiwiX09ydEdldElucHV0T3V0cHV0Q291bnQiLCJfT3J0R2V0SW5wdXRPdXRwdXRNZXRhZGF0YSIsIkhFQVAzMiIsIkhFQVBVMzIiLCJfT3J0RnJlZSIsImV4dGVybmFsRGF0YSIsIm1vdW50RXh0ZXJuYWxEYXRhIiwicGF0aCIsImFsbCIsImN1cnJlbnRDb250ZXh0Iiwid2Vibm5DcmVhdGVNTENvbnRleHQiLCJfT3J0Q3JlYXRlU2Vzc2lvbiIsIndlYmdwdU9uQ3JlYXRlU2Vzc2lvbiIsImpzZXBPbkNyZWF0ZVNlc3Npb24iLCJ3ZWJublJlZ2lzdGVyTUxDb250ZXh0IiwiaXNUZW5zb3IiLCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiIsIndlYm5uSXNHcmFwaE91dHB1dCIsIl9PcnRDcmVhdGVCaW5kaW5nIiwiaGFuZGxlIiwib3V0cHV0UHJlZmVycmVkTG9jYXRpb25zIiwib3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZCIsIl9PcnRSZWxlYXNlQmluZGluZyIsIl9PcnRSZWxlYXNlU2Vzc2lvbiIsInVubW91bnRFeHRlcm5hbERhdGEiLCJfT3J0Q2xlYXJCb3VuZE91dHB1dHMiLCJqc2VwT25SZWxlYXNlU2Vzc2lvbiIsIndlYm5uT25SZWxlYXNlU2Vzc2lvbiIsIndlYmdwdU9uUmVsZWFzZVNlc3Npb24iLCJqc2VwUmVnaXN0ZXJCdWZmZXIiLCJ3ZWJublJlZ2lzdGVyTUxUZW5zb3IiLCJ3ZWJubklzR3JhcGhJbnB1dCIsIndlYm5uQ3JlYXRlVGVtcG9yYXJ5VGVuc29yIiwid2Vibm5VcGxvYWRUZW5zb3IiLCJfT3J0Q3JlYXRlVGVuc29yIiwiX09ydEJpbmRJbnB1dCIsIl9PcnRCaW5kT3V0cHV0IiwianNlcE9uUnVuU3RhcnQiLCJ3ZWJubk9uUnVuU3RhcnQiLCJfT3J0UnVuV2l0aEJpbmRpbmciLCJfT3J0UnVuIiwiX09ydEdldFRlbnNvckRhdGEiLCJhZSIsIkxlIiwidnQiLCJnciIsImpzZXBHZXRCdWZmZXIiLCJqc2VwQ3JlYXRlRG93bmxvYWRlciIsIl9PcnRSZWxlYXNlVGVuc29yIiwid2Vibm5FbnN1cmVUZW5zb3IiLCJ3ZWJubklzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQiLCJ3ZWJubkNyZWF0ZU1MVGVuc29yRG93bmxvYWRlciIsIndlYm5uUmVsZWFzZVRlbnNvcklkIiwid2Vibm5PblJ1bkVuZCIsIl9PcnRFbmRQcm9maWxpbmciLCJociIsInByb3h5Iiwic2hpZnQiLCJvbmVycm9yIiwiT3UiLCJmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSIsImxvYWRNb2RlbCIsIlV1IiwiT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQiLCJfbiIsImluaXRpYWxpemVGbGFncyIsIk11Iiwid2FzbUJhY2tlbmQiLCJ5cCIsIlJ1IiwiY3B1cyIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJfcCIsImJwIiwid2VicGFja0VtcHR5Q29udGV4dCIsInJlcSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsIl9fd2VicGFja19tb2R1bGVzX18iLCJvYmoiLCJwcm9wIl0sInNvdXJjZVJvb3QiOiIifQ==