/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var e={603:(e,t,n)=>{"use strict";var i=(()=>{var e,t,i,r,a,s,o,u,l,d,p,h,c,f,m,g,_,y,$,w,b,v,x,k,S,I,T,E,z,C,O,A,B,R=Object.defineProperty,D=Object.getOwnPropertyDescriptor,M=Object.getOwnPropertyNames,U=Object.prototype.hasOwnProperty,P=n(687),N=(e,t)=>()=>(e&&(t=e(e=0)),t),q=(e,t)=>{for(var n in t)R(e,n,{get:t[n],enumerable:!0})},V=e=>((e,t,n,i)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of M(t))!U.call(e,n)&&undefined!==n&&R(e,n,{get:()=>t[n],enumerable:!(i=D(t,n))||i.enumerable});return e})(R({},"__esModule",{value:!0}),e),L=N(()=>{e=new Map,t=[],i=(n,i,r)=>{if(i&&"function"==typeof i.init&&"function"==typeof i.createInferenceSessionHandler){let a=e.get(n);if(void 0===a)e.set(n,{backend:i,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==i)throw new Error(`cannot register backend "${n}" using priority ${r}`)}if(r>=0){let i=t.indexOf(n);-1!==i&&t.splice(i,1);for(let i=0;i<t.length;i++)if(e.get(t[i]).priority<=r)return void t.splice(i,0,n);t.push(n)}return}throw new TypeError("not a valid backend")},r=async t=>{let n=e.get(t);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{let e=!!n.initPromise;try{return e||(n.initPromise=n.backend.init(t)),await n.initPromise,n.initialized=!0,n.backend}catch(t){return e||(n.error=`${t}`,n.aborted=!0),n.error}finally{delete n.initPromise}}},a=async e=>{let n,i=e.executionProviders||[],a=i.map(e=>"string"==typeof e?e:e.name),s=0===a.length?t:a,o=[],u=new Set;for(let e of s){let t=await r(e);"string"==typeof t?o.push({name:e,err:t}):(n||(n=t),n===t&&u.add(e))}if(!n)throw new Error(`no available backend found. ERR: ${o.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of o)a.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let l=i.filter(e=>u.has("string"==typeof e?e:e.name));return[n,new Proxy(e,{get:(e,t)=>"executionProviders"===t?l:Reflect.get(e,t)})]}}),G=N(()=>{L()}),W=N(()=>{s="1.23.2"}),H=N(()=>{W(),o="warning",u={wasm:{},webgl:{},webgpu:{},versions:{common:s},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);o=e}},get logLevel(){return o}},Object.defineProperty(u,"logLevel",{enumerable:!0})}),F=N(()=>{H(),l=u}),K=N(()=>{d=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let i=n.getContext("2d");if(null!=i){let r,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(r=e.dims[2],a=e.dims[3]):(r=e.dims[3],a=e.dims[2]);let s,o,u=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?s=[255,255,255,255]:"number"==typeof l.mean?s=[l.mean,l.mean,l.mean,l.mean]:(s=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(s[3]=l.mean[3])),void 0===l||void 0===l.bias?o=[0,0,0,0]:"number"==typeof l.bias?o=[l.bias,l.bias,l.bias,l.bias]:(o=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(o[3]=l.bias[3]));let d=a*r,p=0,h=d,c=2*d,f=-1;"RGBA"===u?(p=0,h=d,c=2*d,f=3*d):"RGB"===u?(p=0,h=d,c=2*d):"RBG"===u&&(p=0,c=d,h=2*d);for(let t=0;t<a;t++)for(let n=0;n<r;n++){let r=(e.data[p++]-o[0])*s[0],a=(e.data[h++]-o[1])*s[1],u=(e.data[c++]-o[2])*s[2],l=-1===f?255:(e.data[f++]-o[3])*s[3];i.fillStyle="rgba("+r+","+a+","+u+","+l+")",i.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},p=(e,t)=>{let n,i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==i)throw new Error("Can not access image data");{let r,a,s;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(r=e.dims[2],a=e.dims[1],s=e.dims[3]):(r=e.dims[3],a=e.dims[2],s=e.dims[1]);let o,u,l=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?o=[255,255,255,255]:"number"==typeof d.mean?o=[d.mean,d.mean,d.mean,d.mean]:(o=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(o[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));let p=a*r;if(void 0!==t&&(void 0!==t.format&&4===s&&"RGBA"!==t.format||3===s&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let h=4,c=0,f=1,m=2,g=3,_=0,y=p,$=2*p,w=-1;"RGBA"===l?(_=0,y=p,$=2*p,w=3*p):"RGB"===l?(_=0,y=p,$=2*p):"RBG"===l&&(_=0,$=p,y=2*p),n=i.createImageData(r,a);for(let t=0;t<a*r;c+=h,f+=h,m+=h,g+=h,t++)n.data[c]=(e.data[_++]-u[0])*o[0],n.data[f]=(e.data[y++]-u[1])*o[1],n.data[m]=(e.data[$++]-u[2])*o[2],n.data[g]=-1===w?255:(e.data[w++]-u[3])*o[3]}return n}}),j=N(()=>{X(),h=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,i,{height:r,width:a}=t,s=t.norm??{mean:255,bias:0};n="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],i="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let o=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=r*a,d="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l),p=4,h=0,c=1,f=2,m=3,g=0,_=l,y=2*l,$=-1;"RGB"===o&&(p=3,h=0,c=1,f=2,m=-1),"RGBA"===u?$=3*l:"RBG"===u?(g=0,y=l,_=2*l):"BGR"===u&&(y=0,_=l,g=2*l);for(let t=0;t<l;t++,h+=p,f+=p,c+=p,m+=p)d[g++]=(e[h]+i[0])/n[0],d[_++]=(e[c]+i[1])/n[1],d[y++]=(e[f]+i[2])/n[2],-1!==$&&-1!==m&&(d[$++]=(e[m]+i[3])/n[3]);return new k("float32",d,"RGBA"===u?[1,4,r,a]:[1,3,r,a])},c=async(e,t)=>{let n,i=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,r=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s="string"==typeof e,o=t??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(i){let i=u();i.width=e.width,i.height=e.height;let r=l(i);if(null==r)throw new Error("Can not access image data");{let i=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(i=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=i,o.width=a}else o.tensorFormat="RGBA",o.height=i,o.width=a;r.drawImage(e,0,0),n=r.getImageData(0,0,a,i).data}}else{if(!r){if(a){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let i=u();i.width=e.width,i.height=e.height;let r=l(i);if(null!=r){let t=e.height,i=e.width;return r.drawImage(e,0,0,i,t),n=r.getImageData(0,0,i,t).data,o.height=t,o.width=i,h(n,o)}throw new Error("Can not access image data")}if(s)return new Promise((t,n)=>{let i=u(),r=l(i);if(!e||!r)return n();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{i.width=a.width,i.height=a.height,r.drawImage(a,0,0,i.width,i.height);let e=r.getImageData(0,0,i.width,i.height);o.height=i.height,o.width=i.width,t(h(e.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let i,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(i=t.resizedHeight,r=t.resizedWidth):(i=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=i,o.width=r,void 0!==t){let t=u();t.width=r,t.height=i;let a=l(t);if(null==a)throw new Error("Can not access image data");a.putImageData(e,0,0),n=a.getImageData(0,0,r,i).data}else n=e.data}}if(void 0!==n)return h(n,o);throw new Error("Input data provided is not supported - aborted tensor creation")},f=(e,t)=>{let{width:n,height:i,download:r,dispose:a}=t;return new k({location:"texture",type:"float32",texture:e,dims:[1,i,n,4],download:r,dispose:a})},m=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:a}=t;return new k({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:i,download:r,dispose:a})},g=(e,t)=>{let{dataType:n,dims:i,download:r,dispose:a}=t;return new k({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:i,download:r,dispose:a})},_=(e,t,n)=>new k({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),Z=N(()=>{y=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),$=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),w=!1,b=()=>{if(!w){w=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,i=typeof n<"u"&&n.from;e&&(y.set("int64",BigInt64Array),$.set(BigInt64Array,"int64")),t&&(y.set("uint64",BigUint64Array),$.set(BigUint64Array,"uint64")),i?(y.set("float16",n),$.set(n,"float16")):y.set("float16",Uint16Array)}}}),Q=N(()=>{X(),v=e=>{let t=1;for(let n=0;n<e.length;n++){let i=e[n];if("number"!=typeof i||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);t*=i}return t},x=(e,t)=>{switch(e.location){case"cpu":return new k(e.type,e.data,t);case"cpu-pinned":return new k({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new k({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new k({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new k({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),X=N(()=>{K(),j(),Z(),Q(),k=class{constructor(e,t,n){let i,r;if(b(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,i=e.type,r=e.dims,e.location){case"cpu-pinned":{let t=y.get(i);if(!t)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==i)throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==i&&"float16"!==i&&"int32"!==i&&"int64"!==i&&"uint32"!==i&&"uint8"!==i&&"bool"!==i&&"uint4"!==i&&"int4"!==i)throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==i&&"float16"!==i&&"int32"!==i&&"int64"!==i&&"uint32"!==i&&"uint64"!==i&&"int8"!==i&&"uint8"!==i&&"bool"!==i&&"uint4"!==i&&"int4"!==i)throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,s;if("string"==typeof e)if(i=e,s=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{let n=y.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);a="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");a=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&n!==Uint16Array))throw new TypeError(`A ${i} tensor's data must be type of ${n}`);a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(s=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)i="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);i="bool",a=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)i="uint8",a=Uint8Array.from(e);else{let t=$.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=t,a=e}if(void 0===s)s=[a.length];else if(!Array.isArray(s))throw new TypeError("A tensor's dims must be a number array");r=s,this.cpuData=a,this.dataLocation="cpu"}let a=v(r);if(this.cpuData&&a!==this.cpuData.length&&("uint4"!==i&&"int4"!==i||Math.ceil(a/2)!==this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=r,this.size=a}static async fromImage(e,t){return c(e,t)}static fromTexture(e,t){return f(e,t)}static fromGpuBuffer(e,t){return m(e,t)}static fromMLTensor(e,t){return g(e,t)}static fromPinnedBuffer(e,t,n){return _(e,t,n)}toDataURL(e){return d(this,e)}toImageData(e){return p(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return x(this,e)}}}),Y=N(()=>{X(),S=k}),J=N(()=>{H(),I=(e,t)=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||console.timeStamp(`${e}::ORT::${t}`)},T=(e,t)=>{let n=(new Error).stack?.split(/\r\n|\r|\n/g)||[],i=!1;for(let r=0;r<n.length;r++){if(i&&!n[r].includes("TRACE_FUNC")){let i=`FUNC_${e}::${n[r].trim().split(" ")[1]}`;return t&&(i+=`::${t}`),void I("CPU",i)}n[r].includes("TRACE_FUNC")&&(i=!0)}},E=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||T("BEGIN",e)},z=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||T("END",e)},C=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||console.time(`ORT::${e}`)},O=e=>{(typeof u.trace>"u"?!u.wasm.trace:!u.trace)||console.timeEnd(`ORT::${e}`)}}),ee=N(()=>{L(),Y(),J(),A=class e{constructor(e){this.handler=e}async run(e,t,n){E(),C("InferenceSession.run");let i={},r={};if("object"!=typeof e||null===e||e instanceof S||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof S)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);i[e]=null}if("object"==typeof n&&null!==n)r=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,s=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==s.indexOf(n)){let r=t[n];(null===r||r instanceof S)&&(e=!0,a=!1,i[n]=r)}if(e){if("object"==typeof n&&null!==n)r=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else r=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)i[e]=null;let s=await this.handler.run(e,i,r),o={};for(let e in s)if(Object.hasOwnProperty.call(s,e)){let t=s[e];o[e]=t instanceof S?t:new S(t.type,t.data,t.dims)}return O("InferenceSession.run"),z(),o}async release(){return this.handler.dispose()}static async create(t,n,i,r){E(),C("InferenceSession.create");let s,o={};if("string"==typeof t){if(s=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,a=0,u=t.byteLength;if("object"==typeof n&&null!==n)o=n;else if("number"==typeof n){if(a=n,!Number.isSafeInteger(a))throw new RangeError("'byteOffset' must be an integer.");if(a<0||a>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-a,"number"==typeof i){if(u=i,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||a+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-a}].`);if("object"==typeof r&&null!==r)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(e,a,u)}}let[u,l]=await a(o),d=await u.createInferenceSessionHandler(s,l);return O("InferenceSession.create"),z(),new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),te=N(()=>{ee(),B=A}),ne=N(()=>{}),ie=N(()=>{}),re=N(()=>{}),ae=N(()=>{}),se={};q(se,{InferenceSession:()=>B,TRACE:()=>I,TRACE_EVENT_BEGIN:()=>C,TRACE_EVENT_END:()=>O,TRACE_FUNC_BEGIN:()=>E,TRACE_FUNC_END:()=>z,Tensor:()=>S,env:()=>l,registerBackend:()=>i});var oe=N(()=>{G(),F(),te(),Y(),ne(),ie(),J(),re(),ae()}),ue=N(()=>{}),le={};q(le,{default:()=>he});var de,pe,he,ce,fe,me,ge,_e,ye,$e,we,be,ve,xe,ke,Se,Ie,Te,Ee,ze,Ce,Oe,Ae,Be,Re,De,Me,Ue,Pe,Ne,qe,Ve,Le,Ge,We,He,Fe,Ke,je,Ze,Qe,Xe,Ye,Je,et,tt,nt,it,rt,at,st,ot,ut,lt,dt,pt,ht,ct,ft,mt,gt,_t,yt,$t,wt,bt,vt,xt,kt,St,It,Tt,Et,zt,Ct,Ot,At,Bt,Rt,Dt,Mt,Ut,Pt,Nt,qt,Vt,Lt,Gt,Wt,Ht,Ft,Kt,jt,Zt,Qt,Xt,Yt,Jt,en,tn,nn,rn,an,sn,on,un,ln,dn,pn,hn,cn,fn,mn,gn,_n,yn,$n,wn,bn,vn,xn,kn,Sn,In,Tn,En,zn,Cn,On,An,Bn,Rn,Dn,Mn,Un,Pn,Nn,qn,Vn,Ln,Gn,Wn,Hn,Fn,Kn,jn,Zn,Qn,Xn,Yn,Jn,ei,ti,ni,ii,ri,ai,si,oi,ui,li,di,pi,hi,ci,fi,mi,gi,_i,yi,$i,wi,bi,vi,xi,ki,Si,Ii,Ti,Ei,zi,Ci,Oi,Ai,Bi,Ri,Di,Mi,Ui,Pi,Ni,qi,Vi,Li,Gi,Wi,Hi,Fi,Ki,ji,Zi,Qi,Xi,Yi,Ji,er,tr,nr,ir,rr,ar,sr,or,ur,lr,dr,pr,hr,cr,fr,mr,gr,_r,yr,$r,wr,br,vr,xr,kr,Sr,Ir,Tr,Er,zr,Cr,Or,Ar,Br,Rr,Dr,Mr,Ur,Pr,Nr,qr,Vr,Lr,Gr,Wr,Hr,Fr,Kr,jr,Zr,Qr,Xr,Yr,Jr,ea,ta,na,ia,ra,aa,sa,oa,ua,la,da,pa,ha,ca,fa,ma,ga,_a,ya,$a,wa,ba,va,xa,ka,Sa,Ia,Ta,Ea,za,Ca,Oa,Aa,Ba,Ra,Da,Ma,Ua,Pa,Na,qa,Va,La,Ga,Wa,Ha,Fa,Ka,ja,Za,Qa,Xa,Ya,Ja,es,ts,ns,is,rs,as,ss,os,us,ls,ds,ps,hs,cs,fs,ms,gs,_s,ys,$s,ws,bs,vs,xs,ks,Ss,Is,Ts,Es,zs,Cs,Os,As,Bs,Rs,Ds,Ms,Us,Ps,Ns,qs,Vs,Ls,Gs,Ws,Hs,Fs,Ks,js,Zs,Qs,Xs,Ys,Js,eo,to,no,io,ro,ao,so,oo,uo,lo,po,ho,co,fo,mo,go,_o,yo,$o,wo,bo,vo,xo,ko,So,Io,To,Eo,zo,Co,Oo,Ao,Bo,Ro,Do,Mo,Uo,Po,No,qo,Vo,Lo,Go,Wo,Ho,Fo,Ko,jo,Zo,Qo,Xo,Yo,Jo,eu,tu,nu,iu,ru,au,su,ou,uu,lu,du,pu,hu,cu,fu,mu,gu,_u,yu,$u,wu,bu,vu,xu,ku,Su,Iu,Tu,Eu,zu,Cu,Ou,Au,Bu,Ru,Du,Mu,Uu,Pu,Nu,qu,Vu,Lu,Gu,Wu,Hu,Fu,Ku=N(()=>{tp(),Zu(),ju(),de="ort-wasm-proxy-worker",(pe=globalThis.self?.name===de)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":Ae(n.wasm).then(()=>{bd(n).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})})},e=>{postMessage({type:t,err:e})});break;case"init-ep":{let{epName:e,env:i}=n;vd(i,e).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})});break}case"copy-from":{let{buffer:e}=n,i=Id(e);postMessage({type:t,out:i});break}case"create":{let{model:e,options:i}=n;Td(e,i).then(e=>{postMessage({type:t,out:e})},e=>{postMessage({type:t,err:e})});break}case"release":Ed(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:i,inputs:r,outputIndices:a,options:s}=n;Cd(e,i,r,a,new Array(a.length).fill(null),s).then(e=>{e.some(e=>"cpu"!==e[3])?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},Ad([...r,...e]))},e=>{postMessage({type:t,err:e})});break}case"end-profiling":Od(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),he=pe?null:e=>new Worker(e??fe,{type:"classic",name:de})}),ju=N(()=>{ue(),ce=typeof location>"u"?void 0:location.origin,fe=typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,me=()=>{if(fe&&!fe.startsWith("blob:"))return fe.substring(0,fe.lastIndexOf("/")+1)},ge=(e,t)=>{try{let n=t??fe;return(n?new URL(e,n):new URL(e)).origin===ce}catch{return!1}},_e=(e,t)=>{let n=t??fe;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},ye=(e,t)=>`${t??"./"}${e}`,$e=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},we=async e=>(await import(e)).default,be=(Ku(),V(le)).default,ve=async()=>{if(!fe)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(ge(fe))return[void 0,be()];let e=await $e(fe);return[e,be(e)]},xe=void 0,ke=async(e,t,n,i)=>{let r=xe;if(r)if(fe)r=ge(fe);else{if(!i||n)throw new Error("cannot determine the script source URL.");r=!0}if(r)return[void 0,xe];{let i="ort-wasm-simd-threaded.jsep.mjs",r=e??_e(i,t),a=n&&r&&!ge(r,t),s=a?await $e(r):r??ye(i,t);return[a?s:void 0,await we(s)]}}}),Zu=N(()=>{ju(),Ie=!1,Te=!1,Ee=!1,ze=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Ce=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Oe=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Ae=async e=>{if(Ie)return Promise.resolve();if(Te)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ee)throw new Error("previous call to 'initializeWebAssembly()' failed.");Te=!0;let t=e.initTimeout,n=e.numThreads;if(!1!==e.simd)if("relaxed"===e.simd){if(!Oe())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!Ce())throw new Error("WebAssembly SIMD is not supported in the current environment.");let i=ze();n>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,a="string"==typeof r?r:void 0,s=r?.mjs,o=s?.href??s,u=r?.wasm,l=u?.href??u,d=e.wasmBinary,[p,h]=await ke(o,a,n>1,!!d||!!l),c=!1,f=[];if(t>0&&f.push(new Promise(e=>{setTimeout(()=>{c=!0,e()},t)})),f.push(new Promise((e,t)=>{let i={numThreads:n};if(d)i.wasmBinary=d;else if(l||a)i.locateFile=e=>l??a+e;else if(o&&0!==o.indexOf("blob:"))i.locateFile=e=>new URL(e,o).href;else if(p){let e=me();e&&(i.locateFile=t=>e+t)}h(i).then(t=>{Te=!1,Ie=!0,Se=t,e(),p&&URL.revokeObjectURL(p)},e=>{Te=!1,Ee=!0,t(e)})})),await Promise.race(f),c)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Be=()=>{if(Ie&&Se)return Se;throw new Error("WebAssembly is not initialized yet.")}}),Qu=N(()=>{Zu(),Re=(e,t)=>{let n=Be(),i=n.lengthBytesUTF8(e)+1,r=n._malloc(i);return n.stringToUTF8(e,r,i),t.push(r),r},De=(e,t,n,i)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([e,r])=>{let a=t?t+e:e;if("object"==typeof r)De(r,a+".",n,i);else if("string"==typeof r||"number"==typeof r)i(a,r.toString());else{if("boolean"!=typeof r)throw new Error("Can't handle extra config type: "+typeof r);i(a,r?"1":"0")}})},Me=e=>{let t=Be(),n=t.stackSave();try{let n=t.PTR_SIZE,i=t.stackAlloc(2*n);t._OrtGetLastError(i,i+n);let r=Number(t.getValue(i,4===n?"i32":"i64")),a=t.getValue(i+n,"*"),s=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(n)}}}),Xu=N(()=>{Zu(),Qu(),Ue=e=>{let t=Be(),n=0,i=[],r=e||{};try{if(void 0===e?.logSeverityLevel)r.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)r.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(r.terminate=!1);let a=0;return void 0!==e?.tag&&(a=Re(e.tag,i)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),0===n&&Me("Can't create run options."),void 0!==e?.extra&&De(e.extra,"",new WeakSet,(e,r)=>{let a=Re(e,i),s=Re(r,i);0!==t._OrtAddRunConfigEntry(n,a,s)&&Me(`Can't set a run config entry: ${e} - ${r}.`)}),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(e=>t._free(e)),e}}}),Yu=N(()=>{Zu(),Qu(),Pe=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ne=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},qe=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(e=>"webgpu"===("string"==typeof e?e:e.name))&&(e.enableMemPattern=!1)},Ve=(e,t,n,i)=>{let r=Re(t,i),a=Re(n,i);0!==Be()._OrtAddSessionConfigEntry(e,r,a)&&Me(`Can't set a session config entry: ${t} - ${n}.`)},Le=async(e,t,n)=>{for(let i of t){let t="string"==typeof i?i:i.name,r=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof i){let t=i?.deviceType;t&&Ve(e,"deviceType",t,n)}break;case"webgpu":if(t="JS","string"!=typeof i){let t=i;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);Ve(e,"preferredLayout",t.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=Re(t,n),s=r.length,o=0,u=0;if(s>0){o=Be()._malloc(s*Be().PTR_SIZE),n.push(o),u=Be()._malloc(s*Be().PTR_SIZE),n.push(u);for(let e=0;e<s;e++)Be().setValue(o+e*Be().PTR_SIZE,r[e][0],"*"),Be().setValue(u+e*Be().PTR_SIZE,r[e][1],"*")}0!==await Be()._OrtAppendExecutionProvider(e,a,o,u,s)&&Me(`Can't append execution provider: ${t}.`)}},Ge=async e=>{let t=Be(),n=0,i=[],r=e||{};qe(r);try{let e=Pe(r.graphOptimizationLevel??"all"),a=Ne(r.executionMode??"sequential"),s="string"==typeof r.logId?Re(r.logId,i):0,o=r.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log severity level is not valid: ${o}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof r.optimizedModelFilePath?Re(r.optimizedModelFilePath,i):0;if(n=t._OrtCreateSessionOptions(e,!!r.enableCpuMemArena,!!r.enableMemPattern,a,!!r.enableProfiling,0,s,o,u,l),0===n&&Me("Can't create session options."),r.executionProviders&&await Le(n,r.executionProviders,i),void 0!==r.enableGraphCapture){if("boolean"!=typeof r.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);Ve(n,"enableGraphCapture",r.enableGraphCapture.toString(),i)}if(r.freeDimensionOverrides)for(let[e,a]of Object.entries(r.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof a||!Number.isInteger(a)||a<0)throw new Error(`free dimension override value must be a non-negative integer: ${a}`);let r=Re(e,i);0!==t._OrtAddFreeDimensionOverride(n,r,a)&&Me(`Can't set a free dimension override: ${e} - ${a}.`)}return void 0!==r.extra&&De(r.extra,"",new WeakSet,(e,t)=>{Ve(n,e,t,i)}),[n,i]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&Me("Can't release session options."),i.forEach(e=>t._free(e)),e}}}),Ju=N(()=>{We=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},He=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Fe=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],i="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return n>0?Math.ceil(i*n):void 0},Ke=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},je=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ze=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Qe=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Xe=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),el=N(()=>{ue(),Ye=async e=>{if("string"==typeof e){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),i=n?parseInt(n,10):0;if(i<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,r=t.body.getReader();try{n=new ArrayBuffer(i)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(i/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let a=0;for(;;){let{done:e,value:t}=await r.read();if(e)break;let i=t.byteLength;new Uint8Array(n,a,i).set(t),a+=i}return new Uint8Array(n,0,i)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),tl=N(()=>{Ju(),Je=["V","I","W","E","F"],et=(e,t)=>{console.log(`[${Je[e]},${(new Date).toISOString()}]${t}`)},it=(e,t)=>{tt=e,nt=t},rt=(e,t)=>{let n=je(e);n>=je(tt)&&et(n,"function"==typeof t?t():t)},at=(...e)=>{nt&&rt(...e)}}),nl=N(()=>{st=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},ot=class{static calcShape(e,t,n=!1){let i=e.length,r=t.length;if(0===i)return t;if(0===r)return e;let a=Math.max(e.length,t.length),s=new Array(a);if(n){if(i<2||r<2)return;let n=st.calcMatMulShape([e[i-2],e[i-1]],[t[r-2],t[r-1]]);if(void 0===n)return;[s[a-2],s[a-1]]=n}for(let o=n?3:1;o<=a;o++){let n=i-o<0?1:e[i-o],u=r-o<0?1:t[r-o];if(n!==u&&n>1&&u>1)return;let l=Math.max(n,u);if(n&&u)s[a-o]=Math.max(n,u);else{if(l>1)return;s[a-o]=0}}return s}static isValidBroadcast(e,t){let n=e.length,i=t.length;if(n>i)return!1;for(let r=1;r<=n;r++)if(1!==e[n-r]&&e[n-r]!==t[i-r])return!1;return!0}},ut=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let i=new Array(n),r=n-1;for(;r>=0;){if(e[r]%t===0){i[r]=e[r]/t;break}if(t%e[r]!==0)throw new Error("cannot convert shape");i[r]=1,t/=e[r],r--}for(r--;r>=0;r--)i[r]=e[r];return i}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let i=1;for(let r=t;r<n;r++){if(e[r]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=Number(e[r])}return i}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let i=t-3;i>=0;--i)n[i]=n[i+1]*e[i+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(n=>this.normalizeAxis(n,t??e.length))}static sortBasedOnPerm(e,t){return t?t.map(t=>e[t]):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map((e,i)=>e+t[i]+t[i+n])}static areEqual(e,t){return e.length===t.length&&e.every((e,n)=>e===t[n])}},lt=class e{static adjustPoolAttributes(e,t,n,i,r,a){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("dilations should be greater than or equal to 1")}else r.push(1);for(let e=0;e<2*n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[e]>=n[e]||a[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,i,r,a,s,o){if(o){if(a.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(s?1:2)],n[u],i[u],r[u],a,u,u+t.length-2,o)}}static computePoolOutputShape(t,n,i,r,a,s,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return e.computeShapeHelper(t,n,u,i,r,a,s,o),u}static computeConvOutputShape(t,n,i,r,a,s,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return e.computeShapeHelper(!1,t,u,i,r,a,s,o),u}static computeShapeHelper(t,n,i,r,a,s,o,u){if(t)for(let e=0;e<n.length-2;e++)i.push(1);else for(let t=0;t<n.length-2;t++)i.push(e.adjustPadAndReturnShape(n[t+2],r[t],a[t],s[t],o,t,t+n.length-2,u))}static adjustPadAndReturnShape(e,t,n,i,r,a,s,o){let u=n*(i-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+r[a]+r[s]-u)/t+1);switch(o){case"VALID":return r[a]=0,r[s]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+i-e;return r[a]=Math.floor("SAME_LOWER"===o?(n+1)/2:n/2),r[s]=n-r[a],Math.floor((e+n-i)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},dt=class{static getShapeOfGemmResult(e,t,n,i,r){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,s,o;t?(a=e[1],s=e[0]):(a=e[0],s=e[1]);let u=-1;if(i?(o=n[0],u=1):(o=n[1],u=0),n[u]!==s)throw new Error("dimension mismatch");if(a<=0||o<=0||s<=0)throw new Error("invalid shape specified");if(r&&!ot.isValidBroadcast(r,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,s]}},pt=-34028234663852886e22,ht=34028234663852886e22}),il=N(()=>{Ju(),ct=(e,t)=>new(Ke(t))(e)}),rl=N(()=>{Ju(),tl(),ft=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),mt=(e,t)=>{if("int32"===t)return e;let n=ft.get(t);if(!n)throw new Error(`WebNN backend does not support data type: ${t}`);let i=n/8;if(e.byteLength%i!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${i}.`);let r=e.byteLength/i,a=new(Ke(t))(e.buffer,e.byteOffset,r);switch(t){case"int64":case"uint64":{let e=new Int32Array(r);for(let t=0;t<r;t++){let n=a[t];if(n>2147483647n||n<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");e[t]=Number(n)}return new Uint8Array(e.buffer)}case"int8":case"uint8":case"uint32":{if("uint32"===t&&a.some(e=>e>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let e=Int32Array.from(a,Number);return new Uint8Array(e.buffer)}default:throw new Error(`Unsupported data conversion from ${t} to 'int32'`)}},gt=(e,t)=>{if("int32"===t)return e;if(e.byteLength%4!=0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let n=e.byteLength/4,i=new Int32Array(e.buffer,e.byteOffset,n);switch(t){case"int64":{let e=BigInt64Array.from(i,BigInt);return new Uint8Array(e.buffer)}case"uint64":{if(i.some(e=>e<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let e=BigUint64Array.from(i,BigInt);return new Uint8Array(e.buffer)}case"int8":{if(i.some(e=>e<-128||e>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let e=Int8Array.from(i,Number);return new Uint8Array(e.buffer)}case"uint8":if(i.some(e=>e<0||e>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(i,Number);case"uint32":{if(i.some(e=>e<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let e=Uint32Array.from(i,Number);return new Uint8Array(e.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${t}`)}},_t=1,yt=()=>_t++,$t=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),wt=(e,t)=>{let n=ft.get(e);if(!n)throw new Error(`WebNN backend does not support data type: ${e}`);return t.length>0?Math.ceil(t.reduce((e,t)=>e*t)*n/8):0},bt=class{constructor(e){this.isDataConverted=!1;let{sessionId:t,context:n,tensor:i,dataType:r,shape:a,fallbackDataType:s}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=i,this.dataType=r,this.tensorShape=a,this.fallbackDataType=s}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return wt(this.dataType,this.tensorShape)}destroy(){at("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(this.fallbackDataType){let t=await this.mlContext.readTensor(this.mlTensor),n=gt(new Uint8Array(t),this.dataType);return e?void(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(n):n.buffer}return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((e,t)=>e===n[t])}setIsDataConverted(e){this.isDataConverted=e}},vt=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,i){let r,a=this.tensorManager.getMLContext(e);if(!a.opSupportLimits().input.dataTypes.includes(t)){if(r=$t.get(t),!r||!a.opSupportLimits().input.dataTypes.includes(r))throw new Error(`WebNN backend does not support data type: ${t}`);at("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${t} to ${r}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(a,t,n))return this.wrapper.tensor;if(i){if(this.wrapper.byteLength!==wt(t,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let s=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,n,s,!0,!0,r),i&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper){if(this.wrapper.fallbackType){if("int32"!==this.wrapper.fallbackType)throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);t=mt(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0)}if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(t);at("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){if(this.activeUpload){let t=this.wrapper?.isDataConverted?gt(this.activeUpload,this.wrapper?.type):this.activeUpload;return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(t):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t)):t.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},xt=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=yt();return this.tensorTrackersById.set(e,new vt(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,i,r){at("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${i}, copyOld: ${r}}`);let a=this.tensorTrackersById.get(t);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(e,n,i,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){at("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,i){let r=this.getMLContext(e),a=yt(),s=new bt({sessionId:e,context:r,tensor:t,dataType:n,shape:i});return this.tensorTrackersById.set(a,new vt(this,s)),this.externalTensors.add(s),a}async getCachedTensor(e,t,n,i,r,a,s){let o=this.getMLContext(e);for(let[i,r]of this.freeTensors.entries())if(r.canReuseTensor(o,t,n)){at("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, ${s?`fallbackDataType: ${s},`:""} shape: ${n}`);let r=this.freeTensors.splice(i,1)[0];return r.sessionId=e,r}at("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, ${s?`fallbackDataType: ${s},`:""} shape: ${n}}`);let u=await o.createTensor({dataType:s??t,shape:n,dimensions:n,usage:i,writable:r,readable:a});return new bt({sessionId:e,context:o,tensor:u,dataType:t,shape:n,fallbackDataType:s})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},kt=(...e)=>new xt(...e)}),al=N(()=>{Ju(),Zu(),il(),rl(),tl(),St=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),It=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),i=Object.keys(t).sort();return n.length===i.length&&n.every((n,r)=>n===i[r]&&e[n]===t[n])},Tt=class{constructor(e){this.tensorManager=kt(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,it(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){at("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){at("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let e of t)at("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex(t=>t.gpuDevice===e);if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex(e=>void 0===e.options&&void 0===e.gpuDevice);if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex(t=>It(t.options,e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex(e=>e.mlContext===t);-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){at("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,i,r){let a=St.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,a,i,r)}async createTemporaryTensor(e,t,n){at("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let i=St.get(t);if(!i)throw new Error(`Unsupported ONNX data type: ${t}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,r,i,n,!1);let a=this.temporarySessionTensorIds.get(e);return a?a.push(r):this.temporarySessionTensorIds.set(e,[r]),r}uploadTensor(e,t){if(!Be().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");at("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return ct(n,t)}}registerMLTensor(e,t,n,i){let r=St.get(n);if(!r)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.registerTensor(e,t,r,i);return at("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${r}, dimensions: ${i}} -> {tensorId: ${a}}`),a}registerMLConstant(e,t,n,i,r,a,s=!1){if(!a)throw new Error("External mounted files are not available.");let o=e;e.startsWith("./")&&(o=e.substring(2));let u=a.get(o);if(!u)throw new Error(`File with name ${o} not found in preloaded files.`);if(t+n>u.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,d=u.slice(t,t+n).buffer;switch(r.dataType){case"float32":l=new Float32Array(d);break;case"float16":l=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":l=new Int32Array(d);break;case"uint32":l=new Uint32Array(d);break;case"int64":if(s){let e=mt(new Uint8Array(d),"int64");l=new Int32Array(e.buffer),r.dataType="int32"}else l=new BigInt64Array(d);break;case"uint64":l=new BigUint64Array(d);break;case"int8":l=new Int8Array(d);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return at("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}} ${s?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),i.constant(r,l)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return!!n&&n.includes(t)}isGraphOutput(e,t){let n=this.sessionGraphOutputs.get(e);return!!n&&n.includes(t)}isGraphInputOutputTypeSupported(e,t,n=!0){let i=this.mlContextBySessionId.get(e),r=St.get(We(t));return!(typeof r>"u"||(n?!i?.opSupportLimits().input.dataTypes.includes(r):!i?.opSupportLimits().output.dataTypes.includes(r)))}flush(){}}}),sl=N(()=>{}),ol=N(()=>{tl(),sl(),Et=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),zt=[],Ct=e=>16*Math.ceil(Number(e)/16),Ot=e=>{for(let t=0;t<zt.length;t++){let n=zt[t];if(e<=n)return n}return 16*Math.ceil(e/16)},At=1,Bt=()=>At++,Rt=async(e,t,n,i)=>{let r=Ct(n),a=e.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,a,0,r),e.flush(),await a.mapAsync(GPUMapMode.READ);let o=a.getMappedRange();if(i){let e=i();return e.set(new Uint8Array(o,0,n)),e}return new Uint8Array(o.slice(0,n))}finally{a.destroy()}},Dt=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Et)zt.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,i=t.byteOffset,r=t.byteLength,a=Ct(r),s=this.storageCache.get(e);if(!s)throw new Error("gpu data for uploading does not exist");if(Number(s.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${s.originalSize}, data size=${r}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=o.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,i,r)),o.unmap();let l=this.backend.device.createCommandEncoder();l.copyBufferToBuffer(o,0,s.gpuData.buffer,0,a),this.backend.device.queue.submit([l.finish()]),o.destroy(),at("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(t);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=Ct(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,i.gpuData.buffer,0,r)}registerExternalBuffer(e,t,n){let i;if(n){if(i=n[0],e===n[1])return at("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!")}else i=Bt();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:e},originalSize:t}),at("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${i}, registered.`),i}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),at("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,i=Ot(e),r=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||a){let e=(r?this.freeBuffers:this.freeUniformBuffers).get(i);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:i,usage:t})}else n=this.backend.device.createBuffer({size:i,usage:t});let s={id:Bt(),type:0,buffer:n};return this.storageCache.set(s.id,{gpuData:s,originalSize:Number(e)}),at("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${s.id}`),s}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return at("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Rt(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=Et.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(e=>{e.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(at("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Mt=(...e)=>new Dt(...e)}),ul=N(()=>{Ut=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},Pt=e=>new Ut(e)}),ll=N(()=>{Ju(),nl(),Nt=64,qt=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},Vt=(e,t=1)=>{let n=qt(e,t);return"string"==typeof n?n:n[0]},Lt=(e,t=1)=>{let n=qt(e,t);return"string"==typeof n?n:n[1]},Gt=(...e)=>{let t=[];return e.forEach(e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:ut.computeStrides(e)})}),t},Wt=e=>e%4==0?4:e%2==0?2:1,Ht=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,Ft=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,Kt=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,jt=(e,t,n,i)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===i?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===i?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Zt=(e,t,n,i,r)=>{let a="number"==typeof n,s=a?n:n.length,o=[...new Array(s).keys()],u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,l=qt(t,r),d="string"==typeof l?l:l[1],p="string"==typeof l?l:l[0],h={indices:u,value:d,storage:p,tensor:t},c=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=a?"uniforms.":"",g=`${m}${e}_shape`,_=`${m}${e}_strides`,y="";for(let e=0;e<s-1;e++)y+=`\n    let dim${e} = current / ${jt(_,e,s)};\n    let rest${e} = current % ${jt(_,e,s)};\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;y+=`indices[${s-1}] = current;`;let $=s<2?"":`\n  fn o2i_${e}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${y}\n    return indices;\n  }`,w=[];if(s>=2)for(let e=s-1;e>=0;e--)w.push(`${jt(_,e,s)} * (indices[${e}])`);let b=s<2?"":`\n  fn i2o_${e}(indices: ${h.indices}) -> u32 {\n    return ${w.join("+")};\n  }`,v=(...e)=>0===s?"0u":`${h.indices}(${e.map(c).join(",")})`,x=(e,t)=>s<2?`${e}`:`${jt(e,t,s)}`,k={},S=(t,n)=>(()=>{if(h.storage===h.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===h.storage&&"i32"===h.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===h.storage&&"u32"===h.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===h.storage&&"vec4<bool>"===h.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),I=t=>(()=>{if(h.storage===h.value)return`${e}[${t}]`;if("vec2<u32>"===h.storage&&"i32"===h.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===h.storage&&"u32"===h.value)return`u32(${e}[${t}].x)`;if("u32"===h.storage&&"vec4<bool>"===h.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),T=s<2?"":`\n  fn get_${e}ByIndices(indices: ${h.indices}) -> ${d} {\n    return ${I(`i2o_${e}(indices)`)};\n  }`,E=s<2?"":(()=>{let t=o.map(e=>`d${e}: u32`).join(", "),n=o.map(e=>`d${e}`).join(", ");return`\n  fn get_${e}(${t}) -> ${d} {\n    return get_${e}ByIndices(${v(n)});\n  }`})(),z=s<2?"":`\n  fn set_${e}ByIndices(indices: ${h.indices}, value: ${d}) {\n    ${S(`i2o_${e}(indices)`,"value")}\n  }`,C=s<2?"":(()=>{let t=o.map(e=>`d${e}: u32`).join(", "),n=o.map(e=>`d${e}`).join(", ");return`\n  fn set_${e}(${t}, value: ${d}) {\n    set_${e}ByIndices(${v(n)}, value);\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push($),t=!0),f.indicesToOffset&&(e.push(b),t=!0),f.broadcastedIndicesToOffset&&(Object.values(k).forEach(t=>e.push(t)),t=!0),f.set&&(e.push(C),t=!0),f.setByIndices&&(e.push(z),t=!0),f.get&&(e.push(E),t=!0),f.getByIndices&&(e.push(T),t=!0),!a&&t&&e.unshift(`const ${g} = ${h.indices}(${n.join(",")});`,`const ${_} = ${h.indices}(${ut.computeStrides(n).join(",")});`),e.join("\n")},type:h,offsetToIndices:t=>(f.offsetToIndices=!0,s<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,s<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let i=`${n.name}broadcastedIndicesTo${e}Offset`;if(i in k)return`${i}(${t})`;let r=[];for(let e=s-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-s);r.push(`${x(_,e)} * (${t} % ${x(g,e)})`)}return k[i]=`fn ${i}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${r.length>0?r.join("+"):"0u"};\n           }`,`${i}(${t})`},indices:v,indicesGet:x,indicesSet:(e,t,n)=>s<2?`${e}=${n};`:`${jt(e,t,s)}=${n};`,set:(...t)=>{if(t.length!==s+1)throw new Error(`indices length must be ${s}`);let n=t[s];if("string"!=typeof n)throw new Error("value must be string");let i=t.slice(0,s).map(c).join(",");return 0===s?S("0u",n):1===s?S(i[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${i}, ${n})`)},setByOffset:S,setByIndices:(t,n)=>s<2?S(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==s)throw new Error(`indices length must be ${s}`);let n=t.map(c).join(",");return 0===s?I("0u"):1===s?I(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:I,getByIndices:t=>s<2?I(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:i,name:e,strides:_,shape:g,rank:s}},Qt=(e,t,n,i=1)=>Zt(e,t,n,"input",i),Xt=(e,t,n,i=1)=>Zt(e,t,n,"output",i),Yt=(e,t,n)=>Zt(e,t,n,"atomicOutput",1),Jt=(e,t,n,i=1)=>Zt(e,t,n,"internal",i),en=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=Nt){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],i="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${i})\n  fn main(${r?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${r?"let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${t*n*i}u + local_idx;`}\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",i="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${i}>;`}declareVariables(...e){return e.map(e=>this.declareVariable(e,this.variableIndex++)).join("\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:i}of this.uniforms)if(i&&i>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(i/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(i/4)}>`);else{let r=null==i||1===i?n:`vec${i}<${n}>`;e.push(`${t}:${r}`)}return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join("\n")+this.internalVariables.map(e=>e.impl()).join("\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},tn=(e,t)=>new en(e,t)}),dl=N(()=>{Ju(),nl(),ul(),ll(),nn=(e,t)=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(0!==t.length&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},rn=(e,t)=>0!==t.length?t:[...new Array(e).keys()].reverse(),an=(e,t)=>ut.sortBasedOnPerm(e,rn(e.length,t)),sn=(e,t,n,i)=>{let r=`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)r+=`a[${e[n]}]=i[${n}];`;return r+"return a;}"},on=(e,t)=>{let n=[],i=[];for(let r=0;r<e.length;++r)1!==e[r]&&n.push(e[r]),1!==e[t[r]]&&i.push(t[r]);return{newShape:n,newPerm:i}},un=(e,t)=>{let n=0;for(let i=0;i<e.length;++i)if(1!==t[e[i]]){if(e[i]<n)return!1;n=e[i]}return!0},ln=(e,t)=>{let n,i=e.dataType,r=e.dims.length,a=rn(r,t),s=an(e.dims,a),o=e.dims,u=s;if(r<2||un(a,e.dims))return n=e=>{let t=Qt("input",i,o,4),n=Xt("output",i,u,4);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    output[global_idx] = input[global_idx];\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=ut.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:l,newPerm:d}=on(e.dims,a),p=ut.areEqual(d,[2,3,1]),h=ut.areEqual(d,[3,1,2]);if(2===l.length||p||h){o=p?[l[0],l[1]*l[2]]:h?[l[0]*l[1],l[2]]:l,u=[o[1],o[0]];let t=16;return n=e=>{let n=Qt("a",i,o.length),r=Xt("output",i,u.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(n,r)}\n  var<workgroup> tile : array<array<${r.type.value}, ${t+1}>, ${t}>;\n  ${e.mainStart([t,t,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${r.setByIndices(`${r.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\n    }\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=ut.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(u[1]/t),y:Math.ceil(u[0]/t)},programUniforms:[{type:12,data:n},...Gt(o,u)]}},getShaderSource:n}}return n=e=>{let t=Qt("a",i,o.length),n=Xt("output",i,u.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n\n  ${sn(a,r,t,n)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${n.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=ut.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...Gt(o,u)]}},getShaderSource:n}},dn=(e,t)=>{nn(e.inputs,t.perm),e.compute(ln(e.inputs[0],t.perm))},pn=e=>Pt({perm:e.perm})}),pl=N(()=>{Ju(),nl(),ll(),hl(),dl(),hn={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},cn={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},fn={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},mn={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},gn=(e,t)=>{let n=[];for(let i=t-e;i<t;++i)n.push(i);return n},_n=(e,t)=>{let n=[],i=e.length;for(let r=0;r<i;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map(t=>e[t])]},yn=(e,t)=>{let n=e.length+t.length,i=[],r=0;for(let a=0;a<n;a++)-1===t.indexOf(a)?i.push(e[r++]):i.push(1);return i},$n=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},wn=(e,t)=>{let n=[];if(!$n(e,t)){for(let i=0;i<t;++i)-1===e.indexOf(i)&&n.push(i);e.forEach(e=>n.push(e))}return n},bn=(e,t,n,i,r,a,s)=>{let o=n[0].dims,u=ut.size(a),l=ut.size(s),d=Qt("_A",n[0].dataType,o),p=Xt("output",r,a),h=64;1===u&&(h=256);let c=`\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:["type"]},getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,p)}\n        ${c}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${fn[i]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${d.getByOffset("offset + k")});\n           bestValue = ${hn[i]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${cn[i]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${p.setByOffset("outputIndex","mean"===i?`${p.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${p.type.storage}(${mn[i]})`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:u},programUniforms:[{type:12,data:l}]})}},vn=(e,t,n,i)=>{let r=1===e.inputs.length?n:Mn(e.inputs,n),a=r.axes;0===a.length&&!r.noopWithEmptyAxes&&(a=e.inputs[0].dims.map((e,t)=>t));let s=ut.normalizeAxes(a,e.inputs[0].dims.length),o=s,u=e.inputs[0],l=wn(o,e.inputs[0].dims.length);l.length>0&&(u=e.compute(ln(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],o=gn(o.length,u.dims.length));let[d,p]=_n(u.dims,o),h=d;r.keepDims&&(h=yn(d,s)),e.compute(bn(t,r.cacheKey,[u],i,e.inputs[0].dataType,h,p),{inputs:[u]})},xn=(e,t)=>{vn(e,"ReduceMeanShared",t,"mean")},kn=(e,t)=>{vn(e,"ReduceL1Shared",t,"l1")},Sn=(e,t)=>{vn(e,"ReduceL2Shared",t,"l2")},In=(e,t)=>{vn(e,"ReduceLogSumExpShared",t,"logSumExp")},Tn=(e,t)=>{vn(e,"ReduceMaxShared",t,"max")},En=(e,t)=>{vn(e,"ReduceMinShared",t,"min")},zn=(e,t)=>{vn(e,"ReduceProdShared",t,"prod")},Cn=(e,t)=>{vn(e,"ReduceSumShared",t,"sum")},On=(e,t)=>{vn(e,"ReduceSumSquareShared",t,"sumSquare")},An=(e,t)=>{vn(e,"ReduceLogSumShared",t,"logSum")}}),hl=N(()=>{Ju(),nl(),ul(),ll(),pl(),Bn=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},Rn=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Dn=(e,t,n,i,r,a,s=!1,o=!1)=>{let u=[],l=n[0].dims,d=l.length,p=ut.normalizeAxes(r,d),h=!o&&0===p.length;l.forEach((e,t)=>{h||p.indexOf(t)>=0?s&&u.push(1):u.push(e)});let c=u.length,f=ut.size(u);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],r=Qt("_A",n[0].dataType,d),o=Xt("output",a,c),u=i(r,o,p),f=u[2];for(let e=0,n=0;e<d;e++)h||p.indexOf(e)>=0?(s&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${l[e]}; j${e}++) {\n                  ${u[2].includes("last_index")?`let last_index = j${e};`:""}\n                  ${r.indicesSet("input_indices",e,`j${e}`)}\n                  ${f}\n                }`):(t.push(`${r.indicesSet("input_indices",e,o.indicesGet("output_indices",n))};`),n++);return`\n\n        ${e.registerUniform("output_size","u32").declareVariables(r,o)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${r.type.indices};\n          let output_indices = ${o.offsetToIndices("global_idx")};\n\n          ${t.join("\n")}\n          ${u[0]}       // init ops for reduce max/min\n          ${u[1]}\n          ${f}\n          ${u[3]}\n          ${4===u.length?o.setByOffset("global_idx","value"):u.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Gt(l,u)]})}},Mn=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(e=>n.push(Number(e))),Pt({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Un=(e,t,n,i)=>{let r=e.inputs,a=1===r.length?n:Mn(r,n);e.compute(Dn(t,{hint:a.cacheKey,inputDependencies:["rank"]},[r[0]],a.noopWithEmptyAxes&&0===a.axes.length?Rn:i,a.axes,r[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},Pn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceLogSum",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"])},Nn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceL1",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""])},qn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceL2",t,(e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Vn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceLogSumExp",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"])},Ln=(e,t)=>{Bn(e.inputs),Un(e,"ReduceMax",t,(e,t,n)=>{let i=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&i.push(e.indicesSet("input_indices",t,0));return[`${i.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]})},Gn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceMean",t,(t,n,i)=>{let r=1;for(let n=0;n<t.rank;n++)(i.indexOf(n)>=0||0===i.length)&&(r*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${r});`]})},Wn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceMin",t,(e,t,n)=>{let i=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&i.push(`input_indices[${t}] = 0;`);return[`${i.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]})},Hn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceProd",t,(e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""])},Fn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceSum",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""])},Kn=(e,t)=>{Bn(e.inputs),Un(e,"ReduceSumSquare",t,(e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""])},jn=(e,t,n)=>{if(0===t.length)return n;let i=1,r=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?i*=e[n]:r*=e[n];return r<32&&i>1024},Zn=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Gn(e,t):xn(e,t)},Qn=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nn(e,t):kn(e,t)},Xn=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?qn(e,t):Sn(e,t)},Yn=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Vn(e,t):In(e,t)},Jn=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ln(e,t):Tn(e,t)},ei=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Wn(e,t):En(e,t)},ti=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hn(e,t):zn(e,t)},ni=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fn(e,t):Cn(e,t)},ii=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kn(e,t):On(e,t)},ri=(e,t)=>{jn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pn(e,t):An(e,t)}}),cl=N(()=>{Ju(),ul(),hl(),ai=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},si=(e,t)=>{ai(e.inputs),e.compute(Dn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],(e,n,i)=>{let r=[];for(let t=0;t<e.rank;t++)(i.indexOf(t)>=0||0===i.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]},[t.axis],7,t.keepDims),{inputs:[0]})},oi=(e,t)=>{ai(e.inputs),e.compute(Dn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],(e,n,i)=>{let r=[];for(let t=0;t<e.rank;t++)(i.indexOf(t)>=0||0===i.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]},[t.axis],7,t.keepDims),{inputs:[0]})},ui=e=>Pt(e)}),fl=N(()=>{Ju(),nl(),sl(),ll(),li=(e,t)=>{let n=e[0],i=e[1],r=e[2],a=e[3],s=e[4],o=e[5];if(s&&o)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error('Input "input" must have 3 dimensions');let u=n.dims[0],l=n.dims[1],d=n.dims[2];if(1!==r.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==i.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let p=r.dims[0]/3,h=p,c=h;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");p=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],c=t.qkvHiddenSizes[2]}let f=l;if(p!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==p+h+c)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let m=0;if(s){if(h!==c)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==s.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==s.dims[0])throw new Error('Input "past" first dimension must be 2');if(s.dims[1]!==u)throw new Error('Input "past" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(s.dims[4]!==h/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(m=s.dims[3])}let g=f+m;if(a)throw new Error("Mask not supported");if(s)throw new Error("past is not supported");if(o){if(4!==o.dims.length)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==u||o.dims[1]!==t.numHeads||o.dims[2]!==l||o.dims[3]!==g)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:u,sequenceLength:l,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:g,maxSequenceLength:-1,inputHiddenSize:d,hiddenSize:p,vHiddenSize:c,headSize:Math.floor(p/t.numHeads),vHeadSize:Math.floor(c/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},di=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\n    let present_sequence_length = total_sequence_length;\n    `,pi=(e,t,n,i,r,a,s,o)=>{let u=Wt(s?1:a),l=64,d=a/u;d<l&&(l=32);let p=Math.ceil(a/u/l),h=[{type:12,data:t},{type:12,data:n},{type:12,data:i},{type:12,data:r},{type:12,data:d},{type:12,data:p}],c=Vt(e.dataType,u),f=Lt(1,u),m=["type"];return s&&m.push("type"),o&&m.push("type"),{name:"AttentionProbsSoftmax",shaderCache:{hint:`${l};${c};${u}`,inputDependencies:m},getShaderSource:t=>{let n=Xt("x",e.dataType,e.dims,u),i=[n],r=s?Qt("seq_lens",s.dataType,s.dims):void 0;r&&i.push(r);let a=o?Qt("total_sequence_length_input",o.dataType,o.dims):void 0;a&&i.push(a);let d=Lt(e.dataType);return`\n  var<workgroup> thread_max: array<f32, ${l}>;\n  var<workgroup> thread_sum: array<f32, ${l}>;\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...i)}\n  ${t.mainStart([l,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${di(r,a,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${l}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${s?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\n    var thread_max_vector = ${f}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(u){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${u}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${l}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${f}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(u){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${u}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${l}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${n.type.value}(${d}(1.0) / ${d}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${f}(x[offset + i]);\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${s?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${n.type.value}(${d}(0));\n        }`:""};\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:r,z:t*n},programUniforms:h})}},hi=(e,t,n,i,r,a,s,o,u)=>{let l=s+a.kvSequenceLength,d=[a.batchSize,a.numHeads,a.sequenceLength,l],p=e>1&&i,h=a.kvNumHeads?a.kvNumHeads:a.numHeads,c=p?[a.batchSize,h,l,a.headSize]:void 0,f=a.nReps?a.nReps:1,m=0===a.scale?1/Math.sqrt(a.headSize):a.scale,g=Wt(a.headSize),_=a.headSize/g,y={x:Math.ceil(l/12),y:Math.ceil(a.sequenceLength/12),z:a.batchSize*a.numHeads},$=[{type:12,data:a.sequenceLength},{type:12,data:_},{type:12,data:l},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:m},{type:12,data:s},{type:12,data:a.kvSequenceLength},{type:12,data:f}],w=p&&i&&ut.size(i.dims)>0,b=["type","type"];w&&b.push("type"),r&&b.push("type"),o&&b.push("type"),u&&b.push("type");let v=[{dims:d,dataType:t.dataType,gpuDataType:0}];return p&&v.push({dims:c,dataType:t.dataType,gpuDataType:0}),{name:"AttentionProbs",shaderCache:{hint:`${g};${void 0!==r};${void 0!==i};${e}`,inputDependencies:b},getRunData:()=>({outputs:v,dispatchGroup:y,programUniforms:$}),getShaderSource:e=>{let a=Qt("q",t.dataType,t.dims,g),s=[a,Qt("key",n.dataType,n.dims,g)];if(w){let e=Qt("past_key",i.dataType,i.dims,g);s.push(e)}r&&s.push(Qt("attention_bias",r.dataType,r.dims));let l=o?Qt("seq_lens",o.dataType,o.dims):void 0;l&&s.push(l);let h=u?Qt("total_sequence_length_input",u.dataType,u.dims):void 0;h&&s.push(h);let m=Xt("output",t.dataType,d),_=[m];p&&_.push(Xt("present_key",t.dataType,c,g));let y=Lt(1,g);return`\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${a.type.storage}, 144>;\n  var<workgroup> tileK: array<${a.type.storage}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...s,..._)}\n  ${e.mainStart([12,12,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${di(l,h,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${w&&p?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${p?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\n    var value = ${y}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${w&&p?"\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }":"\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }"}\n      ${p?"if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }":""}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(g){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${g}`)}})()};\n        output[outputIdx] = ${m.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};\n    }\n  }`}}},ci=(e,t,n,i,r,a,s=void 0,o=void 0)=>{let u=a+r.kvSequenceLength,l=r.nReps?r.nReps:1,d=r.vHiddenSize*l,p=e>1&&i,h=r.kvNumHeads?r.kvNumHeads:r.numHeads,c=p?[r.batchSize,h,u,r.headSize]:void 0,f=[r.batchSize,r.sequenceLength,d],m={x:Math.ceil(r.vHeadSize/12),y:Math.ceil(r.sequenceLength/12),z:r.batchSize*r.numHeads},g=[{type:12,data:r.sequenceLength},{type:12,data:u},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:d},{type:12,data:a},{type:12,data:r.kvSequenceLength},{type:12,data:l}],_=p&&i&&ut.size(i.dims)>0,y=["type","type"];_&&y.push("type"),s&&y.push("type"),o&&y.push("type");let $=[{dims:f,dataType:t.dataType,gpuDataType:0}];return p&&$.push({dims:c,dataType:t.dataType,gpuDataType:0}),{name:"AttentionScore",shaderCache:{hint:`${void 0!==i};${e}`,inputDependencies:y},getRunData:()=>({outputs:$,dispatchGroup:m,programUniforms:g}),getShaderSource:e=>{let r=Qt("probs",t.dataType,t.dims),a=[r,Qt("v",n.dataType,n.dims)];_&&a.push(Qt("past_value",i.dataType,i.dims));let u=s?Qt("seq_lens",s.dataType,s.dims):void 0;s&&a.push(u);let d=o?Qt("total_sequence_length_input",o.dataType,o.dims):void 0;o&&a.push(d);let h=[Xt("output",t.dataType,f)];return p&&h.push(Xt("present_value",t.dataType,c)),`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${r.type.value}, 144>;\n  var<workgroup> tileV: array<${r.type.value}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...h)}\n  ${e.mainStart([12,12,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${1===l?"headIdx":"headIdx / uniforms.n_reps"};\n   let kv_num_heads = ${1===l?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${di(u,d,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${_&&p?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${p?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\n   var value = ${r.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${_&&p?"\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      ":"\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }"}\n        ${p?"\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }":""}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},fi=(e,t,n,i,r,a,s,o,u,l,d=void 0,p=void 0)=>{let h=Math.min(e.outputCount,1+(s?1:0)+(o?1:0)),c=h>1?l.pastSequenceLength:0,f=c+l.kvSequenceLength,m=u&&ut.size(u.dims)>0?u:void 0,g=[t,n];h>1&&s&&ut.size(s.dims)>0&&g.push(s),m&&g.push(m),d&&g.push(d),p&&g.push(p);let _=e.compute(hi(h,t,n,s,m,l,c,d,p),{inputs:g,outputs:h>1?[-1,1]:[-1]})[0];e.compute(pi(_,l.batchSize,l.numHeads,c,l.sequenceLength,f,d,p),{inputs:d&&p?[_,d,p]:[_],outputs:[]});let y=[_,i];h>1&&o&&ut.size(o.dims)>0&&y.push(o),d&&y.push(d),p&&y.push(p),e.compute(ci(h,_,i,o,l,c,d,p),{inputs:y,outputs:h>1?[0,2]:[0]})},mi=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],i=t.sequenceLength,r=t.inputHiddenSize,a=t.headSize,s={x:Math.ceil(t.headSize/12),y:Math.ceil(t.sequenceLength/12),z:t.batchSize*t.numHeads},o=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:i},{type:12,data:r},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:s,programUniforms:u}),getShaderSource:e=>{let t=Xt("output_q",o[0].dataType,n),i=Xt("output_k",o[0].dataType,n),r=Xt("output_v",o[0].dataType,n),a=Qt("input",o[0].dataType,o[0].dims),s=Qt("weight",o[1].dataType,o[1].dims),u=Qt("bias",o[2].dataType,o[2].dims),l=a.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${l}, 144>;\n  var<workgroup> tileWeightQ: array<${l}, 144>;\n  var<workgroup> tileWeightK: array<${l}, 144>;\n  var<workgroup> tileWeightV: array<${l}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(a,s,u,t,i,r)}\n  ${e.mainStart([12,12,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${l}(0);\n    var valueK = ${l}(0);\n    var valueV = ${l}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:o,outputs:[-1,-1,-1]})},gi=(e,t)=>{let n=li(e.inputs,t),[i,r,a]=mi(e,n);return fi(e,i,r,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),ml=N(()=>{oe(),Ju(),nl(),ul(),ll(),_i=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let i=t.length;if(i!==e.length)throw new Error(`${n}: num dimensions != ${i}`);t.forEach((t,i)=>{if(t!==e[i])throw new Error(`${n}: dim[${i}] do not match`)})};if(e[0].dims.length>1){let i="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,i,"Invalid input scale"),n(e[2].dims,i,"Invalid input B"),n(e[3].dims,i,"Invalid input mean"),n(e[4].dims,i,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},yi=(e,t)=>{let{epsilon:n,spatial:i,format:r}=t,a=e[0].dims,s=i?Wt(a[a.length-1]):1,o="NHWC"===r&&a.length>1?s:1,u=ut.size(a)/s,l=i,d=l?a.length:a,p=Qt("x",e[0].dataType,e[0].dims,s),h=Qt("scale",e[1].dataType,e[1].dims,o),c=Qt("bias",e[2].dataType,e[2].dims,o),f=Qt("inputMean",e[3].dataType,e[3].dims,o),m=Qt("inputVar",e[4].dataType,e[4].dims,o),g=Xt("y",e[0].dataType,d,s);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${i}_${s}`,inputDependencies:l?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\n  const epsilon = ${n};\n  ${e.registerUniform("outputSize","u32").declareVariables(p,h,c,f,m,g)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${g.offsetToIndices(`global_idx * ${s}`)};\n    ${(()=>{let e="";if(i)e=`let cOffset = ${1===a.length?"0u":"NHWC"===r?`outputIndices[${a.length-1}] / ${s}`:"outputIndices[1]"};`;else if("NCHW"===r)e=`\n            ${g.indicesSet("outputIndices","0","0")}\n            let cOffset = ${g.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let t=1;t<h.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return e})()}\n    let scale = ${h.getByOffset("cOffset")};\n    let bias = ${c.getByOffset("cOffset")};\n    let inputMean = ${f.getByOffset("cOffset")};\n    let inputVar = ${m.getByOffset("cOffset")};\n    let x = ${p.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${g.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l?[{type:12,data:u},...Gt(a)]:[{type:12,data:u}]})}},$i=e=>Pt(e),wi=(e,t)=>{let{inputs:n,outputCount:i}=e,r=$i({...t,outputCount:i});if(l.webgpu.validateInputContent&&_i(n,r),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(yi(n,r))}}),gl=N(()=>{nl(),ll(),bi=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},vi=e=>{let t=e[0].dims,n=e[0].dims[2],i=ut.size(t)/4,r=e[0].dataType,a=Qt("input",r,t,4),s=Qt("bias",r,[n],4),o=Qt("residual",r,t,4),u=Xt("output",r,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(a,s,o,u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let value = ${a.getByOffset("global_idx")}\n      + ${s.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx","value")}\n  }`}},xi=e=>{bi(e.inputs),e.compute(vi(e.inputs))}}),_l=N(()=>{Ju(),nl(),ul(),ll(),ki=(e,t,n,i,r,a,s)=>{let o=Math.ceil(t/4),u="";u="string"==typeof r?`${r}(a)`:r("a");let l=Qt("inputData",n,[o],4),d=Xt("outputData",i,[o],4),p=[{name:"vec_size",type:"u32"}];return s&&p.push(...s),`\n      ${e.registerUniforms(p).declareVariables(l,d)}\n\n  ${a??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${l.getByOffset("global_idx")};\n    ${d.setByOffset("global_idx",u)}\n  }`},Si=(e,t,n,i,r,a=e.dataType,s,o)=>{let u=[{type:12,data:Math.ceil(ut.size(e.dims)/4)}];return s&&u.push(...s),{name:t,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:t=>ki(t,ut.size(e.dims),e.dataType,a,n,i,o),getRunData:t=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(ut.size(t[0].dims)/64/4)},programUniforms:u})}},Ii=e=>{e.compute(Si(e.inputs[0],"Abs","abs"))},Ti=e=>{e.compute(Si(e.inputs[0],"Acos","acos"))},Ei=e=>{e.compute(Si(e.inputs[0],"Acosh","acosh"))},zi=e=>{e.compute(Si(e.inputs[0],"Asin","asin"))},Ci=e=>{e.compute(Si(e.inputs[0],"Asinh","asinh"))},Oi=e=>{e.compute(Si(e.inputs[0],"Atan","atan"))},Ai=e=>{e.compute(Si(e.inputs[0],"Atanh","atanh"))},Bi=e=>Pt(e),Ri=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Si(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Di=e=>{let t,n,i=e.length>=2&&0!==e[1].data,r=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=i?e[1].getFloat32Array()[0]:-34028234663852886e22,n=r?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=i?e[1].getUint16Array()[0]:64511,n=r?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Pt({min:t,max:n})},Mi=(e,t)=>{let n=t||Di(e.inputs),i=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Clip",e=>`clamp(${e}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},Ui=e=>{e.compute(Si(e.inputs[0],"Ceil","ceil"))},Pi=e=>{e.compute(Si(e.inputs[0],"Cos","cos"))},Ni=e=>{e.compute(Si(e.inputs[0],"Cosh","cosh"))},qi=e=>Pt(e),Vi=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Elu",e=>`elu_vf32(${e})`,`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Li=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Gi=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Erf",e=>`erf_vf32(${e})`,Li(t)))},Wi=e=>{e.compute(Si(e.inputs[0],"Exp","exp"))},Hi=e=>{e.compute(Si(e.inputs[0],"Floor","floor"))},Fi=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Gelu",e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`,Li(t)))},Ki=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"LeakyRelu",e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},ji=e=>{e.compute(Si(e.inputs[0],"Not",e=>`!${e}`))},Zi=e=>{e.compute(Si(e.inputs[0],"Neg",e=>`-${e}`))},Qi=e=>{e.compute(Si(e.inputs[0],"Reciprocal",e=>`1.0/${e}`))},Xi=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"Relu",e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`))},Yi=e=>{e.compute(Si(e.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},Ji=e=>Pt(e),er=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"HardSigmoid",e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},tr=e=>{e.compute(Si(e.inputs[0],"Sin","sin"))},nr=e=>{e.compute(Si(e.inputs[0],"Sinh","sinh"))},ir=e=>{e.compute(Si(e.inputs[0],"Sqrt","sqrt"))},rr=e=>{e.compute(Si(e.inputs[0],"Tan","tan"))},ar=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,sr=e=>{e.compute(Si(e.inputs[0],"Tanh",ar))},or=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${ar("v")};\n}\n`,ur=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,lr=e=>{let t=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"FastGelu",ur,or(t),void 0,e.inputs[0].dataType))},dr=(e,t)=>{let n=Lt(e.inputs[0].dataType);return e.compute(Si(e.inputs[0],"ThresholdedRelu",e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},pr=e=>{e.compute(Si(e.inputs[0],"Log","log"))},hr=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,cr=e=>`quick_gelu_impl(${e})`,fr=(e,t)=>{let n=Lt(e.inputs[0].dataType);e.compute(Si(e.inputs[0],"QuickGelu",cr,hr(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),yl=N(()=>{nl(),ll(),_l(),mr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},gr=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=Qt("input",e[0].dataType,e[0].dims,4),i=Qt("bias",e[0].dataType,[e[0].dims[2]],4),r=Xt("output",e[0].dataType,t,4),a=ut.size(t)/4,s=Vt(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,i,r)}\n\n  ${Li(s)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${r.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},_r=e=>{mr(e.inputs),e.compute(gr(e.inputs))}}),$l=N(()=>{Ju(),nl(),ll(),yr=(e,t,n,i,r,a,s,o,u,l,d,p)=>{let h,c;"string"==typeof o?h=c=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?h=c=o:(h=o.scalar,c=o.vector);let f,m=Xt("outputData",d,i.length,4),g=Qt("aData",u,t.length,4),_=Qt("bData",l,n.length,4);if(r)if(a){let e=1===ut.size(t),i=1===ut.size(n),r=t.length>0&&t[t.length-1]%4==0,a=n.length>0&&n[n.length-1]%4==0;f=e||i?m.setByOffset("global_idx",c(e?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"),i?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"))):`\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${g.broadcastedIndicesToOffset("outputIndices",m)};\n            let offsetB = ${_.broadcastedIndicesToOffset("outputIndices",m)};\n            ${m.setByOffset("global_idx",c(s||r?g.getByOffset("offsetA / 4u"):`${g.type.value}(${g.getByOffset("offsetA / 4u")}[offsetA % 4u])`,s||a?_.getByOffset("offsetB / 4u"):`${_.type.value}(${_.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else f=m.setByOffset("global_idx",c(g.getByOffset("global_idx"),_.getByOffset("global_idx")));else{if(!a)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let i=`aData[indexA${t}][componentA${t}]`,r=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let offsetB${t} = ${_.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${h(i,r)});\n          `};f=9===d?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(g,_,m)}\n\n        ${p??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${f}\n      }`},$r=(e,t,n,i,r,a,s=n.dataType)=>{let o=n.dims.map(e=>Number(e)??1),u=i.dims.map(e=>Number(e)??1),l=!ut.areEqual(o,u),d=o,p=ut.size(o),h=!1,c=!1,f=[l];if(l){let e=ot.calcShape(o,u,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");d=e.slice(),p=ut.size(d);let t=1===ut.size(o),n=1===ut.size(u),i=o.length>0&&o[o.length-1]%4==0,r=u.length>0&&u[u.length-1]%4==0;f.push(t),f.push(n),f.push(i),f.push(r);let a=1;for(let e=1;e<d.length;e++){let t=o[o.length-e];if(t!==u[u.length-e])break;a*=t}a%4==0?(c=!0,h=!0):(t||n||i||r)&&(h=!0)}else h=!0;return f.push(h),{name:e,shaderCache:{hint:t+f.map(e=>e.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>yr(e,o,u,d,h,l,c,r,n.dataType,i.dataType,s,a),getRunData:()=>({outputs:[{dims:d,dataType:s}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:Math.ceil(ut.size(d)/4)},...Gt(o,u,d)]})}},wr=(e,t,n,i,r,a)=>{e.compute($r(t,r??"",e.inputs[0],e.inputs[1],n,i,a))},br=e=>{wr(e,"Add",(e,t)=>`${e}+${t}`)},vr=e=>{wr(e,"Div",(e,t)=>`${e}/${t}`)},xr=e=>{wr(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},kr=e=>{wr(e,"Mul",(e,t)=>`${e}*${t}`)},Sr=e=>{let t=Qt("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;wr(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ir=e=>{wr(e,"Sub",(e,t)=>`${e}-${t}`)},Tr=e=>{wr(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Er=e=>{wr(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},zr=e=>{wr(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Cr=e=>{wr(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}}),wl=N(()=>{Ju(),nl(),ul(),ll(),Or=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],i=n.dataType,r=n.dims.length;e.forEach((e,a)=>{if(0!==a){if(e.dataType!==i)throw new Error("input tensors should be one type");if(e.dims.length!==r)throw new Error("input tensors should have the same shape");e.dims.forEach((e,i)=>{if(i!==t&&e!==n.dims[i])throw new Error("non concat dimensions must match")})}})},Ar=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Br=(e,t)=>{let n=e.length,i=[];for(let r=0;r<n;++r){let a=t.setByOffset("global_idx",e[r].getByIndices("indices"));1===n?i.push(a):0===r?i.push(`if (inputIndex == ${r}u) { ${a} }`):r===n-1?i.push(`else { ${a} }`):i.push(`else if (inputIndex == ${r}) { ${a} }`)}return i.join("\n")},Rr=(e,t,n,i)=>{let r=ut.size(n),a=new Array(e.length),s=new Array(e.length),o=0,u=[],l=[],d=[{type:12,data:r}];for(let n=0;n<e.length;++n)o+=e[n].dims[t],a[n]=o,l.push(e[n].dims.length),s[n]=Qt(`input${n}`,i,l[n]),u.push("rank"),d.push({type:12,data:a[n]});for(let t=0;t<e.length;++t)d.push(...Gt(e[t].dims));d.push(...Gt(n));let p=Xt("output",i,n.length),h=p.indicesGet("indices",t),c=Array.from(Array(a.length).keys()).map(e=>`uniforms.sizeInConcatAxis${e}`).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:n,dataType:i}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:d}),getShaderSource:t=>`\n\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...s,p)})()}\n\n  ${Ar(a.length,c)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${p.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${c});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Br(s,p)}\n  }`}},Dr=(e,t)=>{let n=e.inputs,i=n[0].dims,r=ut.normalizeAxis(t.axis,i.length);Or(n,r);let a=i.slice();a[r]=n.reduce((e,t)=>e+(t.dims.length>r?t.dims[r]:0),0);let s=n.filter(e=>ut.size(e.dims)>0);e.compute(Rr(s,r,a,n[0].dataType),{inputs:s})},Mr=e=>Pt({axis:e.axis})}),bl=N(()=>{Ju(),nl(),Ur=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Pr=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},Nr=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},qr=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,i]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:i}}if("Clip"===t){let[n,i]=e?.activation_params||[pt,ht];return{activation:t,clipMax:i,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}}),vl=N(()=>{Vr=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Lr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `}),xl=N(()=>{Gr=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`}),kl=N(()=>{Ju(),nl(),ll(),bl(),Wr=(e,t,n,i,r)=>{let a=i-n;return`\n      ${Array.from({length:n}).map((n,s)=>`\n      if (${jt(t.shape,s,t.rank)} != 1) {\n        ${t.indicesSet(e,s,jt(r,s+a,i))}\n      } else {\n        ${t.indicesSet(e,s,0)}\n      }`).join("")}\n`},Hr=(e,t,n,i,r=!1,a)=>{let s=e[0].dims,o=e[1].dims,u=s[s.length-2],l=o[o.length-1],d=s[s.length-1],p=Wt(l),h=Wt(d),c=Wt(u),f=ut.size(n)/p/c,m=e.length>2,g=i?i.slice(0,-2):n.slice(0,-2),_=[ut.size(g),u,l],y=[{type:12,data:f},{type:12,data:u},{type:12,data:l},{type:12,data:d}];return Pr(t,y),y.push(...Gt(g,s,o)),m&&y.push(...Gt(e[2].dims)),y.push(...Gt(_)),{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${p};${h};${c};${r}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:y}),getShaderSource:i=>{let a=Jt("batch_dims",e[0].dataType,g.length),u=Qt("a",e[0].dataType,s.length,h),l=Qt("b",e[1].dataType,o.length,p),d=Xt("output",e[0].dataType,_.length,p),f=Vt(d.type.tensor),y=Ur(t,d.type.value,f),$=[u,l],w="";if(m){let t=r?p:1;$.push(Qt("bias",e[2].dataType,e[2].dims.length,t)),w=r?`value += bias[col / ${t}];`:`value += ${d.type.value}(bias[row + i]);`}let b=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];return Nr(t,b),`\n  ${i.registerUniforms(b).registerInternalVariables(a).declareVariables(...$,d)}\n  ${i.mainStart()}\n    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${p})) * ${p};\n    var index1 = global_idx / (uniforms.N / ${p});\n    let stride1 = uniforms.M / ${c};\n    let row = (index1 % stride1) * ${c};\n    let batch = index1 / stride1;\n\n    ${2===n.length?"":`let batch_indices = ${a.offsetToIndices("batch")};`}\n\n    var a_indices: ${u.type.indices};\n    ${Wr("a_indices",u,u.rank-2,a.rank,"batch_indices")}\n    ${u.indicesSet("a_indices",u.rank-2,0)}\n    ${u.indicesSet("a_indices",u.rank-1,0)}\n    let a_offset = ${u.indicesToOffset("a_indices")};\n\n    var b_indices: ${l.type.indices};\n    ${Wr("b_indices",l,l.rank-2,a.rank,"batch_indices")}\n    ${l.indicesSet("b_indices",l.rank-2,0)}\n    ${l.indicesSet("b_indices",l.rank-1,0)}\n    let b_offset = ${l.indicesToOffset("b_indices")};\n    var values: array<${d.type.value}, ${c}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${(()=>{let e=`var a_data: ${u.type.value};`;for(let t=0;t<h;t++)e+=`\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${p}];`;for(let t=0;t<c;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${h}];`;for(let n=0;n<h;n++)e+=`\n            values[${t}] = fma(${l.type.value}(a_data${1===h?"":`[${n}]`}), b_data${n}, values[${t}]);\n`}return e})()}\n    }\n    for (var i = 0u; i < ${c}u; i++) {\n      var value = values[i];\n      ${w}\n      ${y}\n      let cur_indices = ${d.type.indices}(batch, row + i, col);\n      let offset = ${d.indicesToOffset("cur_indices")};\n      ${d.setByOffset(`offset / ${p}`,"value")};\n    }\n  }\n  `}}}}),Sl=N(()=>{Ju(),nl(),ll(),bl(),kl(),vl(),Fr=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Kr=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,jr=(e,t,n="f32",i,r=!1,a=32,s=!1,o=32)=>{let u=t[1]*e[1],l=t[0]*e[0],d=r?u:a,p=r?a:u,h=d/t[0],c=a/t[1];if((!r||4!==h||4!==e[1])&&(r||3!==h&&4!==h)||d%t[0]!==0||a%t[1]!==0||4!==e[0])throw new Error(`If transposeA ${r} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${h}<${n}>, ${d/h}>, ${p}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${s?"0":"i32(globalId.z)"};\n  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let num_tiles = ${s?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${c};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Fr(r,i)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===h?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Kr(r,h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Zr=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Qr=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Xr=(e,t,n="f32",i,r=!1,a=32,s=!1,o=32,u=!1)=>{let l=e[1]*t[1],d=e[0]*t[0],p=r?l:a,h=r?a:l;if(h%t[1]!==0||p%t[0]!==0||a%t[1]!==0)throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let c=h/t[1],f=p/t[0],m=a/t[1],g=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${t[0]}) {\n          ${Zr(r,i)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${i?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${c};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Zr(r,i)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${i?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Qr(r)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${p}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${s?"0":"i32(globalId.z)"};\n    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${s?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${g}\n  }\n`},Yr=(e,t,n,i,r=!1)=>{let[a,s,o,u]=i,l=Vt(i[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Vr(e,l)} {\n      var value = ${Vr(e,l)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${s.type.indices};\n        ${Wr("aIndices",s,s.rank-2,a.rank,"batchIndices")}\n        ${s.indicesSet("aIndices",s.rank-2,"u32(row)")}\n        ${s.indicesSet("aIndices",s.rank-1,"u32(colIn)")}\n        value = ${s.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Vr(e,l)} {\n      var value = ${Vr(e,l)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${o.type.indices};\n        ${Wr("bIndices",o,o.rank-2,a.rank,"batchIndices")}\n        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}\n        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}\n        value = ${o.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Vr(e,l)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${r?"bias[colIn]":`${Vr(e,l)}(bias[row])`};`:""}\n        ${n}\n        ${u.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Jr=(e,t,n,i,r=!1,a)=>{let s=e[0].dims,o=e[1].dims,u=s.slice(0,-2),l=o.slice(0,-2),d=i?i.slice(0,-2):n.slice(0,-2),p=ut.size(d),h=s[s.length-2],c=s[s.length-1],f=o[o.length-1],m=c%4==0&&f%4==0,g=h<=8?[4,1,1]:[4,4,1],_=[8,8,1],y=[Math.ceil(f/_[0]/g[0]),Math.ceil(h/_[1]/g[1]),Math.ceil(p/_[2]/g[2])],$=m?4:1,w=[...u,h,c/$],b=w.length,v=[...l,c,f/$],x=v.length,k=[p,h,f/$],S=[{type:6,data:h},{type:6,data:f},{type:6,data:c}];Pr(t,S),S.push(...Gt(d,w,v));let I=["rank","rank"],T=e.length>2;return T&&(S.push(...Gt(e[2].dims)),I.push("rank")),S.push(...Gt(k)),{name:"MatMul",shaderCache:{hint:`${g};${t.activation};${m};${r}`,inputDependencies:I},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:y[0],y:y[1],z:y[2]},programUniforms:S}),getShaderSource:n=>{let i=d.length,a=Jt("batchDims",e[0].dataType,i,1),s=Vt(e[0].dataType),o=Qt("a",e[0].dataType,b,$),u=Qt("b",e[1].dataType,x,$),l=Xt("result",e[0].dataType,k.length,$),p=[o,u];if(T){let t=r?$:1;p.push(Qt("bias",e[2].dataType,e[2].dims.length,t))}let h=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Nr(t,h);let c=Vt(l.type.tensor),f=Ur(t,l.type.value,c),y=Yr($,T,f,[a,o,u,l],r);return`\n  ${n.registerUniforms(h).registerInternalVariables(a).declareVariables(...p,l)}\n  ${y}\n  ${m?jr(g,_,s,a):Xr(g,_,s,a)}\n                   `}}}}),Il=N(()=>{Ju(),tl(),ll(),bl(),vl(),xl(),Sl(),ea=(e,t,n,i,r=!1,a,s=4,o=4,u=4,l="f32")=>{let d=e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}},p=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",h=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",c=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",f=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",m=e?"row":"col",g=e?"col":"row",_=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${m} / outWidth;\n    let outCol = ${m} % outWidth;\n\n    let WRow = ${g} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${g} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${g} % inChannels;\n    var resData = ${Vr(s,l)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${c} && xCol >= 0 && xCol < ${f}) {\n      ${p}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(s)}\n    }\n    return resData;`,y=e?t&&i?`\n    let col = colIn * ${s};\n    ${_}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${_}\n    }\n    return ${Vr(s,l)}(0.0);`:i&&n?`\n    let col = colIn * ${s};\n    ${_}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${_}\n    }\n    return ${Vr(s,l)}(0.0);`,$=e?i&&n?d(o):`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${d(o)}\n    }\n    return ${Vr(o,l)}(0.0);`:`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${d(o)}\n    }\n    return ${Vr(o,l)}(0.0);`,w=Vr(u,l),b=Vr(e?s:o,l),v=Vr(e?o:s,l),x=Ur(a,w,l);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\n      ${e?y:$}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${v} {\n      ${e?$:y}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n      let col = colIn * ${u};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${h}\n      ${Lr(r)}\n      ${x}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ta=(e,t,n,i,r,a,s,o,u)=>{let l="NHWC"===t.format,d=l?e[0].dims[3]:e[0].dims[1],p=n[0],h=l?n[2]:n[3],c=l?n[1]:n[2],f=l?n[3]:n[1],m=l&&(d%4==0||d%3==0)&&f%4==0,g=l?f:h*c,_=l?h*c:f,y=[8,8,1],$=i<=8?[4,1,1]:[4,4,1],w=[Math.ceil(g/y[0]/$[0]),Math.ceil(_/y[1]/$[1]),Math.ceil(p/y[2]/$[2])];at("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${w}`);let b=m?l&&d%4!=0?3:4:1,v=y[1]*$[1],x=y[0]*$[0],k=Math.max(y[0]*b,y[1]),S=i%v===0,I=r%x===0,T=a%k===0,E=m?[b,4,4]:[1,1,1],z=[{type:6,data:i},{type:6,data:r},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Pr(t,z),z.push(...Gt(e[0].dims,e[1].dims));let C=["rank","rank"];return s&&(z.push(...Gt(e[2].dims)),C.push("rank")),z.push(...Gt(n)),{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${b};${m};${S};${I};${T};${v};${x};${k}`,inputDependencies:C},getRunData:()=>({outputs:[{dims:u?u(n):n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:z}),getShaderSource:i=>{let r=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Nr(t,r);let a=m?4:1,u=Vt(e[0].dataType),d=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${u}>`:u}) {\n        result[flatIndex] = ${m?`vec4<${u}>`:u}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${u}>`:u}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);\n      }`,p=[Qt("x",e[0].dataType,e[0].dims.length,3===b?1:b),Qt("w",e[1].dataType,e[1].dims.length,a)],h=Xt("result",e[0].dataType,n.length,a);if(s){let t=Qt("bias",e[2].dataType,e[2].dims.length,a);p.push(t),d+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${u}>`:u} {\n          return bias[coords.${l?"w":"y"}${m?"/ 4":""}];\n        }`}return`\n        ${Gr("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${i.registerUniforms(r).declareVariables(...p,h)}\n        ${d}\n        ${ea(l,S,I,T,s,t,E[0],E[1],E[2],u)}\n        ${m?jr($,y,u,void 0,!l,k):Xr($,y,u,void 0,!l,k,!1,void 0,o)}`}}}}),Tl=N(()=>{Ju(),tl(),nl(),ll(),bl(),vl(),na=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},ia=e=>"number"==typeof e?[e,e,e]:e,ra=(e,t)=>t<=1?e:e+(e-1)*(t-1),aa=(e,t,n,i=1)=>{let r=ra(t,i);return Math.floor((e[0]*(n-1)-n+r)/2)},sa=(e,t,n,i,r)=>{null==r&&(r=aa(e,t[0],i[0]));let a=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*r>=t[n]&&(a[n]=Math.trunc((e[n]-t[n]+2*r)/i[n]+1));return a},oa=(e,t,n,i,r,a,s,o,u,l)=>{let d,p,h,c;if("VALID"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=sa([t,n,i,1],[o,u,l],1,[r,a,s],e);p=f[0],h=f[1],c=f[2]}else if(Array.isArray(e)){if(!e.every((e,t,n)=>e===n[0]))throw Error(`Unsupported padding parameter: ${e}`);d={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=sa([t,n,i,1],[o,u,l],1,[r,a,s],e[0]);p=f[0],h=f[1],c=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{p=Math.ceil(t/r),h=Math.ceil(n/a),c=Math.ceil(i/s);let e=(p-1)*r+o-t,f=(h-1)*a+u-n,m=(c-1)*s+l-i,g=Math.floor(e/2),_=e-g,y=Math.floor(f/2),$=f-y,w=Math.floor(m/2);d={top:y,bottom:$,left:w,right:m-w,front:g,back:_}}}return{padInfo:d,outDepth:p,outHeight:h,outWidth:c}},ua=(e,t,n,i,r,a=!1,s="channelsLast")=>{let o,u,l,d,p;if("channelsLast"===s)[o,u,l,d,p]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[o,p,u,l,d]=e}let[h,,c,f,m]=t,[g,_,y]=ia(n),[$,w,b]=ia(i),v=ra(c,$),x=ra(f,w),k=ra(m,b),{padInfo:S,outDepth:I,outHeight:T,outWidth:E}=oa(r,u,l,d,g,_,y,v,x,k),z=a?h*p:h,C=[0,0,0,0,0];return"channelsFirst"===s?C=[o,z,I,T,E]:"channelsLast"===s&&(C=[o,I,T,E,z]),{batchSize:o,dataFormat:s,inDepth:u,inHeight:l,inWidth:d,inChannels:p,outDepth:I,outHeight:T,outWidth:E,outChannels:z,padInfo:S,strideDepth:g,strideHeight:_,strideWidth:y,filterDepth:c,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:x,effectiveFilterWidth:k,dilationDepth:$,dilationHeight:w,dilationWidth:b,inShape:e,outShape:C,filterShape:t}},la=(e,t,n,i,r,a)=>{let s="channelsLast"===a,o=(s?e[0].dims[3]:e[0].dims[1],{x:n.map((e,t)=>t)}),u=[Math.ceil(na(o.x.map(e=>n[e]))/64),1,1];at("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let l=[{type:12,data:ut.size(n)},{type:12,data:i},{type:12,data:r},{type:12,data:t.strides},{type:12,data:t.dilations}];Pr(t,l),l.push(...Gt(e[0].dims,e[1].dims));let d=["rank","rank"],p=3===e.length;return p&&(l.push(...Gt(e[2].dims)),d.push("rank")),l.push(...Gt(n)),{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${s};1;${p}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:l}),getShaderSource:a=>{let o=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Nr(t,o);let u=Vt(e[0].dataType),l=Qt("x",e[0].dataType,e[0].dims.length,1),d=Qt("W",e[1].dataType,e[1].dims.length,1),h=[l,d],c=Xt("result",e[0].dataType,n.length,1),f="";if(p){let t=Qt("bias",e[2].dataType,e[2].dims.length,1);h.push(t),f+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${u} {\n          return bias[${jt("coords",s?4:1,5)}];\n        }`}let m=Vr(1,u),g=Ur(t,m,u);return`\n            ${f}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${l.getByIndices("aIndices")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${d.getByIndices("aIndices")};\n            }\n          ${a.registerUniforms(o).declareVariables(...h,c)}\n          ${a.mainStart()}\n          ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n              let coords = ${c.offsetToIndices("global_idx")};\n              let batch = ${jt("coords",0,l.rank)};\n              let d2 = ${jt("coords",s?l.rank-1:1,l.rank)};\n              let xFRCCorner = vec3<u32>(${jt("coords",s?1:2,l.rank)},\n              ${jt("coords",s?2:3,l.rank)},\n              ${jt("coords",s?3:4,l.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${jt("uniforms.x_shape",s?1:2,l.rank)};\n              let xShapeZ = ${jt("uniforms.x_shape",s?2:3,l.rank)};\n              let xShapeW = ${jt("uniforms.x_shape",s?3:4,l.rank)};\n              let xShapeU = ${jt("uniforms.x_shape",s?4:1,l.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${s?"let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            ":"let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            "}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${s?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${s?"let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      ":"let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    "}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${s?"let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      ":"let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    "}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${p?"value = value + getBiasByOutputCoords(coords)":""};\n              ${g}\n              result[global_idx] = f32(value);\n          }`}}}}),El=N(()=>{Ju(),nl(),ll(),bl(),da=(e,t,n,i)=>{let r=e.length>2,a=r?"value += b[output_channel];":"",s=e[0].dims,o=e[1].dims,u="NHWC"===t.format,l=u?n[3]:n[1],d=l/t.group,p=u&&d>=4?Wt(l):1,h=ut.size(n)/p,c=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:d}];Pr(t,c),c.push(...Gt(s,[o[0],o[1],o[2],o[3]/p]));let f=r?["rank","rank","rank"]:["rank","rank"];return c.push(...Gt([n[0],n[1],n[2],n[3]/p])),{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${p}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:c}),getShaderSource:i=>{let l=Xt("output",e[0].dataType,n.length,p),d=Vt(l.type.tensor),h=Ur(t,l.type.value,d),c=Qt("x",e[0].dataType,s.length),f=Qt("w",e[1].dataType,o.length,p),m=[c,f];r&&m.push(Qt("b",e[2].dataType,e[2].dims,p));let g=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Nr(t,g);let _=u?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${c.get("batch","xHeight","xWidth","input_channel")};\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${c.get("batch","input_channel","xHeight","xWidth")};\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${i.registerUniforms(g).declareVariables(...m,l)}\n\n  ${i.mainStart()}\n    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${l.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${u?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${p} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${u?2:1}];\n\n    var value: ${l.type.value} = ${l.type.value}(0);\n    ${_}\n    ${a}\n    ${h}\n    ${l.setByOffset("global_idx","value")}\n  }`}}},pa=(e,t,n,i)=>{let r=e.length>2,a=Wt(n[3]),s=Wt(n[2]),o=ut.size(n)/a/s,u=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],l=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],d=[n[0],n[1],n[2],n[3]/a],p=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Pr(t,p),p.push(...Gt(u,l,d));let h=(s-1)*t.strides[1]+l[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${a};${s};${h};${l[0]};${l[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:p}),getShaderSource:n=>{let i=Xt("output",e[0].dataType,d.length,a),o=Vt(i.type.tensor),p=Ur(t,i.type.value,o),c=Qt("x",e[0].dataType,u.length,a),f=Qt("w",e[1].dataType,l.length,a),m=[c,f];r&&m.push(Qt("b",e[2].dataType,e[2].dims,a));let g=r?"value += b[output_channel];":"",_=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Nr(t,_),`\n  ${n.registerUniforms(_).declareVariables(...m,i)}\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${c.type.value}, ${h}>;\n    var values: array<${i.type.value}, ${s}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${l[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${c.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${c.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${l[1]}; w_width++) {\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${s}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${s}u; i++) {\n      var value = values[i];\n      ${g}\n      ${p}\n      ${i.set("batch","row","col + i","output_channel","value")};\n    }\n  }`}}}}),zl=N(()=>{nl(),Il(),Tl(),Sl(),El(),bl(),kl(),dl(),ha=(e,t,n,i,r,a)=>{let s=e[0],o=e.slice(a?1:2,a?3:4),u=o.length,l=t[0],d=t.slice(2).map((e,t)=>e+(e-1)*(n[t]-1)),p=o.map((e,t)=>e+i[t]+i[t+u]).map((e,t)=>Math.floor((e-d[t]+r[t])/r[t]));return p.splice(0,0,s),p.splice(a?3:1,0,l),p},ca=[2,3,1,0],fa=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ma=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let i=e.pads.slice();lt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,i,"NHWC"===e.format,e.autoPad);let r=Object.assign({},e);return Object.assign(r,{kernelShape:n,pads:i}),r},ga=e=>{let t=qr(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},_a=(e,t,n,i)=>{let r="NHWC"===n.format,a=ha(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,r);if(1!==n.group){let s=[t[0]];if(r){let i=e.kernelCustomData.wT??e.compute(ln(t[1],ca),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=i),s.push(i)}else s.push(t[1]);return 3===t.length&&s.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&r&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(pa(s,n,a,i),{inputs:s}):e.compute(da(s,n,a,i),{inputs:s}))}let s=3===t.length,o=t[0].dims[r?1:2],u=t[0].dims[r?2:3],l=t[0].dims[r?3:1],d=t[1].dims[2],p=t[1].dims[3],h=a[r?1:2],c=a[r?2:3],f=a[r?3:1],m=r&&d===o&&p===u&&0===n.pads[0]&&0===n.pads[1];if(m||1===d&&1===p&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let d,p,g,_=a[0],y=[];if(r){let i=e.kernelCustomData.wT??e.compute(ln(t[1],ca),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=i),m){let e=o*u*l;d=t[0].reshape([1,_,e]),p=i.reshape([1,e,f]),g=[1,_,f]}else d=t[0].reshape([_,o*u,l]),p=i.reshape([1,l,f]),g=[_,h*c,f];y.push(d),y.push(p)}else d=t[0].reshape([_,l,o*u]),p=t[1].reshape([1,f,l]),g=[_,f,h*c],y.push(p),y.push(d);s&&y.push(t[2]);let $=g[2],w=y[0].dims[y[0].dims.length-1];return void($<8&&w<8?e.compute(Hr(y,n,a,g,r,i),{inputs:y}):e.compute(Jr(y,n,a,g,r,i),{inputs:y}))}let g=e.kernelCustomData.wT??e.compute(ln(t[1],ca),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let _=[t[0],g];s&&_.push(t[2]);let y=r?h*c:f,$=r?f:h*c,w=d*p*l;e.compute(ta(_,n,a,y,$,w,s,!0,i),{inputs:_})},ya=(e,t)=>{let n="NHWC"===t.format,i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&i.push(e.inputs[2]);let r=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),o=[1].concat(t.kernelShape),u=ma({...t,pads:r,strides:a,dilations:s,kernelShape:o},i);_a(e,i,u,e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])},$a=(e,t,n)=>{let i="NHWC"===n.format?"channelsLast":"channelsFirst",r=ma(n,t),a="NOTSET"===n.autoPad?n.pads:n.autoPad,s=ua(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,i);e.compute(la(t,r,s.outShape,[s.filterDepth,s.filterHeight,s.filterWidth],[s.padInfo.front,s.padInfo.top,s.padInfo.left],i))},wa=(e,t)=>{if(fa(e.inputs,t),3===e.inputs[0].dims.length)ya(e,t);else if(5===e.inputs[0].dims.length)$a(e,e.inputs,t);else{let n=ma(t,e.inputs);_a(e,e.inputs,n)}}}),Cl=N(()=>{Ju(),tl(),nl(),ll(),ba=(e,t,n)=>{let i=e.length>2,r=t.outputShape,a="NHWC"===t.format,s=t.group,o=e[1].dims,u=o[2]/s,l=o[3],d=a?Wt(u):1,p=a&&1===l&&u>=4,h=p?4*Math.floor(u/4):Math.floor(u/d)*d,c=u-h,f=a?Wt(l):1,m=a?1===l?d:f:1,g=ut.size(r)/f,_=[Math.ceil(g/64),1,1];at("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${_}`);let y=["rank","rank"],$=[t.strides[0],t.strides[1]],w=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],b=[t.dilations[0],t.dilations[1]],v=[w[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),w[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],x=[v[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),v[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],k=[{type:12,data:g},{type:12,data:$},{type:12,data:w},{type:12,data:b},{type:12,data:v},{type:6,data:x},{type:12,data:h},{type:12,data:u},{type:12,data:l},...Gt(e[0].dims,e[1].dims)];return i&&(k.push(...Gt(e[2].dims)),y.push("rank")),k.push(...Gt(r)),{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${d}${m}${f}${p}${c}`,inputDependencies:y},getRunData:()=>({dispatchGroup:{x:_[0],y:_[1],z:_[2]},outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],programUniforms:k}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:$.length},{name:"filter_dims",type:"u32",length:w.length},{name:"dilations",type:"u32",length:w.length},{name:"effective_filter_dims",type:"u32",length:v.length},{name:"pads",type:"i32",length:x.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],s=Vt(e[0].dataType),o=a?1:2,u=a?2:3,l=a?3:1,h=Qt("W",e[1].dataType,e[1].dims.length,m),g=Qt("Dy",e[0].dataType,e[0].dims.length,d),_=[g,h];i&&_.push(Qt("bias",e[2].dataType,[r[l]].length,f));let y=Xt("result",e[0].dataType,r.length,f),b=`\n            let outputIndices = ${y.offsetToIndices(`global_idx * ${f}`)};\n            let batch = ${y.indicesGet("outputIndices",0)};\n            let d1 = ${y.indicesGet("outputIndices",l)};\n            let r = ${y.indicesGet("outputIndices",o)};\n            let c = ${y.indicesGet("outputIndices",u)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${y.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${s}(dyRCorner) + ${s}(wR)) / ${s}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${s}(uniforms.Dy_shape[${o}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${s}(dyCCorner) + ${s}(wC)) / ${s}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${s}(uniforms.Dy_shape[${u}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                ${p?`\n                var x_offset = ${g.indicesToOffset(`${g.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${d};\n                var w_offset = ${h.indicesToOffset(`${h.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${m};\n                  `:""}\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${p?4:d}) {\n                  ${(()=>{let e="";if(p)4===d?e+=`\n        let xValue = ${g.getByOffset("x_offset")};\n        let wValue = ${h.getByOffset("w_offset")};\n        dotProd = dotProd + dot(xValue, wValue);\n        x_offset += 1u;\n        w_offset += 1u;`:2===d?e+=`\n          dotProd = dotProd + dot(vec4<${s}>(${g.getByOffset("x_offset")}, ${g.getByOffset("x_offset + 1u")}), vec4<${s}>(${h.getByOffset("w_offset")}, ${h.getByOffset("w_offset + 1u")}));\n          x_offset += 2u;\n          w_offset += 2u;`:1===d&&(e+=`\n          dotProd = dotProd + dot(vec4<${s}>(${g.getByOffset("x_offset")}, ${g.getByOffset("x_offset + 1u")}, ${g.getByOffset("x_offset + 2u")}, ${g.getByOffset("x_offset + 3u")}), vec4<${s}>(${h.getByOffset("w_offset")}, ${h.getByOffset("w_offset + 1u")}, ${h.getByOffset("w_offset + 2u")}, ${h.getByOffset("w_offset + 3u")}));\n          x_offset += 4u;\n          w_offset += 4u;`);else if(e+=`\n                  let xValue = ${a?g.getByOffset(`${g.indicesToOffset(`${g.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${d}`):g.get("batch","inputChannel","idyR","idyC")};\n        `,1===d)e+=`\n          let w_offset = ${h.indicesToOffset(`${h.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n          let wValue = ${h.getByOffset(`w_offset / ${m}`)};\n          dotProd = dotProd + xValue * wValue;`;else for(let t=0;t<d;t++)e+=`\n            let wValue${t} = ${h.getByOffset(`${h.indicesToOffset(`${h.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${t}, wOutChannel)`)} / ${m}`)};\n            dotProd = dotProd + xValue[${t}] * wValue${t};`;return e})()}\n                  inputChannel = inputChannel + ${p?4:d};\n                }\n                ${(()=>{if(0===c)return"";if(!p)throw new Error(`packInputAs4 ${p} is not true.`);let e="";if(1===d){e+="dotProd = dotProd";for(let t=0;t<c;t++)e+=`\n            + ${g.getByOffset(`x_offset + ${t}`)} * ${h.getByOffset(`w_offset + ${t}`)}`;e+=";"}else if(2===d){if(2!==c)throw new Error(`Invalid inputChannelsRemainder ${c}.`);e+=`\n          let xValue = ${g.getByOffset("x_offset")};\n          let wValue = ${h.getByOffset("w_offset")};\n          dotProd = dotProd + dot(xValue, wValue);`}return e})()}\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${i?` + bias[d1 / ${f}]`:""};\n            ${y.setByOffset("global_idx","value")};\n          `;return`\n    ${t.registerUniforms(n).declareVariables(..._,y)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n    ${b}}`}}}}),Ol=N(()=>{Cl(),bl(),dl(),va=(e,t,n,i,r,a)=>(e-1)*t+n+(i-1)*r+1-a,xa=(e,t,n,i,r)=>{let a=Math.floor(e/2);"SAME_UPPER"===t?(n[i]=a,n[r]=e-a):"SAME_LOWER"===t&&(n[i]=e-a,n[r]=a)},ka=(e,t,n,i,r,a,s,o,u,l)=>{let d=e.length-2,p=0===l.length;u.length<d&&u.push(...Array(d-u.length).fill(0));let h=e[0],c=t[o?3:1]*r;for(let r=0,h=e.length-d-(o?1:0);r<d;++r,++h){let o=e[h],c=p?o*s[r]:l[r],f=va(o,s[r],a[r],t[h],n[r],c);xa(f,i,a,r,r+d),p&&l.push(s[r]*(o-1)+u[r]+(t[h]-1)*n[r]+1-a[r]-a[r+d])}l.splice(0,0,h),l.splice(o?3:1,0,c)},Sa=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce((e,t)=>e*t,1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let i="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(i?3:1,0,t[1].dims[1]);let r=e.pads.slice(),a=e.outputShape.slice(),s=e.outputPadding.slice(),o=t[0].dims,u=e.dilations.slice();if(0===u.reduce((e,t)=>e+t,0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce((e,t)=>e+t,0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}ka(o,n,u,e.autoPad,e.group,r,l,i,s,a);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:r,outputPadding:s,outputShape:a,dilations:u,strides:l}),d},Ia=e=>{let t=qr(e),n=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],r=e.dilations,a=e.group,s=e.kernelShape,o=e.pads,u=e.strides,l=e.wIsConst();return{autoPad:i,format:n,dilations:r,group:a,kernelShape:s,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:o,strides:u,wIsConst:l,...t,cacheKey:`${e.format};${t.activation};`}},Ta=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.reduce((e,t)=>e+t,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((e,t)=>e+t,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((e,t)=>e+t,0)>0&&t.pads.length!==2*i)throw new Error(`pads should be ${2*i}D`);if(t.outputPadding.length!==i&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((e,t)=>e+t,0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ea=(e,t,n,i)=>{let r=e.kernelCustomData.wT??e.compute(ln(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r);let a=[t[0],r];3===t.length&&a.push(t[2]),e.compute(ba(a,n,i),{inputs:a})},za=(e,t)=>{let n="NHWC"===t.format,i=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&i.push(e.inputs[2]);let r=t.kernelShape;(0===r.length||0===r[0])&&(r=[e.inputs[1].dims[2]]);let a=t.dilations;(0===a.length||0===a[0])&&(a=[1]);let s=t.strides;(0===s.length||0===s[0])&&(s=[1]);let o=t.pads;0===o.length&&(o=[0,0]),o=[0,o[0],0,o[1]],s=[1].concat(s),a=[1].concat(a),r=[1].concat(r);let u=t.outputPadding;u=[0].concat(u);let l=Sa({...t,pads:o,strides:s,dilations:a,kernelShape:r,outputPadding:u},i);Ea(e,i,l,e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])},Ca=(e,t)=>{if(Ta(e.inputs,t),3===e.inputs[0].dims.length)za(e,t);else{let n=Sa(t,e.inputs);Ea(e,e.inputs,n)}}}),Al=N(()=>{Ju(),nl(),ul(),ll(),Oa=(e,t,n,i)=>{let r=ut.size(t),a=t.length,s=Qt("input",e,a),o=Xt("output",e,a),u=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),l=ut.normalizeAxis(u,a);return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:l},...Gt(t,t)]}),getShaderSource:e=>{let t=` i32(${s.indicesGet("inputIndices","uniforms.axis")}) `,n=jt("uniforms.input_shape","uniforms.axis",a),r=i.reverse?t+(i.exclusive?" + 1":""):"0",u=i.reverse?n:t+(i.exclusive?"":" + 1");return`\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(s,o)}\n                ${e.mainStart()}\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${o.offsetToIndices("global_idx")};\n                  var sum = ${o.type.value}(0);\n                  let first : i32 = ${r};\n                  let last : i32 = ${u};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${s.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${s.getByIndices("inputIndices")};\n                  }\n                  ${o.setByOffset("global_idx","sum")};\n                }`}}},Aa=(e,t)=>{let n=e.inputs[0].dims,i=e.inputs[0].dataType,r=e.inputs[1];e.compute(Oa(i,n,r,t),{inputs:[0]})},Ba=e=>{let t=1===e.exclusive,n=1===e.reverse;return Pt({exclusive:t,reverse:n})}}),Bl=N(()=>{Ju(),nl(),ul(),ll(),Ra=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},Da=(e,t,n,i)=>{let r=[];r.push(`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let i=0;i<t;++i)r.push(n.indicesSet("a",e[i],`i[${i}]`));return r.push("return a;}"),r.join("\n")},Ma=(e,t)=>{let n,i,r,a,s,o,u="NHWC"===t.format,l=t.blocksize,d="DCR"===t.mode;u?([n,i,r,a]=e.dims,s=d?[n,i,r,l,l,a/l**2]:[n,i,r,a/l**2,l,l],o=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,i,r,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=d?[n,l,l,a/l**2,i,r]:[n,a/l**2,l,l,i,r],o=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let p=e.reshape(s),h=p.dims.length,c=e.dataType,f=Qt("a",c,h),m=Xt("output",c,h);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=u?[n,i*l,r*l,a/l**2]:[n,a/l**2,i*l,r*l],s=ut.size(t),d=p.dims,h=ut.sortBasedOnPerm(d,o);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},...Gt(d,h)]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(f,m)}\n\n  ${Da(o,h,f,m)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}\n  }`}},Ua=(e,t)=>{Ra(e.inputs),e.compute(Ma(e.inputs[0],t))},Pa=e=>Pt({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Rl=N(()=>{Ju(),nl(),ul(),ll(),Va="^"+(qa="("+(Na="[a-zA-Z]|\\.\\.\\.")+")+")+"$",La="^("+qa+",)*"+qa+"$",Ga=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Wa=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,i]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(La)))throw new Error("Invalid LHS term");if(n.split(",").forEach((t,n)=>{let i=e[n].dims.slice();if(!t.match(RegExp(Va)))throw new Error("Invalid LHS term");let r=this.processTerm(t,!0,i,n);this.lhs.push(r)}),""===i)i+=[...this.symbolToInfo.entries()].filter(([e,t])=>1===t.count||"..."===e).map(([e])=>e).join("");else if(!i.match(RegExp(qa)))throw new Error("Invalid RHS");i.match(RegExp(Na,"g"))?.forEach(e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(e,t,n){let i=this.symbolToInfo.get(e);if(void 0!==i){if(i.dimValue!==t&&1!==i.count)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(n)}else i={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,i)}processTerm(e,t,n,i=-1){let r=n.length,a=!1,s=[],o=0;if(!e.match(RegExp(Va))&&!t&&""!==e)throw new Error("Invalid LHS term");let u=e.match(RegExp(Na,"g")),l=new Ga(i);return u?.forEach((e,d)=>{if("..."===e){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let e=r-u.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(s=n.slice(o,o+e),this.hasEllipsis){if(this.ellipsisDims.length!==s.length||this.ellipsisDims.toString()!==s.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=s}for(let e=0;e<s.length;e++){let t=String.fromCharCode(48+e);l.addSymbol(t,d+e),this.addSymbol(t,n[o++],i)}}else l.addSymbol(e,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[o++],i)}),l}},Ha=e=>e+"_max",Fa=(e,t,n,i)=>{let r=e.map(e=>e.length).map((e,n)=>Qt(`input${n}`,t,e)),a=ut.size(i),s=Xt("output",t,i.length),o=[...n.symbolToInfo.keys()].filter(e=>!n.rhs.symbolToIndices.has(e));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let r=o.filter(e=>n.symbolToInfo.has(e)).map(e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0}));r.push({type:12,data:a});let s=e.map((e,t)=>[...Gt(e)]).reduce((e,t)=>e.concat(t),r);return s.push(...Gt(i)),{outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:s}},getShaderSource:e=>{let t=[],i=[],a=[],u=[],l=[],d=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((e,o)=>{if(n.rhs.symbolToIndices.has(o)){let i=n.rhs.symbolToIndices.get(o)?.[0];void 0!==i&&n.lhs.forEach((n,a)=>{if(e.inputIndices.includes(a)){let e=n.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach(e=>{t.push(`${r[a].indicesSet(`input${a}Indices`,e,s.indicesGet("outputIndices",i))}`)})}})}else n.lhs.forEach((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach(e=>{i.push(`${r[n].indicesSet(`input${n}Indices`,e,`${o}`)}`)}),l.push(`prod *= ${r[n].getByIndices(`input${n}Indices`)};`)}}),a.push(`for(var ${o}: u32 = 0; ${o} < uniforms.${Ha(o)}; ${o}++) {`),u.push("}")});let p=d?[...t,`let sum = ${r.map((e,t)=>e.getByIndices(`input${t}Indices`)).join(" * ")};`]:[...t,"var sum = 0.0;",...a,...i,"var prod = 1.0;",...l,"sum += prod;",...u];return`\n            ${e.registerUniforms(o.map(e=>({name:`${Ha(e)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,s)}\n\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${s.offsetToIndices("global_idx")};\n            ${r.map((e,t)=>`var input${t}Indices: ${r[t].type.indices};`).join("\n")}\n            ${p.join("\n")};\n            ${s.setByOffset("global_idx","sum")};\n          }`}}},Ka=(e,t)=>{let n=new Wa(e.inputs,t.equation),i=n.outputDims,r=e.inputs.map((e,t)=>e.dims);e.compute(Fa(r,e.inputs[0].dataType,n,i))},ja=e=>{let t=e.equation.replace(/\s+/g,"");return Pt({equation:t})}}),Dl=N(()=>{Ju(),nl(),ll(),Za=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=n.length<t.length?0:n.length-t.length,r=t.length<n.length?0:t.length-n.length;for(;i<n.length&&r<t.length;++i,++r)if(n[i]!==t[r]&&1!==n[i]&&1!==t[r])throw new Error("Expand requires shape to be broadcastable to input")},Qa=(e,t)=>{let n=e.length-t.length,i=[];for(let t=0;t<n;++t)i.push(e[t]);for(let r=0;r<t.length;++r)i.push(1===t[r]?e[r+n]:t[r]);return i},Xa=(e,t)=>e.length>t.length?Qa(e,t):Qa(t,e),Ya=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),i=Xa(t,n),r=e[0].dataType,a=9===r||1===ut.size(t),s=9===r||t.length>0&&t[t.length-1]%4==0?4:1,o=a||i.length>0&&i[i.length-1]%4==0?4:1,u=Math.ceil(ut.size(i)/o),l=[{type:12,data:u},...Gt(t,i)];return{name:"Expand",shaderCache:{hint:`${i.length};${s}${o}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,a=Qt("input",r,t.length,s),u=Xt("output",r,i.length,o);if(9===r){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${u.offsetToIndices(`outputOffset + ${t}u`)};\n          let offset${t} = ${a.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${a.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${o};\n        var data = vec4<u32>(0);\n        ${e("data",0,"u32")}\n        ${e("data",1,"u32")}\n        ${e("data",2,"u32")}\n        ${e("data",3,"u32")}\n        ${u.setByOffset("global_idx","data")}\n      }`}else n=`\n        let outputIndices = ${u.offsetToIndices(`global_idx * ${o}`)};\n        let inputOffset = ${a.broadcastedIndicesToOffset("outputIndices",u)};\n        let data = ${u.type.value}(${a.getByOffset(`inputOffset / ${s}`)});\n        ${u.setByOffset("global_idx","data")}\n      }`;return`\n    ${e.registerUniform("vec_size","u32").declareVariables(a,u)}\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${n}`},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l})}},Ja=e=>{Za(e.inputs),e.compute(Ya(e.inputs),{inputs:[0]})}}),Ml=N(()=>{Ju(),nl(),ll(),_l(),es=e=>{let t=e[0].dataType,n=ut.size(e[0].dims),i=ut.size(e[1].dims),r=i%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=Qt("x",t,[1],4),i=Qt("bias",t,[1],4),a=Xt("y",t,[1],4),s=e=>`\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\n      let bias${e} = ${i.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,o=r?`\n      let bias = ${i.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${s(0)}${s(1)}${s(2)}${s(3)}\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,i,a)}\n\n    ${or(Lt(t))}\n\n    ${e.mainStart(Nt)}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${n.getByOffset("global_idx")};\n      ${o}\n      let x_in = x + bias;\n      ${a.setByOffset("global_idx",ur("x_in"))}\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(n/Nt/4)}})}},ts=e=>{e.inputs.length<2||0===ut.size(e.inputs[1].dims)?lr(e):e.compute(es(e.inputs))}}),Ul=N(()=>{Ju(),nl(),ul(),ll(),ns=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},is=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,a=ut.normalizeAxis(t.axis,r),s=n.slice(0);s.splice(a,1,...i);let o=n[a],u=9===e[0].dataType?4:1,l=Math.ceil(ut.size(s)/u),d=[{type:12,data:l},{type:6,data:o},{type:12,data:a},...Gt(e[0].dims,e[1].dims,s)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:t=>{let n,o=Qt("data",e[0].dataType,e[0].dims.length,u),l=Qt("inputIndices",e[1].dataType,e[1].dims.length),d=Xt("output",e[0].dataType,s.length,u),p=e=>{let t=i.length,n=`var indicesIndices${e}  = ${l.type.indices}(0);`;for(let i=0;i<t;i++)n+=`${t>1?`indicesIndices${e}[${i}]`:`indicesIndices${e}`} = ${s.length>1?`outputIndices${e}[uniforms.axis + ${i}]`:`outputIndices${e}`};`;n+=`\n          var idx${e} = ${l.getByIndices(`indicesIndices${e}`)};\n          if (idx${e} < 0) {\n            idx${e} = idx${e} + uniforms.axisDimLimit;\n          }\n          var dataIndices${e} : ${o.type.indices};\n        `;for(let i=0,o=0;i<r;i++)i===a?(n+=`${r>1?`dataIndices${e}[${i}]`:`dataIndices${e}`} = u32(idx${e});`,o+=t):(n+=`${r>1?`dataIndices${e}[${i}]`:`dataIndices${e}`} = ${s.length>1?`outputIndices${e}[${o}]`:`outputIndices${e}`};`,o++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${d.offsetToIndices(`outputOffset + ${t}u`)};\n          ${p(t)};\n          let offset${t} = ${o.indicesToOffset(`dataIndices${t}`)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${u};\n        var value = vec4<u32>(0);\n        ${e("value",0,"u32")}\n        ${e("value",1,"u32")}\n        ${e("value",2,"u32")}\n        ${e("value",3,"u32")}\n        ${d.setByOffset("global_idx","value")}\n      `}else n=`\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      ${p("")};\n      let value = ${o.getByIndices("dataIndices")};\n      ${d.setByOffset("global_idx","value")};\n      `;return`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(o,l,d)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${n}\n      }`}}},rs=e=>Pt({axis:e.axis}),as=(e,t)=>{let n=e.inputs;ns(n),e.compute(is(e.inputs,t))}}),Pl=N(()=>{Ju(),nl(),ll(),ss=(e,t,n,i,r,a,s,o,u)=>{let l=[{type:12,data:a},{type:12,data:i},{type:12,data:r},{type:12,data:n},{type:12,data:s},{type:12,data:o},{type:12,data:u}],d=[a];return l.push(...Gt(t.dims,d)),e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:e=>{let i=[Qt("indices_data",t.dataType,t.dims.length),Xt("input_slice_offsets_data",12,1,1)],a=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\n  ${e.registerUniforms(a).declareVariables(...i)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${1===r.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\n      }\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`}},{inputs:[t],outputs:[-1]})[0]},os=(e,t)=>{let n=e.inputs,i=n[0].dims,r=n[0].dataType,a=n[1].dims,s=a[a.length-1],o=ut.sizeToDimension(a,a.length-1),u=ut.sizeFromDimension(i,t.batchDims+s),l=ut.sizeToDimension(i,t.batchDims),d=ut.sizeFromDimension(i,t.batchDims),p=o/l,h=new Array(s),c=u;for(let e=0;e<s;++e)h[s-1-e]=c,c*=i[t.batchDims+s-1-e];let f=ss(e,n[1],h,t.batchDims,i,o,p,d,s),m=t.batchDims+s;if(m>i.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let g=a.slice(0,-1).concat(i.slice(m)),_=ut.size(g),y=[{type:12,data:_},{type:12,data:u},...Gt(n[0].dims,f.dims,g)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:g,dataType:r}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:y}),getShaderSource:e=>{let t=Qt("data",n[0].dataType,n[0].dims.length),i=Qt("slice_offsets",12,f.dims.length),r=Xt("output",n[0].dataType,g.length);return`\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,i,r)}\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`}},{inputs:[n[0],f]})},us=e=>({batchDims:e.batch_dims,cacheKey:""})}),Nl=N(()=>{Ju(),nl(),ul(),ll(),ls=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=ut.normalizeAxis(t.quantizeAxis,e[0].dims.length),i=t.blockSize,r=e[0],a=e[2],s=4===e.length?e[3]:void 0;if(a.dims.length!==r.dims.length||!r.dims.map((e,t)=>t===n?Math.ceil(e/i)===a.dims[t]:e===a.dims[t]).reduce((e,t)=>e&&t,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(s){if(s.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(s.dims.length!==a.dims.length||!s.dims.map((e,t)=>e===a.dims[t]).reduce((e,t)=>e&&t,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},ds=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n.length,a=ut.normalizeAxis(t.gatherAxis,r),s=ut.normalizeAxis(t.quantizeAxis,r),o=n.slice(0);o.splice(a,1,...i);let u=ut.size(o),l=e[2].dataType,d=22===e[0].dataType,p=[{type:12,data:u},{type:12,data:s},{type:12,data:a},{type:12,data:t.blockSize},...Gt(...e.map((e,t)=>e.dims),o)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((e,t)=>1!==t).map(e=>e.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(e,t)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:l}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:p}),getShaderSource:t=>{let r=Qt("data",e[0].dataType,e[0].dims.length),s=Qt("inputIndices",e[1].dataType,e[1].dims.length),u=Qt("scales",e[2].dataType,e[2].dims.length),p=e.length>3?Qt("zeroPoint",e[3].dataType,e[3].dims.length):void 0,h=Xt("output",l,o.length),c=[r,s,u];return p&&c.push(p),`\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...c,h)}\n        ${t.mainStart()}\n        let output_indices = ${h.offsetToIndices("global_idx")};\n        var indices_indices = ${s.type.indices}(0);\n        ${i.length>1?`\n          for (var i: u32 = 0; i < ${i.length}; i++) {\n            let index = ${h.indicesGet("output_indices","uniforms.gather_axis + i")};\n            ${s.indicesSet("indices_indices","i","index")};\n          }`:`indices_indices = ${h.indicesGet("output_indices","uniforms.gather_axis")};`};\n        var data_indices = ${r.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${h.indicesGet("output_indices","i")};\n          ${r.indicesSet("data_indices","i","index")};\n        }\n        var index_from_indices = ${s.getByIndices("indices_indices")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${r.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\n        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {\n          let index = ${h.indicesGet("output_indices",`i + ${i.length} - 1`)};\n          ${r.indicesSet("data_indices","i","index")};\n        }\n        let data_offset = ${r.indicesToOffset("data_indices")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${r.getByOffset("data_offset / 8")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${u.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\n        ${u.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\n        var scale = ${u.getByIndices("scale_indices")};\n        ${p?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${p.indicesToOffset("zero_point_indices")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${p.getByOffset("zero_point_offset / 8")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\n        let dequantized_data = ${Lt(l)}(quantized_data - zero_point) * scale;\n        ${h.setByOffset("global_idx","dequantized_data")};\n    }`}}},ps=(e,t)=>{let n=e.inputs;ls(n,t),e.compute(ds(e.inputs,t))},hs=e=>Pt({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),ql=N(()=>{Ju(),nl(),ul(),ll(),cs=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},fs=(e,t)=>{let n=e[0].dims,i=e[0].dataType,r=n.length,a=e[1].dims,s=e[1].dataType,o=ut.normalizeAxis(t.axis,r),u=n[o],l=a.slice(0),d=ut.size(l),p=Qt("input",i,r),h=Qt("indicesInput",s,a.length),c=Xt("output",i,l.length),f=[{type:12,data:d},{type:6,data:u},{type:12,data:o}];return f.push(...Gt(n,a,l)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:e=>`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,h,c)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${c.offsetToIndices("global_idx")};\n\n      var idx = ${h.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${p.type.indices}(outputIndices);\n      ${p.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${p.getByIndices("inputIndices")};\n\n      ${c.setByOffset("global_idx","value")};\n  }`}},ms=e=>Pt({axis:e.axis}),gs=(e,t)=>{let n=e.inputs;cs(n),e.compute(fs(e.inputs,t))}}),Vl=N(()=>{Ju(),nl(),ll(),_s=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},ys=(e,t)=>{let n=e[0].dims.slice(),i=e[1].dims.slice(),[r,a,s]=dt.getShapeOfGemmResult(n,t.transA,i,t.transB,3===e.length?e[2].dims:void 0),o=[r,a];if(!o)throw new Error("Can't use gemm on the given tensors");let u=Math.ceil(a/16),l=Math.ceil(r/16),d=(ut.size(o),[{type:12,data:u},{type:12,data:r},{type:12,data:a},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}]),p=["type","type"];return 3===e.length&&(d.push(...Gt(e[2].dims)),p.push("rank")),d.push(...Gt(o)),{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*l},programUniforms:d}),getShaderSource:n=>{let i=Qt("a",e[0].dataType,e[0].dims),r=Qt("b",e[1].dataType,e[1].dims),a=null,s=[i,r];3===e.length&&(a=Qt("c",e[2].dataType,e[2].dims.length),s.push(a));let u=Xt("output",e[0].dataType,o.length);s.push(u);let l="",d="";t.transA&&t.transB?(d=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(d=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(d=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(d=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${i.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n      `,l="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let p=1===t.alpha?"":"value *= uniforms.alpha;";return`\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...s)}\n  var<workgroup> tile_a: array<array<${i.type.storage}, 16>, 16>;\n  var<workgroup> tile_b: array<array<${r.type.storage}, 16>, 16>;\n  ${n.mainStart([16,16,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\n    var k_start = 0u;\n    var value = ${u.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${d}\n      k_start = k_start + 16;\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < 16; k++) {\n        ${l}\n      }\n      workgroupBarrier();\n    }\n\n    ${p}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${null!=a?`let cOffset = ${a.broadcastedIndicesToOffset("vec2(m, n)",u)}; value += ${u.type.value}(uniforms.beta) * ${a.getByOffset("cOffset")};`:""}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`}}},$s=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),ws=(e,t)=>{_s(e.inputs),e.compute(ys(e.inputs,t))}}),Ll=N(()=>{Ju(),nl(),ul(),ll(),[bs,vs,xs,ks]=[0,1,2,3],Ss=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Is=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Ts=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${0===e.alignCorners?"\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    ":"\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    "}\n  }\n`,Es=e=>`\n  ${"reflection"===e.paddingMode?"\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }":""}\n`,zs=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${bs}] = batch;\n     indices[${vs}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${xs}] = u32(r);\n            indices[${ks}] = u32(c);\n          } else {\n            return ${t}(0);\n          }\n        `;case"border":return`\n          indices[${xs}] = u32(clamp(r, 0, H - 1));\n          indices[${ks}] = u32(clamp(c, 0, W - 1));\n        `;case"reflection":return`\n          indices[${xs}] = gs_reflect(r, border[1], border[3]);\n          indices[${ks}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices("indices")};\n  }\n`,Cs=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${bs}], indices[${vs}], border);\n        `;case"bilinear":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${bs}], indices[${vs}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${bs}], indices[${vs}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${bs}], indices[${vs}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${bs}], indices[${vs}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case"bicubic":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${bs}], indices[${vs}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,Os=(e,t)=>{let n=Qt("x",e[0].dataType,e[0].dims.length),i=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],r=Qt("grid",e[1].dataType,i.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[bs,vs,xs,ks]=[0,3,1,2]);let s=Xt("output",e[0].dataType,a.length),o=n.type.value,u=[{type:12,data:ut.size(a)},...Gt(e[0].dims,i,a)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=ut.size(a);return{outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:u}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(n,r,s)}\n  \n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n\n  ${Is(o)}\n  ${Ts(t)}\n  ${Es(t)}\n  ${zs(n,o,t)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let H_in = i32(uniforms.x_shape[${xs}]);\n      let W_in = i32(uniforms.x_shape[${ks}]);\n\n      ${0===t.alignCorners?"\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      ":"\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      "};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${s.offsetToIndices("global_idx")};\n      var grid_indices = vec3<u32>(indices[${bs}], indices[${xs}], indices[${ks}]);\n      let nxy = ${r.getByIndices("grid_indices")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Cs(s,o,t)}\n  }`}},As=(e,t)=>{Ss(e.inputs),e.compute(Os(e.inputs,t))},Bs=e=>Pt({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),Gl=N(()=>{Ju(),nl(),ul(),sl(),fl(),ll(),dl(),Rs=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Ds=(e,t)=>{let n=e[0],i=Rs(e,1),r=Rs(e,2),a=Rs(e,3),s=Rs(e,4),o=Rs(e,5),u=Rs(e,6),l=Rs(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let d,p=n.dims[0],h=n.dims[1],c=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=h,m=0,g=0,_=Math.floor(c/t.numHeads);if(u&&l&&ut.size(u.dims)&&ut.size(l.dims)){if(4!==u.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(u.dims[0]!==p||u.dims[1]!==t.numHeads||u.dims[3]!==_)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[0]!==p||l.dims[1]!==t.numHeads||l.dims[3]!==_)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[2]!==l.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(4!==l.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');m=u.dims[2],g=u.dims[2]}else if(u&&ut.size(u.dims)||l&&ut.size(l.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');if(i&&ut.size(i.dims)>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===i.dims.length){if(i.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');d=2,f=i.dims[1]}else if(5===i.dims.length){if(i.dims[2]!==t.numHeads||2!==i.dims[3]||i.dims[4]!==_)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');d=5,f=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==_)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=0,f=i.dims[2]}}else{if(5!==n.dims.length)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');d=3}if(a&&ut.size(a.dims)>0){if(1!==a.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&5===i.dims.length&&2===i.dims[3])throw new Error("bias is not allowed for packed kv.")}let y=m+f,$=0;if(s&&ut.size(s.dims)>0){$=8;let e=s.dims;throw 1===e.length?e[0]===p?$=1:e[0]===3*p+2&&($=3):2===e.length&&e[0]===p&&e[1]===y&&($=5),8===$?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let w=!1,b=c;if(r&&ut.size(r.dims)>0){if(3!==r.dims.length&&4!==r.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===r.dims.length){if(f!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');b=r.dims[2]}else{if(f!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');b=r.dims[1]*r.dims[3],w=!0}}if(s&&ut.size(s.dims)>0)throw new Error("Key padding mask is not supported");if(o&&ut.size(o.dims)>0){if(4!==o.dims.length)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==p||o.dims[1]!==t.numHeads||o.dims[2]!==h||o.dims[3]!==y)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:p,sequenceLength:h,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:y,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:c,vHiddenSize:b,headSize:_,vHeadSize:Math.floor(b/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:$,scale:t.scale,broadcastResPosBias:!1,passPastInKv:w,qkvFormat:d}},Ms=e=>Pt({...e}),Us=Pt({perm:[0,2,1,3]}),Ps=(e,t,n,i,r,a,s)=>{let o=[i,r,a],u=ut.size(o),l=[{type:12,data:u},{type:12,data:s},{type:12,data:a}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l}),getShaderSource:e=>{let i=Xt("qkv_with_bias",t.dataType,o),r=Qt("qkv",t.dataType,o),a=Qt("bias",n.dataType,o);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(r,a,i)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},Ns=(e,t,n,i,r,a,s,o)=>{let u=a;if(s&&ut.size(s.dims)>0){if(1===i)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return u=Ps(e,a,s,t,i,n*r,o),u=u.reshape([t,i,n,r]),1===n||1===i?u:e.compute(ln(u,Us.perm),{inputs:[u],outputs:[-1]})[0]}return 3===a.dims.length&&(u=a.reshape([t,i,n,r])),1===n||1===i?u:e.compute(ln(u,Us.perm),{inputs:[u],outputs:[-1]})[0]},qs=(e,t)=>{let n=Ds(e.inputs,t),i=e.inputs[0],r=Rs(e.inputs,1),a=Rs(e.inputs,2),s=Rs(e.inputs,3),o=Rs(e.inputs,4),u=Rs(e.inputs,5),l=Rs(e.inputs,6),d=Rs(e.inputs,7);if(5===i.dims.length)throw new Error("Packed QKV is not implemented");if(5===r?.dims.length)throw new Error("Packed KV is not implemented");let p=r&&a&&4===r.dims.length&&4===a.dims.length,h=Ns(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,i,s,0);if(p)return fi(e,h,r,a,o,void 0,l,d,u,n);if(!r||!a)throw new Error("key and value must be provided");let c=Ns(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r,s,n.hiddenSize),f=Ns(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,s,2*n.hiddenSize);fi(e,h,c,f,o,void 0,l,d,u,n)}}),Wl=N(()=>{Ju(),nl(),ul(),ll(),Vs=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Ls=(e,t)=>{let n=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(e=>n.push(Number(e))),i=n.length),Pt({numOutputs:i,axis:t.axis,splitSizes:n})},Gs=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${jt("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Ws=e=>{let t=e.length,n=[];for(let i=0;i<t;++i){let r=e[i].setByIndices("indices","input[global_idx]");1===t?n.push(r):0===i?n.push(`if (output_number == ${i}u) { ${r} }`):i===t-1?n.push(`else { ${r} }`):n.push(`else if (output_number == ${i}) { ${r} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},Hs=(e,t)=>{let n=e[0].dims,i=ut.size(n),r=e[0].dataType,a=ut.normalizeAxis(t.axis,n.length),s=new Array(t.numOutputs),o=Qt("input",r,n.length),u=new Array(t.numOutputs),l=[],d=[],p=0,h=[{type:12,data:i}];for(let i=0;i<t.numOutputs;i++){p+=t.splitSizes[i],u[i]=p;let o=n.slice();o[a]=t.splitSizes[i],d.push(o),s[i]=Xt(`output${i}`,r,o.length),l.push({dims:d[i],dataType:e[0].dataType})}return h.push({type:12,data:u},...Gt(n,...d)),{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",u.length).declareVariables(o,...s)}\n  ${Gs(u.length)}\n  ${Ws(s)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${o.offsetToIndices("global_idx")};\n    var index = ${o.indicesGet("indices",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${jt("uniforms.size_in_split_axis","output_number - 1u",u.length)};\n      ${o.indicesSet("indices",a,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:l,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:h})}},Fs=(e,t)=>{Vs(e.inputs);let n=1===e.inputs.length?t:Ls(e.inputs,t);e.compute(Hs(e.inputs,n),{inputs:[0]})},Ks=e=>{let t=e.axis,n=e.splitSizes,i=e.numOutputs<0?n.length:e.numOutputs;if(i!==n.length)throw new Error("numOutputs and splitSizes length must be equal");return Pt({axis:t,numOutputs:i,splitSizes:n})}}),Hl=N(()=>{Ju(),nl(),ul(),ll(),js=(e,t)=>{let[n,i,r,a]=e,{numHeads:s,rotaryEmbeddingDim:o}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!ut.areEqual(i.dims,[])&&!ut.areEqual(i.dims,[1])&&2!==i.dims.length)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(2!==r.dims.length)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(2!==a.dims.length)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!ut.areEqual(r.dims,a.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&0===s)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let u=n.dims[0],l=n.dims[n.dims.length-2],d=r.dims[0],p=ut.sizeFromDimension(n.dims,1)/l,h=0===o?2*r.dims[1]:p/s;if(o>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===i.dims.length){if(u!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(l!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(h/2!==r.dims[1]&&o/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(l>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Zs=(e,t)=>{let{interleaved:n,numHeads:i,rotaryEmbeddingDim:r,scale:a}=t,s=e[0].dims[0],o=ut.sizeFromDimension(e[0].dims,1),u=e[0].dims[e[0].dims.length-2],l=o/u,d=e[2].dims[1],p=0===r?2*d:l/i,h=new Array(s,u,l/p,p-d),c=ut.computeStrides(h),f=[{type:1,data:a},{type:12,data:h},{type:12,data:c},...3===e[0].dims.length?new Array({type:12,data:[o,l,p,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[o,p,u*p,1]}):[],...Gt(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:Pt({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let i=Qt("input",e[0].dataType,e[0].dims.length),r=Qt("position_ids",e[1].dataType,e[1].dims.length),a=Qt("cos_cache",e[2].dataType,e[2].dims.length),s=Qt("sin_cache",e[3].dataType,e[3].dims.length),o=Xt("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:c.length},{name:"input_output_strides",type:"u32",length:c.length}]),`\n        ${t.declareVariables(i,r,a,s,o)}\n\n        ${t.mainStart(Nt)}\n          let half_rotary_emb_dim = uniforms.${a.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${r.broadcastedIndicesToOffset("bsnh.xy",Xt("",r.type.tensor,2))};\n            let position_id =\n                u32(${r.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${i.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} -\n                ${i.getByOffset("j")} * ${s.get("position_id","bsnh[3]")};\n            ${o.setByOffset("i","re")}\n            let im = ${i.getByOffset("i")} * ${s.get("position_id","bsnh[3]")} +\n                ${i.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\n            ${o.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${o.setByOffset("k",i.getByOffset("k"))}\n          }\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ut.size(h)/Nt)},programUniforms:f})}},Qs=(e,t)=>{js(e.inputs,t),e.compute(Zs(e.inputs,t))}}),Fl=N(()=>{ul(),Ju(),fl(),Gl(),Wl(),dl(),Hl(),ll(),Xs=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],i=e[1],r=e[2],a=e[3],s=e[4];if(0!==t.doRotary&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=n.dims[0],u=n.dims[1],l=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],d=u,p=0,h=!i||0===i.dims.length,c=Math.floor(h?l/(t.numHeads+2*t.kvNumHeads):l/t.numHeads);h&&(l=c*t.numHeads);let f=a&&0!==a.dims.length,m=s&&0!==s.dims.length;if(f&&4===a.dims.length&&a.dims[0]===o&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===c)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&m){if(4!==a.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==s.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');p=a.dims[2]}else if(f||m)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g=1;if(i&&i.dims.length>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===i.dims.length){if(n.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');d=i.dims[1]}else if(5===i.dims.length){if(i.dims[2]!==t.numHeads||2!==i.dims[3]||i.dims[4]!==c)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');d=i.dims[1]}else{if(i.dims[1]!==t.numHeads||i.dims[3]!==c)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=i.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let _=!1,y=t.kvNumHeads?c*t.kvNumHeads:l;if(r&&r.dims.length>0){if(3!==r.dims.length&&4!==r.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===r.dims.length){if(d!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');y=r.dims[2]}else{if(d!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');y=r.dims[1]*r.dims[3],_=!0}}let $=e.length>4?e[5]:void 0;if($&&1!==$.dims.length&&$.dims[0]!==o)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:o,sequenceLength:u,pastSequenceLength:p,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:l,vHiddenSize:y,headSize:c,vHeadSize:Math.floor(y/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:_,qkvFormat:g}},Ys=Pt({perm:[0,2,1,3]}),Js=(e,t,n)=>{let i=t,r=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(i=t.reshape([n.batchSize,n.kvSequenceLength,r,n.headSize]),i=e.compute(ln(i,Ys.perm),{inputs:[i],outputs:[-1]})[0]),i},eo=(e,t,n,i)=>{let r=[e*t],a=e*t,s=[{type:12,data:a},{type:12,data:t},{type:12,data:e}];return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:7}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:s}),getShaderSource:e=>{let t=Qt("seq_lens",n.dataType,n.dims),a=Qt("total_seq_lens",i.dataType,i.dims),s=Xt("pos_ids",7,r);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}]).declareVariables(t,a,s)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let total_sequence_length = u32(${a.getByOffset("0")});\n    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;\n    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;\n    let batch_idx = global_idx / uniforms.sequence_length;\n    let sequence_idx = i32(global_idx % uniforms.sequence_length);\n    var pos_id: i32 = 0;\n    let seqlen = ${t.getByOffset("batch_idx")};\n    let total_seqlen = seqlen + 1;\n    if (is_first_prompt) {\n      if (sequence_idx < total_seqlen) {\n        pos_id = sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${s.setByOffset("global_idx","pos_id")}\n    } else if (is_subsequent_prompt) {\n      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);\n      if (past_seqlen + sequence_idx < total_seqlen) {\n        pos_id = past_seqlen + sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${s.setByOffset("global_idx","pos_id")}\n    } else if (global_idx < uniforms.batch_size) {\n      ${s.setByOffset("global_idx","seqlen")}\n    };\n  }\n  `}}},to=(e,t)=>{let n=Xs(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let i,r,a=e.inputs[0],s=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,o=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,u=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,l=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,d=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,h=n.kvNumHeads?n.kvNumHeads:n.numHeads,c=Pt({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,h*n.headSize,h*n.headSize]}),[f,m,g]=s||o?[a,s,o]:e.compute(Hs([a],c),{inputs:[a],outputs:[-1,-1,-1]});if(t.doRotary){let a=e.compute(eo(n.batchSize,n.sequenceLength,d,p),{inputs:[d,p],outputs:[-1]})[0],s=e.inputs[7],o=e.inputs[8],u=Pt({interleaved:0!==t.rotaryInterleaved,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),l=[f,a,s,o],h=[-1];i=e.compute(Zs(l,u),{inputs:l,outputs:h})[0],l.splice(0,1,m);let c=Pt({interleaved:0!==t.rotaryInterleaved,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});r=e.compute(Zs(l,c),{inputs:l,outputs:h})[0]}let _=Ns(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?i:f,void 0,0),y=Js(e,t.doRotary?r:m,n),$=Js(e,g,n);fi(e,_,y,$,void 0,void 0,u,l,void 0,n,d,p)}}),Kl=N(()=>{Ju(),nl(),dl(),ll(),no=(e,t,n,i,r,a,s,o)=>{let u=Wt(a),l=1===u?"f32":`vec${u}f`,d=1===u?"vec2f":`mat2x${u}f`,p=r*s,h=64;1===p&&(h=256);let c=[r,s,a/u],f=[r,s,2],m=[];return m.push(...Gt(c,f)),e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${u};${o};${h}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:p},programUniforms:m}),getShaderSource:e=>{let r=Qt("x",t.dataType,3,u),a=[r,Qt("scale",n.dataType,n.dims),Qt("bias",i.dataType,i.dims),Xt("output",1,3,2)];return`\n  var<workgroup> workgroup_shared : array<${d}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${e.declareVariables(...a)}\n  ${e.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${l}(0);\n    var squared_sum = ${l}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${l}(${r.get("batch","channel","h")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${d}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Kt("workgroup_shared[0][0]",u)} / f32(hight * ${u});\n      let squared_sum_final = ${Kt("workgroup_shared[0][1]",u)} / f32(hight * ${u});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`}},{inputs:[t,n,i],outputs:[-1]})[0]},io=(e,t,n)=>{let i=t[0].dims,r=i,a=i[0],s=i[1],o=ut.sizeFromDimension(i,2),u=Wt(o),l=ut.size(r)/u,d=no(e,t[0],t[1],t[2],a,o,s,n.epsilon),p=[a,s,o/u],h=[a,s];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:[{type:12,data:l},...Gt(p,h,p)]}),getShaderSource:e=>{let n=Qt("x",t[0].dataType,p.length,u),i=Qt("scale_shift",1,h.length,2),r=Xt("output",t[0].dataType,p.length,u),a=[n,i,r];return`\n  ${e.registerUniform("output_size","u32").declareVariables(...a)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let outputIndices = ${r.offsetToIndices("global_idx")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${i.getByIndices("vec2<u32>(batch, channel)")};\n      let value = ${n.getByOffset("global_idx")} * ${r.type.value}(scale_shift.x) + ${r.type.value}(scale_shift.y);\n      ${r.setByOffset("global_idx","value")};\n  }`}},{inputs:[t[0],d]})},ro=(e,t,n)=>{let i=t[0].dims,r=i,a=i[0],s=i[i.length-1],o=ut.sizeFromDimension(i,1)/s,u=Wt(s),l=ut.size(r)/u,d=[{type:12,data:o},{type:12,data:Math.floor(s/u)}],p=!1,h=[0,i.length-1];for(let e=0;e<i.length-2;e++)p=p||1!==i[e+1],h.push(e+1);p=p&&1!==i[i.length-1];let c=p?e.compute(ln(e.inputs[0],h),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:i.length},(e,t)=>i[h[t]])),f=no(e,c,t[1],t[2],a,o,s,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${u}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:e=>{let n=Vt(t[0].dataType),i=1===u?"vec2f":`mat${u}x2f`,a=e=>{let t=0===e?"x":"y",i=1===u?"f32":`vec${u}f`;switch(u){case 1:return`${n}(${i}(scale.${t}))`;case 2:return`vec2<${n}>(${i}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${i}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${u}`)}},s=Qt("input",t[0].dataType,t[0].dims,u),o=Xt("output",t[0].dataType,r,u);return`\n  @group(0) @binding(0) var<storage, read> input : array<${s.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${i}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${o.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${a(0)}, ${a(1)});\n  }`}},{inputs:[t[0],f]})},ao=(e,t)=>{"NHWC"===t.format?ro(e,e.inputs,t):io(e,e.inputs,t)}}),jl=N(()=>{Ju(),nl(),ll(),so=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},oo=(e,t,n)=>{let i=t.simplified,r=e[0].dims,a=e[1],s=!i&&e[2],o=r,u=ut.normalizeAxis(t.axis,r.length),l=ut.sizeToDimension(r,u),d=ut.sizeFromDimension(r,u),p=ut.size(a.dims),h=s?ut.size(s.dims):0;if(p!==d||s&&h!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${p} and bias size of ${h}`);let c=[];for(let e=0;e<r.length;++e)e<u?c.push(r[e]):c.push(1);let f=Wt(d),m=["type","type"],g=[{type:12,data:l},{type:1,data:d},{type:12,data:Math.floor(d/f)},{type:1,data:t.epsilon}];s&&m.push("type");let _=n>1,y=n>2,$=[{dims:o,dataType:e[0].dataType}];return _&&$.push({dims:c,dataType:1}),y&&$.push({dims:c,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${i}`,inputDependencies:m},getRunData:()=>({outputs:$,dispatchGroup:{x:Math.ceil(l/64)},programUniforms:g}),getShaderSource:t=>{let n=Vt(e[0].dataType),r=[Qt("x",e[0].dataType,e[0].dims,f),Qt("scale",a.dataType,a.dims,f)];return s&&r.push(Qt("bias",s.dataType,s.dims,f)),r.push(Xt("output",e[0].dataType,o,f)),_&&r.push(Xt("mean_data_output",1,c)),y&&r.push(Xt("inv_std_output",1,c)),`\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...r)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${Ht("f32",f)};\n    var mean_square_vector = ${Ht("f32",f)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Ft(n,f,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Kt("mean_vector",f)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Kt("mean_square_vector",f)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Ft(n,f,"x[j + offset]")};\n      let f32scale = ${Ft(n,f,"scale[j]")};\n      output[j + offset] = ${r[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale\n        ${s?`+ ${Ft(n,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${_?"mean_data_output[global_idx] = mean":""};\n    ${y?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`}}},uo=(e,t)=>{so(e.inputs),e.compute(oo(e.inputs,t,e.outputCount))}}),Zl=N(()=>{nl(),kl(),Sl(),lo=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},po=e=>{lo(e.inputs);let t=ot.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],i=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&i<8)e.compute(Hr(e.inputs,{activation:""},t));else{let r=t[t.length-2],a=ut.size(e.inputs[0].dims.slice(0,-2)),s=ut.size(e.inputs[1].dims.slice(0,-2));if(1!==a&&1===r&&1===s){let r=[1,a,n],s=[e.inputs[0].reshape([1,a,i]),e.inputs[1].reshape([1,i,n])];e.compute(Jr(s,{activation:""},t,r),{inputs:s})}else e.compute(Jr(e.inputs,{activation:""},t))}}}),Ql=N(()=>{Ju(),nl(),ul(),ll(),ho=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],i=n.dims.length;if(n.dims[i-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,s=e[1];if(!ut.areEqual(s.dims,[t.n,r,a]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(ut.size(o)!==t.n*r)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,i=t.n*(8===t.bits?r:Math.floor((r*t.bits+7)/8));if(ut.size(n)!==i)throw new Error("zeroPoints input size error.")}},co=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],a=t.k,s=t.n,o=n.slice(0,i-2),u=ut.size(o),l=e[1].dims[2]/4,d=e[0].dataType,p=Wt(t.k),h=Wt(l),c=Wt(s),f=o.concat([r,s]),m=r>1&&s/c%2==0?2:1,g=ut.size(f)/c/m,_=[],y=[u,r,a/p],$=ut.convertShape(e[1].dims).slice();$.splice(-1,1,l/h),_.push(...Gt(y)),_.push(...Gt($)),_.push(...Gt(e[2].dims)),4===e.length&&_.push(...Gt(ut.convertShape(e[3].dims)));let w=[u,r,s/c];return _.push(...Gt(w)),{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${p};${h};${c};${m};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:d}],dispatchGroup:{x:g},programUniforms:_}),getShaderSource:n=>{let i=y.length,r=Qt("a",e[0].dataType,i,p),a=Qt("b",12,$.length,h),s=Qt("scales",e[2].dataType,e[2].dims.length),o=[r,a,s],u=4===e.length?Qt("zero_points",12,e[3].dims.length):void 0;u&&o.push(u);let d=w.length,f=Xt("output",e[0].dataType,d,c),g=Vt(e[0].dataType),_=(()=>{switch(p){case 1:return`array<${g}, 8>`;case 2:return`mat4x2<${g}>`;case 4:return`mat2x4<${g}>`;default:throw new Error(`${p}-component is not supported.`)}})();return`\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${64*m}>;\n        ${n.declareVariables(...o,f)}\n        ${n.mainStart([64,1,1])}\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${m}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/p};\n            ${(()=>{let e=`\n            var col_index = col * ${c};\n            ${u?"\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;":`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${g}(8);`}\n            `;for(let t=0;t<c*m;t++)e+=`\n            let scale${t} = ${s.getByOffset("col_index * nBlocksPerCol + block")};\n            ${u?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${u.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point${t} = ${g}((zero_point_word) & 0xFu);`:""}\n            col_index += 1;`;return e})()}\n            for (var word: u32 = 0; word < ${l}; word += ${h}) {\n              ${(()=>{let e=`col_index = col * ${c};`;for(let t=0;t<c*m;t++)e+=`\n            let b${t}_data = ${a.getByIndices(`${a.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return e+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${_};\n            var b_dequantized_values: ${_};`,e})()}\n              for (var i: u32 = 0; i < ${h}; i++) {\n                ${(()=>{let e=`\n          // reuse a data\n            var input_offset = ${r.indicesToOffset(`${r.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${_};\n            for (var j: u32 = 0; j < ${8/p}; j++) {\n              a_data[j] = ${r.getByOffset("input_offset")};\n              input_offset++;\n            }\n          `;for(let t=0;t<c*m;t++)e+=`\n            b_value = ${1===h?`b${t}_data`:`b${t}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${_}(${Array.from({length:4},(e,t)=>`${g}(b_value_lower[${t}]), ${g}(b_value_upper[${t}])`).join(", ")});\n            b_dequantized_values = ${1===p?`${_}(${Array.from({length:8},(e,n)=>`(b_quantized_values[${n}] - ${u?`zero_point${t}`:"zero_point"}) * scale${t}`).join(", ")});`:`(b_quantized_values - ${_}(${Array(8).fill(u?`zero_point${t}`:"zero_point").join(",")})) * scale${t};`};\n            workgroup_shared[local_id.x * ${m} + ${Math.floor(t/c)}]${c>1?`[${t%c}]`:""} += ${Array.from({length:8/p},(e,t)=>1===p?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`).join(" + ")};\n          `;return e})()}\n                word_offset += ${8/p};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${m}) {\n            var output_value: ${f.type.value} = ${f.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < 64u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${m};\n            }\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\n          }\n        }`}}},fo=(e,t)=>{let n=e[0].dims,i=n.length,r=n[i-2],a=t.k,s=t.n,o=n.slice(0,i-2),u=ut.size(o),l=e[1].dims[2]/4,d=e[0].dataType,p=Wt(t.k),h=Wt(l),c=o.concat([r,s]),f=s%8==0?8:s%4==0?4:1,m=128/f,g=m*h*8,_=g/p,y=g/t.blockSize,$=ut.size(c)/f,w=[],b=[u,r,a/p],v=ut.convertShape(e[1].dims).slice();v.splice(-1,1,l/h),w.push(...Gt(b)),w.push(...Gt(v)),w.push(...Gt(e[2].dims)),4===e.length&&w.push(...Gt(ut.convertShape(e[3].dims)));let x=[u,r,s];return w.push(...Gt(x)),{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${p};${h};${m};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:c,dataType:d}],dispatchGroup:{x:$},programUniforms:w}),getShaderSource:n=>{let i=b.length,r=Qt("a",e[0].dataType,i,p),a=Qt("b",12,v.length,h),s=Qt("scales",e[2].dataType,e[2].dims.length),o=[r,a,s],u=4===e.length?Qt("zero_points",12,e[3].dims.length):void 0;u&&o.push(u);let l=x.length,d=Xt("output",e[0].dataType,l),c=Vt(e[0].dataType);return`\n        var<workgroup> sub_a: array<${r.type.value}, ${_}>;\n        var<workgroup> inter_results: array<array<${d.type.value}, ${m}>, ${f}>;\n        ${n.declareVariables(...o,d)}\n        ${n.mainStart([m,f,1])}\n          let output_indices = ${d.offsetToIndices(`workgroup_index * ${f}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${y} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${_};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${_}; a_offset += 128)\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${r.getByIndices(`${r.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${r.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${y} + local_id.x;\n            ${u?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${u.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point = ${c}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${c}(8);`}\n            let scale = ${s.getByOffset("b_row * n_blocks_per_col + block")};\n            let b_data = ${a.getByIndices(`${a.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/p};\n            for (var i: u32 = 0; i < ${h}; i++) {\n              ${(()=>{switch(p){case 1:return`\n          let a_data0 = vec4<${c}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${c}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${c}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${c}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${p}-component is not supported.`)}})()}\n              let b_value = ${1===h?"b_data":"b_data[i]"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${c}>(${Array.from({length:4},(e,t)=>`${c}(b_value_lower[${t}]), ${c}(b_value_upper[${t}])`).join(", ")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${c}>(${Array(8).fill("zero_point").join(",")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`).join(" + ")};\n              word_offset += ${8/p};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${f}) {\n            var output_value: ${d.type.value} = ${d.type.value}(0);\n            for (var b = 0u; b < ${m}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${d.setByIndices(`${d.type.indices}(batch, row, col + local_idx)`,"output_value")}\n            }\n          }\n        }`}}},mo=(e,t)=>{ho(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(fo(e.inputs,t)):e.compute(co(e.inputs,t))},go=e=>Pt(e)}),Xl=N(()=>{Ju(),nl(),ll(),_o=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},yo=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n            k = i32(${e.indicesGet("indices",r)}) - ${jt("uniforms.pads",r,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${jt("uniforms.x_shape",r,t)})) {\n              break;\n            }\n            offset += k * i32(${jt("uniforms.x_strides",r,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${i}\n            value = x[offset];\n          }\n      `},$o=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n                k = i32(${e.indicesGet("indices",r)}) - ${jt("uniforms.pads",r,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${jt("uniforms.x_shape",r,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${jt("uniforms.x_shape",r,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${jt("uniforms.x_strides",r,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},wo=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n                k = i32(${e.indicesGet("indices",r)}) - ${jt("uniforms.pads",r,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${jt("uniforms.x_shape",r,t)})) {\n                  k = i32(${jt("uniforms.x_shape",r,t)}) - 1;\n                }\n                offset += k * i32(${jt("uniforms.x_strides",r,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},bo=(e,t,n)=>{let i="";for(let r=t-1;r>=0;--r)i+=`\n                k = i32(${e.indicesGet("indices",r)}) - ${jt("uniforms.pads",r,n)};\n                if (k < 0)  {\n                  k += i32(${jt("uniforms.x_shape",r,t)}]);\n                }\n                if (k >= i32(${jt("uniforms.x_shape",r,t)})) {\n                  k -= i32(${jt("uniforms.x_shape",r,t)});\n                }\n                offset += k * i32(${jt("uniforms.x_strides",r,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},vo=(e,t,n)=>{switch(n.mode){case 0:return yo(e,t,n.pads.length);case 1:return $o(e,t,n.pads.length);case 2:return wo(e,t,n.pads.length);case 3:return bo(e,t,n.pads.length);default:throw new Error("Invalid mode")}},xo=(e,t)=>{let n=ut.padShape(e[0].dims.slice(),t.pads),i=e[0].dims,r=[{type:12,data:ut.size(n)},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;return 0===t.mode&&r.push({type:a?e[2].dataType:1,data:t.value}),r.push(...Gt(e[0].dims,n)),{name:"Pad",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ut.size(n)/64)},programUniforms:r}),getShaderSource:r=>{let s=Xt("output",e[0].dataType,n.length),o=Qt("x",e[0].dataType,i.length),u=o.type.value,l=vo(s,i.length,t),d=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&d.push({name:"constant_value",type:a?u:"f32"}),`\n            ${r.registerUniforms(d).declareVariables(o,s)}\n            ${r.mainStart()}\n            ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${s.offsetToIndices("global_idx")};\n\n            var value = ${u}(0);\n            ${l}\n            output[global_idx] = value;\n        }`}}},ko=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,r=e[0].dims.length,a=new Int32Array(2*r).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)a[Number(t[e])]=Number(n[e]),a[Number(t[e])+r]=Number(n[e+t.length])}else n.forEach((e,t)=>a[Number(t)]=Number(e));let s=[];return a.forEach(e=>s.push(e)),{mode:t.mode,value:i,pads:s}}return t},So=(e,t)=>{_o(e.inputs);let n=ko(e.inputs,t);e.compute(xo(e.inputs,n),{inputs:[0]})}}),Yl=N(()=>{oe(),Ju(),nl(),ll(),Io=e=>{if(l.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},To=(e,t,n)=>{let i="NHWC"===t.format,r=e.dims.slice();i&&r.splice(1,0,r.pop());let a=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),o=t.strides.slice(),u=a?t.dilations.slice():[],l=t.pads.slice();lt.adjustPoolAttributes(n,r,s,o,u,l);let d=lt.computePoolOutputShape(n,r,o,u,s,l,t.autoPad),p=Object.assign({},t);a?Object.assign(p,{kernelShape:s,strides:o,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:s,strides:o,pads:l,cacheKey:t.cacheKey});let h=d.slice();return h.push(h.splice(1,1)[0]),[p,i?h:d]},Eo=(e,t)=>{let n="NHWC"===t.format,i=[{type:12,data:ut.size(e)},{type:12,data:ut.size(t.kernelShape)}],r=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],a=t.pads[t.pads.length/2-1],s=t.pads[t.pads.length-1],o=!!(a+s);i.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:s}),r.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let u=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],a=t.pads[t.pads.length/2-2],s=t.pads[t.pads.length-2];u=!!(a+s),i.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:s}),r.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[i,r,!0,o,u]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=ut.computeStrides(t.kernelShape);return i.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),r.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[i,r,!!t.pads.reduce((e,t)=>e+t),!1,!1]}},zo=(e,t,n,i,r,a,s,o,u,l,d,p)=>{let h="NHWC"===r.format,c=t.type.value,f=Xt("output",t.type.tensor,i);if(r.kernelShape.length<=2){let i="",l="",m="",g=n-(h?2:1);if(i=d?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${g}] < 0 || xIndices[${g}]\n                      >= uniforms.x_shape[${g}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`,2===r.kernelShape.length){let e=n-(h?3:2);l=p?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                `,m="\n              }\n            "}return`\n            ${e.registerUniforms(u).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value = ${c}(${o});\n              var pad = 0;\n              ${l}\n              ${i}\n              ${m}\n              ${s}\n\n              output[global_idx] = value;\n            }`}{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let i=r.kernelShape.length,d=r.pads.length,p="";return p=l?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${a}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(u).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${i}>;\n\n              var value = ${c}(${o});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${i-1}u; j++) {\n                  offsets[j] = offset / ${jt("uniforms.kernelStrides","j",i)};\n                  offset -= offsets[j] * ${jt("uniforms.kernelStrides","j",i)};\n                }\n                offsets[${i-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-i}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${jt("uniforms.strides",`j - ${n-i}u`,i)}\n                    + offsets[j - ${n-i}u] - ${jt("uniforms.pads","j - 2u",d)};\n                  ${p}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},Co=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Oo=e=>`${Co(e)};${e.countIncludePad}`,Ao=e=>`${Co(e)};${e.storageOrder};${e.dilations}`,Bo=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ro=(e,t,n,i)=>{let[r,a]=To(t,i,n),s=Qt("x",t.dataType,t.dims.length),o=s.type.value,u="";r.countIncludePad?u+=`value /= ${o}(uniforms.kernelSize);`:u+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[l,d,p,h,c]=Eo(a,r);return l.push(...Gt(t.dims,a)),{name:e,shaderCache:{hint:`${i.cacheKey};${p};${h};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ut.size(a)/64)},programUniforms:l}),getShaderSource:e=>zo(e,s,t.dims.length,a.length,r,"value += x_val;",u,0,d,p,h,c)}},Do=e=>{let t=0!==e.count_include_pad,n=Bo(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:t,...n,cacheKey:""};return{...i,cacheKey:Oo(i)}},Mo=(e,t)=>{Io(e.inputs),e.compute(Ro("AveragePool",e.inputs[0],!1,t))},Uo={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Po=e=>{let t=e.format;return{format:t,...Uo,cacheKey:t}},No=(e,t)=>{Io(e.inputs),e.compute(Ro("GlobalAveragePool",e.inputs[0],!0,t))},qo=(e,t,n,i)=>{let[r,a]=To(t,i,n),s=Qt("x",t.dataType,t.dims.length),[o,u,l,d,p]=Eo(a,r);return o.push(...Gt(t.dims,a)),{name:e,shaderCache:{hint:`${i.cacheKey};${l};${d};${p}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ut.size(a)/64)},programUniforms:o}),getShaderSource:e=>zo(e,s,t.dims.length,a.length,r,"\n      value = max(x_val, value);\n    ","",10===t.dataType?-65504:-1e5,u,l,d,p)}},Vo=(e,t)=>{Io(e.inputs),e.compute(qo("MaxPool",e.inputs[0],!1,t))},Lo=e=>{let t=e.storage_order,n=e.dilations,i=Bo(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==i.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:t,dilations:n,...i,cacheKey:""};return{...r,cacheKey:Ao(r)}},Go=e=>{let t=e.format;return{format:t,...Uo,cacheKey:t}},Wo=(e,t)=>{Io(e.inputs),e.compute(qo("GlobalMaxPool",e.inputs[0],!0,t))}}),Jl=N(()=>{Ju(),nl(),ul(),ll(),Ho=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((t,n)=>t===e[2].dims[n]).reduce((e,t)=>e&&t,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((n,i)=>i===t.axis||n===e[0].dims[i]).reduce((e,t)=>e&&t,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],i=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/i)||t.blockSize>Math.ceil(n/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Fo=(e,t)=>{let n=ut.normalizeAxis(t.axis,e[0].dims.length),i=e[0].dataType,r=3===i,a=e[0].dims,s=e[1].dataType,o=ut.size(a),u=3===i||2===i,l=u?[Math.ceil(ut.size(e[0].dims)/4)]:e[0].dims,d=e[1].dims,p=e.length>2?e[2]:void 0,h=p?u?[Math.ceil(ut.size(p.dims)/4)]:p.dims:void 0,c=0===d.length||1===d.length&&1===d[0],f=!1===c&&1===d.length,m=Wt(o),g=c&&(!u||4===m),_=g?m:1,y=g&&!u?m:1,$=Qt("input",u?12:i,l.length,y),w=Qt("scale",s,d.length),b=p?Qt("zero_point",u?12:i,h.length):void 0,v=Xt("output",s,a.length,_),x=[$,w];b&&x.push(b);let k=[l,d];p&&k.push(h);let S=[{type:12,data:o/_},{type:12,data:n},{type:12,data:t.blockSize},...Gt(...k,a)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:b?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...x,v)}\n      ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let output_indices = ${v.offsetToIndices("global_idx")};\n\n          // Set input x\n          ${u?`\n            let input = ${$.getByOffset("global_idx / 4")};\n            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};\n            let x_value = ${1===_?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${$.getByOffset("global_idx")};`};\n\n          // Set scale input\n          ${c?`let scale_value= ${w.getByOffset("0")}`:f?`\n            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};\n            let scale_value= ${w.getByOffset("scale_index")};`:`\n            var scale_indices: ${w.type.indices} = output_indices;\n            let index = ${w.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\n            ${w.indicesSet("scale_indices","uniforms.axis","index")};\n            let scale_value= ${w.getByIndices("scale_indices")};`};\n\n          // Set zero-point input\n          ${b?c?u?`\n                let zero_point_input = ${b.getByOffset("0")};\n                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${b.getByOffset("0")}`:f?u?`\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_input = ${b.getByOffset("zero_point_index / 4")};\n                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_value = ${b.getByOffset("zero_point_index")};`:u?`\n                let zero_point_offset = ${w.indicesToOffset("scale_indices")};\n                let zero_point_input = ${b.getByOffset("zero_point_offset / 4")};\n                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${b.getByIndices("scale_indices")};`:`let zero_point_value = ${u?r?"i32":"u32":$.type.value}(0);`};\n      // Compute and write output\n      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(o/_/64),y:1,z:1},programUniforms:S})}},Ko=(e,t)=>{Ho(e.inputs,t),e.compute(Fo(e.inputs,t))},jo=e=>Pt({axis:e.axis,blockSize:e.blockSize})}),ed=N(()=>{oe(),Ju(),ll(),Zo=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},Qo=(e,t,n,i)=>{let r=Math.abs(Math.ceil((t-e)/n)),a=[r],s=r,o=[{type:12,data:s},{type:i,data:e},{type:i,data:n},...Gt(a)];return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:e=>{let t=Xt("output",i,a.length),n=t.type.value,r=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\n        ${e.registerUniforms(r).declareVariables(t)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:o})}},Xo=e=>{let t=0,n=0,i=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),l.webgpu.validateInputContent&&Zo(t,n,i),e.compute(Qo(t,n,i,e.inputs[0].dataType),{inputs:[]})}}),td=N(()=>{Ju(),nl(),ul(),ll(),Yo=(e,t,n,i)=>{if("none"!==e&&"i32"!==i&&"u32"!==i&&"f32"!==i)throw new Error(`Input ${i} is not supported with reduction ${e}.`);let r="{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =",a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===i||"u32"===i?`atomicAdd(&${t}, bitcast<${i}>(${n}));`:`\n              ${r}bitcast<${i}>(oldValue) + (${n})${a}`;case"max":return"i32"===i||"u32"===i?`atomicMax(&${t}, bitcast<${i}>(${n}));`:`\n                ${r}max(bitcast<f32>(oldValue), (${n}))${a}`;case"min":return"i32"===i||"u32"===i?`atomicMin(&${t}, bitcast<${i}>(${n}));`:`${r}min(bitcast<${i}>(oldValue), (${n}))${a}`;case"mul":return`${r}(bitcast<${i}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},Jo=(e,t)=>{let n=e[0].dims,i=e[1].dims,r=n,a=Math.ceil(ut.sizeToDimension(i,i.length-1)/1),s=i[i.length-1],o=ut.sizeFromDimension(n,s),u=[{type:12,data:a},{type:12,data:s},{type:12,data:o},...Gt(e[1].dims,e[2].dims,r)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}),getShaderSource:n=>{let i=Qt("indices",e[1].dataType,e[1].dims.length),a=Qt("updates",e[2].dataType,e[2].dims.length,1),s="none"!==t.reduction&&""!==t.reduction?Yt("output",e[0].dataType,r.length):Xt("output",e[0].dataType,r.length,1);return`\n      ${n.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(i,a,s)}\n      ${n.mainStart()}\n        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n  var data_offset = 0u;\n  let indices_start = uniforms.last_index_dimension * global_idx;\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${1===e[0].dims.length?"\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;":"\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start];"}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${Yo(t.reduction,"output[data_offset + i]","value",s.type.value)}\n  }\n\n      }`}}},eu=e=>Pt({reduction:e.reduction}),tu=(e,t)=>{e.compute(Jo(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),nd=N(()=>{Ju(),nl(),ul(),ll(),nu=(e,t)=>{if(e.every(e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},iu=(e,t,n)=>{t.every(e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(n).fill(1);return t.forEach((t,n)=>i[t]=e[n]),i},ru=(e,t,n,i,r,a)=>{let[s,o,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(e=>a.push(e));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach(e=>i.push(e)),0!==i.length&&i.length!==l&&n>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");nu(i,t),t.axes.length>0&&iu(i,t.axes,l).forEach((e,t)=>i[t]=e)}if(u>0&&e.length>u&&1===e[u].dims.length&&e[u].dims[0]>0&&(e[u].getBigInt64Array().forEach(e=>r.push(Number(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==i.length&&i.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(0!==r.length&&r.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof r<"u"&&i.length>0&&r.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},au=(e,t,n,i)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${i}(big / (${n}));\n  let fract = ${i}(big % (${n})) / ${i}(${n});\n  return whole + fract;\n`,su=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${au("xResized","lengthOriginal","lengthResized",t)}\n          }\n        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${au("xResized","lengthOriginal - 1","lengthResized - 1",t)}\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",ou=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",uu=(e,t,n)=>{let i=new Array(n).fill(0).concat(new Array(n).fill(1)),r=0===e.length?i:e.slice();return t.length>0?(t.forEach((e,a)=>{i[e]=r[a],i[a+n]=r[t.length+a]}),i):r},lu=(e,t,n,i)=>{let r=[];if(n.length>0)if(i.length>0){if(e.forEach(e=>r.push(e)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((e,t)=>r[e]=n[t])}else n.forEach(e=>r.push(e));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");r=e.map((e,n)=>Math.round(e*t[n]))}return r},du=(e,t,n)=>{let i=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(e=>t[e]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(e=>t[e]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let r=e.slice();return n.axes.length>0?(n.axes.forEach(e=>t[e]=i),n.axes.forEach(n=>r[n]=Math.round(e[n]*t[n]))):(t.fill(i,0,t.length),r.forEach((e,n)=>r[n]=Math.round(e*t[n]))),r},pu=(e,t,n,i,r)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${jt("uniforms.scales","i",i)};\n        var roi_low = ${jt("uniforms.roi","i",r)};\n        var roi_hi = ${jt("uniforms.roi",`i + ${t.length}`,r)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${jt("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${jt("uniforms.output_shape","i",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,hu=(e,t,n,i,r,a,s)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${i.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${jt("uniforms.scales","i",r)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${jt("uniforms.roi","i",a)};\n          var roi_hi = ${jt("uniforms.roi",`i + ${n.length}`,a)};\n          var input_shape_i = ${jt("uniforms.input_shape","i",n.length)};\n          var output_shape_i = ${jt("uniforms.output_shape","i",i.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i","input_index")}\n      }\n      return input_indices;\n    }`,cu=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${jt("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,fu=(e,t,n,i)=>e.rank>i?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",n,"batch")};\n`:"",mu=(e,t,n,i,r)=>{let[a,s,o,u]=2===n.length?[-1,0,1,-1]:[0,2,3,1],l=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${l} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",s,`max(0, min(row, ${n[s]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};\n      ${fu(e,u,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${l} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${l} = originalIndices[${s}];\n      var col:${l} = originalIndices[${o}];\n      ${i?`if (row < 0 || row > (${n[s]} - 1) || col < 0 || col > (${n[o]} - 1)) {\n        return ${r};\n      }`:""};\n      row = max(0, min(row, ${n[s]} - 1));\n      col = max(0, min(col, ${n[o]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${u}])`:"0"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${l} = getInputValue(batch, channel, row1, col1);\n      var x12: ${l} = getInputValue(batch, channel, row1, col2);\n      var x21: ${l} = getInputValue(batch, channel, row2, col1);\n      var x22: ${l} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${l} = abs(row - ${l}(row1));\n      var dx2: ${l} = abs(${l}(row2) - row);\n      var dy1: ${l} = abs(col - ${l}(col1));\n      var dy2: ${l} = abs(${l}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},gu=(e,t,n,i,r,a,s,o,u,l)=>{let d=2===n.length,[p,h]=d?[0,1]:[2,3],c=e.type.value,f=s=>{let d=s===p?"row":"col";return`\n      fn ${d}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${c} {\n        var output_index = ${t.indicesGet("output_indices",s)};\n        var originalIdx: ${c} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[s]},\n        ${i[s]}, ${n[s]}, ${a[s]}, ${a[s]} + ${n.length});\n        var fractOriginalIdx: ${c} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${o} && (originalIdx < 0 || originalIdx > (${n[s]} - 1))) {\n          return ${u};\n        }\n        var data: array<${c}, 4> = array<${c}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${d}: ${c} = originalIdx + ${c}(i);\n          if (${d} < 0 || ${d} >= ${n[s]}) {\n            ${l?"coefs[i + 1] = 0.0;\n                        continue;":o?`return ${u};`:`${d} = max(0, min(${d}, ${n[s]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",s,`u32(${d})`)};\n          data[i + 1] = ${s===p?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${f(p)};\n    ${f(h)};\n  fn getCubicInterpolationCoefs(s: ${c}) -> array<${c}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${c}, 4> = array<${c}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${c} = 1.0 - absS;\n    var twoMinusAbsS: ${c} = 2.0 - absS;\n    var onePlusAbsS: ${c} = 1.0 + absS;\n    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};\n    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${c}, 4>, coefs: array<${c}, 4>) -> ${c} {\n    var coefsSum: ${c} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${c} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},_u=(e,t,n,i,r)=>{let[a,s,o,u,l]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",s,`max(0, min(depth, ${n[s]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};\n      ${e.indicesSet("input_indices",u,`max(0, min(width, ${n[u]} - 1))`)};\n      ${fu(e,l,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${d} = originalIndices[${s}];\n      var height:${d} = originalIndices[${o}];\n      var width:${d} = originalIndices[${u}];\n      ${i?`if (depth < 0 || depth > (${n[s]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[u]} - 1)) {\n      return ${r};\n        }`:""};\n\n    depth = max(0, min(depth, ${n[s]} - 1));\n      height = max(0, min(height, ${n[o]} - 1));\n      width = max(0, min(width, ${n[u]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${l}])`:"0"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${d} = abs(depth - ${d}(depth1));\n      var dx2: ${d} = abs(${d}(depth2) - depth);\n      var dy1: ${d} = abs(height - ${d}(height1));\n      var dy2: ${d} = abs(${d}(height2) - height);\n      var dz1: ${d} = abs(width - ${d}(width1));\n      var dz2: ${d} = abs(${d}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},yu=(e,t,n,i,r,a)=>{let s=e.dims,o=uu(a,t.axes,s.length),u=lu(s,i,r,t.axes),l=i.slice();0===i.length&&(l=s.map((e,t)=>0===e?1:u[t]/e),"stretch"!==t.keepAspectRatioPolicy&&(u=du(s,l,t)));let d=Xt("output",e.dataType,u.length),p=Qt("input",e.dataType,s.length),h=ut.size(u),c=s.length===u.length&&s.every((e,t)=>e===u[t]),f="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,g=p.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?"cubic"===t.mode?l:l.length:""}|${r.length>0?r:""}|${o.length>0?o:""}|${c}|${"nearest"===t.mode?s.length:s}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${c?"":`\n      ${su(t.coordinateTransformMode,g)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${cu(p,s)};\n              ${ou(t.nearestMode,n,g)};\n              ${hu(p,d,s,u,l.length,o.length,f)};\n              `;case"linear":return`\n              ${pu(d,s,u,l.length,o.length)};\n              ${(()=>{if(2===s.length||4===s.length)return`${mu(p,d,s,f,m)}`;if(3===s.length||5===s.length)return`${_u(p,d,s,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===s.length||4===s.length)return`${gu(p,d,s,u,l,o,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",l.length).registerUniform("roi","f32",o.length).declareVariables(p,d)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${c?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${p.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${p.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===s.length||4===s.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:l},{type:1,data:o},...Gt(s,u)]})}},$u=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},wu=(e,t)=>{let n=[],i=[],r=[],a=$u(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");ru(e.inputs,t,a,n,i,r),e.compute(yu(e.inputs[0],t,a,n,i,r),{inputs:[0]})},bu=e=>{let t=e.antialias,n=e.axes,i=e.coordinateTransformMode,r=e.cubicCoeffA,a=0!==e.excludeOutside,s=e.extrapolationValue,o=e.keepAspectRatioPolicy,u=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return Pt({antialias:t,axes:n,coordinateTransformMode:i,cubicCoeffA:r,excludeOutside:a,extrapolationValue:s,keepAspectRatioPolicy:o,mode:u,nearestMode:l})}}),id=N(()=>{Ju(),nl(),ll(),vu=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],i=e[2];if(t.dataType!==n.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let r=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==a)throw new Error("Skip must have the same sequence length as input");if(1!==i.dims.length)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},xu=(e,t,n,i)=>{let r=t.simplified,a=e[0].dims,s=ut.size(a),o=a,u=s,l=a.slice(-1)[0],d=i?a.slice(0,-1).concat(1):[],p=!r&&e.length>3,h=e.length>4,c=i&&n>1,f=i&&n>2,m=n>3,g=Wt(l),_=[{type:12,data:u},{type:12,data:g},{type:12,data:l},{type:1,data:t.epsilon}],y=[{dims:o,dataType:e[0].dataType}];return n>1&&y.push({dims:d,dataType:1}),n>2&&y.push({dims:d,dataType:1}),n>3&&y.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${c};${f};${m}`,inputDependencies:e.map((e,t)=>"type")},getShaderSource:t=>{let n=[Qt("x",e[0].dataType,e[0].dims,g),Qt("skip",e[1].dataType,e[1].dims,g),Qt("gamma",e[2].dataType,e[2].dims,g)];p&&n.push(Qt("beta",e[3].dataType,e[3].dims,g)),h&&n.push(Qt("bias",e[4].dataType,e[4].dims,g)),n.push(Xt("output",e[0].dataType,o,g)),c&&n.push(Xt("mean_output",1,d)),f&&n.push(Xt("inv_std_output",1,d)),m&&n.push(Xt("input_skip_bias_sum",e[0].dataType,o,g));let i=Vt(e[0].dataType),a=Vt(1,g);return`\n\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\n      var<workgroup> sum_shared : array<${a}, 64>;\n      var<workgroup> sum_squared_shared : array<${a}, 64>;\n\n      ${t.mainStart([64,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / 64;\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / 64;\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == 63) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h?"bias[offset1d + i]":i+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${m?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${Ft(i,g,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = 64;\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Kt("sum",g)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Kt("square_sum",g)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);\n        ${c?"mean_output[global_idx] = mean;":""}\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${r?"":`- ${i}(mean)`}) *\n            ${i}(inv_std_dev) * gamma[offset1d + i]\n            ${p?"+ beta[offset1d + i]":""};\n        }\n      }`},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(u/l)},programUniforms:_})}},ku=(e,t)=>{vu(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(xu(e.inputs,t,e.outputCount,!1),{outputs:n})}}),rd=N(()=>{Ju(),nl(),ul(),ll(),Su=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)})},Iu=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach(e=>n.push(Number(e)));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach(e=>n.push(Number(e)))}return n},Tu=(e,t)=>{if(e.length>1){let t=Iu(e,1),n=Iu(e,2),i=Iu(e,3);return 0===i.length&&(i=[...Array(e[0].dims.length).keys()]),Pt({starts:t,ends:n,axes:i})}return t},Eu=(e,t,n,i,r)=>{let a=e;return e<0&&(a+=n[i[t]]),r[t]<0?Math.max(0,Math.min(a,n[i[t]]-1)):Math.max(0,Math.min(a,n[i[t]]))},zu=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length-1}; i >= 0; i--) {\n            let input_shape_i = ${jt("uniforms.input_shape","i",n.length)};\n            let steps_i = ${jt("uniforms.steps","i",n.length)};\n            let signs_i = ${jt("uniforms.signs","i",n.length)};\n            let starts_i = ${jt("uniforms.starts","i",n.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Cu=(e,t)=>{let n=e[0].dims,i=ut.size(n),r=t.axes.length>0?ut.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=Iu(e,4);a.forEach(e=>0!==e||(()=>{throw new Error("step cannot be 0")})),0===a.length&&(a=Array(r.length).fill(1));let s=t.starts.map((e,t)=>Eu(e,t,n,r,a)),o=t.ends.map((e,t)=>Eu(e,t,n,r,a));if(r.length!==s.length||r.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==n.length)for(let e=0;e<n.length;++e)r.includes(e)||(s.splice(e,0,0),o.splice(e,0,n[e]),a.splice(e,0,1));let u=a.map(e=>Math.sign(e));a.forEach((e,t,n)=>{if(e<0){let i=(o[t]-s[t])/e,r=s[t],u=r+i*a[t];s[t]=u,o[t]=r,n[t]=-e}});let l=n.slice(0);r.forEach((e,t)=>{l[e]=Math.ceil((o[e]-s[e])/a[e])});let d={dims:l,dataType:e[0].dataType},p=Xt("output",e[0].dataType,l.length),h=Qt("input",e[0].dataType,e[0].dims.length),c=ut.size(l),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:s.length},{name:"signs",type:"i32",length:u.length},{name:"steps",type:"u32",length:a.length}],m=[{type:12,data:c},{type:12,data:s},{type:6,data:u},{type:12,data:a},...Gt(e[0].dims,l)];return{name:"Slice",shaderCache:{hint:`${u.length}_${s.length}_${a.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${e.registerUniforms(f).declareVariables(h,p)}\n        ${zu(h,p,n)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${p.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${p.setByOffset("global_idx",h.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:m})}},Ou=(e,t)=>{Su(e.inputs,t);let n=Tu(e.inputs,t);e.compute(Cu(e.inputs,n),{inputs:[0]})},Au=e=>{let t=e.starts,n=e.ends,i=e.axes;return Pt({starts:t,ends:n,axes:i})}}),ad=N(()=>{Ju(),nl(),ul(),dl(),ll(),Bu=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},Ru=(e,t)=>{let n,i=e.inputs[0],r=i.dims,a=ut.size(r),s=r.length,o=ut.normalizeAxis(t.axis,s),u=o<r.length-1,l=[];u?(l=Array.from({length:s},(e,t)=>t),l[o]=s-1,l[s-1]=o,n=e.compute(ln(i,l),{inputs:[i],outputs:[-1]})[0]):n=i;let d=n.dims,p=d[s-1],h=a/p,c=Wt(p),f=p/c,m=64;1===h&&(m=256);let g=Qt("x",n.dataType,n.dims,c),_=Xt("result",n.dataType,n.dims,c),y=g.type.value,$="f32"===Vt(n.dataType)?`var threadMax = ${y}(-3.402823e+38f);`:`var threadMax = ${y}(-65504.0h);`,w=e.compute({name:"Softmax",shaderCache:{hint:`${c};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:d,dataType:n.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${y};\n      var<workgroup> rowSumShared : ${y};\n      var<workgroup> threadShared : array<${y}, ${m}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${y} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${y}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${e.registerUniform("packedCols","i32").declareVariables(g,_)}\n      ${e.mainStart(m)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${m};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${$}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${y}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",c)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${y}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${y}(${Kt("threadShared[0]",c)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          // max operation protects against NaN since all values should be >=0\n          value = max(value, ${y}(0.0));\n          setValue(row, col, row_stride, value);\n        }\n      }`},{inputs:[n],outputs:[u?-1:0]})[0];u&&e.compute(ln(w,l),{inputs:[w]})},Du=(e,t)=>{Bu(e.inputs),Ru(e,t)},Mu=e=>Pt({axis:e.axis})}),sd=N(()=>{Ju(),nl(),ll(),Uu=e=>Array.from(e.getBigInt64Array(),Number),Pu=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Uu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Nu=(e,t)=>{let n=[];for(let i=0;i<e.length;++i)n.push(e[i]*t[i]);return n},qu=(e,t)=>{let n=e[0].dims,i=t??Uu(e[1]),r=Nu(n,i),a=ut.size(r),s=e[0].dataType,o=Qt("input",s,n.length),u=Xt("output",s,r.length);return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Gt(e[0].dims,r)]}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...n)};\n      ${e.registerUniform("output_size","u32").declareVariables(o,u)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${u.offsetToIndices("global_idx")};\n      var input_indices: ${o.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${u.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${o.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${u.setByOffset("global_idx",o.getByIndices("input_indices"))}\n    }`}},Vu=e=>{Pu(e.inputs),e.compute(qu(e.inputs),{inputs:[0]})}}),od=N(()=>{Ju(),nl(),ll(),Lu=(e,t,n,i,r)=>{let a,s=Xt("output_data",r,n.length,4),o=Qt("a_data",t[1].dataType,t[1].dims.length,4),u=Qt("b_data",t[2].dataType,t[2].dims.length,4),l=Qt("c_data",t[0].dataType,t[0].dims.length,4),d=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(i){let e=(e,t,n="")=>{let i=`a_data[index_a${t}][component_a${t}]`,r=`b_data[index_b${t}][component_b${t}]`,a=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\n            let output_indices${t} = ${s.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offset_a${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,s)};\n            let offset_b${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,s)};\n            let offset_c${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,s)};\n            let index_a${t} = offset_a${t} / 4u;\n            let index_b${t} = offset_b${t} / 4u;\n            let index_c${t} = offset_c${t} / 4u;\n            let component_a${t} = offset_a${t} % 4u;\n            let component_b${t} = offset_b${t} % 4u;\n            let component_c${t} = offset_c${t} % 4u;\n            ${e}[${t}] = ${n}(${d(i,r,a)});\n          `};a=9===r?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("output_data[global_idx]",0)}\n            ${e("output_data[global_idx]",1)}\n            ${e("output_data[global_idx]",2)}\n            ${e("output_data[global_idx]",3)}\n          `}else a=s.setByOffset("global_idx",d(o.getByOffset("global_idx"),u.getByOffset("global_idx"),l.getByOffset("global_idx")));return`\n        ${e.registerUniform("vec_size","u32").declareVariables(l,o,u,s)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${a}\n      }`},Gu=e=>{let t=e[1].dims,n=e[2].dims,i=e[0].dims,r=e[1].dataType,a=!(ut.areEqual(t,n)&&ut.areEqual(n,i)),s=t,o=ut.size(t);if(a){let e=ot.calcShape(ot.calcShape(t,n,!1),i,!1);if(!e)throw new Error("Can't perform where op on the given tensors");s=e,o=ut.size(s)}let u=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>Lu(t,e,s,a,r),getRunData:()=>({outputs:[{dims:s,dataType:r}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:u},...Gt(i,t,n,s)]})}},Wu=e=>{e.compute(Gu(e.inputs))}}),ud=N(()=>{cl(),fl(),ml(),gl(),yl(),$l(),wl(),zl(),Ol(),Al(),Bl(),Rl(),Dl(),Ml(),Ul(),Pl(),Nl(),ql(),Vl(),Ll(),Fl(),Kl(),jl(),Zl(),Ql(),Gl(),Xl(),Yl(),Jl(),ed(),td(),hl(),nd(),Hl(),id(),rd(),ad(),Wl(),sd(),dl(),_l(),od(),Hu=new Map([["Abs",[Ii]],["Acos",[Ti]],["Acosh",[Ei]],["Add",[br]],["ArgMax",[oi,ui]],["ArgMin",[si,ui]],["Asin",[zi]],["Asinh",[Ci]],["Atan",[Oi]],["Atanh",[Ai]],["Attention",[gi]],["AveragePool",[Mo,Do]],["BatchNormalization",[wi]],["BiasAdd",[xi]],["BiasSplitGelu",[_r]],["Cast",[Ri,Bi]],["Ceil",[Ui]],["Clip",[Mi]],["Concat",[Dr,Mr]],["Conv",[wa,ga]],["ConvTranspose",[Ca,Ia]],["Cos",[Pi]],["Cosh",[Ni]],["CumSum",[Aa,Ba]],["DepthToSpace",[Ua,Pa]],["DequantizeLinear",[Ko,jo]],["Div",[vr]],["Einsum",[Ka,ja]],["Elu",[Vi,qi]],["Equal",[xr]],["Erf",[Gi]],["Exp",[Wi]],["Expand",[Ja]],["FastGelu",[ts]],["Floor",[Hi]],["FusedConv",[wa,ga]],["Gather",[as,rs]],["GatherElements",[gs,ms]],["GatherBlockQuantized",[ps,hs]],["GatherND",[os,us]],["Gelu",[Fi]],["Gemm",[ws,$s]],["GlobalAveragePool",[No,Po]],["GlobalMaxPool",[Wo,Go]],["Greater",[Tr]],["GreaterOrEqual",[zr]],["GridSample",[As,Bs]],["GroupQueryAttention",[to]],["HardSigmoid",[er,Ji]],["InstanceNormalization",[ao]],["LayerNormalization",[uo]],["LeakyRelu",[Ki,qi]],["Less",[Er]],["LessOrEqual",[Cr]],["Log",[pr]],["MatMul",[po]],["MatMulNBits",[mo,go]],["MaxPool",[Vo,Lo]],["Mul",[kr]],["MultiHeadAttention",[qs,Ms]],["Neg",[Zi]],["Not",[ji]],["Pad",[So]],["Pow",[Sr]],["QuickGelu",[fr,qi]],["Range",[Xo]],["Reciprocal",[Qi]],["ReduceMin",[ei]],["ReduceMean",[Zn]],["ReduceMax",[Jn]],["ReduceSum",[ni]],["ReduceProd",[ti]],["ReduceL1",[Qn]],["ReduceL2",[Xn]],["ReduceLogSum",[ri]],["ReduceLogSumExp",[Yn]],["ReduceSumSquare",[ii]],["Relu",[Xi]],["Resize",[wu,bu]],["RotaryEmbedding",[Qs]],["ScatterND",[tu,eu]],["Sigmoid",[Yi]],["Sin",[tr]],["Sinh",[nr]],["Slice",[Ou,Au]],["SkipLayerNormalization",[ku]],["Split",[Fs,Ks]],["Sqrt",[ir]],["Softmax",[Du,Mu]],["Sub",[Ir]],["Tan",[rr]],["Tanh",[sr]],["ThresholdedRelu",[dr,qi]],["Tile",[Vu]],["Transpose",[dn,pn]],["Where",[Wu]]])}),ld=N(()=>{oe(),tl(),ll(),Fu=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,i,r){E(e.programInfo.name);let a=this.backend.device,s=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let o=[];for(let e of t)o.push({binding:o.length,resource:{buffer:e.buffer}});for(let e of n)o.push({binding:o.length,resource:{buffer:e.buffer}});r&&o.push({binding:o.length,resource:r});let u=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:u,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}s.setPipeline(e.computePipeline),s.setBindGroup(0,u),s.dispatchWorkgroups(...i),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),z(e.programInfo.name)}dispose(){}build(e,t){E(e.name);let n=this.backend.device,i=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(e=>{n.features.has(e.feature)&&i.push(`enable ${e.extension};`)});let r=tn(t,this.backend.device.limits),a=e.getShaderSource(r),s=`${i.join("\n")}\n${r.additionalImplementations}\n${a}`,o=n.createShaderModule({code:s,label:e.name});at("verbose",()=>`[WebGPU] ${e.name} shader code: ${s}`);let u=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return z(e.name),{programInfo:e,computePipeline:u,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,i="number"==typeof e?1:e.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=r&&n<=r&&i<=r)return[t,n,i];let a=t*n*i,s=Math.ceil(Math.sqrt(a));if(s>r){if(s=Math.ceil(Math.cbrt(a)),s>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[s,s,s]}return[s,s,1]}}}),dd={};q(dd,{WebGpuBackend:()=>fd});var pd,hd,cd,fd,md=N(()=>{oe(),Ju(),tl(),il(),ol(),ud(),ld(),pd=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let i=0;i<e.length;++i){let r=e[i].dataType;switch(t[i]){case"none":n.push("");break;case"type":n.push(`${r}`);break;case"rank":{let t=e[i].dims.length;n.push(`${r};${t}`);break}case"dims":{let t=e[i].dims.join(",");n.push(`${r};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return n.join("|")},hd=(e,t,n)=>{let i=e.name;return e.shaderCache?.hint&&(i+="["+e.shaderCache.hint+"]"),i+=":"+n+`:${pd(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,i},cd=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},fd=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},r=e=>t.features.has(e)&&n.push(e)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups"),this.device=await t.requestDevice(i),this.adapterInfo=new cd(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Mt(this),this.programManager=new Fu(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,it(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;E(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then(()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let i=n[e],r=i.kernelId,a=this.kernels.get(r),s=a.kernelType,o=a.kernelName,u=i.programName,l=i.inputTensorViews,d=i.outputTensorViews,p=t[2*e],h=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=p);let c=Number(p-this.queryTimeBase),f=Number(h-this.queryTimeBase);if(!Number.isSafeInteger(c)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:l.map(e=>({dims:e.dims,dataType:He(e.dataType)})),outputsMetadata:d.map(e=>({dims:e.dims,dataType:He(e.dataType)})),kernelId:r,kernelType:s,kernelName:o,programName:u,startTime:c,endTime:f});else{let e="";l.forEach((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${He(t.dataType)}, `});let t="";d.forEach((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${He(e.dataType)}, `}),console.log(`[profiling] kernel "${r}|${s}|${o}|${u}" ${e}${t}start time: ${c} ns, execution time: ${f-c} ns`)}I("GPU",`${u}::${p}::${h}`)}e.unmap(),this.pendingQueries.delete(e)}),z()}run(e,t,n,i,r,a){E(e.name);let s=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let i=this.gpuDataManager.get(n);if(!i)throw new Error(`no GPU data for input: ${n}`);s.push(i)}let{outputs:o,dispatchGroup:u,programUniforms:l}=e.getRunData(t),d=0===n.length?o.map((e,t)=>t):n;if(d.length!==o.length)throw new Error(`Output size ${d.length} must be equal to ${o.length}.`);let p,h=[],c=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(d[e])||d[e]<-3||d[e]>=a)throw new Error(`Invalid output index: ${d[e]}`);if(-3===d[e])continue;let t=-1===d[e],n=-2===d[e],s=t||n?r(o[e].dataType,o[e].dims):i(d[e],o[e].dataType,o[e].dims);if(h.push(s),0===s.data)continue;let u=this.gpuDataManager.get(s.data);if(!u)throw new Error(`no GPU data for output: ${s.data}`);if(t&&this.temporaryData.push(u),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(u)}c.push(u)}if(s.length!==t.length||c.length!==h.length){if(0===c.length)return z(e.name),h;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(l){let e=0,t=[];l.forEach(n=>{let i="number"==typeof n.data?[n.data]:n.data;if(0===i.length)return;let r,a,s=10===n.type?2:4;10===n.type?(a=i.length>4?16:i.length>2?8:i.length*s,r=i.length>4?16:s*i.length):(a=i.length<=2?i.length*s:16,r=16),e=Math.ceil(e/a)*a,t.push(e);let o=10===n.type?8:4;e+=i.length>4?Math.ceil(i.length/o)*r:i.length*s});let n=16;e=Math.ceil(e/n)*n;let i=new ArrayBuffer(e);l.forEach((e,n)=>{let r=t[n],a="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(i,r,a.length).set(a);else if(12===e.type)new Uint32Array(i,r,a.length).set(a);else if(10===e.type)new Uint16Array(i,r,a.length).set(a);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${He(e.type)}`);new Float32Array(i,r,a.length).set(a)}});let r=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(r.buffer,0,i,0,e),this.gpuDataManager.release(r.id),p={offset:0,size:e,buffer:r.buffer}}let f=this.programManager.normalizeDispatchGroupSize(u),m=1===f[1]&&1===f[2],g=hd(e,t,m),_=this.programManager.getArtifact(g);if(_||(_=this.programManager.build(e,f),this.programManager.setArtifact(g,_),at("info",()=>`[artifact] key: ${g}, programName: ${e.name}`)),l&&_.uniformVariablesInfo){if(l.length!==_.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${_.uniformVariablesInfo.length}, got ${l.length} in program "${_.programInfo.name}".`);for(let e=0;e<l.length;e++){let t=l[e],n=t.type,i="number"==typeof t.data?1:t.data.length,[r,a]=_.uniformVariablesInfo[e];if(n!==r||i!==a)throw new Error(`Uniform variable ${e} mismatch: expect type ${r} with size ${a}, got type ${n} with size ${i} in program "${_.programInfo.name}".`)}}if(at("info",()=>`[ProgramManager] run "${e.name}" (key=${g}) with ${f[0]}x${f[1]}x${f[2]}`),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:_.programInfo.name,inputTensorViews:t,outputTensorViews:h};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(_,s,c,f,p),z(e.name),h}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,i){let r=Hu.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);let a={kernelType:e,kernelName:i,kernelEntry:r[0],attributes:[r[1],n]};this.kernels.set(t,a)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let i=this.kernels.get(e);if(!i)throw new Error(`kernel not created: ${e}`);let r=i.kernelType,a=i.kernelName,s=i.kernelEntry,o=i.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${r}] ${a}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),at("info",()=>`[WebGPU] Start to run kernel "[${r}] ${a}"...`);let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),s(t,o[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${a}" failed. ${e}`)),1}finally{u&&n.push(this.device.popErrorScope().then(e=>e?`GPU validation error for kernel "[${r}] ${a}": ${e.message}`:null));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,i){let r=this.sessionExternalDataMapping.get(e);r||(r=new Map,this.sessionExternalDataMapping.set(e,r));let a=r.get(t),s=this.gpuDataManager.registerExternalBuffer(n,i,a);return r.set(t,[s,n]),s}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(e=>this.gpuDataManager.unregisterExternalBuffer(e[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let i=await Rt(this,e,t);return ct(i.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){at("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){at("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){at("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let i=0;i<n;i++){let n=this.getComputePassEncoder(),r=e[i];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(r.computePipeline),n.setBindGroup(0,r.bindGroup),n.dispatchWorkgroups(...r.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),gd={};q(gd,{init:()=>$d});var _d,yd,$d,wd,bd,vd,xd,kd,Sd,Id,Td,Ed,zd,Cd,Od,Ad,Bd,Rd,Dd,Md,Ud,Pd,Nd,qd,Vd,Ld,Gd,Wd,Hd,Fd,Kd,jd,Zd,Qd,Xd,Yd,Jd,ep=N(()=>{Ju(),tl(),nl(),al(),_d=class e{constructor(e,t,n,i){this.module=e,this.dataType=t,this.data=n,this.dims=i}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=ut.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(ut.size(t)!==ut.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},yd=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let i=e.PTR_SIZE,r=n/e.PTR_SIZE,a=4===i?"i32":"i64";this.opKernelContext=Number(e.getValue(i*r++,a));let s=Number(e.getValue(i*r++,a));this.outputCount=Number(e.getValue(i*r++,a)),this.customDataOffset=Number(e.getValue(i*r++,"*")),this.customDataSize=Number(e.getValue(i*r++,a));let o=[];for(let t=0;t<s;t++){let t=Number(e.getValue(i*r++,a)),n=Number(e.getValue(i*r++,"*")),s=Number(e.getValue(i*r++,a)),u=[];for(let t=0;t<s;t++)u.push(Number(e.getValue(i*r++,a)));o.push(new _d(e,t,n,u))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map(e=>"number"==typeof e?this.inputs[e]:e)??this.inputs,i=t?.outputs??[];return this.backend.run(e,n,i,(e,t,n)=>new _d(this.module,t,this.output(e,n),n),(e,t)=>{let n=Fe(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let i=n>0?this.backend.gpuDataManager.create(n).id:0;return new _d(this.module,e,i,t)},this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,i=4===n?"i32":"i64",r=this.module.stackAlloc((1+t.length)*n);this.module.setValue(r,t.length,i);for(let e=0;e<t.length;e++)this.module.setValue(r+n*(e+1),t[e],i);return this.module._JsepOutput(this.opKernelContext,e,r)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},$d=async(e,t,n,i)=>{let r=t.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new(0,(md(),V(dd)).WebGpuBackend);await e.initialize(n,i),r("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,i,r,a=!1)=>{if(a)at("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(i)}, size=${Number(r)}`),e.memcpy(Number(n),Number(i));else{at("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(i)}, size=${Number(r)}`);let a=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(r));e.upload(Number(i),a)}},async(n,i,r)=>{at("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${i}, size=${r}`),await e.download(Number(n),()=>t.HEAPU8.subarray(Number(i)>>>0,Number(i+r)>>>0))},(n,i,r)=>e.createKernel(n,Number(i),r,t.UTF8ToString(t._JsepGetNodeName(Number(i)))),t=>e.releaseKernel(t),(n,i,r,a)=>{at("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${r}, kernel=${n}, contextDataOffset=${i}`);let s=new yd(t,e,Number(i));return e.computeKernel(Number(n),s,a)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new Tt(n);r("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,i,r,a)=>e.ensureTensor(t,n,i,r,a),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n),(t,n)=>e.registerMLContext(t,n),!!n.trace])}}}),tp=N(()=>{oe(),Xu(),Yu(),Ju(),Zu(),Qu(),el(),wd=(e,t)=>{0!==Be()._OrtInit(e,t)&&Me("Can't initialize onnxruntime.")},bd=async e=>{wd(e.wasm.numThreads,je(e.logLevel))},vd=async(e,t)=>{Be().asyncInit?.();let n=e.webgpu.adapter;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(n){if("object"!=typeof n.limits||"object"!=typeof n.features||"function"!=typeof n.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let t=e.webgpu.powerPreference;if(void 0!==t&&"low-power"!==t&&"high-performance"!==t)throw new Error(`Invalid powerPreference setting: "${t}"`);let i=e.webgpu.forceFallbackAdapter;if(void 0!==i&&"boolean"!=typeof i)throw new Error(`Invalid forceFallbackAdapter setting: "${i}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:t,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===t&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");{let i=(ep(),V(gd)).init;"webgpu"===t&&await i("webgpu",Be(),e,n),"webnn"===t&&await i("webnn",Be(),e)}},xd=new Map,kd=e=>{let t=Be(),n=t.stackSave();try{let n=t.PTR_SIZE,i=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,i,i+n)&&Me("Can't get session input/output count.");let r=4===n?"i32":"i64";return[Number(t.getValue(i,r)),Number(t.getValue(i+n,r))]}finally{t.stackRestore(n)}},Sd=(e,t)=>{let n=Be(),i=n.stackSave(),r=0;try{let i=n.PTR_SIZE,a=n.stackAlloc(2*i);0!==n._OrtGetInputOutputMetadata(e,t,a,a+i)&&Me("Can't get session input/output metadata.");let s=Number(n.getValue(a,"*"));r=Number(n.getValue(a+i,"*"));let o=n.HEAP32[r/4];if(0===o)return[s,0];let u=n.HEAPU32[r/4+1],l=[];for(let e=0;e<u;e++){let t=Number(n.getValue(r+8+e*i,"*"));l.push(0!==t?n.UTF8ToString(t):Number(n.getValue(r+8+(e+u)*i,"*")))}return[s,o,l]}finally{n.stackRestore(i),0!==r&&n._OrtFree(r)}},Id=e=>{let t=Be(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Td=async(e,t)=>{let n,i,r=Be();Array.isArray(e)?[n,i]=e:e.buffer===r.HEAPU8.buffer?[n,i]=[e.byteOffset,e.byteLength]:[n,i]=Id(e);let a=0,s=0,o=0,u=[],l=[],d=[];try{if([s,u]=await Ge(t),t?.externalData&&r.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(Ye("string"==typeof n?n:n.data).then(e=>{r.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(r.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,i=t?.gpuDevice,a=t?.deviceType,s=t?.powerPreference;r.currentContext=n||(i?await r.webnnCreateMLContext(i):await r.webnnCreateMLContext({deviceType:a,powerPreference:s}))}else r.currentContext=await r.webnnCreateMLContext();break}a=await r._OrtCreateSession(n,i,s),r.webgpuOnCreateSession?.(a),0===a&&Me("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.webnnRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[e,p]=kd(a),h=!!t?.enableGraphCapture,c=[],f=[],m=[],g=[],_=[];for(let t=0;t<e;t++){let[e,n,i]=Sd(a,t);0===e&&Me("Can't get an input name."),l.push(e);let s=r.UTF8ToString(e);c.push(s),m.push(0===n?{name:s,isTensor:!1}:{name:s,isTensor:!0,type:He(n),shape:i})}for(let n=0;n<p;n++){let[i,s,o]=Sd(a,n+e);0===i&&Me("Can't get an output name."),d.push(i);let u=r.UTF8ToString(i);f.push(u),g.push(0===s?{name:u,isTensor:!1}:{name:u,isTensor:!0,type:He(s),shape:o});{if(h&&void 0===t?.preferredOutputLocation){_.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[u]??"cpu",n=r.webnnIsGraphOutput;if("cpu"===e&&n&&n(a,u)){_.push("ml-tensor-cpu-output");continue}if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(h&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);_.push(e)}}let y=null;return _.some(e=>"gpu-buffer"===e||"ml-tensor"===e||"ml-tensor-cpu-output"===e)&&(o=r._OrtCreateBinding(a),0===o&&Me("Can't create IO binding."),y={handle:o,outputPreferredLocations:_,outputPreferredLocationsEncoded:_.map(e=>"ml-tensor-cpu-output"===e?"ml-tensor":e).map(e=>Xe(e))}),xd.set(a,[a,l,d,y,h,!1]),[a,c,f,m,g]}catch(e){throw l.forEach(e=>r._OrtFree(e)),d.forEach(e=>r._OrtFree(e)),0!==o&&0!==r._OrtReleaseBinding(o)&&Me("Can't release IO binding."),0!==a&&0!==r._OrtReleaseSession(a)&&Me("Can't release session."),e}finally{r._free(n),0!==s&&0!==r._OrtReleaseSessionOptions(s)&&Me("Can't release session options."),u.forEach(e=>r._free(e)),r.unmountExternalData?.()}},Ed=e=>{let t=Be(),n=xd.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,r,a,s,o]=n;s&&(o&&0!==t._OrtClearBoundOutputs(s.handle)&&Me("Can't clear bound outputs."),0!==t._OrtReleaseBinding(s.handle)&&Me("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),r.forEach(e=>t._OrtFree(e)),a.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(i)&&Me("Can't release session."),xd.delete(e)},zd=async(e,t,n,i,r,a,s=!1)=>{if(!e)return void t.push(0);let o,u,l=Be(),d=l.PTR_SIZE,p=e[0],h=e[1],c=e[3],f=c;if("string"===p&&("gpu-buffer"===c||"ml-tensor"===c))throw new Error("String tensor is not supported on GPU.");if(s&&"gpu-buffer"!==c)throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if("gpu-buffer"===c){let t=e[2].gpuBuffer;u=Fe(We(p),h);{let e=l.jsepRegisterBuffer;if(!e)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');o=e(i,a,t,u)}}else if("ml-tensor"===c){let t=e[2].mlTensor;u=Fe(We(p),h);let n=l.webnnRegisterMLTensor;if(!n)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');o=n(i,t,We(p),h)}else{let t=e[2];if(Array.isArray(t)){u=d*t.length,o=l._malloc(u),n.push(o);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(o+e*d,Re(t[e],n),"*")}}else{let e=l.webnnIsGraphInput,a=l.webnnIsGraphOutput;if("string"!==p&&e&&a){let s=l.UTF8ToString(r);if(e(i,s)||a(i,s)){let e=We(p);u=Fe(e,h),f="ml-tensor";let n=l.webnnCreateTemporaryTensor,r=l.webnnUploadTensor;if(!n||!r)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let a=await n(i,e,h);r(a,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),o=a}else u=t.byteLength,o=l._malloc(u),n.push(o),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),o)}else u=t.byteLength,o=l._malloc(u),n.push(o),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),o)}}let m=l.stackSave(),g=l.stackAlloc(4*h.length);try{h.forEach((e,t)=>l.setValue(g+t*d,e,4===d?"i32":"i64"));let e=l._OrtCreateTensor(We(p),o,u,g,h.length,Xe(f));0===e&&Me(`Can't create tensor for input/output. session=${i}, index=${a}.`),t.push(e)}finally{l.stackRestore(m)}},Cd=async(e,t,n,i,r,a)=>{let s=Be(),o=s.PTR_SIZE,u=xd.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let l=u[0],d=u[1],p=u[2],h=u[3],c=u[4],f=u[5],m=t.length,g=i.length,_=0,y=[],$=[],w=[],b=[],v=s.stackSave(),x=s.stackAlloc(m*o),k=s.stackAlloc(m*o),S=s.stackAlloc(g*o),I=s.stackAlloc(g*o);try{[_,y]=Ue(a),C("wasm prepareInputOutputTensor");for(let i=0;i<m;i++)await zd(n[i],$,b,e,d[t[i]],t[i],c);for(let t=0;t<g;t++)await zd(r[t],w,b,e,p[i[t]],m+i[t],c);O("wasm prepareInputOutputTensor");for(let e=0;e<m;e++)s.setValue(x+e*o,$[e],"*"),s.setValue(k+e*o,d[t[e]],"*");for(let e=0;e<g;e++)s.setValue(S+e*o,w[e],"*"),s.setValue(I+e*o,p[i[e]],"*");if(h&&!f){let{handle:n,outputPreferredLocations:a,outputPreferredLocationsEncoded:o}=h;if(d.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${d.length}).`);C("wasm bindInputsOutputs");for(let i=0;i<m;i++){let r=t[i];0!==await s._OrtBindInput(n,d[r],$[i])&&Me(`Can't bind input[${i}] for session=${e}.`)}for(let t=0;t<g;t++){let u=i[t];r[t]?.[3]?0!==s._OrtBindOutput(n,p[u],w[t],0)&&Me(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==s._OrtBindOutput(n,p[u],0,o[u])&&Me(`Can't bind output[${t}] to ${a[t]} for session=${e}.`)}O("wasm bindInputsOutputs"),xd.set(e,[l,d,p,h,c,!0])}let u;s.jsepOnRunStart?.(l),s.webnnOnRunStart?.(l),u=h?await s._OrtRunWithBinding(l,h.handle,g,S,_):await s._OrtRun(l,k,x,m,I,g,S,_),0!==u&&Me("failed to call OrtRun().");let v=[],T=[];C("wasm ProcessOutputTensor");for(let t=0;t<g;t++){let n=Number(s.getValue(S+t*o,"*"));if(n===w[t]){v.push(r[t]);continue}let a,u=s.stackSave(),l=s.stackAlloc(4*o),d=!1,p=0;try{0!==s._OrtGetTensorData(n,l,l+o,l+2*o,l+3*o)&&Me(`Can't access output tensor data on index ${t}.`);let r=4===o?"i32":"i64",u=Number(s.getValue(l,r));p=s.getValue(l+o,"*");let c=s.getValue(l+2*o,"*"),f=Number(s.getValue(l+3*o,r)),m=[];for(let e=0;e<f;e++)m.push(Number(s.getValue(c+e*o,r)));0!==s._OrtFree(c)&&Me("Can't free memory for tensor dims.");let g=m.reduce((e,t)=>e*t,1);a=He(u);let _=h?.outputPreferredLocations[i[t]];if("string"===a){if("gpu-buffer"===_||"ml-tensor"===_)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<g;t++){let n=s.getValue(p+t*o,"*"),i=s.getValue(p+(t+1)*o,"*"),r=t===g-1?void 0:i-n;e.push(s.UTF8ToString(n,r))}v.push([a,m,e,"cpu"])}else if("gpu-buffer"===_&&g>0){let e=s.jsepGetBuffer;if(!e)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(p),i=Fe(u,g);if(void 0===i||!Ze(a))throw new Error(`Unsupported data type: ${a}`);d=!0,v.push([a,m,{gpuBuffer:t,download:s.jsepCreateDownloader(t,i,a),dispose:()=>{0!==s._OrtReleaseTensor(n)&&Me("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===_&&g>0){let t=s.webnnEnsureTensor,i=s.webnnIsGraphInputOutputTypeSupported;if(!t||!i)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===Fe(u,g)||!Qe(a))throw new Error(`Unsupported data type: ${a}`);if(!i(e,a,!1))throw new Error(`preferredLocation "ml-tensor" for ${a} output is not supported by current WebNN Context.`);let r=await t(e,p,u,m,!1);d=!0,v.push([a,m,{mlTensor:r,download:s.webnnCreateMLTensorDownloader(p,a),dispose:()=>{s.webnnReleaseTensorId(p),s._OrtReleaseTensor(n)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===_&&g>0){let e=s.webnnCreateMLTensorDownloader(p,a)(),t=v.length;d=!0,T.push((async()=>{let i=[t,await e];return s.webnnReleaseTensorId(p),s._OrtReleaseTensor(n),i})()),v.push([a,m,[],"cpu"])}else{let e=new(Ke(a))(g);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(s.HEAPU8.subarray(p,p+e.byteLength)),v.push([a,m,e,"cpu"])}}finally{s.stackRestore(u),"string"===a&&p&&s._free(p),d||s._OrtReleaseTensor(n)}}h&&!c&&(0!==s._OrtClearBoundOutputs(h.handle)&&Me("Can't clear bound outputs."),xd.set(e,[l,d,p,h,c,!1]));for(let[e,t]of await Promise.all(T))v[e][2]=t;return O("wasm ProcessOutputTensor"),v}finally{s.webnnOnRunEnd?.(l),s.stackRestore(v),$.forEach(e=>s._OrtReleaseTensor(e)),w.forEach(e=>s._OrtReleaseTensor(e)),b.forEach(e=>s._free(e)),0!==_&&s._OrtReleaseRunOptions(_),y.forEach(e=>s._free(e))}},Od=e=>{let t=Be(),n=xd.get(e);if(!n)throw new Error("invalid session id");let i=n[0],r=t._OrtEndProfiling(i);0===r&&Me("Can't get an profile file name."),t._OrtFree(r)},Ad=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}}),np=N(()=>{oe(),tp(),Zu(),ju(),Bd=()=>!!l.wasm.proxy&&typeof document<"u",Dd=!1,Md=!1,Ud=!1,qd=new Map,Vd=(e,t)=>{let n=qd.get(e);n?n.push(t):qd.set(e,[t])},Ld=()=>{if(Dd||!Md||Ud||!Rd)throw new Error("worker not ready")},Gd=e=>{switch(e.data.type){case"init-wasm":Dd=!1,e.data.err?(Ud=!0,Nd[1](e.data.err)):(Md=!0,Nd[0]()),Pd&&(URL.revokeObjectURL(Pd),Pd=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=qd.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},Wd=async()=>{if(!Md){if(Dd)throw new Error("multiple calls to 'initWasm()' detected.");if(Ud)throw new Error("previous call to 'initWasm()' failed.");if(Dd=!0,Bd())return new Promise((e,t)=>{Rd?.terminate(),ve().then(([n,i])=>{try{(Rd=i).onerror=e=>t(e),Rd.onmessage=Gd,Nd=[e,t];let r={type:"init-wasm",in:l};if(!r.in.wasm.wasmPaths&&n){let e=me();e&&(r.in.wasm.wasmPaths=e)}Rd.postMessage(r),Pd=n}catch(e){t(e)}},t)});try{await Ae(l.wasm),await bd(l),Md=!0}catch(e){throw Ud=!0,e}finally{Dd=!1}}},Hd=async e=>{if(Bd())return Ld(),new Promise((t,n)=>{Vd("init-ep",[t,n]);let i={type:"init-ep",in:{epName:e,env:l}};Rd.postMessage(i)});await vd(l,e)},Fd=async e=>Bd()?(Ld(),new Promise((t,n)=>{Vd("copy-from",[t,n]);let i={type:"copy-from",in:{buffer:e}};Rd.postMessage(i,[e.buffer])})):Id(e),Kd=async(e,t)=>{if(Bd()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Ld(),new Promise((n,i)=>{Vd("create",[n,i]);let r={type:"create",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),Rd.postMessage(r,a)})}return Td(e,t)},jd=async e=>{if(Bd())return Ld(),new Promise((t,n)=>{Vd("release",[t,n]);let i={type:"release",in:e};Rd.postMessage(i)});Ed(e)},Zd=async(e,t,n,i,r,a)=>{if(Bd()){if(n.some(e=>"cpu"!==e[3]))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(e=>e))throw new Error("pre-allocated output tensor is not supported for proxy.");return Ld(),new Promise((r,s)=>{Vd("run",[r,s]);let o=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:i,options:a}};Rd.postMessage(u,Ad(o))})}return Cd(e,t,n,i,r,a)},Qd=async e=>{if(Bd())return Ld(),new Promise((t,n)=>{Vd("end-profiling",[t,n]);let i={type:"end-profiling",in:e};Rd.postMessage(i)});Od(e)}}),ip=N(()=>{oe(),np(),Ju(),ue(),el(),Xd=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Yd=e=>{switch(e[3]){case"cpu":return new S(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ze(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:i,dispose:r}=e[2];return S.fromGpuBuffer(n,{dataType:t,dims:e[1],download:i,dispose:r})}case"ml-tensor":{let t=e[0];if(!Qe(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:i,dispose:r}=e[2];return S.fromMLTensor(n,{dataType:t,dims:e[1],download:i,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},Jd=class{async fetchModelAndCopyToWasmMemory(e){return Fd(await Ye(e))}async loadModel(e,t){let n;E(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await Kd(n,t),z()}async dispose(){return jd(this.sessionId)}async run(e,t,n){E();let i=[],r=[];Object.entries(e).forEach(e=>{let t=e[0],n=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw new Error(`invalid input '${t}'`);i.push(n),r.push(a)});let a=[],s=[];Object.entries(t).forEach(e=>{let t=e[0],n=e[1],i=this.outputNames.indexOf(t);if(-1===i)throw new Error(`invalid output '${t}'`);a.push(n),s.push(i)});let o=i.map((e,t)=>Xd(e,()=>`input "${this.inputNames[r[t]]}"`)),u=a.map((e,t)=>e?Xd(e,()=>`output "${this.outputNames[s[t]]}"`):null),l=await Zd(this.sessionId,r,o,s,u,n),d={};for(let e=0;e<l.length;e++)d[this.outputNames[s[e]]]=a[e]??Yd(l[e]);return z(),d}startProfiling(){}endProfiling(){Qd(this.sessionId)}}}),rp={};q(rp,{OnnxruntimeWebAssemblyBackend:()=>sp,initializeFlags:()=>ap,wasmBackend:()=>op});var ap,sp,op,up=N(()=>{oe(),np(),ip(),ap=()=>{("number"!=typeof l.wasm.initTimeout||l.wasm.initTimeout<0)&&(l.wasm.initTimeout=0);let e=l.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),l.wasm.simd=!1),"boolean"!=typeof l.wasm.proxy&&(l.wasm.proxy=!1),"boolean"!=typeof l.wasm.trace&&(l.wasm.trace=!1),"number"!=typeof l.wasm.numThreads||!Number.isInteger(l.wasm.numThreads)||l.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)l.wasm.numThreads=1;else{let e=typeof navigator>"u"?P("node:os").cpus().length:navigator.hardwareConcurrency;l.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},op=new(sp=class{async init(e){ap(),await Wd(),await Hd(e)}async createInferenceSessionHandler(e,t){let n=new Jd;return await n.loadModel(e,t),n}})}),lp={};q(lp,{InferenceSession:()=>B,TRACE:()=>I,TRACE_EVENT_BEGIN:()=>C,TRACE_EVENT_END:()=>O,TRACE_FUNC_BEGIN:()=>E,TRACE_FUNC_END:()=>z,Tensor:()=>S,default:()=>dp,env:()=>l,registerBackend:()=>i}),oe(),oe(),oe();var dp=se;{let e=(up(),V(rp)).wasmBackend;i("webgpu",e,5),i("webnn",e,5),i("cpu",e,10),i("wasm",e,10)}return Object.defineProperty(l.versions,"web",{value:"1.23.2",enumerable:!0}),V(lp)})();e.exports=i},687:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=687,e.exports=t}},t={};function n(i){var r=t[i];if(void 0!==r)return r.exports;var a=t[i]={exports:{}};return e[i](a,a.exports,n),a.exports}n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";const e=n(603);!async function(){try{const t=await e.InferenceSession.create("./models/best.onnx"),n=Float32Array.from([1,2,3,4,5,6,7,8,9,10,11,12]),i=Float32Array.from([10,20,30,40,50,60,70,80,90,100,110,120]),r={a:new e.Tensor("float32",n,[3,4]),b:new e.Tensor("float32",i,[4,3])},a=(await t.run(r)).c.data;document.write(`data of result tensor 'c': ${a}`)}catch(e){document.write(`failed to inference ONNX model: ${e}.`)}}()})()})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxHQUFJLEdBQUksR0FBSSxJQUFLLElBQUssTUFJekVrMUMsRUFBUSxDQUFFbDZDLEVBSEEsSUFBSTFGLEVBQUlpUCxPQUFPLFVBQVd5d0MsRUFBTyxDQUFDLEVBQUcsSUFHekI5M0MsRUFGWixJQUFJNUgsRUFBSWlQLE9BQU8sVUFBVzB3QyxFQUFPLENBQUMsRUFBRyxLQU0vQ0UsU0FGZ0IvdEIsRUFBUXJrQixJQUFJbXlDLElBRVpyNEMsRUFBRU8sS0FDeEJwQixTQUFTK3ZCLE1BQU0sOEJBQThCb3BCLElBQ2pELENBQ0EsTUFBTy84QyxHQUNINEQsU0FBUyt2QixNQUFNLG1DQUFtQzN6QixLQUN0RCxDQUNKLENBQ0FnOUMsRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FyX3doZWVscy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQubWluLmpzIiwid2VicGFjazovL2FyX3doZWVscy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC8gc3luYyIsIndlYnBhY2s6Ly9hcl93aGVlbHMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vYXJfd2hlZWxzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vYXJfd2hlZWxzLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4yMy4yXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7dmFyIG9ydD0oKCk9Pnt2YXIgd249T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBWdT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBOdT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgTHU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgJG49KGU9PnR5cGVvZiByZXF1aXJlPFwidVwiP3JlcXVpcmU6dHlwZW9mIFByb3h5PFwidVwiP25ldyBQcm94eShlLHtnZXQ6KHQsbik9Pih0eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnQpW25dfSk6ZSkoZnVuY3Rpb24oZSl7aWYodHlwZW9mIHJlcXVpcmU8XCJ1XCIpcmV0dXJuIHJlcXVpcmUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3Rocm93IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgXCInK2UrJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKX0pO3ZhciBrPShlLHQpPT4oKT0+KGUmJih0PWUoZT0wKSksdCk7dmFyIG50PShlLHQpPT57Zm9yKHZhciBuIGluIHQpd24oZSxuLHtnZXQ6dFtuXSxlbnVtZXJhYmxlOiEwfSl9LFd1PShlLHQsbixyKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgbyBvZiBOdSh0KSkhTHUuY2FsbChlLG8pJiZvIT09biYmd24oZSxvLHtnZXQ6KCk9PnRbb10sZW51bWVyYWJsZTohKHI9VnUodCxvKSl8fHIuZW51bWVyYWJsZX0pO3JldHVybiBlfTt2YXIgZHQ9ZT0+V3Uod24oe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZSk7dmFyIHh0LGplLFdlLEd1LHlyLHZuPWsoKCk9PntcInVzZSBzdHJpY3RcIjt4dD1uZXcgTWFwLGplPVtdLFdlPShlLHQsbik9PntpZih0JiZ0eXBlb2YgdC5pbml0PT1cImZ1bmN0aW9uXCImJnR5cGVvZiB0LmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyPT1cImZ1bmN0aW9uXCIpe2xldCByPXh0LmdldChlKTtpZihyPT09dm9pZCAwKXh0LnNldChlLHtiYWNrZW5kOnQscHJpb3JpdHk6bn0pO2Vsc2V7aWYoci5wcmlvcml0eT5uKXJldHVybjtpZihyLnByaW9yaXR5PT09biYmci5iYWNrZW5kIT09dCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtlfVwiIHVzaW5nIHByaW9yaXR5ICR7bn1gKX1pZihuPj0wKXtsZXQgbz1qZS5pbmRleE9mKGUpO28hPT0tMSYmamUuc3BsaWNlKG8sMSk7Zm9yKGxldCBpPTA7aTxqZS5sZW5ndGg7aSsrKWlmKHh0LmdldChqZVtpXSkucHJpb3JpdHk8PW4pe2plLnNwbGljZShpLDAsZSk7cmV0dXJufWplLnB1c2goZSl9cmV0dXJufXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSB2YWxpZCBiYWNrZW5kXCIpfSxHdT1hc3luYyBlPT57bGV0IHQ9eHQuZ2V0KGUpO2lmKCF0KXJldHVyblwiYmFja2VuZCBub3QgZm91bmQuXCI7aWYodC5pbml0aWFsaXplZClyZXR1cm4gdC5iYWNrZW5kO2lmKHQuYWJvcnRlZClyZXR1cm4gdC5lcnJvcjt7bGV0IG49ISF0LmluaXRQcm9taXNlO3RyeXtyZXR1cm4gbnx8KHQuaW5pdFByb21pc2U9dC5iYWNrZW5kLmluaXQoZSkpLGF3YWl0IHQuaW5pdFByb21pc2UsdC5pbml0aWFsaXplZD0hMCx0LmJhY2tlbmR9Y2F0Y2gocil7cmV0dXJuIG58fCh0LmVycm9yPWAke3J9YCx0LmFib3J0ZWQ9ITApLHQuZXJyb3J9ZmluYWxseXtkZWxldGUgdC5pbml0UHJvbWlzZX19fSx5cj1hc3luYyBlPT57bGV0IHQ9ZS5leGVjdXRpb25Qcm92aWRlcnN8fFtdLG49dC5tYXAodT0+dHlwZW9mIHU9PVwic3RyaW5nXCI/dTp1Lm5hbWUpLHI9bi5sZW5ndGg9PT0wP2plOm4sbyxpPVtdLHM9bmV3IFNldDtmb3IobGV0IHUgb2Ygcil7bGV0IGQ9YXdhaXQgR3UodSk7dHlwZW9mIGQ9PVwic3RyaW5nXCI/aS5wdXNoKHtuYW1lOnUsZXJyOmR9KToob3x8KG89ZCksbz09PWQmJnMuYWRkKHUpKX1pZighbyl0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7aS5tYXAodT0+YFske3UubmFtZX1dICR7dS5lcnJ9YCkuam9pbihcIiwgXCIpfWApO2ZvcihsZXR7bmFtZTp1LGVycjpkfW9mIGkpbi5pbmNsdWRlcyh1KSYmY29uc29sZS53YXJuKGByZW1vdmluZyByZXF1ZXN0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyIFwiJHt1fVwiIGZyb20gc2Vzc2lvbiBvcHRpb25zIGJlY2F1c2UgaXQgaXMgbm90IGF2YWlsYWJsZTogJHtkfWApO2xldCBhPXQuZmlsdGVyKHU9PnMuaGFzKHR5cGVvZiB1PT1cInN0cmluZ1wiP3U6dS5uYW1lKSk7cmV0dXJuW28sbmV3IFByb3h5KGUse2dldDoodSxkKT0+ZD09PVwiZXhlY3V0aW9uUHJvdmlkZXJzXCI/YTpSZWZsZWN0LmdldCh1LGQpfSldfX0pO3ZhciBicj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dm4oKX0pO3ZhciBfcix3cj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3I9XCIxLjIzLjJcIn0pO3ZhciAkcixsZSx4bj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d3IoKTskcj1cIndhcm5pbmdcIixsZT17d2FzbTp7fSx3ZWJnbDp7fSx3ZWJncHU6e30sdmVyc2lvbnM6e2NvbW1vbjpfcn0sc2V0IGxvZ0xldmVsKGUpe2lmKGUhPT12b2lkIDApe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wifHxbXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKT09PS0xKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApOyRyPWV9fSxnZXQgbG9nTGV2ZWwoKXtyZXR1cm4gJHJ9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJsb2dMZXZlbFwiLHtlbnVtZXJhYmxlOiEwfSl9KTt2YXIgdGUsdnI9aygoKT0+e1widXNlIHN0cmljdFwiO3huKCk7dGU9bGV9KTt2YXIgeHIsU3IsVHI9aygoKT0+e1widXNlIHN0cmljdFwiO3hyPShlLHQpPT57bGV0IG49dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpO24ud2lkdGg9ZS5kaW1zWzNdLG4uaGVpZ2h0PWUuZGltc1syXTtsZXQgcj1uLmdldENvbnRleHQoXCIyZFwiKTtpZihyIT1udWxsKXtsZXQgbyxpO3Q/LnRlbnNvckxheW91dCE9PXZvaWQgMCYmdC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIj8obz1lLmRpbXNbMl0saT1lLmRpbXNbM10pOihvPWUuZGltc1szXSxpPWUuZGltc1syXSk7bGV0IHM9dD8uZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsYT10Py5ub3JtLHUsZDthPT09dm9pZCAwfHxhLm1lYW49PT12b2lkIDA/dT1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgYS5tZWFuPT1cIm51bWJlclwiP3U9W2EubWVhbixhLm1lYW4sYS5tZWFuLGEubWVhbl06KHU9W2EubWVhblswXSxhLm1lYW5bMV0sYS5tZWFuWzJdLDBdLGEubWVhblszXSE9PXZvaWQgMCYmKHVbM109YS5tZWFuWzNdKSksYT09PXZvaWQgMHx8YS5iaWFzPT09dm9pZCAwP2Q9WzAsMCwwLDBdOnR5cGVvZiBhLmJpYXM9PVwibnVtYmVyXCI/ZD1bYS5iaWFzLGEuYmlhcyxhLmJpYXMsYS5iaWFzXTooZD1bYS5iaWFzWzBdLGEuYmlhc1sxXSxhLmJpYXNbMl0sMF0sYS5iaWFzWzNdIT09dm9pZCAwJiYoZFszXT1hLmJpYXNbM10pKTtsZXQgbD1pKm8sYz0wLHA9bCxmPWwqMixtPS0xO3M9PT1cIlJHQkFcIj8oYz0wLHA9bCxmPWwqMixtPWwqMyk6cz09PVwiUkdCXCI/KGM9MCxwPWwsZj1sKjIpOnM9PT1cIlJCR1wiJiYoYz0wLGY9bCxwPWwqMik7Zm9yKGxldCBoPTA7aDxpO2grKylmb3IobGV0IGI9MDtiPG87YisrKXtsZXQgeT0oZS5kYXRhW2MrK10tZFswXSkqdVswXSxnPShlLmRhdGFbcCsrXS1kWzFdKSp1WzFdLF89KGUuZGF0YVtmKytdLWRbMl0pKnVbMl0sdz1tPT09LTE/MjU1OihlLmRhdGFbbSsrXS1kWzNdKSp1WzNdO3IuZmlsbFN0eWxlPVwicmdiYShcIit5K1wiLFwiK2crXCIsXCIrXytcIixcIit3K1wiKVwiLHIuZmlsbFJlY3QoYixoLDEsMSl9aWYoXCJ0b0RhdGFVUkxcImluIG4pcmV0dXJuIG4udG9EYXRhVVJMKCk7dGhyb3cgbmV3IEVycm9yKFwidG9EYXRhVVJMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfSxTcj0oZSx0KT0+e2xldCBuPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTpuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSkuZ2V0Q29udGV4dChcIjJkXCIpLHI7aWYobiE9bnVsbCl7bGV0IG8saSxzO3Q/LnRlbnNvckxheW91dCE9PXZvaWQgMCYmdC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIj8obz1lLmRpbXNbMl0saT1lLmRpbXNbMV0scz1lLmRpbXNbM10pOihvPWUuZGltc1szXSxpPWUuZGltc1syXSxzPWUuZGltc1sxXSk7bGV0IGE9dCE9PXZvaWQgMCYmdC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIix1PXQ/Lm5vcm0sZCxsO3U9PT12b2lkIDB8fHUubWVhbj09PXZvaWQgMD9kPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiB1Lm1lYW49PVwibnVtYmVyXCI/ZD1bdS5tZWFuLHUubWVhbix1Lm1lYW4sdS5tZWFuXTooZD1bdS5tZWFuWzBdLHUubWVhblsxXSx1Lm1lYW5bMl0sMjU1XSx1Lm1lYW5bM10hPT12b2lkIDAmJihkWzNdPXUubWVhblszXSkpLHU9PT12b2lkIDB8fHUuYmlhcz09PXZvaWQgMD9sPVswLDAsMCwwXTp0eXBlb2YgdS5iaWFzPT1cIm51bWJlclwiP2w9W3UuYmlhcyx1LmJpYXMsdS5iaWFzLHUuYmlhc106KGw9W3UuYmlhc1swXSx1LmJpYXNbMV0sdS5iaWFzWzJdLDBdLHUuYmlhc1szXSE9PXZvaWQgMCYmKGxbM109dS5iaWFzWzNdKSk7bGV0IGM9aSpvO2lmKHQhPT12b2lkIDAmJih0LmZvcm1hdCE9PXZvaWQgMCYmcz09PTQmJnQuZm9ybWF0IT09XCJSR0JBXCJ8fHM9PT0zJiZ0LmZvcm1hdCE9PVwiUkdCXCImJnQuZm9ybWF0IT09XCJCR1JcIikpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO2xldCBwPTQsZj0wLG09MSxoPTIsYj0zLHk9MCxnPWMsXz1jKjIsdz0tMTthPT09XCJSR0JBXCI/KHk9MCxnPWMsXz1jKjIsdz1jKjMpOmE9PT1cIlJHQlwiPyh5PTAsZz1jLF89YyoyKTphPT09XCJSQkdcIiYmKHk9MCxfPWMsZz1jKjIpLHI9bi5jcmVhdGVJbWFnZURhdGEobyxpKTtmb3IobGV0IHY9MDt2PGkqbztmKz1wLG0rPXAsaCs9cCxiKz1wLHYrKylyLmRhdGFbZl09KGUuZGF0YVt5KytdLWxbMF0pKmRbMF0sci5kYXRhW21dPShlLmRhdGFbZysrXS1sWzFdKSpkWzFdLHIuZGF0YVtoXT0oZS5kYXRhW18rK10tbFsyXSkqZFsyXSxyLmRhdGFbYl09dz09PS0xPzI1NTooZS5kYXRhW3crK10tbFszXSkqZFszXX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIik7cmV0dXJuIHJ9fSk7dmFyIFNuLElyLENyLEFyLEVyLGtyLFByPWsoKCk9PntcInVzZSBzdHJpY3RcIjtTdCgpO1NuPShlLHQpPT57aWYoZT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHQuaGVpZ2h0PT09dm9pZCAwfHx0LndpZHRoPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHQudGVuc29yTGF5b3V0PT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKFwiTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO2xldHtoZWlnaHQ6bix3aWR0aDpyfT10LG89dC5ub3JtPz97bWVhbjoyNTUsYmlhczowfSxpLHM7dHlwZW9mIG8ubWVhbj09XCJudW1iZXJcIj9pPVtvLm1lYW4sby5tZWFuLG8ubWVhbixvLm1lYW5dOmk9W28ubWVhblswXSxvLm1lYW5bMV0sby5tZWFuWzJdLG8ubWVhblszXT8/MjU1XSx0eXBlb2Ygby5iaWFzPT1cIm51bWJlclwiP3M9W28uYmlhcyxvLmJpYXMsby5iaWFzLG8uYmlhc106cz1bby5iaWFzWzBdLG8uYmlhc1sxXSxvLmJpYXNbMl0sby5iaWFzWzNdPz8wXTtsZXQgYT10LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQkFcIix1PXQudGVuc29yRm9ybWF0IT09dm9pZCAwJiZ0LnRlbnNvckZvcm1hdCE9PXZvaWQgMD90LnRlbnNvckZvcm1hdDpcIlJHQlwiLGQ9bipyLGw9dT09PVwiUkdCQVwiP25ldyBGbG9hdDMyQXJyYXkoZCo0KTpuZXcgRmxvYXQzMkFycmF5KGQqMyksYz00LHA9MCxmPTEsbT0yLGg9MyxiPTAseT1kLGc9ZCoyLF89LTE7YT09PVwiUkdCXCImJihjPTMscD0wLGY9MSxtPTIsaD0tMSksdT09PVwiUkdCQVwiP189ZCozOnU9PT1cIlJCR1wiPyhiPTAsZz1kLHk9ZCoyKTp1PT09XCJCR1JcIiYmKGc9MCx5PWQsYj1kKjIpO2ZvcihsZXQgdj0wO3Y8ZDt2KysscCs9YyxtKz1jLGYrPWMsaCs9YylsW2IrK109KGVbcF0rc1swXSkvaVswXSxsW3krK109KGVbZl0rc1sxXSkvaVsxXSxsW2crK109KGVbbV0rc1syXSkvaVsyXSxfIT09LTEmJmghPT0tMSYmKGxbXysrXT0oZVtoXStzWzNdKS9pWzNdKTtyZXR1cm4gdT09PVwiUkdCQVwiP25ldyBtZShcImZsb2F0MzJcIixsLFsxLDQsbixyXSk6bmV3IG1lKFwiZmxvYXQzMlwiLGwsWzEsMyxuLHJdKX0sSXI9YXN5bmMoZSx0KT0+e2xldCBuPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PFwidVwiJiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCxyPXR5cGVvZiBJbWFnZURhdGE8XCJ1XCImJmUgaW5zdGFuY2VvZiBJbWFnZURhdGEsbz10eXBlb2YgSW1hZ2VCaXRtYXA8XCJ1XCImJmUgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCxpPXR5cGVvZiBlPT1cInN0cmluZ1wiLHMsYT10Pz97fSx1PSgpPT57aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2lmKHR5cGVvZiBPZmZzY3JlZW5DYW52YXM8XCJ1XCIpcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKX0sZD1sPT50eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQ8XCJ1XCImJmwgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8bCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcz9sLmdldENvbnRleHQoXCIyZFwiKTpudWxsO2lmKG4pe2xldCBsPXUoKTtsLndpZHRoPWUud2lkdGgsbC5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IGM9ZChsKTtpZihjIT1udWxsKXtsZXQgcD1lLmhlaWdodCxmPWUud2lkdGg7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkSGVpZ2h0IT09dm9pZCAwJiZ0LnJlc2l6ZWRXaWR0aCE9PXZvaWQgMCYmKHA9dC5yZXNpemVkSGVpZ2h0LGY9dC5yZXNpemVkV2lkdGgpLHQhPT12b2lkIDApe2lmKGE9dCx0LnRlbnNvckZvcm1hdCE9PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudFwiKTthLnRlbnNvckZvcm1hdD1cIlJHQkFcIixhLmhlaWdodD1wLGEud2lkdGg9Zn1lbHNlIGEudGVuc29yRm9ybWF0PVwiUkdCQVwiLGEuaGVpZ2h0PXAsYS53aWR0aD1mO2MuZHJhd0ltYWdlKGUsMCwwKSxzPWMuZ2V0SW1hZ2VEYXRhKDAsMCxmLHApLmRhdGF9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgaWYocil7bGV0IGwsYztpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRXaWR0aCE9PXZvaWQgMCYmdC5yZXNpemVkSGVpZ2h0IT09dm9pZCAwPyhsPXQucmVzaXplZEhlaWdodCxjPXQucmVzaXplZFdpZHRoKToobD1lLmhlaWdodCxjPWUud2lkdGgpLHQhPT12b2lkIDAmJihhPXQpLGEuZm9ybWF0PVwiUkdCQVwiLGEuaGVpZ2h0PWwsYS53aWR0aD1jLHQhPT12b2lkIDApe2xldCBwPXUoKTtwLndpZHRoPWMscC5oZWlnaHQ9bDtsZXQgZj1kKHApO2lmKGYhPW51bGwpZi5wdXRJbWFnZURhdGEoZSwwLDApLHM9Zi5nZXRJbWFnZURhdGEoMCwwLGMsbCkuZGF0YTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBzPWUuZGF0YX1lbHNlIGlmKG8pe2lmKHQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcFwiKTtsZXQgbD11KCk7bC53aWR0aD1lLndpZHRoLGwuaGVpZ2h0PWUuaGVpZ2h0O2xldCBjPWQobCk7aWYoYyE9bnVsbCl7bGV0IHA9ZS5oZWlnaHQsZj1lLndpZHRoO3JldHVybiBjLmRyYXdJbWFnZShlLDAsMCxmLHApLHM9Yy5nZXRJbWFnZURhdGEoMCwwLGYscCkuZGF0YSxhLmhlaWdodD1wLGEud2lkdGg9ZixTbihzLGEpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNle2lmKGkpcmV0dXJuIG5ldyBQcm9taXNlKChsLGMpPT57bGV0IHA9dSgpLGY9ZChwKTtpZighZXx8IWYpcmV0dXJuIGMoKTtsZXQgbT1uZXcgSW1hZ2U7bS5jcm9zc09yaWdpbj1cIkFub255bW91c1wiLG0uc3JjPWUsbS5vbmxvYWQ9KCk9PntwLndpZHRoPW0ud2lkdGgscC5oZWlnaHQ9bS5oZWlnaHQsZi5kcmF3SW1hZ2UobSwwLDAscC53aWR0aCxwLmhlaWdodCk7bGV0IGg9Zi5nZXRJbWFnZURhdGEoMCwwLHAud2lkdGgscC5oZWlnaHQpO2EuaGVpZ2h0PXAuaGVpZ2h0LGEud2lkdGg9cC53aWR0aCxsKFNuKGguZGF0YSxhKSl9fSk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9aWYocyE9PXZvaWQgMClyZXR1cm4gU24ocyxhKTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX0sQ3I9KGUsdCk9PntsZXR7d2lkdGg6bixoZWlnaHQ6cixkb3dubG9hZDpvLGRpc3Bvc2U6aX09dCxzPVsxLHIsbiw0XTtyZXR1cm4gbmV3IG1lKHtsb2NhdGlvbjpcInRleHR1cmVcIix0eXBlOlwiZmxvYXQzMlwiLHRleHR1cmU6ZSxkaW1zOnMsZG93bmxvYWQ6byxkaXNwb3NlOml9KX0sQXI9KGUsdCk9PntsZXR7ZGF0YVR5cGU6bixkaW1zOnIsZG93bmxvYWQ6byxkaXNwb3NlOml9PXQ7cmV0dXJuIG5ldyBtZSh7bG9jYXRpb246XCJncHUtYnVmZmVyXCIsdHlwZTpuPz9cImZsb2F0MzJcIixncHVCdWZmZXI6ZSxkaW1zOnIsZG93bmxvYWQ6byxkaXNwb3NlOml9KX0sRXI9KGUsdCk9PntsZXR7ZGF0YVR5cGU6bixkaW1zOnIsZG93bmxvYWQ6byxkaXNwb3NlOml9PXQ7cmV0dXJuIG5ldyBtZSh7bG9jYXRpb246XCJtbC10ZW5zb3JcIix0eXBlOm4/P1wiZmxvYXQzMlwiLG1sVGVuc29yOmUsZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGtyPShlLHQsbik9Pm5ldyBtZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsdHlwZTplLGRhdGE6dCxkaW1zOm4/P1t0Lmxlbmd0aF19KX0pO3ZhciBaZSxsdCx6cixCcixEcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WmU9bmV3IE1hcChbW1wiZmxvYXQzMlwiLEZsb2F0MzJBcnJheV0sW1widWludDhcIixVaW50OEFycmF5XSxbXCJpbnQ4XCIsSW50OEFycmF5XSxbXCJ1aW50MTZcIixVaW50MTZBcnJheV0sW1wiaW50MTZcIixJbnQxNkFycmF5XSxbXCJpbnQzMlwiLEludDMyQXJyYXldLFtcImJvb2xcIixVaW50OEFycmF5XSxbXCJmbG9hdDY0XCIsRmxvYXQ2NEFycmF5XSxbXCJ1aW50MzJcIixVaW50MzJBcnJheV0sW1wiaW50NFwiLFVpbnQ4QXJyYXldLFtcInVpbnQ0XCIsVWludDhBcnJheV1dKSxsdD1uZXcgTWFwKFtbRmxvYXQzMkFycmF5LFwiZmxvYXQzMlwiXSxbVWludDhBcnJheSxcInVpbnQ4XCJdLFtJbnQ4QXJyYXksXCJpbnQ4XCJdLFtVaW50MTZBcnJheSxcInVpbnQxNlwiXSxbSW50MTZBcnJheSxcImludDE2XCJdLFtJbnQzMkFycmF5LFwiaW50MzJcIl0sW0Zsb2F0NjRBcnJheSxcImZsb2F0NjRcIl0sW1VpbnQzMkFycmF5LFwidWludDMyXCJdXSksenI9ITEsQnI9KCk9PntpZighenIpe3pyPSEwO2xldCBlPXR5cGVvZiBCaWdJbnQ2NEFycmF5PFwidVwiJiZCaWdJbnQ2NEFycmF5LmZyb20sdD10eXBlb2YgQmlnVWludDY0QXJyYXk8XCJ1XCImJkJpZ1VpbnQ2NEFycmF5LmZyb20sbj1nbG9iYWxUaGlzLkZsb2F0MTZBcnJheSxyPXR5cGVvZiBuPFwidVwiJiZuLmZyb207ZSYmKFplLnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSksbHQuc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKFplLnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxsdC5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpLHI/KFplLnNldChcImZsb2F0MTZcIixuKSxsdC5zZXQobixcImZsb2F0MTZcIikpOlplLnNldChcImZsb2F0MTZcIixVaW50MTZBcnJheSl9fX0pO3ZhciBPcixNcixVcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7U3QoKTtPcj1lPT57bGV0IHQ9MTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7bGV0IHI9ZVtuXTtpZih0eXBlb2YgciE9XCJudW1iZXJcInx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtufV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7cn1gKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtufV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7cn1gKTt0Kj1yfXJldHVybiB0fSxNcj0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IG1lKGUudHlwZSxlLmRhdGEsdCk7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiBuZXcgbWUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLGRhdGE6ZS5kYXRhLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gbmV3IG1lKHtsb2NhdGlvbjpcInRleHR1cmVcIix0ZXh0dXJlOmUudGV4dHVyZSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIG5ldyBtZSh7bG9jYXRpb246XCJncHUtYnVmZmVyXCIsZ3B1QnVmZmVyOmUuZ3B1QnVmZmVyLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiBuZXcgbWUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsbWxUZW5zb3I6ZS5tbFRlbnNvcix0eXBlOmUudHlwZSxkaW1zOnR9KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdGVuc29yUmVzaGFwZTogdGVuc29yIGxvY2F0aW9uICR7ZS5sb2NhdGlvbn0gaXMgbm90IHN1cHBvcnRlZGApfX19KTt2YXIgbWUsU3Q9aygoKT0+e1widXNlIHN0cmljdFwiO1RyKCk7UHIoKTtEcigpO1VyKCk7bWU9Y2xhc3N7Y29uc3RydWN0b3IodCxuLHIpe0JyKCk7bGV0IG8saTtpZih0eXBlb2YgdD09XCJvYmplY3RcIiYmXCJsb2NhdGlvblwiaW4gdClzd2l0Y2godGhpcy5kYXRhTG9jYXRpb249dC5sb2NhdGlvbixvPXQudHlwZSxpPXQuZGltcyx0LmxvY2F0aW9uKXtjYXNlXCJjcHUtcGlubmVkXCI6e2xldCBhPVplLmdldChvKTtpZighYSl0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBwaW5uZWQgYnVmZmVyYCk7aWYoISh0LmRhdGEgaW5zdGFuY2VvZiBhKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBidWZmZXIgc2hvdWxkIGJlIG9mIHR5cGUgJHthLm5hbWV9YCk7dGhpcy5jcHVEYXRhPXQuZGF0YTticmVha31jYXNlXCJ0ZXh0dXJlXCI6e2lmKG8hPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSB0ZXh0dXJlYCk7dGhpcy5ncHVUZXh0dXJlRGF0YT10LnRleHR1cmUsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9Y2FzZVwiZ3B1LWJ1ZmZlclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIGdwdSBidWZmZXJgKTt0aGlzLmdwdUJ1ZmZlckRhdGE9dC5ncHVCdWZmZXIsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9Y2FzZVwibWwtdGVuc29yXCI6e2lmKG8hPT1cImZsb2F0MzJcIiYmbyE9PVwiZmxvYXQxNlwiJiZvIT09XCJpbnQzMlwiJiZvIT09XCJpbnQ2NFwiJiZvIT09XCJ1aW50MzJcIiYmbyE9PVwidWludDY0XCImJm8hPT1cImludDhcIiYmbyE9PVwidWludDhcIiYmbyE9PVwiYm9vbFwiJiZvIT09XCJ1aW50NFwiJiZvIT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gTUxUZW5zb3JgKTt0aGlzLm1sVGVuc29yRGF0YT10Lm1sVGVuc29yLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKX1lbHNle2xldCBhLHU7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpaWYobz10LHU9cix0PT09XCJzdHJpbmdcIil7aWYoIUFycmF5LmlzQXJyYXkobikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7YT1ufWVsc2V7bGV0IGQ9WmUuZ2V0KHQpO2lmKGQ9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7dH0uYCk7aWYoQXJyYXkuaXNBcnJheShuKSl7aWYodD09PVwiZmxvYXQxNlwiJiZkPT09VWludDE2QXJyYXl8fHQ9PT1cInVpbnQ0XCJ8fHQ9PT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGBDcmVhdGluZyBhICR7dH0gdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgJHtkLm5hbWV9IGFzIGRhdGEuYCk7dD09PVwidWludDY0XCJ8fHQ9PT1cImludDY0XCI/YT1kLmZyb20obixCaWdJbnQpOmE9ZC5mcm9tKG4pfWVsc2UgaWYobiBpbnN0YW5jZW9mIGQpYT1uO2Vsc2UgaWYobiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KWlmKHQ9PT1cInVpbnQ4XCIpYT1VaW50OEFycmF5LmZyb20obik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OFwiKTtlbHNlIGlmKHQ9PT1cImZsb2F0MTZcIiYmbiBpbnN0YW5jZW9mIFVpbnQxNkFycmF5JiZkIT09VWludDE2QXJyYXkpYT1uZXcgZ2xvYmFsVGhpcy5GbG9hdDE2QXJyYXkobi5idWZmZXIsbi5ieXRlT2Zmc2V0LG4ubGVuZ3RoKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHtvfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke2R9YCl9ZWxzZSBpZih1PW4sQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS5cIik7bGV0IGQ9dHlwZW9mIHRbMF07aWYoZD09PVwic3RyaW5nXCIpbz1cInN0cmluZ1wiLGE9dDtlbHNlIGlmKGQ9PT1cImJvb2xlYW5cIilvPVwiYm9vbFwiLGE9VWludDhBcnJheS5mcm9tKHQpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtkfS5gKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlvPVwidWludDhcIixhPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNle2xldCBkPWx0LmdldCh0LmNvbnN0cnVjdG9yKTtpZihkPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke3QuY29uc3RydWN0b3J9LmApO289ZCxhPXR9aWYodT09PXZvaWQgMCl1PVthLmxlbmd0aF07ZWxzZSBpZighQXJyYXkuaXNBcnJheSh1KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7aT11LHRoaXMuY3B1RGF0YT1hLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCJ9bGV0IHM9T3IoaSk7aWYodGhpcy5jcHVEYXRhJiZzIT09dGhpcy5jcHVEYXRhLmxlbmd0aCYmISgobz09PVwidWludDRcInx8bz09PVwiaW50NFwiKSYmTWF0aC5jZWlsKHMvMik9PT10aGlzLmNwdURhdGEubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7dGhpcy50eXBlPW8sdGhpcy5kaW1zPWksdGhpcy5zaXplPXN9c3RhdGljIGFzeW5jIGZyb21JbWFnZSh0LG4pe3JldHVybiBJcih0LG4pfXN0YXRpYyBmcm9tVGV4dHVyZSh0LG4pe3JldHVybiBDcih0LG4pfXN0YXRpYyBmcm9tR3B1QnVmZmVyKHQsbil7cmV0dXJuIEFyKHQsbil9c3RhdGljIGZyb21NTFRlbnNvcih0LG4pe3JldHVybiBFcih0LG4pfXN0YXRpYyBmcm9tUGlubmVkQnVmZmVyKHQsbixyKXtyZXR1cm4ga3IodCxuLHIpfXRvRGF0YVVSTCh0KXtyZXR1cm4geHIodGhpcyx0KX10b0ltYWdlRGF0YSh0KXtyZXR1cm4gU3IodGhpcyx0KX1nZXQgZGF0YSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5jcHVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsIG9yIHVzZSBgdGV4dHVyZWAgb3IgYGdwdUJ1ZmZlcmAgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBHUFUgZGF0YSBkaXJlY3RseS5cIik7cmV0dXJuIHRoaXMuY3B1RGF0YX1nZXQgbG9jYXRpb24oKXtyZXR1cm4gdGhpcy5kYXRhTG9jYXRpb259Z2V0IHRleHR1cmUoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1VGV4dHVyZURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuXCIpO3JldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhfWdldCBncHVCdWZmZXIoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1QnVmZmVyRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci5cIik7cmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YX1nZXQgbWxUZW5zb3IoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMubWxUZW5zb3JEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJOTiBNTFRlbnNvci5cIik7cmV0dXJuIHRoaXMubWxUZW5zb3JEYXRhfWFzeW5jIGdldERhdGEodCl7c3dpdGNoKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRhdGFMb2NhdGlvbil7Y2FzZVwiY3B1XCI6Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiB0aGlzLmRhdGE7Y2FzZVwidGV4dHVyZVwiOmNhc2VcImdwdS1idWZmZXJcIjpjYXNlXCJtbC10ZW5zb3JcIjp7aWYoIXRoaXMuZG93bmxvYWRlcil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuXCIpO2lmKHRoaXMuaXNEb3dubG9hZGluZyl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC5cIik7dHJ5e3RoaXMuaXNEb3dubG9hZGluZz0hMDtsZXQgbj1hd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtyZXR1cm4gdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwiLHRoaXMuY3B1RGF0YT1uLHQmJnRoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLG59ZmluYWxseXt0aGlzLmlzRG93bmxvYWRpbmc9ITF9fWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKX19ZGlzcG9zZSgpe2lmKHRoaXMuaXNEb3dubG9hZGluZyl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC5cIik7dGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCksdGhpcy5jcHVEYXRhPXZvaWQgMCx0aGlzLmdwdVRleHR1cmVEYXRhPXZvaWQgMCx0aGlzLmdwdUJ1ZmZlckRhdGE9dm9pZCAwLHRoaXMubWxUZW5zb3JEYXRhPXZvaWQgMCx0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuaXNEb3dubG9hZGluZz12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJub25lXCJ9ZW5zdXJlVmFsaWQoKXtpZih0aGlzLmRhdGFMb2NhdGlvbj09PVwibm9uZVwiKXRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXCIpfXJlc2hhcGUodCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZG93bmxvYWRlcnx8dGhpcy5kaXNwb3Nlcil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLlwiKTtyZXR1cm4gTXIodGhpcyx0KX19fSk7dmFyIHZlLFRuPWsoKCk9PntcInVzZSBzdHJpY3RcIjtTdCgpO3ZlPW1lfSk7dmFyIGN0LFJyLGhlLGZlLFVlLFJlLEluPWsoKCk9PntcInVzZSBzdHJpY3RcIjt4bigpO2N0PShlLHQpPT57KHR5cGVvZiBsZS50cmFjZT5cInVcIj8hbGUud2FzbS50cmFjZTohbGUudHJhY2UpfHxjb25zb2xlLnRpbWVTdGFtcChgJHtlfTo6T1JUOjoke3R9YCl9LFJyPShlLHQpPT57bGV0IG49bmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKXx8W10scj0hMTtmb3IobGV0IG89MDtvPG4ubGVuZ3RoO28rKyl7aWYociYmIW5bb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpKXtsZXQgaT1gRlVOQ18ke2V9Ojoke25bb10udHJpbSgpLnNwbGl0KFwiIFwiKVsxXX1gO3QmJihpKz1gOjoke3R9YCksY3QoXCJDUFVcIixpKTtyZXR1cm59bltvXS5pbmNsdWRlcyhcIlRSQUNFX0ZVTkNcIikmJihyPSEwKX19LGhlPWU9PnsodHlwZW9mIGxlLnRyYWNlPlwidVwiPyFsZS53YXNtLnRyYWNlOiFsZS50cmFjZSl8fFJyKFwiQkVHSU5cIixlKX0sZmU9ZT0+eyh0eXBlb2YgbGUudHJhY2U+XCJ1XCI/IWxlLndhc20udHJhY2U6IWxlLnRyYWNlKXx8UnIoXCJFTkRcIixlKX0sVWU9ZT0+eyh0eXBlb2YgbGUudHJhY2U+XCJ1XCI/IWxlLndhc20udHJhY2U6IWxlLnRyYWNlKXx8Y29uc29sZS50aW1lKGBPUlQ6OiR7ZX1gKX0sUmU9ZT0+eyh0eXBlb2YgbGUudHJhY2U+XCJ1XCI/IWxlLndhc20udHJhY2U6IWxlLnRyYWNlKXx8Y29uc29sZS50aW1lRW5kKGBPUlQ6OiR7ZX1gKX19KTt2YXIgVHQsVnI9aygoKT0+e1widXNlIHN0cmljdFwiO3ZuKCk7VG4oKTtJbigpO1R0PWNsYXNzIGV7Y29uc3RydWN0b3IodCl7dGhpcy5oYW5kbGVyPXR9YXN5bmMgcnVuKHQsbixyKXtoZSgpLFVlKFwiSW5mZXJlbmNlU2Vzc2lvbi5ydW5cIik7bGV0IG89e30saT17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiB2ZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCBzPSEwO2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiKXtpZihuPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKG4gaW5zdGFuY2VvZiB2ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KG4pKXtpZihuLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO3M9ITE7Zm9yKGxldCBkIG9mIG4pe2lmKHR5cGVvZiBkIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihkKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtkfS5gKTtvW2RdPW51bGx9aWYodHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKWk9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IGQ9ITEsbD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKTtmb3IobGV0IGMgb2YgdGhpcy5vdXRwdXROYW1lcylpZihsLmluZGV4T2YoYykhPT0tMSl7bGV0IHA9bltjXTsocD09PW51bGx8fHAgaW5zdGFuY2VvZiB2ZSkmJihkPSEwLHM9ITEsb1tjXT1wKX1pZihkKXtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpaT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpPW59fWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBkIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtkXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke2R9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYocylmb3IobGV0IGQgb2YgdGhpcy5vdXRwdXROYW1lcylvW2RdPW51bGw7bGV0IGE9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bih0LG8saSksdT17fTtmb3IobGV0IGQgaW4gYSlpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhLGQpKXtsZXQgbD1hW2RdO2wgaW5zdGFuY2VvZiB2ZT91W2RdPWw6dVtkXT1uZXcgdmUobC50eXBlLGwuZGF0YSxsLmRpbXMpfXJldHVybiBSZShcIkluZmVyZW5jZVNlc3Npb24ucnVuXCIpLGZlKCksdX1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LG4scixvKXtoZSgpLFVlKFwiSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGVcIik7bGV0IGkscz17fTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil7aWYoaT10LHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClzPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZihpPXQsdHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKXM9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI8XCJ1XCImJnQgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcil7bGV0IGw9dCxjPTAscD10LmJ5dGVMZW5ndGg7aWYodHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKXM9bjtlbHNlIGlmKHR5cGVvZiBuPT1cIm51bWJlclwiKXtpZihjPW4sIU51bWJlci5pc1NhZmVJbnRlZ2VyKGMpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoYzwwfHxjPj1sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7bC5ieXRlTGVuZ3RofSkuYCk7aWYocD10LmJ5dGVMZW5ndGgtYyx0eXBlb2Ygcj09XCJudW1iZXJcIil7aWYocD1yLCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHA8PTB8fGMrcD5sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7bC5ieXRlTGVuZ3RoLWN9XS5gKTtpZih0eXBlb2Ygbz09XCJvYmplY3RcIiYmbyE9PW51bGwpcz1vO2Vsc2UgaWYodHlwZW9mIG88XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYSBudW1iZXIuXCIpfWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7aT1uZXcgVWludDhBcnJheShsLGMscCl9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO2xldFthLHVdPWF3YWl0IHlyKHMpLGQ9YXdhaXQgYS5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihpLHUpO3JldHVybiBSZShcIkluZmVyZW5jZVNlc3Npb24uY3JlYXRlXCIpLGZlKCksbmV3IGUoZCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc31nZXQgaW5wdXRNZXRhZGF0YSgpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXRNZXRhZGF0YX1nZXQgb3V0cHV0TWV0YWRhdGEoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE1ldGFkYXRhfX19KTt2YXIgTnIsTHI9aygoKT0+e1widXNlIHN0cmljdFwiO1ZyKCk7TnI9VHR9KTt2YXIgV3I9aygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEdyPWsoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBIcj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgcXI9aygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIENuPXt9O250KENuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5OcixUUkFDRTooKT0+Y3QsVFJBQ0VfRVZFTlRfQkVHSU46KCk9PlVlLFRSQUNFX0VWRU5UX0VORDooKT0+UmUsVFJBQ0VfRlVOQ19CRUdJTjooKT0+aGUsVFJBQ0VfRlVOQ19FTkQ6KCk9PmZlLFRlbnNvcjooKT0+dmUsZW52OigpPT50ZSxyZWdpc3RlckJhY2tlbmQ6KCk9PldlfSk7dmFyIHllPWsoKCk9PntcInVzZSBzdHJpY3RcIjticigpO3ZyKCk7THIoKTtUbigpO1dyKCk7R3IoKTtJbigpO0hyKCk7cXIoKX0pO3ZhciBJdD1rKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgWnI9e307bnQoWnIse2RlZmF1bHQ6KCk9Pkh1fSk7dmFyIEtyLGpyLEh1LFFyPWsoKCk9PntcInVzZSBzdHJpY3RcIjtBbigpO0dlKCk7Q3QoKTtLcj1cIm9ydC13YXNtLXByb3h5LXdvcmtlclwiLGpyPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT09PUtyO2pyJiYoc2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46bn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6QXQobi53YXNtKS50aGVuKCgpPT57RXQobikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0scj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX0pfSxyPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6cn0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOnIsZW52Om99PW47a3QobyxyKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6cn09bixvPXB0KHIpO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Om99KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOnIsb3B0aW9uczpvfT1uO1B0KHIsbykudGhlbihpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6aX0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOnp0KG4pLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpyLGlucHV0SW5kaWNlczpvLGlucHV0czppLG91dHB1dEluZGljZXM6cyxvcHRpb25zOmF9PW47QnQocixvLGkscyxuZXcgQXJyYXkocy5sZW5ndGgpLmZpbGwobnVsbCksYSkudGhlbih1PT57dS5zb21lKGQ9PmRbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDp1fSxPdChbLi4uaSwuLi51XSkpfSx1PT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6dX0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOkR0KG4pLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztkZWZhdWx0On19Y2F0Y2gocil7cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6cn0pfX0pO0h1PWpyP251bGw6ZT0+bmV3IFdvcmtlcihlPz9iZSx7dHlwZTpcImNsYXNzaWNcIixuYW1lOktyfSl9KTt2YXIgcXUsRnUsYmUsTXQsRW4sS3UsanUsSnIsWnUsWHIsZW8sWXIsdG8sQ3Q9aygoKT0+e1widXNlIHN0cmljdFwiO0l0KCk7cXU9dHlwZW9mIGxvY2F0aW9uPlwidVwiP3ZvaWQgMDpsb2NhdGlvbi5vcmlnaW4sRnU9KCk9PntpZighITEpcmV0dXJuIHR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jdXJyZW50U2NyaXB0Py5zcmM6dHlwZW9mIHNlbGY8XCJ1XCI/c2VsZi5sb2NhdGlvbj8uaHJlZjp2b2lkIDB9LGJlPUZ1KCksTXQ9KCk9PntpZihiZSYmIWJlLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSlyZXR1cm4gYmUuc3Vic3RyaW5nKDAsYmUubGFzdEluZGV4T2YoXCIvXCIpKzEpfSxFbj0oZSx0KT0+e3RyeXtsZXQgbj10Pz9iZTtyZXR1cm4obj9uZXcgVVJMKGUsbik6bmV3IFVSTChlKSkub3JpZ2luPT09cXV9Y2F0Y2h7cmV0dXJuITF9fSxLdT0oZSx0KT0+e2xldCBuPXQ/P2JlO3RyeXtyZXR1cm4obj9uZXcgVVJMKGUsbik6bmV3IFVSTChlKSkuaHJlZn1jYXRjaHtyZXR1cm59fSxqdT0oZSx0KT0+YCR7dD8/XCIuL1wifSR7ZX1gLEpyPWFzeW5jIGU9PntsZXQgbj1hd2FpdChhd2FpdCBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KSkuYmxvYigpO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG4pfSxadT1hc3luYyBlPT4oYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTp0cnVlKi9lKSkuZGVmYXVsdCxYcj0oUXIoKSxkdChacikpLmRlZmF1bHQsZW89YXN5bmMoKT0+e2lmKCFiZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLlwiKTtpZihFbihiZSkpcmV0dXJuW3ZvaWQgMCxYcigpXTtsZXQgZT1hd2FpdCBKcihiZSk7cmV0dXJuW2UsWHIoZSldfSxZcj12b2lkIDAsdG89YXN5bmMoZSx0LG4scik9PntsZXQgbz1ZciYmIShlfHx0KTtpZihvKWlmKGJlKW89RW4oYmUpO2Vsc2UgaWYociYmIW4pbz0hMDtlbHNlIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLlwiKTtpZihvKXJldHVyblt2b2lkIDAsWXJdO3tsZXQgaT1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNcIixzPWU/P0t1KGksdCksYT0hITEmJm4mJnMmJiFFbihzLHQpLHU9YT9hd2FpdCBKcihzKTpzPz9qdShpLHQpO3JldHVyblthP3U6dm9pZCAwLGF3YWl0IFp1KHUpXX19fSk7dmFyIGtuLFBuLFV0LG5vLFF1LFh1LFl1LEF0LG5lLEdlPWsoKCk9PntcInVzZSBzdHJpY3RcIjtDdCgpO1BuPSExLFV0PSExLG5vPSExLFF1PSgpPT57aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiExO3RyeXtyZXR1cm4gdHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxYdT0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxZdT0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNSwxLDk2LDAsMSwxMjMsMywyLDEsMCwxMCwxOSwxLDE3LDAsNjUsMSwyNTMsMTUsNjUsMiwyNTMsMTUsNjUsMywyNTMsMTUsMjUzLDE0NywyLDExXSkpfWNhdGNoe3JldHVybiExfX0sQXQ9YXN5bmMgZT0+e2lmKFBuKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihVdCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihubyl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtVdD0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LG49ZS5udW1UaHJlYWRzO2lmKGUuc2ltZCE9PSExKXtpZihlLnNpbWQ9PT1cInJlbGF4ZWRcIil7aWYoIVl1KCkpdGhyb3cgbmV3IEVycm9yKFwiUmVsYXhlZCBXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXCIpfWVsc2UgaWYoIVh1KCkpdGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlwiKX1sZXQgcj1RdSgpO24+MSYmIXImJih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrbitcIiwgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuIFNlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby5cIiksY29uc29sZS53YXJuKFwiV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLlwiKSxlLm51bVRocmVhZHM9bj0xKTtsZXQgbz1lLndhc21QYXRocyxpPXR5cGVvZiBvPT1cInN0cmluZ1wiP286dm9pZCAwLHM9bz8ubWpzLGE9cz8uaHJlZj8/cyx1PW8/Lndhc20sZD11Py5ocmVmPz91LGw9ZS53YXNtQmluYXJ5LFtjLHBdPWF3YWl0IHRvKGEsaSxuPjEsISFsfHwhIWQpLGY9ITEsbT1bXTtpZih0PjAmJm0ucHVzaChuZXcgUHJvbWlzZShoPT57c2V0VGltZW91dCgoKT0+e2Y9ITAsaCgpfSx0KX0pKSxtLnB1c2gobmV3IFByb21pc2UoKGgsYik9PntsZXQgeT17bnVtVGhyZWFkczpufTtpZihsKXkud2FzbUJpbmFyeT1sO2Vsc2UgaWYoZHx8aSl5LmxvY2F0ZUZpbGU9Zz0+ZD8/aStnO2Vsc2UgaWYoYSYmYS5pbmRleE9mKFwiYmxvYjpcIikhPT0wKXkubG9jYXRlRmlsZT1nPT5uZXcgVVJMKGcsYSkuaHJlZjtlbHNlIGlmKGMpe2xldCBnPU10KCk7ZyYmKHkubG9jYXRlRmlsZT1fPT5nK18pfXAoeSkudGhlbihnPT57VXQ9ITEsUG49ITAsa249ZyxoKCksYyYmVVJMLnJldm9rZU9iamVjdFVSTChjKX0sZz0+e1V0PSExLG5vPSEwLGIoZyl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UobSksZil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LG5lPSgpPT57aWYoUG4mJmtuKXJldHVybiBrbjt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIgX2UsbXQsWSxSdD1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtfZT0oZSx0KT0+e2xldCBuPW5lKCkscj1uLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89bi5fbWFsbG9jKHIpO3JldHVybiBuLnN0cmluZ1RvVVRGOChlLG8sciksdC5wdXNoKG8pLG99LG10PShlLHQsbixyKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYobi5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7bi5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28saV0pPT57bGV0IHM9dD90K286bztpZih0eXBlb2YgaT09XCJvYmplY3RcIiltdChpLHMrXCIuXCIsbixyKTtlbHNlIGlmKHR5cGVvZiBpPT1cInN0cmluZ1wifHx0eXBlb2YgaT09XCJudW1iZXJcIilyKHMsaS50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBpPT1cImJvb2xlYW5cIilyKHMsaT9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgaX1gKX0pfSxZPWU9PntsZXQgdD1uZSgpLG49dC5zdGFja1NhdmUoKTt0cnl7bGV0IHI9dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKnIpO3QuX09ydEdldExhc3RFcnJvcihvLG8rcik7bGV0IGk9TnVtYmVyKHQuZ2V0VmFsdWUobyxyPT09ND9cImkzMlwiOlwiaTY0XCIpKSxzPXQuZ2V0VmFsdWUobytyLFwiKlwiKSxhPXM/dC5VVEY4VG9TdHJpbmcocyk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtpfSwgRVJST1JfTUVTU0FHRTogJHthfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobil9fX0pO3ZhciBybyxvbz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtSdCgpO3JvPWU9PntsZXQgdD1uZSgpLG49MCxyPVtdLG89ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApby5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2V2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZihlPy5sb2dWZXJib3NpdHlMZXZlbD09PXZvaWQgMClvLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZih0eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO2U/LnRlcm1pbmF0ZT09PXZvaWQgMCYmKG8udGVybWluYXRlPSExKTtsZXQgaT0wO3JldHVybiBlPy50YWchPT12b2lkIDAmJihpPV9lKGUudGFnLHIpKSxuPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMoby5sb2dTZXZlcml0eUxldmVsLG8ubG9nVmVyYm9zaXR5TGV2ZWwsISFvLnRlcm1pbmF0ZSxpKSxuPT09MCYmWShcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJm10KGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwocyxhKT0+e2xldCB1PV9lKHMsciksZD1fZShhLHIpO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sdSxkKSE9PTAmJlkoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7c30gLSAke2F9LmApfSksW24scl19Y2F0Y2goaSl7dGhyb3cgbiE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLHIuZm9yRWFjaChzPT50Ll9mcmVlKHMpKSxpfX19KTt2YXIgSnUsZWQsdGQsVnQsbmQsaW8sc289aygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7UnQoKTtKdT1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImxheW91dFwiOnJldHVybiAzO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSxlZD1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sdGQ9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKG49Pih0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm4ubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LFZ0PShlLHQsbixyKT0+e2xldCBvPV9lKHQsciksaT1fZShuLHIpO25lKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLG8saSkhPT0wJiZZKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt0fSAtICR7bn0uYCl9LG5kPWFzeW5jKGUsdCxuKT0+e2ZvcihsZXQgciBvZiB0KXtsZXQgbz10eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSxpPVtdO3N3aXRjaChvKXtjYXNlXCJ3ZWJublwiOmlmKG89XCJXRUJOTlwiLHR5cGVvZiByIT1cInN0cmluZ1wiKXtsZXQgYz1yPy5kZXZpY2VUeXBlO2MmJlZ0KGUsXCJkZXZpY2VUeXBlXCIsYyxuKX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihvPVwiSlNcIix0eXBlb2YgciE9XCJzdHJpbmdcIil7bGV0IGw9cjtpZihsPy5wcmVmZXJyZWRMYXlvdXQpe2lmKGwucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJmwucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHtsLnByZWZlcnJlZExheW91dH1gKTtWdChlLFwicHJlZmVycmVkTGF5b3V0XCIsbC5wcmVmZXJyZWRMYXlvdXQsbil9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7b31gKX1sZXQgcz1fZShvLG4pLGE9aS5sZW5ndGgsdT0wLGQ9MDtpZihhPjApe3U9bmUoKS5fbWFsbG9jKGEqbmUoKS5QVFJfU0laRSksbi5wdXNoKHUpLGQ9bmUoKS5fbWFsbG9jKGEqbmUoKS5QVFJfU0laRSksbi5wdXNoKGQpO2ZvcihsZXQgbD0wO2w8YTtsKyspbmUoKS5zZXRWYWx1ZSh1K2wqbmUoKS5QVFJfU0laRSxpW2xdWzBdLFwiKlwiKSxuZSgpLnNldFZhbHVlKGQrbCpuZSgpLlBUUl9TSVpFLGlbbF1bMV0sXCIqXCIpfWF3YWl0IG5lKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUscyx1LGQsYSkhPT0wJiZZKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299LmApfX0saW89YXN5bmMgZT0+e2xldCB0PW5lKCksbj0wLHI9W10sbz1lfHx7fTt0ZChvKTt0cnl7bGV0IGk9SnUoby5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSxzPWVkKG8uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGE9dHlwZW9mIG8ubG9nSWQ9PVwic3RyaW5nXCI/X2Uoby5sb2dJZCxyKTowLHU9by5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHUpfHx1PDB8fHU+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dX1gKTtsZXQgZD1vLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGQpfHxkPDB8fGQ+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2R9YCk7bGV0IGw9dHlwZW9mIG8ub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9fZShvLm9wdGltaXplZE1vZGVsRmlsZVBhdGgscik6MDtpZihuPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKGksISFvLmVuYWJsZUNwdU1lbUFyZW5hLCEhby5lbmFibGVNZW1QYXR0ZXJuLHMsISFvLmVuYWJsZVByb2ZpbGluZywwLGEsdSxkLGwpLG49PT0wJiZZKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksby5leGVjdXRpb25Qcm92aWRlcnMmJmF3YWl0IG5kKG4sby5leGVjdXRpb25Qcm92aWRlcnMsciksby5lbmFibGVHcmFwaENhcHR1cmUhPT12b2lkIDApe2lmKHR5cGVvZiBvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7by5lbmFibGVHcmFwaENhcHR1cmV9YCk7VnQobixcImVuYWJsZUdyYXBoQ2FwdHVyZVwiLG8uZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCkscil9aWYoby5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbYyxwXW9mIE9iamVjdC5lbnRyaWVzKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiBjIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke2N9YCk7aWYodHlwZW9mIHAhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHApfHxwPDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7cH1gKTtsZXQgZj1fZShjLHIpO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShuLGYscCkhPT0wJiZZKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtjfSAtICR7cH0uYCl9cmV0dXJuIG8uZXh0cmEhPT12b2lkIDAmJm10KG8uZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoYyxwKT0+e1Z0KG4sYyxwLHIpfSksW24scl19Y2F0Y2goaSl7dGhyb3cgbiE9PTAmJnQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSE9PTAmJlkoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksci5mb3JFYWNoKHM9PnQuX2ZyZWUocykpLGl9fX0pO3ZhciBIZSxFZSxxZSxydCxmdCxOdCxMdCx6bixWPWsoKCk9PntcInVzZSBzdHJpY3RcIjtIZT1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7Y2FzZVwiaW50NFwiOnJldHVybiAyMjtjYXNlXCJ1aW50NFwiOnJldHVybiAyMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxFZT1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTA6cmV0dXJuXCJmbG9hdDE2XCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7Y2FzZSAyMjpyZXR1cm5cImludDRcIjtjYXNlIDIxOnJldHVyblwidWludDRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxxZT0oZSx0KT0+e2xldCBuPVstMSw0LDEsMSwyLDIsNCw4LC0xLDEsMiw4LDQsOCwtMSwtMSwtMSwtMSwtMSwtMSwtMSwuNSwuNV1bZV0scj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQucmVkdWNlKChvLGkpPT5vKmksMSk7cmV0dXJuIG4+MD9NYXRoLmNlaWwocipuKTp2b2lkIDB9LHJ0PWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiB0eXBlb2YgRmxvYXQxNkFycmF5PFwidVwiJiZGbG9hdDE2QXJyYXkuZnJvbT9GbG9hdDE2QXJyYXk6VWludDE2QXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gQmlnVWludDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7ZX1gKX19LGZ0PWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fSxOdD1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLEx0PWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJ1aW50MzJcInx8ZT09PVwidWludDY0XCJ8fGU9PT1cImludDhcInx8ZT09PVwidWludDhcInx8ZT09PVwiYm9vbFwifHxlPT09XCJ1aW50NFwifHxlPT09XCJpbnQ0XCIsem49ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIDU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIGh0LEJuPWsoKCk9PntcInVzZSBzdHJpY3RcIjtJdCgpO2h0PWFzeW5jIGU9PntpZih0eXBlb2YgZT09XCJzdHJpbmdcIilpZighMSl0cnl7bGV0e3JlYWRGaWxlOnR9PSRuKFwibm9kZTpmcy9wcm9taXNlc1wiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdChlKSl9Y2F0Y2godCl7aWYodC5jb2RlPT09XCJFUlJfRlNfRklMRV9UT09fTEFSR0VcIil7bGV0e2NyZWF0ZVJlYWRTdHJlYW06bn09JG4oXCJub2RlOmZzXCIpLHI9bihlKSxvPVtdO2ZvciBhd2FpdChsZXQgaSBvZiByKW8ucHVzaChpKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChvKSl9dGhyb3cgdH1lbHNle2xldCB0PWF3YWl0IGZldGNoKGUpO2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9YCk7bGV0IG49dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLHI9bj9wYXJzZUludChuLDEwKTowO2lmKHI8MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKTt7aWYoIXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgbz10LmJvZHkuZ2V0UmVhZGVyKCksaTt0cnl7aT1uZXcgQXJyYXlCdWZmZXIocil9Y2F0Y2goYSl7aWYoYSBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCB1PU1hdGguY2VpbChyLzY1NTM2KTtpPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6dSxtYXhpbXVtOnV9KS5idWZmZXJ9ZWxzZSB0aHJvdyBhfWxldCBzPTA7Zm9yKDs7KXtsZXR7ZG9uZTphLHZhbHVlOnV9PWF3YWl0IG8ucmVhZCgpO2lmKGEpYnJlYWs7bGV0IGQ9dS5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KGkscyxkKS5zZXQodSkscys9ZH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSwwLHIpfX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCBlLmFycmF5QnVmZmVyKCkpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9fSk7dmFyIHJkLG9kLGFvLHVvLFd0LGlkLGosa2U9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtyZD1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLG9kPShlLHQpPT57Y29uc29sZS5sb2coYFske3JkW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxXdD0oZSx0KT0+e2FvPWUsdW89dH0saWQ9KGUsdCk9PntsZXQgbj1mdChlKSxyPWZ0KGFvKTtuPj1yJiZvZChuLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSxqPSguLi5lKT0+e3VvJiZpZCguLi5lKX19KTt2YXIgRG4sUGUseCxYZSxHdCxsbyxjbyxxPWsoKCk9PntcInVzZSBzdHJpY3RcIjtEbj1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQsbil7cmV0dXJuIHRbMV0hPT1uWzBdP3ZvaWQgMDpbdFswXSxuWzFdXX19LFBlPWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxuLHI9ITEpe2xldCBvPXQubGVuZ3RoLGk9bi5sZW5ndGg7aWYobz09PTApcmV0dXJuIG47aWYoaT09PTApcmV0dXJuIHQ7bGV0IHM9TWF0aC5tYXgodC5sZW5ndGgsbi5sZW5ndGgpLGE9bmV3IEFycmF5KHMpO2lmKHIpe2lmKG88Mnx8aTwyKXJldHVybjtsZXQgdT1Ebi5jYWxjTWF0TXVsU2hhcGUoW3Rbby0yXSx0W28tMV1dLFtuW2ktMl0sbltpLTFdXSk7aWYodT09PXZvaWQgMClyZXR1cm47W2Fbcy0yXSxhW3MtMV1dPXV9Zm9yKGxldCB1PXI/MzoxO3U8PXM7dSsrKXtsZXQgZD1vLXU8MD8xOnRbby11XSxsPWktdTwwPzE6bltpLXVdO2lmKGQhPT1sJiZkPjEmJmw+MSlyZXR1cm47bGV0IGM9TWF0aC5tYXgoZCxsKTtpZihkJiZsKWFbcy11XT1NYXRoLm1heChkLGwpO2Vsc2V7aWYoYz4xKXJldHVybjthW3MtdV09MH19cmV0dXJuIGF9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxuKXtsZXQgcj10Lmxlbmd0aCxvPW4ubGVuZ3RoO2lmKHI+bylyZXR1cm4hMTtmb3IobGV0IGk9MTtpPD1yO2krKylpZih0W3ItaV0hPT0xJiZ0W3ItaV0hPT1uW28taV0pcmV0dXJuITE7cmV0dXJuITB9fSx4PWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBjb252ZXJ0U2hhcGUodCxuPTQpe2xldCByPXQubGVuZ3RoO2lmKHI9PT0wKXJldHVybltdO2xldCBvPW5ldyBBcnJheShyKSxpPXItMTtmb3IoO2k+PTA7KXtpZih0W2ldJW49PT0wKXtvW2ldPXRbaV0vbjticmVha31pZihuJXRbaV0hPT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHNoYXBlXCIpO29baV09MSxuLz10W2ldLGktLX1mb3IoaS0tO2k+PTA7aS0tKW9baV09dFtpXTtyZXR1cm4gb31zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxuKXtpZihuPDB8fG4+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke259IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LG4sdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxuKXtpZihuPDB8fG4+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke259IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLG4pfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsbixyKXtsZXQgbz0xO2ZvcihsZXQgaT1uO2k8cjtpKyspe2lmKHRbaV08MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO28qPU51bWJlcih0W2ldKX1yZXR1cm4gb31zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IG49dC5sZW5ndGg7aWYobj09PTApcmV0dXJuW107aWYobj09PTEpcmV0dXJuWzFdO2xldCByPW5ldyBBcnJheShuKTtyW24tMV09MSxyW24tMl09dFtuLTFdO2ZvcihsZXQgbz1uLTM7bz49MDstLW8pcltvXT1yW28rMV0qdFtvKzFdO3JldHVybiByfXN0YXRpYyBub3JtYWxpemVBeGlzKHQsbil7aWYodDwtbiYmdD49bil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K246dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LG4pe3JldHVybiB0Lm1hcChyPT50aGlzLm5vcm1hbGl6ZUF4aXMocixuPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxuKXtyZXR1cm4gbj9uLm1hcChyPT50W3JdKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LG4pe2xldCByPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobyxpKT0+bytuW2ldK25baStyXSl9c3RhdGljIGFyZUVxdWFsKHQsbil7cmV0dXJuIHQubGVuZ3RoIT09bi5sZW5ndGg/ITE6dC5ldmVyeSgocixvKT0+cj09PW5bb10pfX0sWGU9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxuLHIsbyxpLHMpe2lmKCF0JiZyLmxlbmd0aCE9PW4ubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgYT0wO2E8bi5sZW5ndGgtMjthKyspYT49ci5sZW5ndGg/ci5wdXNoKG5bYSsyXSk6clthXT1uW2ErMl07Zm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspaWYoYTxvLmxlbmd0aCl7aWYob1thXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKWlmKGE8aS5sZW5ndGgpe2lmKGlbYV08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgaS5wdXNoKDEpO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGgqMjthKyspaWYoYTxzLmxlbmd0aCl7aWYoc1thXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBzLnB1c2goMCk7Zm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspe2lmKHJbYV08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKHNbYV0+PXJbYV18fHNbYStyLmxlbmd0aF0+PXJbYV0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LG4scixvLGkscyxhKXtpZihhKXtpZihpLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihuLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG8ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCB1PTA7dTx0Lmxlbmd0aC0yO3UrKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbdSsocz8xOjIpXSxuW3VdLHJbdV0sb1t1XSxpLHUsdSt0Lmxlbmd0aC0yLGEpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LG4scixvLGkscyxhKXtpZihuLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IHU9W25bMF0sblsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQsbix1LHIsbyxpLHMsYSksdX1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LG4scixvLGkscyxhKXtpZih0Lmxlbmd0aDw9MHx8bi5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgdT1bdFswXSxuWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCx1LHIsbyxpLHMsYSksdX1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsbixyLG8saSxzLGEsdSl7aWYodClmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoLTI7ZCsrKXIucHVzaCgxKTtlbHNlIGZvcihsZXQgZD0wO2Q8bi5sZW5ndGgtMjtkKyspci5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUobltkKzJdLG9bZF0saVtkXSxzW2RdLGEsZCxkK24ubGVuZ3RoLTIsdSkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LG4scixvLGkscyxhLHUpe2xldCBkPXIqKG8tMSkrMTtpZih1JiZ1IT09XCJOT1RTRVRcIilzd2l0Y2godSl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVtzXT0wLGlbYV09MCxNYXRoLmZsb29yKCh0LWQpL24rMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihyIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCBjPSgodCtuLTEpL24tMSkqbitvLXQ7cmV0dXJuIGlbc109TWF0aC5mbG9vcih1PT09XCJTQU1FX0xPV0VSXCI/KGMrMSkvMjpjLzIpLGlbYV09Yy1pW3NdLE1hdGguZmxvb3IoKHQrYy1vKS9uKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQraVtzXStpW2FdLWQpL24rMSl9fSxHdD1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxuLHIsbyxpKXtpZih0Lmxlbmd0aCE9PTJ8fHIubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgcyxhLHU7bj8ocz10WzFdLGE9dFswXSk6KHM9dFswXSxhPXRbMV0pO2xldCBkPS0xO2lmKG8/KHU9clswXSxkPTEpOih1PXJbMV0sZD0wKSxyW2RdIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYoczw9MHx8dTw9MHx8YTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihpJiYhUGUuaXNWYWxpZEJyb2FkY2FzdChpLFtzLHVdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bcyx1LGFdfX0sbG89LTM0MDI4MjM0NjYzODUyODg2ZTIyLGNvPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIEh0LE9uPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7SHQ9KGUsdCk9Pm5ldyhydCh0KSkoZSl9KTt2YXIgbW8sVW4sZm8sc2QscG8sYWQsaG8scXQsRnQsTW4sZ28seW89aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtrZSgpO21vPW5ldyBNYXAoW1tcImZsb2F0MzJcIiwzMl0sW1wiZmxvYXQxNlwiLDE2XSxbXCJpbnQzMlwiLDMyXSxbXCJ1aW50MzJcIiwzMl0sW1wiaW50NjRcIiw2NF0sW1widWludDY0XCIsNjRdLFtcImludDhcIiw4XSxbXCJ1aW50OFwiLDhdLFtcImludDRcIiw0XSxbXCJ1aW50NFwiLDRdXSksVW49KGUsdCk9PntpZih0PT09XCJpbnQzMlwiKXJldHVybiBlO2xldCBuPW1vLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoYFdlYk5OIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhIHR5cGU6ICR7dH1gKTtsZXQgcj1uLzg7aWYoZS5ieXRlTGVuZ3RoJXIhPT0wKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVaW50OEFycmF5IGxlbmd0aCAtIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke3J9LmApO2xldCBvPWUuYnl0ZUxlbmd0aC9yLGk9bmV3KHJ0KHQpKShlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsbyk7c3dpdGNoKHQpe2Nhc2VcImludDY0XCI6Y2FzZVwidWludDY0XCI6e2xldCBzPW5ldyBJbnQzMkFycmF5KG8pO2ZvcihsZXQgYT0wO2E8bzthKyspe2xldCB1PWlbYV07aWYodT4yMTQ3NDgzNjQ3bnx8dTwtMjE0NzQ4MzY0OG4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGludDY0IGRhdGEgdG8gaW50MzIgLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuXCIpO3NbYV09TnVtYmVyKHUpfXJldHVybiBuZXcgVWludDhBcnJheShzLmJ1ZmZlcil9Y2FzZVwiaW50OFwiOmNhc2VcInVpbnQ4XCI6Y2FzZVwidWludDMyXCI6e2lmKHQ9PT1cInVpbnQzMlwiJiZpLnNvbWUoYT0+YT4yMTQ3NDgzNjQ3KSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgdWludDMyIGRhdGEgdG8gaW50MzIgLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuXCIpO2xldCBzPUludDMyQXJyYXkuZnJvbShpLE51bWJlcik7cmV0dXJuIG5ldyBVaW50OEFycmF5KHMuYnVmZmVyKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSBjb252ZXJzaW9uIGZyb20gJHt0fSB0byAnaW50MzInYCl9fSxmbz0oZSx0KT0+e2lmKHQ9PT1cImludDMyXCIpcmV0dXJuIGU7aWYoZS5ieXRlTGVuZ3RoJTQhPT0wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVWludDhBcnJheSBsZW5ndGggLSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCAoaW50MzIpLlwiKTtsZXQgbj1lLmJ5dGVMZW5ndGgvNCxyPW5ldyBJbnQzMkFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxuKTtzd2l0Y2godCl7Y2FzZVwiaW50NjRcIjp7bGV0IG89QmlnSW50NjRBcnJheS5mcm9tKHIsQmlnSW50KTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIpfWNhc2VcInVpbnQ2NFwiOntpZihyLnNvbWUoaT0+aTwwKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW42NCAtIG5lZ2F0aXZlIHZhbHVlIGZvdW5kLlwiKTtsZXQgbz1CaWdVaW50NjRBcnJheS5mcm9tKHIsQmlnSW50KTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIpfWNhc2VcImludDhcIjp7aWYoci5zb21lKGk9Pmk8LTEyOHx8aT4xMjcpKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIGludDggLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuXCIpO2xldCBvPUludDhBcnJheS5mcm9tKHIsTnVtYmVyKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIpfWNhc2VcInVpbnQ4XCI6e2lmKHIuc29tZShvPT5vPDB8fG8+MjU1KSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW50OCAtIHZhbHVlIG91dCBvZiByYW5nZS5cIik7cmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyLE51bWJlcil9Y2FzZVwidWludDMyXCI6e2lmKHIuc29tZShpPT5pPDApKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIHVpbnQzMiAtIG5lZ2F0aXZlIHZhbHVlIGZvdW5kLlwiKTtsZXQgbz1VaW50MzJBcnJheS5mcm9tKHIsTnVtYmVyKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIGNvbnZlcnNpb24gZnJvbSAnaW50MzInIHRvICR7dH1gKX19LHNkPTEscG89KCk9PnNkKyssYWQ9bmV3IE1hcChbW1wiaW50OFwiLFwiaW50MzJcIl0sW1widWludDhcIixcImludDMyXCJdLFtcInVpbnQzMlwiLFwiaW50MzJcIl0sW1wiaW50NjRcIixcImludDMyXCJdXSksaG89KGUsdCk9PntsZXQgbj1tby5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke2V9YCk7cmV0dXJuIHQubGVuZ3RoPjA/TWF0aC5jZWlsKHQucmVkdWNlKChyLG8pPT5yKm8pKm4vOCk6MH0scXQ9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5pc0RhdGFDb252ZXJ0ZWQ9ITE7bGV0e3Nlc3Npb25JZDpuLGNvbnRleHQ6cix0ZW5zb3I6byxkYXRhVHlwZTppLHNoYXBlOnMsZmFsbGJhY2tEYXRhVHlwZTphfT10O3RoaXMuc2Vzc2lvbklkPW4sdGhpcy5tbENvbnRleHQ9cix0aGlzLm1sVGVuc29yPW8sdGhpcy5kYXRhVHlwZT1pLHRoaXMudGVuc29yU2hhcGU9cyx0aGlzLmZhbGxiYWNrRGF0YVR5cGU9YX1nZXQgdGVuc29yKCl7cmV0dXJuIHRoaXMubWxUZW5zb3J9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5kYXRhVHlwZX1nZXQgZmFsbGJhY2tUeXBlKCl7cmV0dXJuIHRoaXMuZmFsbGJhY2tEYXRhVHlwZX1nZXQgc2hhcGUoKXtyZXR1cm4gdGhpcy50ZW5zb3JTaGFwZX1nZXQgYnl0ZUxlbmd0aCgpe3JldHVybiBobyh0aGlzLmRhdGFUeXBlLHRoaXMudGVuc29yU2hhcGUpfWRlc3Ryb3koKXtqKFwidmVyYm9zZVwiLCgpPT5cIltXZWJOTl0gVGVuc29yV3JhcHBlci5kZXN0cm95XCIpLHRoaXMubWxUZW5zb3IuZGVzdHJveSgpfXdyaXRlKHQpe3RoaXMubWxDb250ZXh0LndyaXRlVGVuc29yKHRoaXMubWxUZW5zb3IsdCl9YXN5bmMgcmVhZCh0KXtpZih0aGlzLmZhbGxiYWNrRGF0YVR5cGUpe2xldCBuPWF3YWl0IHRoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcikscj1mbyhuZXcgVWludDhBcnJheShuKSx0aGlzLmRhdGFUeXBlKTtpZih0KXsodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP25ldyBVaW50OEFycmF5KHQpOm5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpKS5zZXQocik7cmV0dXJufWVsc2UgcmV0dXJuIHIuYnVmZmVyfWVsc2UgcmV0dXJuIHQ/dGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yLHQpOnRoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcil9Y2FuUmV1c2VUZW5zb3IodCxuLHIpe3JldHVybiB0aGlzLm1sQ29udGV4dD09PXQmJnRoaXMuZGF0YVR5cGU9PT1uJiZ0aGlzLnRlbnNvclNoYXBlLmxlbmd0aD09PXIubGVuZ3RoJiZ0aGlzLnRlbnNvclNoYXBlLmV2ZXJ5KChvLGkpPT5vPT09cltpXSl9c2V0SXNEYXRhQ29udmVydGVkKHQpe3RoaXMuaXNEYXRhQ29udmVydGVkPXR9fSxGdD1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMudGVuc29yTWFuYWdlcj10O3RoaXMud3JhcHBlcj1ufWdldCB0ZW5zb3JXcmFwcGVyKCl7cmV0dXJuIHRoaXMud3JhcHBlcn1yZWxlYXNlVGVuc29yKCl7dGhpcy50ZW5zb3JXcmFwcGVyJiYodGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy50ZW5zb3JXcmFwcGVyKSx0aGlzLndyYXBwZXI9dm9pZCAwKX1hc3luYyBlbnN1cmVUZW5zb3IodCxuLHIsbyl7bGV0IGk9dGhpcy50ZW5zb3JNYW5hZ2VyLmdldE1MQ29udGV4dCh0KSxzO2lmKCFpLm9wU3VwcG9ydExpbWl0cygpLmlucHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhuKSl7aWYocz1hZC5nZXQobiksIXN8fCFpLm9wU3VwcG9ydExpbWl0cygpLmlucHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhzKSl0aHJvdyBuZXcgRXJyb3IoYFdlYk5OIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhIHR5cGU6ICR7bn1gKTtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JJZFRyYWNrZXIuZW5zdXJlVGVuc29yOiBmYWxsYmFjayBkYXRhVHlwZSBmcm9tICR7bn0gdG8gJHtzfWApfWlmKHRoaXMud3JhcHBlcil7aWYodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKGksbixyKSlyZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtpZihvKXtpZih0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCE9PWhvKG4scikpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS5cIik7dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSl9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKX1sZXQgYT10eXBlb2YgTUxUZW5zb3JVc2FnZT5cInVcIj92b2lkIDA6TUxUZW5zb3JVc2FnZS5SRUFEfE1MVGVuc29yVXNhZ2UuV1JJVEU7cmV0dXJuIHRoaXMud3JhcHBlcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKHQsbixyLGEsITAsITAscyksbyYmdGhpcy5hY3RpdmVVcGxvYWQmJih0aGlzLndyYXBwZXIud3JpdGUodGhpcy5hY3RpdmVVcGxvYWQpLHRoaXMuYWN0aXZlVXBsb2FkPXZvaWQgMCksdGhpcy53cmFwcGVyLnRlbnNvcn11cGxvYWQodCl7bGV0IG49dDtpZih0aGlzLndyYXBwZXIpe2lmKHRoaXMud3JhcHBlci5mYWxsYmFja1R5cGUpaWYodGhpcy53cmFwcGVyLmZhbGxiYWNrVHlwZT09PVwiaW50MzJcIiluPVVuKHQsdGhpcy53cmFwcGVyLnR5cGUpLHRoaXMud3JhcHBlci5zZXRJc0RhdGFDb252ZXJ0ZWQoITApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBmYWxsYmFjayBkYXRhIHR5cGU6ICR7dGhpcy53cmFwcGVyLmZhbGxiYWNrVHlwZX1gKTtpZih0LmJ5dGVMZW5ndGg9PT10aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCl7dGhpcy53cmFwcGVyLndyaXRlKG4pO3JldHVybn1lbHNlIGooXCJ2ZXJib3NlXCIsKCk9PlwiRGF0YSBzaXplIGRvZXMgbm90IG1hdGNoIHRlbnNvciBzaXplLiBSZWxlYXNpbmcgdGVuc29yLlwiKSx0aGlzLnJlbGVhc2VUZW5zb3IoKX10aGlzLmFjdGl2ZVVwbG9hZD90aGlzLmFjdGl2ZVVwbG9hZC5zZXQobik6dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkobil9YXN5bmMgZG93bmxvYWQodCl7aWYodGhpcy5hY3RpdmVVcGxvYWQpe2xldCBuPXRoaXMud3JhcHBlcj8uaXNEYXRhQ29udmVydGVkP2ZvKHRoaXMuYWN0aXZlVXBsb2FkLHRoaXMud3JhcHBlcj8udHlwZSk6dGhpcy5hY3RpdmVVcGxvYWQ7aWYodCl7dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP25ldyBVaW50OEFycmF5KHQpLnNldChuKTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKS5zZXQobik7cmV0dXJufWVsc2UgcmV0dXJuIG4uYnVmZmVyfWlmKCF0aGlzLndyYXBwZXIpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGhhcyBub3QgYmVlbiBjcmVhdGVkLlwiKTtyZXR1cm4gdD90aGlzLndyYXBwZXIucmVhZCh0KTp0aGlzLndyYXBwZXIucmVhZCgpfX0sTW49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQ9bmV3IE1hcDt0aGlzLmZyZWVUZW5zb3JzPVtdO3RoaXMuZXh0ZXJuYWxUZW5zb3JzPW5ldyBTZXR9Z2V0TUxDb250ZXh0KHQpe2xldCBuPXRoaXMuYmFja2VuZC5nZXRNTENvbnRleHQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiTUxDb250ZXh0IG5vdCBmb3VuZCBmb3Igc2Vzc2lvbi5cIik7cmV0dXJuIG59cmVzZXJ2ZVRlbnNvcklkKCl7bGV0IHQ9cG8oKTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHQsbmV3IEZ0KHRoaXMpKSx0fXJlbGVhc2VUZW5zb3JJZCh0KXtsZXQgbj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7biYmKHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmRlbGV0ZSh0KSxuLnRlbnNvcldyYXBwZXImJnRoaXMucmVsZWFzZVRlbnNvcihuLnRlbnNvcldyYXBwZXIpKX1hc3luYyBlbnN1cmVUZW5zb3IodCxuLHIsbyxpKXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvciB7dGVuc29ySWQ6ICR7bn0sIGRhdGFUeXBlOiAke3J9LCBzaGFwZTogJHtvfSwgY29weU9sZDogJHtpfX1gKTtsZXQgcz10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQobik7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7cmV0dXJuIHMuZW5zdXJlVGVuc29yKHQscixvLGkpfXVwbG9hZCh0LG4pe2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyLnVwbG9hZChuKX1hc3luYyBkb3dubG9hZCh0LG4pe2ooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZG93bmxvYWQge3RlbnNvcklkOiAke3R9LCBkc3RCdWZmZXI6ICR7bj8uYnl0ZUxlbmd0aH19YCk7bGV0IHI9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiByLmRvd25sb2FkKG4pfXJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbih0KXtmb3IobGV0IG4gb2YgdGhpcy5mcmVlVGVuc29ycyluLnNlc3Npb25JZD09PXQmJm4uZGVzdHJveSgpO3RoaXMuZnJlZVRlbnNvcnM9dGhpcy5mcmVlVGVuc29ycy5maWx0ZXIobj0+bi5zZXNzaW9uSWQhPT10KX1yZWdpc3RlclRlbnNvcih0LG4scixvKXtsZXQgaT10aGlzLmdldE1MQ29udGV4dCh0KSxzPXBvKCksYT1uZXcgcXQoe3Nlc3Npb25JZDp0LGNvbnRleHQ6aSx0ZW5zb3I6bixkYXRhVHlwZTpyLHNoYXBlOm99KTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHMsbmV3IEZ0KHRoaXMsYSkpLHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZChhKSxzfWFzeW5jIGdldENhY2hlZFRlbnNvcih0LG4scixvLGkscyxhKXtsZXQgdT10aGlzLmdldE1MQ29udGV4dCh0KTtmb3IobGV0W2wsY11vZiB0aGlzLmZyZWVUZW5zb3JzLmVudHJpZXMoKSlpZihjLmNhblJldXNlVGVuc29yKHUsbixyKSl7aihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke259LCAke2E/YGZhbGxiYWNrRGF0YVR5cGU6ICR7YX0sYDpcIlwifSBzaGFwZTogJHtyfWApO2xldCBwPXRoaXMuZnJlZVRlbnNvcnMuc3BsaWNlKGwsMSlbMF07cmV0dXJuIHAuc2Vzc2lvbklkPXQscH1qKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBNTENvbnRleHQuY3JlYXRlVGVuc29yIHtkYXRhVHlwZTogJHtufSwgJHthP2BmYWxsYmFja0RhdGFUeXBlOiAke2F9LGA6XCJcIn0gc2hhcGU6ICR7cn19YCk7bGV0IGQ9YXdhaXQgdS5jcmVhdGVUZW5zb3Ioe2RhdGFUeXBlOmE/P24sc2hhcGU6cixkaW1lbnNpb25zOnIsdXNhZ2U6byx3cml0YWJsZTppLHJlYWRhYmxlOnN9KTtyZXR1cm4gbmV3IHF0KHtzZXNzaW9uSWQ6dCxjb250ZXh0OnUsdGVuc29yOmQsZGF0YVR5cGU6bixzaGFwZTpyLGZhbGxiYWNrRGF0YVR5cGU6YX0pfXJlbGVhc2VUZW5zb3IodCl7dGhpcy5leHRlcm5hbFRlbnNvcnMuaGFzKHQpJiZ0aGlzLmV4dGVybmFsVGVuc29ycy5kZWxldGUodCksdGhpcy5mcmVlVGVuc29ycy5wdXNoKHQpfX0sZ289KC4uLmUpPT5uZXcgTW4oLi4uZSl9KTt2YXIgS3QsdWQsanQsYm89aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtHZSgpO09uKCk7eW8oKTtrZSgpO0t0PW5ldyBNYXAoW1sxLFwiZmxvYXQzMlwiXSxbMTAsXCJmbG9hdDE2XCJdLFs2LFwiaW50MzJcIl0sWzEyLFwidWludDMyXCJdLFs3LFwiaW50NjRcIl0sWzEzLFwidWludDY0XCJdLFsyMixcImludDRcIl0sWzIxLFwidWludDRcIl0sWzMsXCJpbnQ4XCJdLFsyLFwidWludDhcIl0sWzksXCJ1aW50OFwiXV0pLHVkPShlLHQpPT57aWYoZT09PXQpcmV0dXJuITA7aWYoZT09PXZvaWQgMHx8dD09PXZvaWQgMClyZXR1cm4hMTtsZXQgbj1PYmplY3Qua2V5cyhlKS5zb3J0KCkscj1PYmplY3Qua2V5cyh0KS5zb3J0KCk7cmV0dXJuIG4ubGVuZ3RoPT09ci5sZW5ndGgmJm4uZXZlcnkoKG8saSk9Pm89PT1yW2ldJiZlW29dPT09dFtvXSl9LGp0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMudGVuc29yTWFuYWdlcj1nbyh0aGlzKTt0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkPW5ldyBNYXA7dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQ9bmV3IE1hcDt0aGlzLm1sQ29udGV4dENhY2hlPVtdO3RoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzPW5ldyBNYXA7dGhpcy5zZXNzaW9uR3JhcGhPdXRwdXRzPW5ldyBNYXA7dGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cz1bXTt0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cz1bXTt0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHM9bmV3IE1hcDtXdCh0LmxvZ0xldmVsLCEhdC5kZWJ1Zyl9Z2V0IGN1cnJlbnRTZXNzaW9uSWQoKXtpZih0aGlzLmFjdGl2ZVNlc3Npb25JZD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgc2Vzc2lvblwiKTtyZXR1cm4gdGhpcy5hY3RpdmVTZXNzaW9uSWR9b25SdW5TdGFydCh0KXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBvblJ1blN0YXJ0IHtzZXNzaW9uSWQ6ICR7dH19YCksdGhpcy5hY3RpdmVTZXNzaW9uSWQ9dH1vblJ1bkVuZCh0KXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBvblJ1bkVuZCB7c2Vzc2lvbklkOiAke3R9fWApO2xldCBuPXRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5nZXQodCk7aWYobil7Zm9yKGxldCByIG9mIG4paihcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzaW5nIHRlbXBvcmFyeSB0ZW5zb3Ige3RlbnNvcklkOiAke3J9fWApLHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQocik7dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmRlbGV0ZSh0KSx0aGlzLmFjdGl2ZVNlc3Npb25JZD12b2lkIDB9fWFzeW5jIGNyZWF0ZU1MQ29udGV4dCh0KXtpZih0IGluc3RhbmNlb2YgR1BVRGV2aWNlKXtsZXQgcj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLmdwdURldmljZT09PXQpO2lmKHIhPT0tMSlyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVtyXS5tbENvbnRleHQ7e2xldCBvPWF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHQpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe2dwdURldmljZTp0LG1sQ29udGV4dDpvfSksb319ZWxzZSBpZih0PT09dm9pZCAwKXtsZXQgcj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLm9wdGlvbnM9PT12b2lkIDAmJm8uZ3B1RGV2aWNlPT09dm9pZCAwKTtpZihyIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbcl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCgpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe21sQ29udGV4dDpvfSksb319bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgocj0+dWQoci5vcHRpb25zLHQpKTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgcj1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtvcHRpb25zOnQsbWxDb250ZXh0OnJ9KSxyfX1yZWdpc3Rlck1MQ29udGV4dCh0LG4pe3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHQsbik7bGV0IHI9dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG4pO3J8fChyPW5ldyBTZXQsdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KG4scikpLHIuYWRkKHQpLHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMubGVuZ3RoPjAmJih0aGlzLnNlc3Npb25HcmFwaElucHV0cy5zZXQodCx0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzKSx0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzPVtdKSx0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cy5sZW5ndGg+MCYmKHRoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cy5zZXQodCx0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cyksdGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHM9W10pfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZGVsZXRlKHQpLHRoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cy5kZWxldGUodCk7bGV0IG49dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCk7aWYoIW4pcmV0dXJuO3RoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCksdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUodCk7bGV0IHI9dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG4pO2lmKHIuZGVsZXRlKHQpLHIuc2l6ZT09PTApe3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShuKTtsZXQgbz10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChpPT5pLm1sQ29udGV4dD09PW4pO28hPT0tMSYmdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobywxKX19Z2V0TUxDb250ZXh0KHQpe3JldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KX1yZXNlcnZlVGVuc29ySWQoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpfXJlbGVhc2VUZW5zb3JJZCh0KXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWxlYXNlVGVuc29ySWQge3RlbnNvcklkOiAke3R9fWApLHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQodCl9YXN5bmMgZW5zdXJlVGVuc29yKHQsbixyLG8saSl7bGV0IHM9S3QuZ2V0KHIpO2lmKCFzKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7cn1gKTtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvcih0Pz90aGlzLmN1cnJlbnRTZXNzaW9uSWQsbixzLG8saSl9YXN5bmMgY3JlYXRlVGVtcG9yYXJ5VGVuc29yKHQsbixyKXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ige29ubnhEYXRhVHlwZTogJHtufSwgc2hhcGU6ICR7cn19YCk7bGV0IG89S3QuZ2V0KG4pO2lmKCFvKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7bn1gKTtsZXQgaT10aGlzLnRlbnNvck1hbmFnZXIucmVzZXJ2ZVRlbnNvcklkKCk7YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvcih0LGksbyxyLCExKTtsZXQgcz10aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHQpO3JldHVybiBzP3MucHVzaChpKTp0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuc2V0KHQsW2ldKSxpfXVwbG9hZFRlbnNvcih0LG4pe2lmKCFuZSgpLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlXCIpO2ooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHVwbG9hZFRlbnNvciB7dGVuc29ySWQ6ICR7dH0sIGRhdGE6ICR7bi5ieXRlTGVuZ3RofX1gKSx0aGlzLnRlbnNvck1hbmFnZXIudXBsb2FkKHQsbil9YXN5bmMgZG93bmxvYWRUZW5zb3IodCxuKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQsbil9Y3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKHQsbil7cmV0dXJuIGFzeW5jKCk9PntsZXQgcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodCk7cmV0dXJuIEh0KHIsbil9fXJlZ2lzdGVyTUxUZW5zb3IodCxuLHIsbyl7bGV0IGk9S3QuZ2V0KHIpO2lmKCFpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7cn1gKTtsZXQgcz10aGlzLnRlbnNvck1hbmFnZXIucmVnaXN0ZXJUZW5zb3IodCxuLGksbyk7cmV0dXJuIGooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHtufSwgZGF0YVR5cGU6ICR7aX0sIGRpbWVuc2lvbnM6ICR7b319IC0+IHt0ZW5zb3JJZDogJHtzfX1gKSxzfXJlZ2lzdGVyTUxDb25zdGFudCh0LG4scixvLGkscyxhPSExKXtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBtb3VudGVkIGZpbGVzIGFyZSBub3QgYXZhaWxhYmxlLlwiKTtsZXQgdT10O3Quc3RhcnRzV2l0aChcIi4vXCIpJiYodT10LnN1YnN0cmluZygyKSk7bGV0IGQ9cy5nZXQodSk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKGBGaWxlIHdpdGggbmFtZSAke3V9IG5vdCBmb3VuZCBpbiBwcmVsb2FkZWQgZmlsZXMuYCk7aWYobityPmQuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2YgYm91bmRzOiBkYXRhIG9mZnNldCBhbmQgbGVuZ3RoIGV4Y2VlZCB0aGUgZXh0ZXJuYWwgZmlsZSBkYXRhIHNpemUuXCIpO2xldCBsPWQuc2xpY2UobixuK3IpLmJ1ZmZlcixjO3N3aXRjaChpLmRhdGFUeXBlKXtjYXNlXCJmbG9hdDMyXCI6Yz1uZXcgRmxvYXQzMkFycmF5KGwpO2JyZWFrO2Nhc2VcImZsb2F0MTZcIjpjPXR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tP25ldyBGbG9hdDE2QXJyYXkobCk6bmV3IFVpbnQxNkFycmF5KGwpO2JyZWFrO2Nhc2VcImludDMyXCI6Yz1uZXcgSW50MzJBcnJheShsKTticmVhaztjYXNlXCJ1aW50MzJcIjpjPW5ldyBVaW50MzJBcnJheShsKTticmVhaztjYXNlXCJpbnQ2NFwiOmlmKGEpe2xldCBwPVVuKG5ldyBVaW50OEFycmF5KGwpLFwiaW50NjRcIik7Yz1uZXcgSW50MzJBcnJheShwLmJ1ZmZlciksaS5kYXRhVHlwZT1cImludDMyXCJ9ZWxzZSBjPW5ldyBCaWdJbnQ2NEFycmF5KGwpO2JyZWFrO2Nhc2VcInVpbnQ2NFwiOmM9bmV3IEJpZ1VpbnQ2NEFycmF5KGwpO2JyZWFrO2Nhc2VcImludDhcIjpjPW5ldyBJbnQ4QXJyYXkobCk7YnJlYWs7Y2FzZVwiaW50NFwiOmNhc2VcInVpbnQ0XCI6Y2FzZVwidWludDhcIjpjPW5ldyBVaW50OEFycmF5KGwpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7aS5kYXRhVHlwZX0gaW4gY3JlYXRpbmcgV2ViTk4gQ29uc3RhbnQgZnJvbSBleHRlcm5hbCBkYXRhLmApfXJldHVybiBqKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWdpc3Rlck1MQ29uc3RhbnQge2RhdGFUeXBlOiAke2kuZGF0YVR5cGV9LCBzaGFwZTogJHtpLnNoYXBlfX19ICR7YT9cIihOb3RlOiBpdCB3YXMgaW50NjQgZGF0YSB0eXBlIGFuZCByZWdpc3RlcmVkIHRvIGludDMyIGFzIHdvcmthcm91bmQpXCI6XCJcIn1gKSxvLmNvbnN0YW50KGksYyl9cmVnaXN0ZXJHcmFwaElucHV0KHQpe3RoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMucHVzaCh0KX1yZWdpc3RlckdyYXBoT3V0cHV0KHQpe3RoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzLnB1c2godCl9aXNHcmFwaElucHV0KHQsbil7bGV0IHI9dGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZ2V0KHQpO3JldHVybiByP3IuaW5jbHVkZXMobik6ITF9aXNHcmFwaE91dHB1dCh0LG4pe2xldCByPXRoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cy5nZXQodCk7cmV0dXJuIHI/ci5pbmNsdWRlcyhuKTohMX1pc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkKHQsbixyPSEwKXtsZXQgbz10aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KSxpPUt0LmdldChIZShuKSk7cmV0dXJuIHR5cGVvZiBpPlwidVwiPyExOnI/ISFvPy5vcFN1cHBvcnRMaW1pdHMoKS5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoaSk6ISFvPy5vcFN1cHBvcnRMaW1pdHMoKS5vdXRwdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGkpfWZsdXNoKCl7fX19KTt2YXIgWnQ9aygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIF9vLFJuLFZuLGRkLGxkLHdvLExuLE5uLHZvLHhvPWsoKCk9PntcInVzZSBzdHJpY3RcIjtrZSgpO1p0KCk7X289bmV3IE1hcChbWzY0LDI1MF0sWzEyOCwyMDBdLFsyNTYsMjAwXSxbNTEyLDIwMF0sWzIwNDgsMjMwXSxbNDA5NiwyMDBdLFs4MTkyLDUwXSxbMTYzODQsNTBdLFszMjc2OCw1MF0sWzY1NTM2LDUwXSxbMTMxMDcyLDUwXSxbMjYyMTQ0LDUwXSxbNTI0Mjg4LDUwXSxbMTA0ODU3Niw1MF0sWzIwOTcxNTIsMzBdLFs0MTk0MzA0LDIwXSxbODM4ODYwOCwxMF0sWzEyNTgyOTEyLDEwXSxbMTY3NzcyMTYsMTBdLFsyNjIxNDQwMCwxNV0sWzMzNTU0NDMyLDIyXSxbNDQyMzY4MDAsMl0sWzU4OTgyNDAwLDZdLFs2NzEwODg2NCw2XSxbMTM0MjE3NzI4LDZdLFsxNjc3NzIxNjAsNl1dKSxSbj1bXSxWbj1lPT5NYXRoLmNlaWwoTnVtYmVyKGUpLzE2KSoxNixkZD1lPT57Zm9yKGxldCB0PTA7dDxSbi5sZW5ndGg7dCsrKXtsZXQgbj1Sblt0XTtpZihlPD1uKXJldHVybiBufXJldHVybiBNYXRoLmNlaWwoZS8xNikqMTZ9LGxkPTEsd289KCk9PmxkKyssTG49YXN5bmMoZSx0LG4scik9PntsZXQgbz1WbihuKSxpPWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCBzPWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCkscy5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLGksMCxvKSxlLmZsdXNoKCksYXdhaXQgaS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBhPWkuZ2V0TWFwcGVkUmFuZ2UoKTtpZihyKXtsZXQgdT1yKCk7cmV0dXJuIHUuc2V0KG5ldyBVaW50OEFycmF5KGEsMCxuKSksdX1lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShhLnNsaWNlKDAsbikpfWZpbmFsbHl7aS5kZXN0cm95KCl9fSxObj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc1BlbmRpbmc9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXA7Zm9yKGxldFtuXW9mIF9vKVJuLnB1c2gobiksdGhpcy5mcmVlQnVmZmVycy5zZXQobixbXSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuc2V0KG4sW10pO3RoaXMuc2Vzc2lvbkNvdW50PTB9dXBsb2FkKHQsbil7bGV0IHI9bi5idWZmZXIsbz1uLmJ5dGVPZmZzZXQsaT1uLmJ5dGVMZW5ndGgscz1WbihpKSxhPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKE51bWJlcihhLm9yaWdpbmFsU2l6ZSkhPT1pKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2Eub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7aX1gKTtsZXQgdT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOnMsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSksZD11LmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkoZCkuc2V0KG5ldyBVaW50OEFycmF5KHIsbyxpKSksdS51bm1hcCgpO2xldCBsPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtsLmNvcHlCdWZmZXJUb0J1ZmZlcih1LDAsYS5ncHVEYXRhLmJ1ZmZlciwwLHMpLHRoaXMuYmFja2VuZC5kZXZpY2UucXVldWUuc3VibWl0KFtsLmZpbmlzaCgpXSksdS5kZXN0cm95KCksaihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke3R9KWApfW1lbWNweSh0LG4pe2xldCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQobik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtpZihyLm9yaWdpbmFsU2l6ZSE9PW8ub3JpZ2luYWxTaXplKXRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemVcIik7bGV0IGk9Vm4oci5vcmlnaW5hbFNpemUpLHM9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCkscy5jb3B5QnVmZmVyVG9CdWZmZXIoci5ncHVEYXRhLmJ1ZmZlciwwLG8uZ3B1RGF0YS5idWZmZXIsMCxpKX1yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQsbixyKXtsZXQgbztpZihyKXtpZihvPXJbMF0sdD09PXJbMV0pcmV0dXJuIGooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtufSkgPT4gaWQ9JHtvfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG87aWYodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKSl0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApfWVsc2Ugbz13bygpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobyx7Z3B1RGF0YTp7aWQ6byx0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpufSksaihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke259KSA9PiBpZD0ke299LCByZWdpc3RlcmVkLmApLG99dW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQpe3QhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUodCksaihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7dH1gKSl9Y3JlYXRlKHQsbj1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKXtsZXQgcj1kZCh0KSxvLGk9KG4mR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFLHM9KG4mR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNO2lmKGl8fHMpe2xldCBkPShpP3RoaXMuZnJlZUJ1ZmZlcnM6dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMpLmdldChyKTtkP2QubGVuZ3RoPjA/bz1kLnBvcCgpOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6cix1c2FnZTpufSk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLHVzYWdlOm59KX1lbHNlIG89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6cix1c2FnZTpufSk7bGV0IGE9e2lkOndvKCksdHlwZTowLGJ1ZmZlcjpvfTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGEuaWQse2dwdURhdGE6YSxvcmlnaW5hbFNpemU6TnVtYmVyKHQpfSksaihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7YS5pZH1gKSxhfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IG49dHlwZW9mIHQ9PVwiYmlnaW50XCI/TnVtYmVyKHQpOnQscj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQobik7aWYoIXIpe2lmKHRoaXMuc3RvcmFnZUNhY2hlLnNpemU9PT0wKXJldHVybiAwO3Rocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpfXJldHVybiBqKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke259KSwgZ3B1RGF0YUlkPSR7ci5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShuKSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goci5ncHVEYXRhLmJ1ZmZlciksci5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxuKXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoTnVtYmVyKHQpKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IExuKHRoaXMuYmFja2VuZCxyLmdwdURhdGEuYnVmZmVyLHIub3JpZ2luYWxTaXplLG4pfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2lmKHRoaXMuYnVmZmVyc1BlbmRpbmcubGVuZ3RoIT09MClpZih0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cz09PVwiZGVmYXVsdFwiKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzUGVuZGluZyl7bGV0IG49X28uZ2V0KHQuc2l6ZSk7aWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFKXtsZXQgcj10aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpfHxbXTtuPT09dm9pZCAwfHxyLmxlbmd0aD49bj90LmRlc3Ryb3koKTpyLnB1c2godCl9ZWxzZSBpZigodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pe2xldCByPXRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpfHxbXTtuPT09dm9pZCAwfHxyLmxlbmd0aD49bj90LmRlc3Ryb3koKTpyLnB1c2godCl9ZWxzZSB0LmRlc3Ryb3koKX10aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWVsc2V7bGV0IHQ9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCk7dHx8KHQ9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLnNldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCx0KSk7Zm9yKGxldCBuIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpdC5wdXNoKG4pO3RoaXMuYnVmZmVyc1BlbmRpbmc9W119fWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXB9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5zZXNzaW9uQ291bnQrPTF9b25SZWxlYXNlU2Vzc2lvbih0KXtsZXQgbj10aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHQpO24mJihuLmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmRlbGV0ZSh0KSksdGhpcy5zZXNzaW9uQ291bnQtPTEsdGhpcy5zZXNzaW9uQ291bnQ9PT0wJiYoaihcIndhcm5pbmdcIiwoKT0+XCJbV2ViR1BVXSBDbGVhcmluZyB3ZWJncHUgYnVmZmVyIGNhY2hlXCIpLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2gocj0+e3IuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCl9fSx2bz0oLi4uZSk9Pm5ldyBObiguLi5lKX0pO3ZhciBXbixOLGllPWsoKCk9PntcInVzZSBzdHJpY3RcIjtXbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LE49ZT0+bmV3IFduKGUpfSk7dmFyIFllLEhuLHJlLGNlLFAsWCxxbixKZSxUZSxPLFF0LFMsQyxTbyxYdCxHbixUbyxLPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO1llPTY0LEhuPShlLHQpPT57aWYodD09PTMpdGhyb3cgbmV3IEVycm9yKFwidmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZFwiKTtzd2l0Y2goTnVtYmVyKGUpKXtjYXNlIDEwOnJldHVybiB0PjE/YHZlYyR7dH08ZjE2PmA6XCJmMTZcIjtjYXNlIDE6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMzI+YDpcImYzMlwiO2Nhc2UgNjpyZXR1cm4gdD4xP2B2ZWMke3R9PGkzMj5gOlwiaTMyXCI7Y2FzZSAxMjpyZXR1cm4gdD4xP2B2ZWMke3R9PHUzMj5gOlwidTMyXCI7Y2FzZSA3OmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJpMzJcIl07Y2FzZSAxMzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwidTMyXCJdO2Nhc2UgOTppZih0IT09NCl0aHJvdyBuZXcgRXJyb3IoXCJib29sIG11c3QgYmUgdmVjNFwiKTtyZXR1cm5bXCJ1MzJcIixcInZlYzQ8Ym9vbD5cIl07Y2FzZSAyMjpyZXR1cm5cImkzMlwiO2Nhc2UgMjE6cmV0dXJuXCJ1MzJcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7ZX1gKX19LHJlPShlLHQ9MSk9PntsZXQgbj1IbihlLHQpO3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm5bMF19LGNlPShlLHQ9MSk9PntsZXQgbj1IbihlLHQpO3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm5bMV19LFA9KC4uLmUpPT57bGV0IHQ9W107cmV0dXJuIGUuZm9yRWFjaChuPT57bi5sZW5ndGghPT0wJiZ0LnB1c2goe3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOnguY29tcHV0ZVN0cmlkZXMobil9KX0pLHR9LFg9ZT0+ZSU0PT09MD80OmUlMj09PTA/MjoxLHFuPShlPVwiZjMyXCIsdCxuPVwiMFwiKT0+IXR8fHQ9PT0xP2Ake2V9KCR7bn0pYDpgdmVjJHt0fTwke2V9Pigke259KWAsSmU9KGUsdCxuKT0+ZT09PVwiZjMyXCI/bjp0PT09MT9gZjMyKCR7bn0pYDpgdmVjJHt0fTxmMzI+KCR7bn0pYCxUZT0oZSx0KT0+dD09PTQ/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnogKyAke2V9LncpYDp0PT09Mj9gKCR7ZX0ueCArICR7ZX0ueSlgOnQ9PT0zP2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56KWA6ZSxPPShlLHQsbixyKT0+ZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZuPjQ/dHlwZW9mIHQ9PVwic3RyaW5nXCI/cj09PVwiZjE2XCI/YCR7ZX1bKCR7dH0pIC8gOF1bKCR7dH0pICUgOCAvIDRdWygke3R9KSAlIDggJSA0XWA6YCR7ZX1bKCR7dH0pIC8gNF1bKCR7dH0pICUgNF1gOnI9PT1cImYxNlwiP2Ake2V9WyR7TWF0aC5mbG9vcih0LzgpfV1bJHtNYXRoLmZsb29yKHQlOC80KX1dWyR7dCU4JTR9XWA6YCR7ZX1bJHtNYXRoLmZsb29yKHQvNCl9XVske3QlNH1dYDpuPjE/YCR7ZX1bJHt0fV1gOmUsUXQ9KGUsdCxuLHIsbyk9PntsZXQgaT10eXBlb2Ygbj09XCJudW1iZXJcIixzPWk/bjpuLmxlbmd0aCxhPVsuLi5uZXcgQXJyYXkocykua2V5cygpXSx1PXM8Mj9cInUzMlwiOnM8PTQ/YHZlYyR7c308dTMyPmA6YGFycmF5PHUzMiwgJHtzfT5gLGQ9SG4odCxvKSxsPXR5cGVvZiBkPT1cInN0cmluZ1wiP2Q6ZFsxXSxjPXR5cGVvZiBkPT1cInN0cmluZ1wiP2Q6ZFswXSxwPXtpbmRpY2VzOnUsdmFsdWU6bCxzdG9yYWdlOmMsdGVuc29yOnR9LGY9RT0+dHlwZW9mIEU9PVwic3RyaW5nXCI/RTpgJHtFfXVgLG09e29mZnNldFRvSW5kaWNlczohMSxpbmRpY2VzVG9PZmZzZXQ6ITEsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ITEsc2V0OiExLHNldEJ5SW5kaWNlczohMSxnZXQ6ITEsZ2V0QnlJbmRpY2VzOiExfSxoPWk/XCJ1bmlmb3Jtcy5cIjpcIlwiLGI9YCR7aH0ke2V9X3NoYXBlYCx5PWAke2h9JHtlfV9zdHJpZGVzYCxnPVwiXCI7Zm9yKGxldCBFPTA7RTxzLTE7RSsrKWcrPWBcbiAgICBsZXQgZGltJHtFfSA9IGN1cnJlbnQgLyAke08oeSxFLHMpfTtcbiAgICBsZXQgcmVzdCR7RX0gPSBjdXJyZW50ICUgJHtPKHksRSxzKX07XG4gICAgaW5kaWNlc1ske0V9XSA9IGRpbSR7RX07XG4gICAgY3VycmVudCA9IHJlc3Qke0V9O1xuICAgIGA7Zys9YGluZGljZXNbJHtzLTF9XSA9IGN1cnJlbnQ7YDtsZXQgXz1zPDI/XCJcIjpgXG4gIGZuIG8yaV8ke2V9KG9mZnNldDogdTMyKSAtPiAke3AuaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke3AuaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHtnfVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YCx3PUU9PihtLm9mZnNldFRvSW5kaWNlcz0hMCxzPDI/RTpgbzJpXyR7ZX0oJHtFfSlgKSx2PVtdO2lmKHM+PTIpZm9yKGxldCBFPXMtMTtFPj0wO0UtLSl2LnB1c2goYCR7Tyh5LEUscyl9ICogKGluZGljZXNbJHtFfV0pYCk7bGV0ICQ9czwyP1wiXCI6YFxuICBmbiBpMm9fJHtlfShpbmRpY2VzOiAke3AuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7di5qb2luKFwiK1wiKX07XG4gIH1gLFQ9RT0+KG0uaW5kaWNlc1RvT2Zmc2V0PSEwLHM8Mj9FOmBpMm9fJHtlfSgke0V9KWApLEk9KC4uLkUpPT5zPT09MD9cIjB1XCI6YCR7cC5pbmRpY2VzfSgke0UubWFwKGYpLmpvaW4oXCIsXCIpfSlgLEE9KEUsTCk9PnM8Mj9gJHtFfWA6YCR7TyhFLEwscyl9YCx6PShFLEwsb2UpPT5zPDI/YCR7RX09JHtvZX07YDpgJHtPKEUsTCxzKX09JHtvZX07YCxNPXt9LFU9KEUsTCk9PnttLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0PSEwO2xldCBvZT1gJHtMLm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke2V9T2Zmc2V0YDtpZihvZSBpbiBNKXJldHVybmAke29lfSgke0V9KWA7bGV0ICRlPVtdO2ZvcihsZXQgU2U9cy0xO1NlPj0wO1NlLS0pe2xldCB1ZT1MLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsU2UrTC5yYW5rLXMpOyRlLnB1c2goYCR7QSh5LFNlKX0gKiAoJHt1ZX0gJSAke0EoYixTZSl9KWApfXJldHVybiBNW29lXT1gZm4gJHtvZX0ob3V0cHV0SW5kaWNlczogJHtMLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7JGUubGVuZ3RoPjA/JGUuam9pbihcIitcIik6XCIwdVwifTtcbiAgICAgICAgICAgfWAsYCR7b2V9KCR7RX0pYH0sRz0oRSxMKT0+KCgpPT57aWYocC5zdG9yYWdlPT09cC52YWx1ZSlyZXR1cm5gJHtlfVske0V9XT0ke0x9O2A7aWYocC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmcC52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYCR7ZX1bJHtFfV09dmVjMjx1MzI+KHUzMigke0x9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHtMfSA8IDApKTtgO2lmKHAuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnAudmFsdWU9PT1cInUzMlwiKXJldHVybmAke2V9WyR7RX1dPXZlYzI8dTMyPih1MzIoJHtMfSksIDB1KTtgO2lmKHAuc3RvcmFnZT09PVwidTMyXCImJnAudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gJHtlfVske0V9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke0x9KSk7YDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7cC5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3AudmFsdWV9IHlldGApfSkoKSxCPUU9PigoKT0+e2lmKHAuc3RvcmFnZT09PXAudmFsdWUpcmV0dXJuYCR7ZX1bJHtFfV1gO2lmKHAuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnAudmFsdWU9PT1cImkzMlwiKXJldHVybmBpMzIoJHtlfVske0V9XS54KWA7aWYocC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmcC52YWx1ZT09PVwidTMyXCIpcmV0dXJuYHUzMigke2V9WyR7RX1dLngpYDtpZihwLnN0b3JhZ2U9PT1cInUzMlwiJiZwLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYHZlYzQ8Ym9vbD4oYm9vbCgke2V9WyR7RX1dICYgMHhGRnUpLCBib29sKCR7ZX1bJHtFfV0gJiAweEZGMDB1KSwgYm9vbCgke2V9WyR7RX1dICYgMHhGRjAwMDB1KSwgYm9vbCgke2V9WyR7RX1dICYgMHhGRjAwMDAwMHUpKWA7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3Auc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtwLnZhbHVlfSB5ZXRgKX0pKCksZWU9czwyP1wiXCI6YFxuICBmbiBnZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3AuaW5kaWNlc30pIC0+ICR7bH0ge1xuICAgIHJldHVybiAke0IoYGkyb18ke2V9KGluZGljZXMpYCl9O1xuICB9YCxXPXM8Mj9cIlwiOigoKT0+e2xldCBFPWEubWFwKG9lPT5gZCR7b2V9OiB1MzJgKS5qb2luKFwiLCBcIiksTD1hLm1hcChvZT0+YGQke29lfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIGdldF8ke2V9KCR7RX0pIC0+ICR7bH0ge1xuICAgIHJldHVybiBnZXRfJHtlfUJ5SW5kaWNlcygke0koTCl9KTtcbiAgfWB9KSgpLEQ9KC4uLkUpPT57aWYoRS5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3N9YCk7bGV0IEw9RS5tYXAoZikuam9pbihcIixcIik7cmV0dXJuIHM9PT0wP0IoXCIwdVwiKTpzPT09MT9CKExbMF0pOihtLmdldD0hMCxtLmdldEJ5SW5kaWNlcz0hMCxtLmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtMfSlgKX0sWj1FPT5zPDI/QihFKToobS5nZXRCeUluZGljZXM9ITAsbS5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7RX0pYCksUj1zPDI/XCJcIjpgXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7cC5pbmRpY2VzfSwgdmFsdWU6ICR7bH0pIHtcbiAgICAke0coYGkyb18ke2V9KGluZGljZXMpYCxcInZhbHVlXCIpfVxuICB9YCxRPXM8Mj9cIlwiOigoKT0+e2xldCBFPWEubWFwKG9lPT5gZCR7b2V9OiB1MzJgKS5qb2luKFwiLCBcIiksTD1hLm1hcChvZT0+YGQke29lfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIHNldF8ke2V9KCR7RX0sIHZhbHVlOiAke2x9KSB7XG4gICAgc2V0XyR7ZX1CeUluZGljZXMoJHtJKEwpfSwgdmFsdWUpO1xuICB9YH0pKCk7cmV0dXJue2ltcGw6KCk9PntsZXQgRT1bXSxMPSExO3JldHVybiBtLm9mZnNldFRvSW5kaWNlcyYmKEUucHVzaChfKSxMPSEwKSxtLmluZGljZXNUb09mZnNldCYmKEUucHVzaCgkKSxMPSEwKSxtLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0JiYoT2JqZWN0LnZhbHVlcyhNKS5mb3JFYWNoKG9lPT5FLnB1c2gob2UpKSxMPSEwKSxtLnNldCYmKEUucHVzaChRKSxMPSEwKSxtLnNldEJ5SW5kaWNlcyYmKEUucHVzaChSKSxMPSEwKSxtLmdldCYmKEUucHVzaChXKSxMPSEwKSxtLmdldEJ5SW5kaWNlcyYmKEUucHVzaChlZSksTD0hMCksIWkmJkwmJkUudW5zaGlmdChgY29uc3QgJHtifSA9ICR7cC5pbmRpY2VzfSgke24uam9pbihcIixcIil9KTtgLGBjb25zdCAke3l9ID0gJHtwLmluZGljZXN9KCR7eC5jb21wdXRlU3RyaWRlcyhuKS5qb2luKFwiLFwiKX0pO2ApLEUuam9pbihgXG5gKX0sdHlwZTpwLG9mZnNldFRvSW5kaWNlczp3LGluZGljZXNUb09mZnNldDpULGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OlUsaW5kaWNlczpJLGluZGljZXNHZXQ6QSxpbmRpY2VzU2V0Onosc2V0OiguLi5FKT0+e2lmKEUubGVuZ3RoIT09cysxKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3N9YCk7bGV0IEw9RVtzXTtpZih0eXBlb2YgTCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgb2U9RS5zbGljZSgwLHMpLm1hcChmKS5qb2luKFwiLFwiKTtyZXR1cm4gcz09PTA/RyhcIjB1XCIsTCk6cz09PTE/RyhvZVswXSxMKToobS5zZXQ9ITAsbS5zZXRCeUluZGljZXM9ITAsbS5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9KCR7b2V9LCAke0x9KWApfSxzZXRCeU9mZnNldDpHLHNldEJ5SW5kaWNlczooRSxMKT0+czwyP0coRSxMKToobS5zZXRCeUluZGljZXM9ITAsbS5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7RX0sICR7TH0pO2ApLGdldDpELGdldEJ5T2Zmc2V0OkIsZ2V0QnlJbmRpY2VzOlosdXNhZ2U6cixuYW1lOmUsc3RyaWRlczp5LHNoYXBlOmIscmFuazpzfX0sUz0oZSx0LG4scj0xKT0+UXQoZSx0LG4sXCJpbnB1dFwiLHIpLEM9KGUsdCxuLHI9MSk9PlF0KGUsdCxuLFwib3V0cHV0XCIsciksU289KGUsdCxuKT0+UXQoZSx0LG4sXCJhdG9taWNPdXRwdXRcIiwxKSxYdD0oZSx0LG4scj0xKT0+UXQoZSx0LG4sXCJpbnRlcm5hbFwiLHIpLEduPWNsYXNze2NvbnN0cnVjdG9yKHQsbil7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cD10O3RoaXMubGltaXRzPW47dGhpcy5pbnRlcm5hbFZhcmlhYmxlcz1bXTt0aGlzLnZhcmlhYmxlcz1bXTt0aGlzLnVuaWZvcm1zPVtdO3RoaXMudmFyaWFibGVJbmRleD0wfWd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModCl7cmV0dXJuYGlmIChnbG9iYWxfaWR4ID49ICR7dHlwZW9mIHQ9PVwibnVtYmVyXCI/YCR7dH11YDp0fSkgeyByZXR1cm47IH1gfW1haW5TdGFydCh0PVllKXtsZXQgbj10eXBlb2YgdD09XCJudW1iZXJcIj90OnRbMF0scj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMV0sbz10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMl07aWYobj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh8fHI+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZfHxvPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWil0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske259LCAke3J9LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBzaXplIFske3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWH0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9XS5gKTtpZihuKnIqbz50aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXApdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHtufSwgJHtyfSwgJHtvfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgaW52b2NhdGlvbnMgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXB9LmApO2xldCBpPXRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV09PT0xJiZ0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdPT09MSxzPWk/YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YDpgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgbnVtX3dvcmtncm91cHMgOiB2ZWMzPHUzMj5gLGE9aT9gbGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcbiAgICAgICAgIGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueDtgOmBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLnogKiBudW1fd29ya2dyb3Vwc1swXSAqIG51bV93b3JrZ3JvdXBzWzFdICtcbiAgICAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqIG51bV93b3JrZ3JvdXBzWzBdICsgd29ya2dyb3VwX2lkLng7XG4gICAgICAgICBsZXQgZ2xvYmFsX2lkeCA9IHdvcmtncm91cF9pbmRleCAqICR7bipyKm99dSArIGxvY2FsX2lkeDtgO3JldHVybmBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtufSwgJHtyfSwgJHtvfSlcbiAgZm4gbWFpbigke3N9KSB7XG4gICAgJHthfVxuICBgfWFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl7dC5yYW5rIT09MCYmKHQuc2hhcGUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc2hhcGUucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5yYW5rfSksdC5zdHJpZGVzLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnN0cmlkZXMucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5yYW5rfSkpfWRlY2xhcmVWYXJpYWJsZSh0LG4pe2lmKHQudXNhZ2U9PT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMudmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpO2xldCByPXQudXNhZ2U9PT1cImlucHV0XCI/XCJyZWFkXCI6XCJyZWFkX3dyaXRlXCIsbz10LnVzYWdlPT09XCJhdG9taWNPdXRwdXRcIj9cImF0b21pYzxpMzI+XCI6dC50eXBlLnN0b3JhZ2U7cmV0dXJuYEBncm91cCgwKSBAYmluZGluZygke259KSB2YXI8c3RvcmFnZSwgJHtyfT4gJHt0Lm5hbWV9OiBhcnJheTwke299PjtgfWRlY2xhcmVWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQubWFwKG49PnRoaXMuZGVjbGFyZVZhcmlhYmxlKG4sdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKGBcbmApfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh0KXtpZih0LnVzYWdlIT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW5wdXQgb3Igb3V0cHV0IHZhcmlhYmxlIHdpdGggcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKCkuIHVzZSBkZWNsYXJlVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KX1yZWdpc3RlckludGVybmFsVmFyaWFibGVzKC4uLnQpe3JldHVybiB0LmZvckVhY2gobj0+dGhpcy5yZWdpc3RlckludGVybmFsVmFyaWFibGUobikpLHRoaXN9cmVnaXN0ZXJVbmlmb3JtKHQsbixyPTEpe3JldHVybiB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dCx0eXBlOm4sbGVuZ3RoOnJ9KSx0aGlzfXJlZ2lzdGVyVW5pZm9ybXModCl7cmV0dXJuIHRoaXMudW5pZm9ybXM9dGhpcy51bmlmb3Jtcy5jb25jYXQodCksdGhpc311bmlmb3JtRGVjbGFyYXRpb24oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgdD1bXTtmb3IobGV0e25hbWU6bix0eXBlOnIsbGVuZ3RoOm99b2YgdGhpcy51bmlmb3JtcylpZihvJiZvPjQpcj09PVwiZjE2XCI/dC5wdXNoKGBAYWxpZ24oMTYpICR7bn06YXJyYXk8bWF0Mng0PCR7cn0+LCAke01hdGguY2VpbChvLzgpfT5gKTp0LnB1c2goYCR7bn06YXJyYXk8dmVjNDwke3J9PiwgJHtNYXRoLmNlaWwoby80KX0+YCk7ZWxzZXtsZXQgaT1vPT1udWxsfHxvPT09MT9yOmB2ZWMke299PCR7cn0+YDt0LnB1c2goYCR7bn06JHtpfWApfXJldHVybmBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dC5qb2luKFwiLCBcIil9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2B9Z2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKXtyZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSt0aGlzLnZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCkrdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCl9Z2V0IHZhcmlhYmxlc0luZm8oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuO2xldCB0PW49PlsxMiwxMCwxLDZdW1tcInUzMlwiLFwiZjE2XCIsXCJmMzJcIixcImkzMlwiXS5pbmRleE9mKG4pXTtyZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXAobj0+W3Qobi50eXBlKSxuLmxlbmd0aD8/MV0pfX0sVG89KGUsdCk9Pm5ldyBHbihlLHQpfSk7dmFyIGNkLElvLHBkLG1kLGZkLGhkLHBlLENvLEFvLFZlPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO2NkPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYodC5sZW5ndGghPT0wJiZ0Lmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBwZXJtIHNpemUgJHt0Lmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggaW5wdXQgcmFuayAke2VbMF0uZGltcy5sZW5ndGh9YCl9LElvPShlLHQpPT50Lmxlbmd0aCE9PTA/dDpbLi4ubmV3IEFycmF5KGUpLmtleXMoKV0ucmV2ZXJzZSgpLHBkPShlLHQpPT54LnNvcnRCYXNlZE9uUGVybShlLElvKGUubGVuZ3RoLHQpKSxtZD0oZSx0LG4scik9PntsZXQgbz1gZm4gcGVybShpOiAke3IudHlwZS5pbmRpY2VzfSkgLT4gJHtuLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke24udHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgaT0wO2k8dDsrK2kpbys9YGFbJHtlW2ldfV09aVske2l9XTtgO3JldHVybiBvKz1cInJldHVybiBhO31cIn0sZmQ9KGUsdCk9PntsZXQgbj1bXSxyPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKWVbb10hPT0xJiZuLnB1c2goZVtvXSksZVt0W29dXSE9PTEmJnIucHVzaCh0W29dKTtyZXR1cm57bmV3U2hhcGU6bixuZXdQZXJtOnJ9fSxoZD0oZSx0KT0+e2xldCBuPTA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYodFtlW3JdXSE9PTEpe2lmKGVbcl08bilyZXR1cm4hMTtuPWVbcl19cmV0dXJuITB9LHBlPShlLHQpPT57bGV0IG49ZS5kYXRhVHlwZSxyPWUuZGltcy5sZW5ndGgsbz1JbyhyLHQpLGk9cGQoZS5kaW1zLG8pLHM9ZS5kaW1zLGE9aSx1PXI8Mnx8aGQobyxlLmRpbXMpLGQ7aWYodSlyZXR1cm4gZD1oPT57bGV0IGI9UyhcImlucHV0XCIsbixzLDQpLHk9QyhcIm91dHB1dFwiLG4sYSw0KTtyZXR1cm5gXG4gICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYix5KX1cbiAgJHtoLm1haW5TdGFydCgpfVxuICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZUNvcHlcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCBoPXguc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChoLzQpfV19fSxnZXRTaGFkZXJTb3VyY2U6ZH07bGV0e25ld1NoYXBlOmwsbmV3UGVybTpjfT1mZChlLmRpbXMsbykscD14LmFyZUVxdWFsKGMsWzIsMywxXSksZj14LmFyZUVxdWFsKGMsWzMsMSwyXSk7aWYobC5sZW5ndGg9PT0yfHxwfHxmKXtzPXA/W2xbMF0sbFsxXSpsWzJdXTpmP1tsWzBdKmxbMV0sbFsyXV06bCxhPVtzWzFdLHNbMF1dO2xldCBoPTE2O3JldHVybiBkPWI9PntsZXQgeT1TKFwiYVwiLG4scy5sZW5ndGgpLGc9QyhcIm91dHB1dFwiLG4sYS5sZW5ndGgpO3JldHVybmBcbiAgJHtiLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh5LGcpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlIDogYXJyYXk8YXJyYXk8JHtnLnR5cGUudmFsdWV9LCAke2grMX0+LCAke2h9PjtcbiAgJHtiLm1haW5TdGFydChbaCxoLDFdKX1cbiAgICBsZXQgc3RyaWRlID0gKHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSAtIDEpIC8gJHtofSArIDE7XG4gICAgbGV0IHdvcmtncm91cF9pZF94ID0gd29ya2dyb3VwX2luZGV4ICUgc3RyaWRlO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeSA9IHdvcmtncm91cF9pbmRleCAvIHN0cmlkZTtcbiAgICBsZXQgaW5wdXRfY29sID0gd29ya2dyb3VwX2lkX3kgKiAke2h9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IGlucHV0X3JvdyA9IHdvcmtncm91cF9pZF94ICogJHtofXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChpbnB1dF9yb3cgPCB1bmlmb3Jtcy5hX3NoYXBlWzBdICYmIGlucHV0X2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMV0pIHtcbiAgICAgIHRpbGVbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3kuZ2V0QnlJbmRpY2VzKGAke3kudHlwZS5pbmRpY2VzfShpbnB1dF9yb3csIGlucHV0X2NvbClgKX07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBvdXRwdXRfY29sID0gd29ya2dyb3VwX2lkX3ggKiAke2h9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IG91dHB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeSAqICR7aH11ICsgbG9jYWxfaWQueTtcbiAgICBpZiAob3V0cHV0X3JvdyA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVswXSAmJiBvdXRwdXRfY29sIDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdKSB7XG4gICAgICAke2cuc2V0QnlJbmRpY2VzKGAke2cudHlwZS5pbmRpY2VzfShvdXRwdXRfcm93LCBvdXRwdXRfY29sKWAsXCJ0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldXCIpfVxuICAgIH1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgYj14LnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGFbMV0vaCkseTpNYXRoLmNlaWwoYVswXS9oKX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmJ9LC4uLlAocyxhKV19fSxnZXRTaGFkZXJTb3VyY2U6ZH19cmV0dXJuIGQ9aD0+e2xldCBiPVMoXCJhXCIsbixzLmxlbmd0aCkseT1DKFwib3V0cHV0XCIsbixhLmxlbmd0aCk7cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGIseSl9XG5cbiAgJHttZChvLHIsYix5KX1cblxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYi5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IGg9eC5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmh9LC4uLlAocyxhKV19fSxnZXRTaGFkZXJTb3VyY2U6ZH19LENvPShlLHQpPT57Y2QoZS5pbnB1dHMsdC5wZXJtKSxlLmNvbXB1dGUocGUoZS5pbnB1dHNbMF0sdC5wZXJtKSl9LEFvPWU9Pk4oe3Blcm06ZS5wZXJtfSl9KTt2YXIgZ2QseWQsYmQsX2Qsd2QsJGQsdmQseGQsU2QsVGQsemUsRW8sa28sUG8sem8sQm8sRG8sT28sTW8sVW8sUm8sVm89aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO1l0KCk7VmUoKTtnZD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSx5ZD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGJkPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LF9kPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0sd2Q9KGUsdCk9PntsZXQgbj1bXTtmb3IobGV0IHI9dC1lO3I8dDsrK3Ipbi5wdXNoKHIpO3JldHVybiBufSwkZD0oZSx0KT0+e2xldCBuPVtdLHI9ZS5sZW5ndGg7Zm9yKGxldCBpPTA7aTxyO2krKyl0LmluZGV4T2YoaSk9PT0tMSYmbi5wdXNoKGVbaV0pO2xldCBvPXQubWFwKGk9PmVbaV0pO3JldHVybltuLG9dfSx2ZD0oZSx0KT0+e2xldCBuPWUubGVuZ3RoK3QubGVuZ3RoLHI9W10sbz0wO2ZvcihsZXQgaT0wO2k8bjtpKyspdC5pbmRleE9mKGkpPT09LTE/ci5wdXNoKGVbbysrXSk6ci5wdXNoKDEpO3JldHVybiByfSx4ZD0oZSx0KT0+e2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKWlmKGVbZS5sZW5ndGgtbi0xXSE9PXQtMS1uKXJldHVybiExO3JldHVybiEwfSxTZD0oZSx0KT0+e2xldCBuPVtdO2lmKCF4ZChlLHQpKXtmb3IobGV0IHI9MDtyPHQ7KytyKWUuaW5kZXhPZihyKT09PS0xJiZuLnB1c2gocik7ZS5mb3JFYWNoKHI9Pm4ucHVzaChyKSl9cmV0dXJuIG59LFRkPShlLHQsbixyLG8saSxzKT0+e2xldCBhPW5bMF0uZGltcyx1PXguc2l6ZShpKSxkPXguc2l6ZShzKSxsPVMoXCJfQVwiLG5bMF0uZGF0YVR5cGUsYSksYz1DKFwib3V0cHV0XCIsbyxpKSxwPTY0O3U9PT0xJiYocD0yNTYpO2xldCBmPWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHtwfT47XG4gICAgICAgYCxtPWg9PmBcbiAgICAgICAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGwsYyl9XG4gICAgICAgICR7Zn1cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7aC5tYWluU3RhcnQocCl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtwfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke2JkW3JdfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke3B9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHtsLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke2dkW3JdfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtwfXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7eWRbcl19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7Yy5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7cj09PVwibWVhblwiP2Ake2MudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYDpgJHtjLnR5cGUuc3RvcmFnZX0oJHtfZFtyXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH07JHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOm0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4OnV9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpkfV19KX19LHplPShlLHQsbixyKT0+e2xldCBvPWUuaW5wdXRzLmxlbmd0aD09PTE/bjpGbihlLmlucHV0cyxuKSxpPW8uYXhlcztpLmxlbmd0aD09PTAmJiFvLm5vb3BXaXRoRW1wdHlBeGVzJiYoaT1lLmlucHV0c1swXS5kaW1zLm1hcCgoZixtKT0+bSkpO2xldCBzPXgubm9ybWFsaXplQXhlcyhpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxhPXMsdT1lLmlucHV0c1swXSxkPVNkKGEsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO2QubGVuZ3RoPjAmJih1PWUuY29tcHV0ZShwZShlLmlucHV0c1swXSxkKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxhPXdkKGEubGVuZ3RoLHUuZGltcy5sZW5ndGgpKTtsZXRbbCxjXT0kZCh1LmRpbXMsYSkscD1sO28ua2VlcERpbXMmJihwPXZkKGwscykpLGUuY29tcHV0ZShUZCh0LG8uY2FjaGVLZXksW3VdLHIsZS5pbnB1dHNbMF0uZGF0YVR5cGUscCxjKSx7aW5wdXRzOlt1XX0pfSxFbz0oZSx0KT0+e3plKGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LGtvPShlLHQpPT57emUoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSxQbz0oZSx0KT0+e3plKGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sem89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sQm89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0sRG89KGUsdCk9Pnt6ZShlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sT289KGUsdCk9Pnt6ZShlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxNbz0oZSx0KT0+e3plKGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxVbz0oZSx0KT0+e3plKGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxSbz0oZSx0KT0+e3plKGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBCZSxJZCxKdCxGbixEZSxDZCxBZCxFZCxrZCxQZCx6ZCxCZCxEZCxPZCxNZCxPZSxObyxMbyxXbyxHbyxIbyxxbyxGbyxLbyxqbyxabyxZdD1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtWbygpO0JlPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sSWQ9ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0sSnQ9KGUsdCxuLHIsbyxpLHM9ITEsYT0hMSk9PntsZXQgdT1bXSxkPW5bMF0uZGltcyxsPWQubGVuZ3RoLGM9eC5ub3JtYWxpemVBeGVzKG8sbCkscD0hYSYmYy5sZW5ndGg9PT0wO2QuZm9yRWFjaCgoYix5KT0+e3B8fGMuaW5kZXhPZih5KT49MD9zJiZ1LnB1c2goMSk6dS5wdXNoKGIpfSk7bGV0IGY9dS5sZW5ndGgsbT14LnNpemUodSk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTpiPT57bGV0IHk9W10sZz1TKFwiX0FcIixuWzBdLmRhdGFUeXBlLGwpLF89QyhcIm91dHB1dFwiLGksZiksdz1yKGcsXyxjKSx2PXdbMl07Zm9yKGxldCAkPTAsVD0wOyQ8bDskKyspcHx8Yy5pbmRleE9mKCQpPj0wPyhzJiZUKyssdj1gZm9yKHZhciBqJHskfTogdTMyID0gMDsgaiR7JH0gPCAke2RbJF19OyBqJHskfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke3dbMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGokeyR9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLCQsYGokeyR9YCl9XG4gICAgICAgICAgICAgICAgICAke3Z9XG4gICAgICAgICAgICAgICAgfWApOih5LnB1c2goYCR7Zy5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLCQsXy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixUKSl9O2ApLFQrKyk7cmV0dXJuYFxuXG4gICAgICAgICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZyxfKX1cblxuICAgICAgICAke2IubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtnLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHt5LmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHt3WzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke3dbMV19XG4gICAgICAgICAgJHt2fVxuICAgICAgICAgICR7d1szXX1cbiAgICAgICAgICAke3cubGVuZ3RoPT09ND9fLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6dy5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOm19LC4uLlAoZCx1KV19KX19LEZuPShlLHQpPT57bGV0IG49W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKHI9Pm4ucHVzaChOdW1iZXIocikpKSxOKHtheGVzOm4sa2VlcERpbXM6dC5rZWVwRGltcyxub29wV2l0aEVtcHR5QXhlczp0Lm5vb3BXaXRoRW1wdHlBeGVzfSl9LERlPShlLHQsbixyKT0+e2xldCBvPWUuaW5wdXRzLGk9by5sZW5ndGg9PT0xP246Rm4obyxuKTtlLmNvbXB1dGUoSnQodCx7aGludDppLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtvWzBdXSxpLm5vb3BXaXRoRW1wdHlBeGVzJiZpLmF4ZXMubGVuZ3RoPT09MD9JZDpyLGkuYXhlcyxvWzBdLmRhdGFUeXBlLGkua2VlcERpbXMsaS5ub29wV2l0aEVtcHR5QXhlcykse2lucHV0czpbMF19KX0sQ2Q9KGUsdCk9PntCZShlLmlucHV0cyksRGUoZSxcIlJlZHVjZUxvZ1N1bVwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxBZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlTDFcIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gYWJzKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXSl9LEVkPShlLHQpPT57QmUoZS5pbnB1dHMpLERlKGUsXCJSZWR1Y2VMMlwiLHQsKHIsbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9ICh0ICogdCk7YCxcInZhbHVlID0gc3FydCh2YWx1ZSk7XCJdKX0sa2Q9KGUsdCk9PntCZShlLmlucHV0cyksRGUoZSxcIlJlZHVjZUxvZ1N1bUV4cFwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBleHAoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LFBkPShlLHQpPT57QmUoZS5pbnB1dHMpLERlKGUsXCJSZWR1Y2VNYXhcIix0LChyLG8saSk9PntsZXQgcz1bXTtmb3IobGV0IGE9MDthPHIucmFuazthKyspKGkuaW5kZXhPZihhKT49MHx8aS5sZW5ndGg9PT0wKSYmcy5wdXNoKHIuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixhLDApKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LHpkPShlLHQpPT57QmUoZS5pbnB1dHMpLERlKGUsXCJSZWR1Y2VNZWFuXCIsdCwocixvLGkpPT57bGV0IHM9MTtmb3IobGV0IGE9MDthPHIucmFuazthKyspKGkuaW5kZXhPZihhKT49MHx8aS5sZW5ndGg9PT0wKSYmKHMqPWUuaW5wdXRzWzBdLmRpbXNbYV0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsYGxldCB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfShzdW0gLyAke3N9KTtgXX0pfSxCZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlTWluXCIsdCwocixvLGkpPT57bGV0IHM9W107Zm9yKGxldCBhPTA7YTxyLnJhbms7YSsrKShpLmluZGV4T2YoYSk+PTB8fGkubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRfaW5kaWNlc1ske2F9XSA9IDA7YCk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtaW4odmFsdWUsICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSxEZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlUHJvZFwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMSk7YCxcIlwiLGB2YWx1ZSAqPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSl9LE9kPShlLHQpPT57QmUoZS5pbnB1dHMpLERlKGUsXCJSZWR1Y2VTdW1cIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxNZD0oZSx0KT0+e0JlKGUuaW5wdXRzKSxEZShlLFwiUmVkdWNlU3VtU3F1YXJlXCIsdCwocixvKT0+W2B2YXIgdCA9ICR7by50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcIlwiXSl9LE9lPShlLHQsbik9PntpZih0Lmxlbmd0aD09PTApcmV0dXJuIG47bGV0IHI9MSxvPTE7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspdC5pbmRleE9mKGkpPT09LTE/cio9ZVtpXTpvKj1lW2ldO3JldHVybiBvPDMyJiZyPjEwMjR9LE5vPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/emQoZSx0KTpFbyhlLHQpfSxMbz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0FkKGUsdCk6a28oZSx0KX0sV289KGUsdCk9PntPZShlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9FZChlLHQpOlBvKGUsdCl9LEdvPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/a2QoZSx0KTp6byhlLHQpfSxIbz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1BkKGUsdCk6Qm8oZSx0KX0scW89KGUsdCk9PntPZShlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9CZChlLHQpOkRvKGUsdCl9LEZvPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RGQoZSx0KTpPbyhlLHQpfSxLbz0oZSx0KT0+e09lKGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP09kKGUsdCk6TW8oZSx0KX0sam89KGUsdCk9PntPZShlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9NZChlLHQpOlVvKGUsdCl9LFpvPShlLHQpPT57T2UoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q2QoZSx0KTpSbyhlLHQpfX0pO3ZhciBRbyxYbyxZbyxLbixKbz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO2llKCk7WXQoKTtRbz1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxYbz0oZSx0KT0+e1FvKGUuaW5wdXRzKTtsZXQgbj0ocixvLGkpPT57bGV0IHM9W107Zm9yKGxldCBhPTA7YTxyLnJhbms7YSsrKShpLmluZGV4T2YoYSk+PTB8fGkubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRfaW5kaWNlc1ske2F9XSA9IDA7YCk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI8PVwiOlwiPFwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoSnQoXCJBcmdNaW5cIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0sbixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LFlvPShlLHQpPT57UW8oZS5pbnB1dHMpO2xldCBuPShyLG8saSk9PntsZXQgcz1bXTtmb3IobGV0IGE9MDthPHIucmFuazthKyspKGkuaW5kZXhPZihhKT49MHx8aS5sZW5ndGg9PT0wKSYmcy5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7YX1dID0gMDtgKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShKdChcImFyZ01heFwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxuLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sS249ZT0+TihlKX0pO3ZhciBVZCxqbixSZCxWZCxOZCxvdCxMZCxlaSxlbj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtadCgpO0soKTtVZD0oZSx0KT0+e2xldCBuPWVbMF0scj1lWzFdLG89ZVsyXSxpPWVbM10scz1lWzRdLGE9ZVs1XTtpZihzJiZhKXRocm93IG5ldyBFcnJvcihcIkF0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzXCIpO2lmKG4uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtsZXQgdT1uLmRpbXNbMF0sZD1uLmRpbXNbMV0sbD1uLmRpbXNbMl07aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO2lmKHIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1sKXRocm93IG5ldyBFcnJvcihcIklucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMFwiKTtpZihvLmRpbXNbMF0hPT1yLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO2xldCBjPW8uZGltc1swXS8zLHA9YyxmPXA7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGg+MCl7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHNcIik7Zm9yKGxldCBfIG9mIHQucWt2SGlkZGVuU2l6ZXMpaWYoXyV0Lm51bUhlYWRzIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzXCIpO2M9dC5xa3ZIaWRkZW5TaXplc1swXSxwPXQucWt2SGlkZGVuU2l6ZXNbMV0sZj10LnFrdkhpZGRlblNpemVzWzJdfWxldCBtPWQ7aWYoYyE9PXApdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmRcIik7aWYoby5kaW1zWzBdIT09YytwK2YpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7bGV0IGg9MDtpZihzKXtpZihwIT09Zil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtpZihzLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtpZihzLmRpbXNbMF0hPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO2lmKHMuZGltc1sxXSE9PXUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO2lmKHMuZGltc1syXSE9PXQubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtpZihzLmRpbXNbNF0hPT1wL3QubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwoaD1zLmRpbXNbM10pfWxldCBiPW0raCx5PS0xLGc9MDtpZihpKXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihzKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihhKXtpZihhLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoYS5kaW1zWzBdIT09dXx8YS5kaW1zWzFdIT09dC5udW1IZWFkc3x8YS5kaW1zWzJdIT09ZHx8YS5kaW1zWzNdIT09Yil0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTp1LHNlcXVlbmNlTGVuZ3RoOmQscGFzdFNlcXVlbmNlTGVuZ3RoOmgsa3ZTZXF1ZW5jZUxlbmd0aDptLHRvdGFsU2VxdWVuY2VMZW5ndGg6YixtYXhTZXF1ZW5jZUxlbmd0aDp5LGlucHV0SGlkZGVuU2l6ZTpsLGhpZGRlblNpemU6Yyx2SGlkZGVuU2l6ZTpmLGhlYWRTaXplOk1hdGguZmxvb3IoYy90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihmL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpnLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxqbj0oZSx0LG4pPT50JiZlP2BcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0LmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtlPy5nZXRCeU9mZnNldChcImJhdGNoSWR4XCIpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgOmBcbiAgICAke24/XCJsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aFwiOlwiXCJ9O1xuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBgLFJkPShlLHQsbixyLG8saSxzLGEpPT57bGV0IHU9WChzPzE6aSksZD02NCxsPWkvdTtsPGQmJihkPTMyKTtsZXQgYz1NYXRoLmNlaWwoaS91L2QpLHA9W3t0eXBlOjEyLGRhdGE6dH0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOmN9XSxmPXJlKGUuZGF0YVR5cGUsdSksbT1jZSgxLHUpLGg9W1widHlwZVwiXTtzJiZoLnB1c2goXCJ0eXBlXCIpLGEmJmgucHVzaChcInR5cGVcIik7bGV0IGI9eT0+e2xldCBnPUMoXCJ4XCIsZS5kYXRhVHlwZSxlLmRpbXMsdSksXz1bZ10sdz1zP1MoXCJzZXFfbGVuc1wiLHMuZGF0YVR5cGUscy5kaW1zKTp2b2lkIDA7dyYmXy5wdXNoKHcpO2xldCB2PWE/UyhcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGEuZGF0YVR5cGUsYS5kaW1zKTp2b2lkIDA7diYmXy5wdXNoKHYpO2xldCAkPWNlKGUuZGF0YVR5cGUpLFQ9W3tuYW1lOlwiYmF0Y2hfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFzdF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInRvdGFsX3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlbGVtZW50c19wZXJfdGhyZWFkXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7ZH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfc3VtOiBhcnJheTxmMzIsICR7ZH0+O1xuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhUKS5kZWNsYXJlVmFyaWFibGVzKC4uLl8pfVxuICAke3kubWFpblN0YXJ0KFtkLDEsMV0pfVxuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgICR7am4odyx2LCExKX1cbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcbiAgICBsZXQgb2Zmc2V0ID0gKGdsb2JhbF9pZHggLyAke2R9KSAqIHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aCArIGxvY2FsX29mZnNldDtcbiAgICBsZXQgc2VxX2NhdXNhbF9sZW5ndGggPSAke3M/XCJ1MzIocGFzdF9zZXF1ZW5jZV9sZW5ndGggKyB3b3JrZ3JvdXBfaWQueSArIDEpXCI6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIn07XG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHttfSgtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRocmVhZF9tYXhfdmVjdG9yID0gbWF4KCR7bX0oeFtvZmZzZXQgKyBpXSksIHRocmVhZF9tYXhfdmVjdG9yKTtcbiAgICB9XG4gICAgdGhyZWFkX21heFtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2godSl7Y2FzZSAxOnJldHVyblwidGhyZWFkX21heF92ZWN0b3JcIjtjYXNlIDI6cmV0dXJuXCJtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSlcIjtjYXNlIDQ6cmV0dXJuXCJtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7dX1gKX19KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgbWF4X3ZhbHVlID0gIGYzMigtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtkfTsgaSsrKSB7XG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7bX0oMCk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bV92ZWN0b3IgKz0gZXhwKCR7bX0oeFtvZmZzZXQgKyBpXSkgLSBtYXhfdmFsdWUpO1xuICAgIH1cbiAgICB0aHJlYWRfc3VtW2xvY2FsX2lkeF0gPSAkeygoKT0+e3N3aXRjaCh1KXtjYXNlIDE6cmV0dXJuXCJzdW1fdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwic3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55XCI7Y2FzZSA0OnJldHVyblwic3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55ICsgc3VtX3ZlY3Rvci56ICsgc3VtX3ZlY3Rvci53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7dX1gKX19KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgc3VtOiBmMzIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7ZH07IGkrKykge1xuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB4W29mZnNldCArIGldID0gJHtnLnR5cGUudmFsdWV9KCR7JH0oMS4wKSAvICR7JH0oc2VxX2NhdXNhbF9sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGYzMmlucHV0ID0gJHttfSh4W29mZnNldCArIGldKTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7Zy50eXBlLnZhbHVlfShleHAoZjMyaW5wdXQgLSBtYXhfdmFsdWUpIC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAke3M/YFxuICAgICAgICBmb3IgKHZhciB0b3RhbF9zZXFfaWQ6IHUzMiA9IHNlcV9jYXVzYWxfbGVuZ3RoOyB0b3RhbF9zZXFfaWQgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IHRvdGFsX3NlcV9pZCsrKSB7XG4gICAgICAgICAgeFtvZmZzZXQgKyB0b3RhbF9zZXFfaWRdID0gJHtnLnR5cGUudmFsdWV9KCR7JH0oMCkpO1xuICAgICAgICB9YDpcIlwifTtcbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uUHJvYnNTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ZH07JHtmfTske3V9YCxpbnB1dERlcGVuZGVuY2llczpofSxnZXRTaGFkZXJTb3VyY2U6YixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W10sZGlzcGF0Y2hHcm91cDp7eDoxLHk6byx6OnQqbn0scHJvZ3JhbVVuaWZvcm1zOnB9KX19LFZkPShlLHQsbixyLG8saSxzLGEsdSk9PntsZXQgZD1zK2kua3ZTZXF1ZW5jZUxlbmd0aCxsPVtpLmJhdGNoU2l6ZSxpLm51bUhlYWRzLGkuc2VxdWVuY2VMZW5ndGgsZF0sYz1lPjEmJnIscD1pLmt2TnVtSGVhZHM/aS5rdk51bUhlYWRzOmkubnVtSGVhZHMsZj1jP1tpLmJhdGNoU2l6ZSxwLGQsaS5oZWFkU2l6ZV06dm9pZCAwLG09aS5uUmVwcz9pLm5SZXBzOjEsaD1pLnNjYWxlPT09MD8xL01hdGguc3FydChpLmhlYWRTaXplKTppLnNjYWxlLGI9WChpLmhlYWRTaXplKSx5PWkuaGVhZFNpemUvYixnPTEyLF89e3g6TWF0aC5jZWlsKGQvZykseTpNYXRoLmNlaWwoaS5zZXF1ZW5jZUxlbmd0aC9nKSx6OmkuYmF0Y2hTaXplKmkubnVtSGVhZHN9LHc9W3t0eXBlOjEyLGRhdGE6aS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6aS5udW1IZWFkc30se3R5cGU6MTIsZGF0YTppLmhlYWRTaXplfSx7dHlwZToxLGRhdGE6aH0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOmkua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTptfV0sdj1jJiZyJiZ4LnNpemUoci5kaW1zKT4wLCQ9W1widHlwZVwiLFwidHlwZVwiXTt2JiYkLnB1c2goXCJ0eXBlXCIpLG8mJiQucHVzaChcInR5cGVcIiksYSYmJC5wdXNoKFwidHlwZVwiKSx1JiYkLnB1c2goXCJ0eXBlXCIpO2xldCBUPVt7ZGltczpsLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO2MmJlQucHVzaCh7ZGltczpmLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBJPUE9PntsZXQgej1TKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLGIpLE09UyhcImtleVwiLG4uZGF0YVR5cGUsbi5kaW1zLGIpLFU9W3osTV07aWYodil7bGV0IFI9UyhcInBhc3Rfa2V5XCIsci5kYXRhVHlwZSxyLmRpbXMsYik7VS5wdXNoKFIpfW8mJlUucHVzaChTKFwiYXR0ZW50aW9uX2JpYXNcIixvLmRhdGFUeXBlLG8uZGltcykpO2xldCBHPWE/UyhcInNlcV9sZW5zXCIsYS5kYXRhVHlwZSxhLmRpbXMpOnZvaWQgMDtHJiZVLnB1c2goRyk7bGV0IEI9dT9TKFwidG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0XCIsdS5kYXRhVHlwZSx1LmRpbXMpOnZvaWQgMDtCJiZVLnB1c2goQik7bGV0IGVlPUMoXCJvdXRwdXRcIix0LmRhdGFUeXBlLGwpLFc9W2VlXTtjJiZXLnB1c2goQyhcInByZXNlbnRfa2V5XCIsdC5kYXRhVHlwZSxmLGIpKTtsZXQgRD1jZSgxLGIpLFo9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2d9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHt6LnR5cGUuc3RvcmFnZX0sICR7ZypnfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke3oudHlwZS5zdG9yYWdlfSwgJHtnKmd9PjtcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoWikuZGVjbGFyZVZhcmlhYmxlcyguLi5VLC4uLlcpfVxuICAke0EubWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBrdkhlYWRJZHggPSAke209PT0xP1wiaGVhZElkeFwiOlwiaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQga3ZfbnVtX2hlYWRzID0gJHttPT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcbiAgICAke2puKEcsQiwhMCl9XG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7diYmYz9cImxldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9O1xuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcbiAgICAke2M/XCJsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9XG4gICAgdmFyIHZhbHVlID0gJHtEfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBxW3FPZmZzZXQgKyBsb2NhbF9pZC55ICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICR7diYmYz9gXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA6YFxuICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgfWB9XG4gICAgICAke2M/YGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSAke0R9KHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIGdsb2JhbF9pZC54IDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICBsZXQgaGVhZE9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gaGVhZE9mZnNldCArIGdsb2JhbF9pZC55ICogdW5pZm9ybXMuTiArIGdsb2JhbF9pZC54O1xuICAgICAgdmFyIHN1bTogZjMyID0gJHsoKCk9Pntzd2l0Y2goYil7Y2FzZSAxOnJldHVyblwidmFsdWVcIjtjYXNlIDI6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueVwiO2Nhc2UgNDpyZXR1cm5cInZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLndcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtifWApfX0pKCl9O1xuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7ZWUudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7bz9cImF0dGVudGlvbl9iaWFzW291dHB1dElkeF1cIjpcIjAuMFwifTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7Yn07JHtvIT09dm9pZCAwfTske3IhPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOiR9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpULGRpc3BhdGNoR3JvdXA6Xyxwcm9ncmFtVW5pZm9ybXM6d30pLGdldFNoYWRlclNvdXJjZTpJfX0sTmQ9KGUsdCxuLHIsbyxpLHM9dm9pZCAwLGE9dm9pZCAwKT0+e2xldCB1PWkrby5rdlNlcXVlbmNlTGVuZ3RoLGQ9by5uUmVwcz9vLm5SZXBzOjEsbD1vLnZIaWRkZW5TaXplKmQsYz1lPjEmJnIscD1vLmt2TnVtSGVhZHM/by5rdk51bUhlYWRzOm8ubnVtSGVhZHMsZj1jP1tvLmJhdGNoU2l6ZSxwLHUsby5oZWFkU2l6ZV06dm9pZCAwLG09W28uYmF0Y2hTaXplLG8uc2VxdWVuY2VMZW5ndGgsbF0saD0xMixiPXt4Ok1hdGguY2VpbChvLnZIZWFkU2l6ZS9oKSx5Ok1hdGguY2VpbChvLnNlcXVlbmNlTGVuZ3RoL2gpLHo6by5iYXRjaFNpemUqby5udW1IZWFkc30seT1be3R5cGU6MTIsZGF0YTpvLnNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6by52SGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6by5udW1IZWFkc30se3R5cGU6MTIsZGF0YTpvLmhlYWRTaXplfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTpvLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6ZH1dLGc9YyYmciYmeC5zaXplKHIuZGltcyk+MCxfPVtcInR5cGVcIixcInR5cGVcIl07ZyYmXy5wdXNoKFwidHlwZVwiKSxzJiZfLnB1c2goXCJ0eXBlXCIpLGEmJl8ucHVzaChcInR5cGVcIik7bGV0IHc9W3tkaW1zOm0sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV07YyYmdy5wdXNoKHtkaW1zOmYsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSk7bGV0IHY9JD0+e2xldCBUPVMoXCJwcm9ic1wiLHQuZGF0YVR5cGUsdC5kaW1zKSxJPVMoXCJ2XCIsbi5kYXRhVHlwZSxuLmRpbXMpLEE9W1QsSV07ZyYmQS5wdXNoKFMoXCJwYXN0X3ZhbHVlXCIsci5kYXRhVHlwZSxyLmRpbXMpKTtsZXQgej1zP1MoXCJzZXFfbGVuc1wiLHMuZGF0YVR5cGUscy5kaW1zKTp2b2lkIDA7cyYmQS5wdXNoKHopO2xldCBNPWE/UyhcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGEuZGF0YVR5cGUsYS5kaW1zKTp2b2lkIDA7YSYmQS5wdXNoKE0pO2xldCBHPVtDKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxtKV07YyYmRy5wdXNoKEMoXCJwcmVzZW50X3ZhbHVlXCIsdC5kYXRhVHlwZSxmKSk7bGV0IEI9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ2X2hpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7aH11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtULnR5cGUudmFsdWV9LCAke2gqaH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlVjogYXJyYXk8JHtULnR5cGUudmFsdWV9LCAke2gqaH0+O1xuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhCKS5kZWNsYXJlVmFyaWFibGVzKC4uLkEsLi4uRyl9XG4gICR7JC5tYWluU3RhcnQoW2gsaCwxXSl9XG4gICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQga3ZIZWFkSWR4ID0gJHtkPT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICBsZXQga3ZfbnVtX2hlYWRzID0gJHtkPT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG4gICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5LO1xuICAgJHtqbih6LE0sITApfVxuICAgbGV0IG9mZnNldEEgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7IC8vIGt2SGVhZElkeCBpcyByZWxhdGl2ZSB0byB0aGUgYmF0Y2hcbiAgICR7ZyYmYz9cImxldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuO1wiOlwiXCJ9O1xuICAgbGV0IHZPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICR7Yz9cImxldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47XCI6XCJcIn1cbiAgIHZhciB2YWx1ZSA9ICR7VC50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7ZyYmYz9gXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgICAgICB9YH1cbiAgICAgICAgJHtjP2BcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xuICAgICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uU2NvcmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpffSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6dyxkaXNwYXRjaEdyb3VwOmIscHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6dn19LG90PShlLHQsbixyLG8saSxzLGEsdSxkLGw9dm9pZCAwLGM9dm9pZCAwKT0+e2xldCBwPU1hdGgubWluKGUub3V0cHV0Q291bnQsMSsocz8xOjApKyhhPzE6MCkpLGY9cD4xP2QucGFzdFNlcXVlbmNlTGVuZ3RoOjAsbT1mK2Qua3ZTZXF1ZW5jZUxlbmd0aCxoPXUmJnguc2l6ZSh1LmRpbXMpPjA/dTp2b2lkIDAsYj1bdCxuXTtwPjEmJnMmJnguc2l6ZShzLmRpbXMpPjAmJmIucHVzaChzKSxoJiZiLnB1c2goaCksbCYmYi5wdXNoKGwpLGMmJmIucHVzaChjKTtsZXQgeT1lLmNvbXB1dGUoVmQocCx0LG4scyxoLGQsZixsLGMpLHtpbnB1dHM6YixvdXRwdXRzOnA+MT9bLTEsMV06Wy0xXX0pWzBdO2UuY29tcHV0ZShSZCh5LGQuYmF0Y2hTaXplLGQubnVtSGVhZHMsZixkLnNlcXVlbmNlTGVuZ3RoLG0sbCxjKSx7aW5wdXRzOmwmJmM/W3ksbCxjXTpbeV0sb3V0cHV0czpbXX0pO2xldCBnPVt5LHJdO3A+MSYmYSYmeC5zaXplKGEuZGltcyk+MCYmZy5wdXNoKGEpLGwmJmcucHVzaChsKSxjJiZnLnB1c2goYyksZS5jb21wdXRlKE5kKHAseSxyLGEsZCxmLGwsYykse2lucHV0czpnLG91dHB1dHM6cD4xP1swLDJdOlswXX0pfSxMZD0oZSx0KT0+e2xldCBuPVt0LmJhdGNoU2l6ZSx0Lm51bUhlYWRzLHQuc2VxdWVuY2VMZW5ndGgsdC5oZWFkU2l6ZV0scj10LnNlcXVlbmNlTGVuZ3RoLG89dC5pbnB1dEhpZGRlblNpemUsaT10LmhlYWRTaXplLHM9MTIsYT17eDpNYXRoLmNlaWwodC5oZWFkU2l6ZS9zKSx5Ok1hdGguY2VpbCh0LnNlcXVlbmNlTGVuZ3RoL3MpLHo6dC5iYXRjaFNpemUqdC5udW1IZWFkc30sdT1bZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLGQ9W3t0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6dC5udW1IZWFkc30se3R5cGU6MTIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxsPWM9PntsZXQgcD1DKFwib3V0cHV0X3FcIix1WzBdLmRhdGFUeXBlLG4pLGY9QyhcIm91dHB1dF9rXCIsdVswXS5kYXRhVHlwZSxuKSxtPUMoXCJvdXRwdXRfdlwiLHVbMF0uZGF0YVR5cGUsbiksaD1TKFwiaW5wdXRcIix1WzBdLmRhdGFUeXBlLHVbMF0uZGltcyksYj1TKFwid2VpZ2h0XCIsdVsxXS5kYXRhVHlwZSx1WzFdLmRpbXMpLHk9UyhcImJpYXNcIix1WzJdLmRhdGFUeXBlLHVbMl0uZGltcyksZz1oLnR5cGUuc3RvcmFnZSxfPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3N9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke2d9LCAke3Mqc30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHtnfSwgJHtzKnN9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7Z30sICR7cypzfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke2d9LCAke3Mqc30+O1xuICAke2MucmVnaXN0ZXJVbmlmb3JtcyhfKS5kZWNsYXJlVmFyaWFibGVzKGgsYix5LHAsZixtKX1cbiAgJHtjLm1haW5TdGFydChbcyxzLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke2d9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke2d9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke2d9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByZXBhcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOm4sZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6bixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDphLHByb2dyYW1Vbmlmb3JtczpkfSksZ2V0U2hhZGVyU291cmNlOmx9LHtpbnB1dHM6dSxvdXRwdXRzOlstMSwtMSwtMV19KX0sZWk9KGUsdCk9PntsZXQgbj1VZChlLmlucHV0cyx0KSxbcixvLGldPUxkKGUsbik7cmV0dXJuIG90KGUscixvLGksZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0sbil9fSk7dmFyIFdkLEdkLEhkLHRpLG5pPWsoKCk9PntcInVzZSBzdHJpY3RcIjt5ZSgpO1YoKTtxKCk7aWUoKTtLKCk7V2Q9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0c1wiKTtsZXQgbj0ocixvLGkpPT57bGV0IHM9by5sZW5ndGg7aWYocyE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgJHtpfTogbnVtIGRpbWVuc2lvbnMgIT0gJHtzfWApO28uZm9yRWFjaCgoYSx1KT0+e2lmKGEhPT1yW3VdKXRocm93IG5ldyBFcnJvcihgJHtpfTogZGltWyR7dX1dIGRvIG5vdCBtYXRjaGApfSl9O2lmKGVbMF0uZGltcy5sZW5ndGg+MSl7bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIj90LnNwYXRpYWw/ZVswXS5kaW1zLnNsaWNlKC0xKTplWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChlWzBdLmRpbXMuc2xpY2UoMSxlWzBdLmRpbXMubGVuZ3RoLTEpKTplWzBdLmRpbXMuc2xpY2UoMSx0LnNwYXRpYWw/Mjp2b2lkIDApO24oZVsxXS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLG4oZVsyXS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IEJcIiksbihlWzNdLmRpbXMscixcIkludmFsaWQgaW5wdXQgbWVhblwiKSxuKGVbNF0uZGltcyxyLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9ZWxzZSBuKGVbMV0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLG4oZVsyXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgQlwiKSxuKGVbM10uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IG1lYW5cIiksbihlWzRdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9LEdkPShlLHQpPT57bGV0e2Vwc2lsb246bixzcGF0aWFsOnIsZm9ybWF0Om99PXQsaT1lWzBdLmRpbXMscz1yP1goaVtpLmxlbmd0aC0xXSk6MSxhPW89PT1cIk5IV0NcIiYmaS5sZW5ndGg+MT9zOjEsdT14LnNpemUoaSkvcyxkPXIsbD1kP2kubGVuZ3RoOmksYz1TKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHMpLHA9UyhcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsYSksZj1TKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGEpLG09UyhcImlucHV0TWVhblwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLGEpLGg9UyhcImlucHV0VmFyXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsYSksYj1DKFwieVwiLGVbMF0uZGF0YVR5cGUsbCxzKSx5PSgpPT57bGV0IF89XCJcIjtpZihyKV89YGxldCBjT2Zmc2V0ID0gJHtpLmxlbmd0aD09PTE/XCIwdVwiOm89PT1cIk5IV0NcIj9gb3V0cHV0SW5kaWNlc1ske2kubGVuZ3RoLTF9XSAvICR7c31gOlwib3V0cHV0SW5kaWNlc1sxXVwifTtgO2Vsc2UgaWYobz09PVwiTkNIV1wiKV89YFxuICAgICAgICAgICAgJHtiLmluZGljZXNTZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCIwXCIsXCIwXCIpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke2IuaW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiKX07YDtlbHNle189YHZhciBjSW5kaWNlcyA9ICR7cC50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAgICAgICAgICAgICAgICBjSW5kaWNlc1swXSA9IG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV07YDtmb3IobGV0IHc9MTt3PHAucmFuazt3KyspXys9YGNJbmRpY2VzWyR7d31dID0gb3V0cHV0SW5kaWNlc1ske3d9XTtgO18rPWBsZXQgY09mZnNldCA9ICR7cC5pbmRpY2VzVG9PZmZzZXQoXCJjSW5kaWNlc1wiKX07YH1yZXR1cm4gX30sZz1fPT5gXG4gIGNvbnN0IGVwc2lsb24gPSAke259O1xuICAke18ucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYyxwLGYsbSxoLGIpfVxuICAke18ubWFpblN0YXJ0KCl9XG4gICR7Xy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7Yi5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke3N9YCl9O1xuICAgICR7eSgpfVxuICAgIGxldCBzY2FsZSA9ICR7cC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBiaWFzID0gJHtmLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7bS5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7aC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCB4ID0gJHtjLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke2Iuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWA7cmV0dXJue25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmVwc2lsb259XyR7dC5mb3JtYXR9XyR7cn1fJHtzfWAsaW5wdXREZXBlbmRlbmNpZXM6ZD9bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdOnZvaWQgMH0sZ2V0U2hhZGVyU291cmNlOmcsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZD9be3R5cGU6MTIsZGF0YTp1fSwuLi5QKGkpXTpbe3R5cGU6MTIsZGF0YTp1fV19KX19LEhkPWU9Pk4oZSksdGk9KGUsdCk9PntsZXR7aW5wdXRzOm4sb3V0cHV0Q291bnQ6cn09ZSxvPUhkKHsuLi50LG91dHB1dENvdW50OnJ9KTtpZih0ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJldkKG4sbyksdC50cmFpbmluZ01vZGUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHRyYWluaW5nTW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7ZS5jb21wdXRlKEdkKG4sbykpfX0pO3ZhciBxZCxGZCxyaSxvaT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cSgpO0soKTtxZD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMzIwLDY0MCwxMjgwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcIm51bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxGZD1lPT57bGV0IHQ9ZVswXS5kaW1zLG49ZVswXS5kaW1zWzJdLHI9eC5zaXplKHQpLzQsbz1lWzBdLmRhdGFUeXBlLGk9UyhcImlucHV0XCIsbyx0LDQpLHM9UyhcImJpYXNcIixvLFtuXSw0KSxhPVMoXCJyZXNpZHVhbFwiLG8sdCw0KSx1PUMoXCJvdXRwdXRcIixvLHQsNCk7cmV0dXJue25hbWU6XCJCaWFzQWRkXCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChyLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bD0+YFxuICBjb25zdCBjaGFubmVscyA9ICR7bn11IC8gNDtcbiAgJHtsLmRlY2xhcmVWYXJpYWJsZXMoaSxzLGEsdSl9XG5cbiAgJHtsLm1haW5TdGFydCgpfVxuICAgICR7bC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHIpfVxuICAgIGxldCB2YWx1ZSA9ICR7aS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9XG4gICAgICArICR7cy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke2EuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke3Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9fSxyaT1lPT57cWQoZS5pbnB1dHMpLGUuY29tcHV0ZShGZChlLmlucHV0cykpfX0pO3ZhciBLZCxKLGlpLHNpLGFpLHVpLGRpLGxpLGNpLHBpLG1pLGpkLGZpLGhpLGdpLHlpLGd0LGJpLHRuLF9pLHdpLCRpLHZpLHhpLFNpLFRpLElpLENpLEFpLEVpLGtpLFBpLHppLEJpLERpLE9pLE1pLFpuLFFuLFVpLFJpLFZpLFpkLFFkLE5pLG5uPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO0tkPShlLHQsbixyLG8saSxzKT0+e2xldCBhPU1hdGguY2VpbCh0LzQpLHU9XCJcIjt0eXBlb2Ygbz09XCJzdHJpbmdcIj91PWAke299KGEpYDp1PW8oXCJhXCIpO2xldCBkPVMoXCJpbnB1dERhdGFcIixuLFthXSw0KSxsPUMoXCJvdXRwdXREYXRhXCIscixbYV0sNCksYz1be25hbWU6XCJ2ZWNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybiBzJiZjLnB1c2goLi4ucyksYFxuICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMoYykuZGVjbGFyZVZhcmlhYmxlcyhkLGwpfVxuXG4gICR7aT8/XCJcIn1cblxuICAke2UubWFpblN0YXJ0KCl9XG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cblxuICAgIGxldCBhID0gJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHUpfVxuICB9YH0sSj0oZSx0LG4scixvLGk9ZS5kYXRhVHlwZSxzLGEpPT57bGV0IHU9W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKHguc2l6ZShlLmRpbXMpLzQpfV07cmV0dXJuIHMmJnUucHVzaCguLi5zKSx7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om8saW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOmQ9PktkKGQseC5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxpLG4scixhKSxnZXRSdW5EYXRhOmQ9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh4LnNpemUoZFswXS5kaW1zKS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOnV9KX19LGlpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0sc2k9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQWNvc1wiLFwiYWNvc1wiKSl9LGFpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LHVpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkFzaW5cIixcImFzaW5cIikpfSxkaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSxsaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sY2k9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0scGk9ZT0+TihlKSxtaT0oZSx0KT0+e2xldCBuO3N3aXRjaCh0LnRvKXtjYXNlIDEwOm49XCJ2ZWM0PGYxNj5cIjticmVhaztjYXNlIDE6bj1cInZlYzQ8ZjMyPlwiO2JyZWFrO2Nhc2UgMTI6bj1cInZlYzQ8dTMyPlwiO2JyZWFrO2Nhc2UgNjpuPVwidmVjNDxpMzI+XCI7YnJlYWs7Y2FzZSA5Om49XCJ2ZWM0PGJvb2w+XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke3QudG99YCl9ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJDYXN0XCIsbix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LGpkPWU9PntsZXQgdCxuLHI9ZS5sZW5ndGg+PTImJmVbMV0uZGF0YSE9PTAsbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MDtzd2l0Y2goZVswXS5kYXRhVHlwZSl7Y2FzZSAxOnQ9cj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOi0zNDAyODIzNDY2Mzg1Mjg4NmUyMixuPW8/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTozNDAyODIzNDY2Mzg1Mjg4NmUyMjticmVhaztjYXNlIDEwOnQ9cj9lWzFdLmdldFVpbnQxNkFycmF5KClbMF06NjQ1MTEsbj1vP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTozMTc0MzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydCBkYXRhIHR5cGVcIil9cmV0dXJuIE4oe21pbjp0LG1heDpufSl9LGZpPShlLHQpPT57bGV0IG49dHx8amQoZS5pbnB1dHMpLHI9Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQ2xpcFwiLG89PmBjbGFtcCgke299LCB2ZWM0PCR7cn0+KHVuaWZvcm1zLm1pbiksIHZlYzQ8JHtyfT4odW5pZm9ybXMubWF4KSlgLHZvaWQgMCxuLmNhY2hlS2V5LHZvaWQgMCxbe3R5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZGF0YTpuLm1pbn0se3R5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZGF0YTpuLm1heH1dLFt7bmFtZTpcIm1pblwiLHR5cGU6cn0se25hbWU6XCJtYXhcIix0eXBlOnJ9XSkse2lucHV0czpbMF19KX0saGk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LGdpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkNvc1wiLFwiY29zXCIpKX0seWk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiQ29zaFwiLFwiY29zaFwiKSl9LGd0PWU9Pk4oZSksYmk9KGUsdCk9PntsZXQgbj1jZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJFbHVcIixyPT5gZWx1X3ZmMzIoJHtyfSlgLGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7bn0oJHt0LmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke259KSAtPiAke259IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtufT4pIC0+IHZlYzQ8JHtufT4ge1xuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xuICB9YCx0LmNhY2hlS2V5KSl9LHRuPShlPVwiZjMyXCIpPT5gXG5jb25zdCByMDogJHtlfSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke2V9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHtlfSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke2V9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHtlfSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke2V9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICBsZXQgYWJzdiA9IGFicyh2KTtcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XG59YCxfaT1lPT57bGV0IHQ9Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiRXJmXCIsbj0+YGVyZl92ZjMyKCR7bn0pYCx0bih0KSkpfSx3aT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LCRpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkZsb29yXCIsXCJmbG9vclwiKSl9LHZpPWU9PntsZXQgdD1jZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJHZWx1XCIsbj0+YDAuNSAqICR7bn0gKiAoMS4wICsgZXJmX3ZmMzIoJHtufSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCx0bih0KSkpfSx4aT0oZSx0KT0+e2xldCBuPWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLHI9PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke3J9LCAke3J9LCAke3J9ID49IHZlYzQ8JHtufT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7bn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LFNpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIk5vdFwiLHQ9PmAhJHt0fWApKX0sVGk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiTmVnXCIsdD0+YC0ke3R9YCkpfSxJaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxDaT1lPT57bGV0IHQ9Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiUmVsdVwiLG49PmBzZWxlY3QodmVjNDwke3R9PigwLjApLCAke259LCAke259ID4gdmVjNDwke3R9PigwLjApKWApKX0sQWk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLHQ9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHt0fSkpKWApKX0sRWk9ZT0+TihlKSxraT0oZSx0KT0+e2xldCBuPWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkhhcmRTaWdtb2lkXCIscj0+YG1heCh2ZWM0PCR7bn0+KDAuMCksIG1pbih2ZWM0PCR7bn0+KDEuMCksICR7dC5hbHBoYX0gKiAke3J9ICsgdmVjNDwke259Pigke3QuYmV0YX0pKSlgLHZvaWQgMCx0LmNhY2hlS2V5KSl9LFBpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0semk9ZT0+e2UuY29tcHV0ZShKKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LEJpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlNxcnRcIixcInNxcnRcIikpfSxEaT1lPT57ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LE9pPWU9PmBzaWduKCR7ZX0pICogKDEgLSBleHAoLTIgKiBhYnMoJHtlfSkpKSAvICgxICsgZXhwKC0yICogYWJzKCR7ZX0pKSlgLE1pPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlRhbmhcIixPaSkpfSxabj0oZT1cImYzMlwiKT0+YFxuY29uc3QgZmFzdF9nZWx1X2E6ICR7ZX0gPSAwLjU7XG5jb25zdCBmYXN0X2dlbHVfYjogJHtlfSA9IDAuNzk3ODg0NTYwODAyODY1NDtcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke2V9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XG5cbmZuIHRhbmhfdih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgcmV0dXJuICR7T2koXCJ2XCIpfTtcbn1cbmAsUW49ZT0+YChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7ZX0gKiAoZmFzdF9nZWx1X2MgKiAke2V9ICogJHtlfSArIGZhc3RfZ2VsdV9iKSkpICogJHtlfWAsVWk9ZT0+e2xldCB0PWNlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkZhc3RHZWx1XCIsUW4sWm4odCksdm9pZCAwLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9LFJpPShlLHQpPT57bGV0IG49Y2UoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO3JldHVybiBlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLHI9PmBzZWxlY3QodmVjNDwke259PigwLjApLCAke3J9LCAke3J9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8gPSB2ZWM0PCR7bn0+KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpLDB9LFZpPWU9PntlLmNvbXB1dGUoSihlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX0sWmQ9KGUsdCk9PmBcbmNvbnN0IGFscGhhID0gdmVjNDwke2V9Pigke3R9KTtcbmNvbnN0IG9uZSA9ICR7ZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke2V9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke2V9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmAsUWQ9ZT0+YHF1aWNrX2dlbHVfaW1wbCgke2V9KWAsTmk9KGUsdCk9PntsZXQgbj1jZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEooZS5pbnB1dHNbMF0sXCJRdWlja0dlbHVcIixRZCxaZChuLHQuYWxwaGEpLHQuY2FjaGVLZXksZS5pbnB1dHNbMF0uZGF0YVR5cGUpKX19KTt2YXIgWGQsWWQsV2ksR2k9aygoKT0+e1widXNlIHN0cmljdFwiO3EoKTtLKCk7bm4oKTtYZD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxZZD1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IG49UyhcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCkscj1TKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbz1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLGk9eC5zaXplKHQpLzQscz1yZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfX0pLGdldFNoYWRlclNvdXJjZTp1PT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7dS5kZWNsYXJlVmFyaWFibGVzKG4scixvKX1cblxuICAke3RuKHMpfVxuXG4gICR7dS5tYWluU3RhcnQoKX1cbiAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhpKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sV2k9ZT0+e1hkKGUuaW5wdXRzKSxlLmNvbXB1dGUoWWQoZS5pbnB1dHMpKX19KTt2YXIgSmQsZWwsTWUsSGkscWksRmksS2ksamksWmksUWksWGksWWksSmksZXM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO0pkPShlLHQsbixyLG8saSxzLGEsdSxkLGwsYyk9PntsZXQgcCxmO3R5cGVvZiBhPT1cInN0cmluZ1wiP3A9Zj0oZyxfKT0+YCR7YX0oKCR7Z30pLCgke199KSlgOnR5cGVvZiBhPT1cImZ1bmN0aW9uXCI/cD1mPWE6KHA9YS5zY2FsYXIsZj1hLnZlY3Rvcik7bGV0IG09QyhcIm91dHB1dERhdGFcIixsLHIubGVuZ3RoLDQpLGg9UyhcImFEYXRhXCIsdSx0Lmxlbmd0aCw0KSxiPVMoXCJiRGF0YVwiLGQsbi5sZW5ndGgsNCkseTtpZihvKWlmKGkpe2xldCBnPXguc2l6ZSh0KT09PTEsXz14LnNpemUobik9PT0xLHc9dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCx2PW4ubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0lND09PTA7Z3x8Xz95PW0uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZihnP2Ake2gudHlwZS52YWx1ZX0oJHtoLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOmguZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLF8/YCR7Yi50eXBlLnZhbHVlfSgke2IuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6Yi5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTp5PWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7aC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIixtKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIixtKX07XG4gICAgICAgICAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZihzfHx3P2guZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7aC50eXBlLnZhbHVlfSgke2guZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxzfHx2P2IuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7Yi50eXBlLnZhbHVlfSgke2IuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSB5PW0uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZihoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxiLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCBnPShfLHcsdj1cIlwiKT0+e2xldCAkPWBhRGF0YVtpbmRleEEke3d9XVtjb21wb25lbnRBJHt3fV1gLFQ9YGJEYXRhW2luZGV4QiR7d31dW2NvbXBvbmVudEIke3d9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3d9ID0gJHttLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt3fXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7d30gPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3d9YCxtKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7d30gPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3d9YCxtKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHt3fSA9IG9mZnNldEEke3d9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHt3fSA9IG9mZnNldEIke3d9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7d30gPSBvZmZzZXRBJHt3fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke3d9ID0gb2Zmc2V0QiR7d30gJSA0dTtcbiAgICAgICAgICAgICR7X31bJHt3fV0gPSAke3Z9KCR7cCgkLFQpfSk7XG4gICAgICAgICAgYH07bD09PTk/eT1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7ZyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtnKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2coXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7ZyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOnk9YFxuICAgICAgICAgICAgJHtnKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHtnKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHtnKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHtnKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGgsYixtKX1cblxuICAgICAgICAke2M/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAke3l9XG4gICAgICB9YH0sZWw9KGUsdCxuLHIsbyxpLHM9bi5kYXRhVHlwZSk9PntsZXQgYT1uLmRpbXMubWFwKGg9Pk51bWJlcihoKT8/MSksdT1yLmRpbXMubWFwKGg9Pk51bWJlcihoKT8/MSksZD0heC5hcmVFcXVhbChhLHUpLGw9YSxjPXguc2l6ZShhKSxwPSExLGY9ITEsbT1bZF07aWYoZCl7bGV0IGg9UGUuY2FsY1NoYXBlKGEsdSwhMSk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bD1oLnNsaWNlKCksYz14LnNpemUobCk7bGV0IGI9eC5zaXplKGEpPT09MSx5PXguc2l6ZSh1KT09PTEsZz1hLmxlbmd0aD4wJiZhW2EubGVuZ3RoLTFdJTQ9PT0wLF89dS5sZW5ndGg+MCYmdVt1Lmxlbmd0aC0xXSU0PT09MDttLnB1c2goYiksbS5wdXNoKHkpLG0ucHVzaChnKSxtLnB1c2goXyk7bGV0IHc9MTtmb3IobGV0IHY9MTt2PGwubGVuZ3RoO3YrKyl7bGV0ICQ9YVthLmxlbmd0aC12XSxUPXVbdS5sZW5ndGgtdl07aWYoJD09PVQpdyo9JDtlbHNlIGJyZWFrfXclND09PTA/KGY9ITAscD0hMCk6KGJ8fHl8fGd8fF8pJiYocD0hMCl9ZWxzZSBwPSEwO3JldHVybiBtLnB1c2gocCkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0K20ubWFwKGg9PmgudG9TdHJpbmcoKSkuam9pbihcIl9cIiksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmg9PkpkKGgsYSx1LGwscCxkLGYsbyxuLmRhdGFUeXBlLHIuZGF0YVR5cGUscyxpKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGMvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoeC5zaXplKGwpLzQpfSwuLi5QKGEsdSxsKV19KX19LE1lPShlLHQsbixyLG8saSk9PntlLmNvbXB1dGUoZWwodCxvPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLG4scixpKSl9LEhpPWU9PntNZShlLFwiQWRkXCIsKHQsbik9PmAke3R9KyR7bn1gKX0scWk9ZT0+e01lKGUsXCJEaXZcIiwodCxuKT0+YCR7dH0vJHtufWApfSxGaT1lPT57TWUoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9PT0ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH09PSR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sS2k9ZT0+e01lKGUsXCJNdWxcIiwodCxuKT0+YCR7dH0qJHtufWApfSxqaT1lPT57bGV0IHQ9UyhcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTtNZShlLFwiUG93XCIse3NjYWxhcjoocixvKT0+YHBvd19jdXN0b20oJHtyfSwke299KWAsdmVjdG9yOihyLG8pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtyfSwke299KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LFppPWU9PntNZShlLFwiU3ViXCIsKHQsbik9PmAke3R9LSR7bn1gKX0sUWk9ZT0+e01lKGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9PiR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fT4ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LFhpPWU9PntNZShlLFwiTGVzc1wiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fTwke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH08JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxZaT1lPT57TWUoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9Pj0ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH0+PSR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sSmk9ZT0+e01lKGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fTw9JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PD0ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIG5sLHJsLG9sLGlsLHRzLG5zLHJzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO25sPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IG49MCxyPWVbbl0sbz1yLmRhdGFUeXBlLGk9ci5kaW1zLmxlbmd0aDtlLmZvckVhY2goKHMsYSk9PntpZihhIT09bil7aWYocy5kYXRhVHlwZSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYocy5kaW1zLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtzLmRpbXMuZm9yRWFjaCgodSxkKT0+e2lmKGQhPT10JiZ1IT09ci5kaW1zW2RdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfSl9fSl9LHJsPShlLHQpPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAsb2w9KGUsdCk9PntsZXQgbj1lLmxlbmd0aCxyPVtdO2ZvcihsZXQgbz0wO288bjsrK28pe2xldCBpPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtvXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtuPT09MT9yLnB1c2goaSk6bz09PTA/ci5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke299dSkgeyAke2l9IH1gKTpvPT09bi0xP3IucHVzaChgZWxzZSB7ICR7aX0gfWApOnIucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke299KSB7ICR7aX0gfWApfXJldHVybiByLmpvaW4oYFxuYCl9LGlsPShlLHQsbixyKT0+e2xldCBvPXguc2l6ZShuKSxpPW5ldyBBcnJheShlLmxlbmd0aCkscz1uZXcgQXJyYXkoZS5sZW5ndGgpLGE9MCx1PVtdLGQ9W10sbD1be3R5cGU6MTIsZGF0YTpvfV07Zm9yKGxldCBoPTA7aDxlLmxlbmd0aDsrK2gpYSs9ZVtoXS5kaW1zW3RdLGlbaF09YSxkLnB1c2goZVtoXS5kaW1zLmxlbmd0aCksc1toXT1TKGBpbnB1dCR7aH1gLHIsZFtoXSksdS5wdXNoKFwicmFua1wiKSxsLnB1c2goe3R5cGU6MTIsZGF0YTppW2hdfSk7Zm9yKGxldCBoPTA7aDxlLmxlbmd0aDsrK2gpbC5wdXNoKC4uLlAoZVtoXS5kaW1zKSk7bC5wdXNoKC4uLlAobikpO2xldCBjPUMoXCJvdXRwdXRcIixyLG4ubGVuZ3RoKSxwPWMuaW5kaWNlc0dldChcImluZGljZXNcIix0KSxmPUFycmF5LmZyb20oQXJyYXkoaS5sZW5ndGgpLmtleXMoKSkubWFwKGg9PmB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHtofWApLmpvaW4oXCIsXCIpLG09aD0+YFxuXG4gICR7KCgpPT57aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIik7Zm9yKGxldCBiPTA7YjxlLmxlbmd0aDtiKyspaC5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke2J9YCxcInUzMlwiKTtyZXR1cm4gaC5kZWNsYXJlVmFyaWFibGVzKC4uLnMsYyl9KSgpfVxuXG4gICR7cmwoaS5sZW5ndGgsZil9XG5cbiAgJHtoLm1haW5TdGFydCgpfVxuICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtjLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7cH0pO1xuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtpLmxlbmd0aH11Pigke2Z9KTtcbiAgICAgICR7cH0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7b2wocyxjKX1cbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6dX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOnJ9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6bX19LHRzPShlLHQpPT57bGV0IG49ZS5pbnB1dHMscj1uWzBdLmRpbXMsbz14Lm5vcm1hbGl6ZUF4aXModC5heGlzLHIubGVuZ3RoKTtubChuLG8pO2xldCBpPXIuc2xpY2UoKTtpW29dPW4ucmVkdWNlKChhLHUpPT5hKyh1LmRpbXMubGVuZ3RoPm8/dS5kaW1zW29dOjApLDApO2xldCBzPW4uZmlsdGVyKGE9Pnguc2l6ZShhLmRpbXMpPjApO2UuY29tcHV0ZShpbChzLG8saSxuWzBdLmRhdGFUeXBlKSx7aW5wdXRzOnN9KX0sbnM9ZT0+Tih7YXhpczplLmF4aXN9KX0pO3ZhciBJZSxDZSxBZSxybixGZT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtJZT0oZSx0LG49XCJmMzJcIik9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJuYHZhbHVlID0gbWF4KHZhbHVlLCAke3R9KDAuMCkpO2A7Y2FzZVwiU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9ICgke3R9KDEuMCkgLyAoJHt0fSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO2Nhc2VcIkNsaXBcIjpyZXR1cm5gdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt0fSgke259KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dH0oJHtufSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO2Nhc2VcIkhhcmRTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gbWF4KCR7dH0oMC4wKSwgbWluKCR7dH0oMS4wKSwgJHtufSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7bn0odW5pZm9ybXMuYmV0YSkpKTtgO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybmB2YWx1ZSA9IHNlbGVjdCgke259KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlLCB2YWx1ZSwgdmFsdWUgPj0gJHt0fSgwLjApKTtgO2Nhc2VcIlRhbmhcIjpyZXR1cm5gbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO2Nhc2VcIlwiOnJldHVyblwiXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHtlLmFjdGl2YXRpb259YCl9fSxDZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5jbGlwTWF4fSx7dHlwZToxLGRhdGE6ZS5jbGlwTWlufSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0se3R5cGU6MSxkYXRhOmUuYmV0YX0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0pfSxBZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0pfSxybj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJIYXJkU2lnbW9pZFwiKXtsZXRbbixyXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4yLC41XTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOm4sYmV0YTpyfX1lbHNlIGlmKHQ9PT1cIkNsaXBcIil7bGV0W24scl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtsbyxjb107cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4OnIsY2xpcE1pbjpufX1lbHNlIGlmKHQ9PT1cIkxlYWt5UmVsdVwiKXtsZXRbbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMDFdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6bn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIGRlLG9zLG9uPWsoKCk9PntcInVzZSBzdHJpY3RcIjtkZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxvcz1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgaXMsc3M9aygoKT0+e1widXNlIHN0cmljdFwiO2lzPWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgeXQsc24sYW49aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO0ZlKCk7eXQ9KGUsdCxuLHIsbyk9PntsZXQgaT1yLW47cmV0dXJuYFxuICAgICAgJHtBcnJheS5mcm9tKHtsZW5ndGg6bn0pLm1hcCgocyxhKT0+YFxuICAgICAgaWYgKCR7Tyh0LnNoYXBlLGEsdC5yYW5rKX0gIT0gMSkge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGEsTyhvLGEraSxyKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGEsMCl9XG4gICAgICB9YCkuam9pbihcIlwiKX1cbmB9LHNuPShlLHQsbixyLG89ITEsaSk9PntsZXQgcz1lWzBdLmRpbXMsYT1lWzFdLmRpbXMsdT1zW3MubGVuZ3RoLTJdLGQ9YVthLmxlbmd0aC0xXSxsPXNbcy5sZW5ndGgtMV0sYz1YKGQpLHA9WChsKSxmPVgodSksbT14LnNpemUobikvYy9mLGg9ZS5sZW5ndGg+MixiPXI/ci5zbGljZSgwLC0yKTpuLnNsaWNlKDAsLTIpLGc9W3guc2l6ZShiKSx1LGRdLF89W3t0eXBlOjEyLGRhdGE6bX0se3R5cGU6MTIsZGF0YTp1fSx7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH1dO0NlKHQsXyksXy5wdXNoKC4uLlAoYixzLGEpKSxoJiZfLnB1c2goLi4uUChlWzJdLmRpbXMpKSxfLnB1c2goLi4uUChnKSk7bGV0IHc9dj0+e2xldCAkPVh0KFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUsYi5sZW5ndGgpLFQ9UyhcImFcIixlWzBdLmRhdGFUeXBlLHMubGVuZ3RoLHApLEk9UyhcImJcIixlWzFdLmRhdGFUeXBlLGEubGVuZ3RoLGMpLEE9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZy5sZW5ndGgsYyksej1yZShBLnR5cGUudGVuc29yKSxNPUllKHQsQS50eXBlLnZhbHVlLHopLFU9W1QsSV0sRz1cIlwiO2lmKGgpe2xldCBXPW8/YzoxO1UucHVzaChTKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxXKSksRz1gJHtvP2B2YWx1ZSArPSBiaWFzW2NvbCAvICR7V31dO2A6YHZhbHVlICs9ICR7QS50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWB9bGV0IEI9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9XTtBZSh0LEIpO2xldCBlZT0oKT0+e2xldCBXPWB2YXIgYV9kYXRhOiAke1QudHlwZS52YWx1ZX07YDtmb3IobGV0IEQ9MDtEPHA7RCsrKVcrPWBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7RH0gPSBiWyhiX29mZnNldCArIChrICsgJHtEfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7Y31dO2A7Zm9yKGxldCBEPTA7RDxmO0QrKyl7Vys9YGFfZGF0YSA9IGFbKGFfb2Zmc2V0ICsgKHJvdyArICR7RH0pICogdW5pZm9ybXMuSyArIGspIC8gJHtwfV07YDtmb3IobGV0IFo9MDtaPHA7WisrKVcrPWBcbiAgICAgICAgICAgIHZhbHVlc1ske0R9XSA9IGZtYSgke0kudHlwZS52YWx1ZX0oYV9kYXRhJHtwPT09MT9cIlwiOmBbJHtafV1gfSksIGJfZGF0YSR7Wn0sIHZhbHVlc1ske0R9XSk7XG5gfXJldHVybiBXfTtyZXR1cm5gXG4gICR7di5yZWdpc3RlclVuaWZvcm1zKEIpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoJCkuZGVjbGFyZVZhcmlhYmxlcyguLi5VLEEpfVxuICAke3YubWFpblN0YXJ0KCl9XG4gICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7Y30pKSAqICR7Y307XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7Y30pO1xuICAgIGxldCBzdHJpZGUxID0gdW5pZm9ybXMuTSAvICR7Zn07XG4gICAgbGV0IHJvdyA9IChpbmRleDEgJSBzdHJpZGUxKSAqICR7Zn07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcblxuICAgICR7bi5sZW5ndGg9PT0yP1wiXCI6YGxldCBiYXRjaF9pbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImJhdGNoXCIpfTtgfVxuXG4gICAgdmFyIGFfaW5kaWNlczogJHtULnR5cGUuaW5kaWNlc307XG4gICAgJHt5dChcImFfaW5kaWNlc1wiLFQsVC5yYW5rLTIsJC5yYW5rLFwiYmF0Y2hfaW5kaWNlc1wiKX1cbiAgICAke1QuaW5kaWNlc1NldChcImFfaW5kaWNlc1wiLFQucmFuay0yLDApfVxuICAgICR7VC5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsVC5yYW5rLTEsMCl9XG4gICAgbGV0IGFfb2Zmc2V0ID0gJHtULmluZGljZXNUb09mZnNldChcImFfaW5kaWNlc1wiKX07XG5cbiAgICB2YXIgYl9pbmRpY2VzOiAke0kudHlwZS5pbmRpY2VzfTtcbiAgICAke3l0KFwiYl9pbmRpY2VzXCIsSSxJLnJhbmstMiwkLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7SS5pbmRpY2VzU2V0KFwiYl9pbmRpY2VzXCIsSS5yYW5rLTIsMCl9XG4gICAgJHtJLmluZGljZXNTZXQoXCJiX2luZGljZXNcIixJLnJhbmstMSwwKX1cbiAgICBsZXQgYl9vZmZzZXQgPSAke0kuaW5kaWNlc1RvT2Zmc2V0KFwiYl9pbmRpY2VzXCIpfTtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke0EudHlwZS52YWx1ZX0sICR7Zn0+O1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke3B9KSB7XG4gICAgICAke2VlKCl9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7Zn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7R31cbiAgICAgICR7TX1cbiAgICAgIGxldCBjdXJfaW5kaWNlcyA9ICR7QS50eXBlLmluZGljZXN9KGJhdGNoLCByb3cgKyBpLCBjb2wpO1xuICAgICAgbGV0IG9mZnNldCA9ICR7QS5pbmRpY2VzVG9PZmZzZXQoXCJjdXJfaW5kaWNlc1wiKX07XG4gICAgICAke0Euc2V0QnlPZmZzZXQoYG9mZnNldCAvICR7Y31gLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfVxuICBgfTtyZXR1cm57bmFtZTpcIk1hdE11bE5haXZlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5hY3RpdmF0aW9ufTske2N9OyR7cH07JHtmfTske299YCxpbnB1dERlcGVuZGVuY2llczpoP1tcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppP2kobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOnd9fX0pO3ZhciBzbCxhbCxYbixhcyx1bCxZbixkbCxidCx1bj1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7RmUoKTthbigpO29uKCk7c2w9KGUsdCk9PmU/YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgOmBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGAsYWw9KGUsdCk9PmU/YFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxuICAgICAgICB9YDpgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxuICAgICAgICB9YCxYbj0oZSx0LG49XCJmMzJcIixyLG89ITEsaT0zMixzPSExLGE9MzIpPT57bGV0IHU9dFsxXSplWzFdLGQ9dFswXSplWzBdLGw9bz91OmksYz1vP2k6dSxwPWwvdFswXSxmPWkvdFsxXTtpZighKChvJiZwPT09NCYmZVsxXT09PTR8fCFvJiYocD09PTN8fHA9PT00KSkmJmwldFswXT09PTAmJmkldFsxXT09PTAmJmVbMF09PT00KSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtvfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7cH0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtwfSBtdXN0IGJlIDMgb3IgNC5cbiAgdGlsZUFXaWR0aCAke2x9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHtpfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke3B9PCR7bn0+LCAke2wvcH0+LCAke2N9PjtcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHtufT4sICR7ZC9lWzBdfT4sICR7aX0+O1xuXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke3B9O1xuY29uc3QgdGlsZUlubmVyID0gJHtpfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XG4gIGxldCBiYXRjaCA9ICR7cz9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgJHtyP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtyLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt1fTtcblxuICBsZXQgbnVtX3RpbGVzID0gJHtzP2Ake01hdGguY2VpbChhL2kpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICB2YXIga1N0YXJ0ID0gJHtzP2BpMzIoZ2xvYmFsSWQueikgKiAke2F9YDpcIjBcIn07XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke259Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke2Z9O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICR7c2wobyxyKX1cbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7Zn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtyP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7cD09PTM/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cblxuICAgICAgICAgICR7YWwobyxwKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWB9LGFzPShlLHQpPT5lP2BcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYDpgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGAsdWw9ZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIsWW49KGUsdCxuPVwiZjMyXCIscixvPSExLGk9MzIscz0hMSxhPTMyLHU9ITEpPT57bGV0IGQ9ZVsxXSp0WzFdLGw9ZVswXSp0WzBdLGM9bz9kOmkscD1vP2k6ZDtpZighKHAldFsxXT09PTAmJmMldFswXT09PTAmJmkldFsxXT09PTApKXRocm93IG5ldyBFcnJvcihgdGlsZUFIaWdodCAke3B9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19LCB0aWxlQVdpZHRoICR7Y30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0sIHRpbGVJbm5lciAke2l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19YCk7bGV0IGY9cC90WzFdLG09Yy90WzBdLGg9aS90WzFdLGI9dT9gXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtkfTtcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke2x9O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3B9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7Y307IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgJHthcyhvLHIpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7aX07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7bH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke3I/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtufSwgY29sUGVyVGhyZWFkPjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke28/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYDpgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2R9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7Zn07XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7bX07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7aH07XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtmfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHttfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHthcyhvLHIpfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7aH07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtyP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7bn0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7dWwobyl9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHtufSwgJHtjfT4sICR7cH0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtufSwgJHtsfT4sICR7aX0+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke2l9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGJhdGNoID0gJHtzP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAgICR7cj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7ci5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gICAgbGV0IG51bV90aWxlcyA9ICR7cz9gJHtNYXRoLmNlaWwoYS9pKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgICB2YXIga1N0YXJ0ID0gJHtzP2BpMzIoZ2xvYmFsSWQueikgKiAke2F9YDpcIjBcIn07XG5cbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHtufSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcbiAgICAke2J9XG4gIH1cbmB9LGRsPShlLHQsbixyLG89ITEpPT57bGV0W2kscyxhLHVdPXIsZD1yZShyWzBdLnR5cGUudGVuc29yKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtpLnR5cGUuaW5kaWNlc30pIC0+ICR7ZGUoZSxkKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtkZShlLGQpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGFJbmRpY2VzOiAke3MudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHt5dChcImFJbmRpY2VzXCIscyxzLnJhbmstMixpLnJhbmssXCJiYXRjaEluZGljZXNcIil9XG4gICAgICAgICR7cy5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixzLnJhbmstMixcInUzMihyb3cpXCIpfVxuICAgICAgICAke3MuaW5kaWNlc1NldChcImFJbmRpY2VzXCIscy5yYW5rLTEsXCJ1MzIoY29sSW4pXCIpfVxuICAgICAgICB2YWx1ZSA9ICR7cy5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtpLnR5cGUuaW5kaWNlc30pIC0+ICR7ZGUoZSxkKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtkZShlLGQpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGJJbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHt5dChcImJJbmRpY2VzXCIsYSxhLnJhbmstMixpLnJhbmssXCJiYXRjaEluZGljZXNcIil9XG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixhLnJhbmstMixcInUzMihyb3cpXCIpfVxuICAgICAgICAke2EuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsYS5yYW5rLTEsXCJ1MzIoY29sSW4pXCIpfVxuICAgICAgICB2YWx1ZSA9ICR7YS5nZXRCeUluZGljZXMoXCJiSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7ZGUoZSxkKX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7bz9cImJpYXNbY29sSW5dXCI6YCR7ZGUoZSxkKX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cbiAgICAgICAgJHtufVxuICAgICAgICAke3Uuc2V0QnlJbmRpY2VzKFwidmVjMzx1MzI+KGNvb3JkcylcIixcInZhbHVlXCIpfVxuICAgICAgfVxuICAgIH1cbiAgICBgfSxidD0oZSx0LG4scixvPSExLGkpPT57bGV0IHM9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHU9cy5zbGljZSgwLC0yKSxkPWEuc2xpY2UoMCwtMiksbD1yP3Iuc2xpY2UoMCwtMik6bi5zbGljZSgwLC0yKSxjPXguc2l6ZShsKSxwPXNbcy5sZW5ndGgtMl0sZj1zW3MubGVuZ3RoLTFdLG09YVthLmxlbmd0aC0xXSxoPWYlND09PTAmJm0lND09PTAsYj1wPD04P1s0LDEsMV06WzQsNCwxXSx5PVs4LDgsMV0sZz1bTWF0aC5jZWlsKG0veVswXS9iWzBdKSxNYXRoLmNlaWwocC95WzFdL2JbMV0pLE1hdGguY2VpbChjL3lbMl0vYlsyXSldLF89aD80OjEsdz1bLi4udSxwLGYvX10sdj13Lmxlbmd0aCwkPVsuLi5kLGYsbS9fXSxUPSQubGVuZ3RoLEk9W2MscCxtL19dLEE9W3t0eXBlOjYsZGF0YTpwfSx7dHlwZTo2LGRhdGE6bX0se3R5cGU6NixkYXRhOmZ9XTtDZSh0LEEpLEEucHVzaCguLi5QKGwsdywkKSk7bGV0IHo9W1wicmFua1wiLFwicmFua1wiXSxNPWUubGVuZ3RoPjI7TSYmKEEucHVzaCguLi5QKGVbMl0uZGltcykpLHoucHVzaChcInJhbmtcIikpLEEucHVzaCguLi5QKEkpKTtsZXQgVT1HPT57bGV0IEI9bC5sZW5ndGgsZWU9WHQoXCJiYXRjaERpbXNcIixlWzBdLmRhdGFUeXBlLEIsMSksVz1yZShlWzBdLmRhdGFUeXBlKSxEPVMoXCJhXCIsZVswXS5kYXRhVHlwZSx2LF8pLFo9UyhcImJcIixlWzFdLmRhdGFUeXBlLFQsXyksUj1DKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxJLmxlbmd0aCxfKSxRPVtELFpdO2lmKE0pe2xldCBMPW8/XzoxO1EucHVzaChTKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxMKSl9bGV0IHdlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn1dO0FlKHQsd2UpO2xldCBzZT1yZShSLnR5cGUudGVuc29yKSxIPUllKHQsUi50eXBlLnZhbHVlLHNlKSxFPWRsKF8sTSxILFtlZSxELFosUl0sbyk7cmV0dXJuYFxuICAke0cucmVnaXN0ZXJVbmlmb3Jtcyh3ZSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhlZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5RLFIpfVxuICAke0V9XG4gICR7aD9YbihiLHksVyxlZSk6WW4oYix5LFcsZWUpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7Yn07JHt0LmFjdGl2YXRpb259OyR7aH07JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6en0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppP2kobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpnWzBdLHk6Z1sxXSx6OmdbMl19LHByb2dyYW1Vbmlmb3JtczpBfSksZ2V0U2hhZGVyU291cmNlOlV9fX0pO3ZhciBsbCx1cyxkcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO2tlKCk7SygpO0ZlKCk7b24oKTtzcygpO3VuKCk7bGw9KGUsdCxuLHIsbz0hMSxpLHM9NCxhPTQsdT00LGQ9XCJmMzJcIik9PntsZXQgbD16PT57c3dpdGNoKHope2Nhc2UgMTpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleF07XCI7Y2FzZSAzOnJldHVybmByZXNEYXRhID0gdmVjMzwke2R9Pih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO2A7Y2FzZSA0OnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4IC8gNF07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHt6fSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sYz16PT57c3dpdGNoKHope2Nhc2UgMTpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTtcIjtjYXNlIDQ6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgLyA0ICsgY29sSW5dO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7en0gaXMgbm90IHN1cHBvcnRlZC5gKX19LHA9ZT9gXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgLGY9ZT9gXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYCxtPWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsxXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzJdKVwiLGg9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pXCIsYj1lP1wicm93XCI6XCJjb2xcIix5PWU/XCJjb2xcIjpcInJvd1wiLGc9YFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcbiAgICBsZXQgb3V0Um93ID0gJHtifSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke2J9ICUgb3V0V2lkdGg7XG5cbiAgICBsZXQgV1JvdyA9ICR7eX0gLyAoaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pICogaW5DaGFubmVscyk7XG4gICAgbGV0IFdDb2wgPSAke3l9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHVuaWZvcm1zLnN0cmlkZVswXSArIHVuaWZvcm1zLmRpbGF0aW9uWzBdICogV1JvdyAtIHVuaWZvcm1zLnBhZFswXTtcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHVuaWZvcm1zLnN0cmlkZVsxXSArIHVuaWZvcm1zLmRpbGF0aW9uWzFdICogV0NvbCAtIHVuaWZvcm1zLnBhZFsxXTtcbiAgICBsZXQgeENoID0gJHt5fSAlIGluQ2hhbm5lbHM7XG4gICAgdmFyIHJlc0RhdGEgPSAke2RlKHMsZCl9KDAuMCk7XG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcbiAgICAvLyB0aGUgJ3NhbWUnIHBhZGRpbmcgdHlwZS5cbiAgICBpZiAoeFJvdyA+PSAwICYmIHhSb3cgPCAke219ICYmIHhDb2wgPj0gMCAmJiB4Q29sIDwgJHtofSkge1xuICAgICAgJHtwfVxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpO1xuICAgICAgJHtsKHMpfVxuICAgIH1cbiAgICByZXR1cm4gcmVzRGF0YTtgLF89ZT90JiZyP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgICR7Z31gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpIHtcbiAgICAgICR7Z31cbiAgICB9XG4gICAgcmV0dXJuICR7ZGUocyxkKX0oMC4wKTtgOnImJm4/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7c307XG4gICAgJHtnfWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7c307XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHtnfVxuICAgIH1cbiAgICByZXR1cm4gJHtkZShzLGQpfSgwLjApO2Asdz1lP3ImJm4/YyhhKTpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke2MoYSl9XG4gICAgfVxuICAgIHJldHVybiAke2RlKGEsZCl9KDAuMCk7YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9hX291dGVyKSB7XG4gICAgICAke2MoYSl9XG4gICAgfVxuICAgIHJldHVybiAke2RlKGEsZCl9KDAuMCk7YCx2PWRlKHUsZCksJD1lP2RlKHMsZCk6ZGUoYSxkKSxUPWU/ZGUoYSxkKTpkZShzLGQpLEk9SWUoaSx2LGQpO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAkeyR9IHtcbiAgICAgICR7ZT9fOnd9XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtUfSB7XG4gICAgICAke2U/dzpffVxuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke3Z9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke3V9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcbiAgICAgICR7Zn1cbiAgICAgICR7b3Mobyl9XG4gICAgICAke0l9XG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9YH0sdXM9KGUsdCxuLHIsbyxpLHMsYSx1KT0+e2xldCBkPXQuZm9ybWF0PT09XCJOSFdDXCIsbD1kP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sYz1uWzBdLHA9ZD9uWzJdOm5bM10sZj1kP25bMV06blsyXSxtPWQ/blszXTpuWzFdLGg9ZCYmKGwlND09PTB8fGwlMz09PTApJiZtJTQ9PT0wLGI9ZD9tOnAqZix5PWQ/cCpmOm0sZz1bOCw4LDFdLF89cjw9OD9bNCwxLDFdOls0LDQsMV0sdz1bTWF0aC5jZWlsKGIvZ1swXS9fWzBdKSxNYXRoLmNlaWwoeS9nWzFdL19bMV0pLE1hdGguY2VpbChjL2dbMl0vX1syXSldO2ooXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3d9YCk7bGV0IHY9aD9kJiZsJTQhPT0wPzM6NDoxLCQ9Z1sxXSpfWzFdLFQ9Z1swXSpfWzBdLEk9TWF0aC5tYXgoZ1swXSp2LGdbMV0pLEE9ciUkPT09MCx6PW8lVD09PTAsTT1pJUk9PT0wLFU9aD9bdiw0LDRdOlsxLDEsMV0sRz1be3R5cGU6NixkYXRhOnJ9LHt0eXBlOjYsZGF0YTpvfSx7dHlwZTo2LGRhdGE6aX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6NixkYXRhOnQuc3RyaWRlc30se3R5cGU6NixkYXRhOnQuZGlsYXRpb25zfV07Q2UodCxHKSxHLnB1c2goLi4uUChlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IEI9W1wicmFua1wiLFwicmFua1wiXTtzJiYoRy5wdXNoKC4uLlAoZVsyXS5kaW1zKSksQi5wdXNoKFwicmFua1wiKSksRy5wdXNoKC4uLlAobikpO2xldCBlZT1XPT57bGV0IEQ9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcInBhZFwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJzdHJpZGVcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtBZSh0LEQpO2xldCBaPWg/NDoxLFI9cmUoZVswXS5kYXRhVHlwZSksUT1gXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2g/YHZlYzQ8JHtSfT5gOlJ9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtoP2B2ZWM0PCR7Un0+YDpSfSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke2g/YHZlYzQ8JHtSfT5gOlJ9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7aD9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XG4gICAgICB9YCx3ZT1TKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCx2PT09Mz8xOnYpLHNlPVMoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLFopLEg9W3dlLHNlXSxFPUMoXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoLFopO2lmKHMpe2xldCBMPVMoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFopO0gucHVzaChMKSxRKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7aD9gdmVjNDwke1J9PmA6Un0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2Q/XCJ3XCI6XCJ5XCJ9JHtoP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7aXMoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7Vy5yZWdpc3RlclVuaWZvcm1zKEQpLmRlY2xhcmVWYXJpYWJsZXMoLi4uSCxFKX1cbiAgICAgICAgJHtRfVxuICAgICAgICAke2xsKGQsQSx6LE0scyx0LFVbMF0sVVsxXSxVWzJdLFIpfVxuICAgICAgICAke2g/WG4oXyxnLFIsdm9pZCAwLCFkLEkpOlluKF8sZyxSLHZvaWQgMCwhZCxJLCExLHZvaWQgMCxhKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7dn07JHtofTske0F9OyR7en07JHtNfTskeyR9OyR7VH07JHtJfWAsaW5wdXREZXBlbmRlbmNpZXM6Qn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1P3Uobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp3WzBdLHk6d1sxXSx6OndbMl19LHByb2dyYW1Vbmlmb3JtczpHfSksZ2V0U2hhZGVyU291cmNlOmVlfX19KTt2YXIgY2wsbHMsZG4scGwsY3MsbWwscHMsbXMsZnM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtrZSgpO3EoKTtLKCk7RmUoKTtvbigpO2NsPWU9PntsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXQqPWVbbl07cmV0dXJuIHR9LGxzPWU9PnR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZSxkbj0oZSx0KT0+dDw9MT9lOmUrKGUtMSkqKHQtMSkscGw9KGUsdCxuLHI9MSk9PntsZXQgbz1kbih0LHIpO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihuLTEpLW4rbykvMil9LGNzPShlLHQsbixyLG8pPT57bz09bnVsbCYmKG89cGwoZSx0WzBdLHJbMF0pKTtsZXQgaT1bMCwwLDAsbl07Zm9yKGxldCBzPTA7czwzO3MrKyllW3NdKzIqbz49dFtzXSYmKGlbc109TWF0aC50cnVuYygoZVtzXS10W3NdKzIqbykvcltzXSsxKSk7cmV0dXJuIGl9LG1sPShlLHQsbixyLG8saSxzLGEsdSxkKT0+e2xldCBsLGMscCxmO2lmKGU9PT1cIlZBTElEXCImJihlPTApLHR5cGVvZiBlPT1cIm51bWJlclwiKXtsPXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSxmcm9udDplLGJhY2s6ZX07bGV0IG09Y3MoW3QsbixyLDFdLFthLHUsZF0sMSxbbyxpLHNdLGUpO2M9bVswXSxwPW1bMV0sZj1tWzJdfWVsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUuZXZlcnkoKGgsYix5KT0+aD09PXlbMF0pKXRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO2w9e3RvcDplWzBdLGJvdHRvbTplWzFdLGxlZnQ6ZVsyXSxyaWdodDplWzNdLGZyb250OmVbNF0sYmFjazplWzVdfTtsZXQgbT1jcyhbdCxuLHIsMV0sW2EsdSxkXSwxLFtvLGksc10sZVswXSk7Yz1tWzBdLHA9bVsxXSxmPW1bMl19ZWxzZSBpZihlPT09XCJTQU1FX1VQUEVSXCIpe2M9TWF0aC5jZWlsKHQvbykscD1NYXRoLmNlaWwobi9pKSxmPU1hdGguY2VpbChyL3MpO2xldCBtPShjLTEpKm8rYS10LGg9KHAtMSkqaSt1LW4sYj0oZi0xKSpzK2Qtcix5PU1hdGguZmxvb3IobS8yKSxnPW0teSxfPU1hdGguZmxvb3IoaC8yKSx3PWgtXyx2PU1hdGguZmxvb3IoYi8yKSwkPWItdjtsPXt0b3A6Xyxib3R0b206dyxsZWZ0OnYscmlnaHQ6JCxmcm9udDp5LGJhY2s6Z319ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOmwsb3V0RGVwdGg6YyxvdXRIZWlnaHQ6cCxvdXRXaWR0aDpmfX0scHM9KGUsdCxuLHIsbyxpPSExLHM9XCJjaGFubmVsc0xhc3RcIik9PntsZXQgYSx1LGQsbCxjO2lmKHM9PT1cImNoYW5uZWxzTGFzdFwiKVthLHUsZCxsLGNdPWU7ZWxzZSBpZihzPT09XCJjaGFubmVsc0ZpcnN0XCIpW2EsYyx1LGQsbF09ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7c31gKTtsZXRbcCwsZixtLGhdPXQsW2IseSxnXT1scyhuKSxbXyx3LHZdPWxzKHIpLCQ9ZG4oZixfKSxUPWRuKG0sdyksST1kbihoLHYpLHtwYWRJbmZvOkEsb3V0RGVwdGg6eixvdXRIZWlnaHQ6TSxvdXRXaWR0aDpVfT1tbChvLHUsZCxsLGIseSxnLCQsVCxJKSxHPWk/cCpjOnAsQj1bMCwwLDAsMCwwXTtyZXR1cm4gcz09PVwiY2hhbm5lbHNGaXJzdFwiP0I9W2EsRyx6LE0sVV06cz09PVwiY2hhbm5lbHNMYXN0XCImJihCPVthLHosTSxVLEddKSx7YmF0Y2hTaXplOmEsZGF0YUZvcm1hdDpzLGluRGVwdGg6dSxpbkhlaWdodDpkLGluV2lkdGg6bCxpbkNoYW5uZWxzOmMsb3V0RGVwdGg6eixvdXRIZWlnaHQ6TSxvdXRXaWR0aDpVLG91dENoYW5uZWxzOkcscGFkSW5mbzpBLHN0cmlkZURlcHRoOmIsc3RyaWRlSGVpZ2h0Onksc3RyaWRlV2lkdGg6ZyxmaWx0ZXJEZXB0aDpmLGZpbHRlckhlaWdodDptLGZpbHRlcldpZHRoOmgsZWZmZWN0aXZlRmlsdGVyRGVwdGg6JCxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6VCxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpJLGRpbGF0aW9uRGVwdGg6XyxkaWxhdGlvbkhlaWdodDp3LGRpbGF0aW9uV2lkdGg6dixpblNoYXBlOmUsb3V0U2hhcGU6QixmaWx0ZXJTaGFwZTp0fX0sbXM9KGUsdCxuLHIsbyxpKT0+e2xldCBzPWk9PT1cImNoYW5uZWxzTGFzdFwiLGE9cz9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLHU9ITEsZD1bNjQsMSwxXSxsPXt4Om4ubWFwKChnLF8pPT5fKX0sYz1bTWF0aC5jZWlsKGNsKGwueC5tYXAoZz0+bltnXSkpL2RbMF0pLDEsMV07aihcInZlcmJvc2VcIiwoKT0+YFtjb252M2RfbmFpdmVfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7Y31gKTtsZXQgcD11P3MmJmElNCE9PTA/Mzo0OjEsZj14LnNpemUobiksbT1be3R5cGU6MTIsZGF0YTpmfSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9XTtDZSh0LG0pLG0ucHVzaCguLi5QKGVbMF0uZGltcyxlWzFdLmRpbXMpKTtsZXQgaD1bXCJyYW5rXCIsXCJyYW5rXCJdLGI9ZS5sZW5ndGg9PT0zO2ImJihtLnB1c2goLi4uUChlWzJdLmRpbXMpKSxoLnB1c2goXCJyYW5rXCIpKSxtLnB1c2goLi4uUChuKSk7bGV0IHk9Zz0+e2xldCBfPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpyLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofV07QWUodCxfKTtsZXQgdz11PzQ6MSx2PXJlKGVbMF0uZGF0YVR5cGUpLCQ9UyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgscD09PTM/MTpwKSxUPVMoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLHcpLEk9WyQsVF0sQT1DKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCx3KSx6PVwiXCI7aWYoYil7bGV0IEc9UyhcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsdyk7SS5wdXNoKEcpLHorPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IGFycmF5PHUzMiwgNT4pIC0+ICR7dT9gdmVjNDwke3Z9PmA6dn0ge1xuICAgICAgICAgIHJldHVybiBiaWFzWyR7cz9PKFwiY29vcmRzXCIsNCw1KTpPKFwiY29vcmRzXCIsMSw1KX0ke3U/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfWxldCBNPWRlKHAsdiksVT1JZSh0LE0sdik7cmV0dXJuYFxuICAgICAgICAgICAgJHt6fVxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7JC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHtULmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAke2cucmVnaXN0ZXJVbmlmb3JtcyhfKS5kZWNsYXJlVmFyaWFibGVzKC4uLkksQSl9XG4gICAgICAgICAgJHtnLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgICAgIGxldCBjb29yZHMgPSAke0Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7TyhcImNvb3Jkc1wiLDAsJC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7cz9PKFwiY29vcmRzXCIsJC5yYW5rLTEsJC5yYW5rKTpPKFwiY29vcmRzXCIsMSwkLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhGUkNDb3JuZXIgPSB2ZWMzPHUzMj4oJHtzP08oXCJjb29yZHNcIiwxLCQucmFuayk6TyhcImNvb3Jkc1wiLDIsJC5yYW5rKX0sXG4gICAgICAgICAgICAgICR7cz9PKFwiY29vcmRzXCIsMiwkLnJhbmspOk8oXCJjb29yZHNcIiwzLCQucmFuayl9LFxuICAgICAgICAgICAgICAke3M/TyhcImNvb3Jkc1wiLDMsJC5yYW5rKTpPKFwiY29vcmRzXCIsNCwkLnJhbmspfSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgICAgbGV0IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xuICAgICAgICAgICAgICBsZXQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XG4gICAgICAgICAgICAgIGxldCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVkgPSAke3M/TyhcInVuaWZvcm1zLnhfc2hhcGVcIiwxLCQucmFuayk6TyhcInVuaWZvcm1zLnhfc2hhcGVcIiwyLCQucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7cz9PKFwidW5pZm9ybXMueF9zaGFwZVwiLDIsJC5yYW5rKTpPKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsJC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVXID0gJHtzP08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMywkLnJhbmspOk8oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCwkLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVUgPSAke3M/TyhcInVuaWZvcm1zLnhfc2hhcGVcIiw0LCQucmFuayk6TyhcInVuaWZvcm1zLnhfc2hhcGVcIiwxLCQucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke3M/YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7cz9gdmFsdWUgKz0gZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YDpgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtzP2BsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICR7cz9gbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke2I/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcylcIjpcIlwifTtcbiAgICAgICAgICAgICAgJHtVfVxuICAgICAgICAgICAgICByZXN1bHRbZ2xvYmFsX2lkeF0gPSBmMzIodmFsdWUpO1xuICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkNvbnYzRE5haXZlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtzfTske3B9OyR7Yn1gLGlucHV0RGVwZW5kZW5jaWVzOmh9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpjWzBdLHk6Y1sxXSx6OmNbMl19LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnl9fX0pO3ZhciBocyxncyx5cz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7RmUoKTtocz0oZSx0LG4scik9PntsZXQgbz1lLmxlbmd0aD4yLGk9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIscz1lWzBdLmRpbXMsYT1lWzFdLmRpbXMsdT10LmZvcm1hdD09PVwiTkhXQ1wiLGQ9dT9uWzNdOm5bMV0sbD1kL3QuZ3JvdXAsYz11JiZsPj00P1goZCk6MSxwPXguc2l6ZShuKS9jLGY9W3t0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTp0LmRpbGF0aW9uc30se3R5cGU6MTIsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjEyLGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfSx7dHlwZToxMixkYXRhOmx9XTtDZSh0LGYpLGYucHVzaCguLi5QKHMsW2FbMF0sYVsxXSxhWzJdLGFbM10vY10pKTtsZXQgbT1vP1tcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl06W1wicmFua1wiLFwicmFua1wiXTtmLnB1c2goLi4uUChbblswXSxuWzFdLG5bMl0sblszXS9jXSkpO2xldCBoPWI9PntsZXQgeT1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCxjKSxnPXJlKHkudHlwZS50ZW5zb3IpLF89SWUodCx5LnR5cGUudmFsdWUsZyksdz1TKFwieFwiLGVbMF0uZGF0YVR5cGUscy5sZW5ndGgpLHY9UyhcIndcIixlWzFdLmRhdGFUeXBlLGEubGVuZ3RoLGMpLCQ9W3csdl07byYmJC5wdXNoKFMoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsYykpO2xldCBUPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV07QWUodCxUKTtsZXQgST11P2BcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVswXTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgICAgIGxldCB4VmFsID0gJHt3LmdldChcImJhdGNoXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIixcImlucHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke3YuZ2V0KFwid0hlaWdodFwiLFwid1dpZHRoXCIsXCJ3SW5DaGFubmVsXCIsXCJvdXRwdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0hlaWdodCsrKSB7XG4gICAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVszXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVszXSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHhWYWwgPSAke3cuZ2V0KFwiYmF0Y2hcIixcImlucHV0X2NoYW5uZWxcIixcInhIZWlnaHRcIixcInhXaWR0aFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7di5nZXQoXCJvdXRwdXRfY2hhbm5lbFwiLFwid0luQ2hhbm5lbFwiLFwid0hlaWdodFwiLFwid1dpZHRoXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDtyZXR1cm5gXG4gICR7Yi5yZWdpc3RlclVuaWZvcm1zKFQpLmRlY2xhcmVWYXJpYWJsZXMoLi4uJCx5KX1cblxuICAke2IubWFpblN0YXJ0KCl9XG4gICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHt1PzM6MX1dO1xuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7dT8xOjJ9XSwgb3V0cHV0SW5kaWNlc1ske3U/MjozfV0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAqICR7Y30gLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgIHZhciBpbl9jaGFubmVsX29mZnNldCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVske3U/MjoxfV07XG5cbiAgICB2YXIgdmFsdWU6ICR7eS50eXBlLnZhbHVlfSA9ICR7eS50eXBlLnZhbHVlfSgwKTtcbiAgICAke0l9XG4gICAgJHtpfVxuICAgICR7X31cbiAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9O3JldHVybntuYW1lOlwiR3JvdXBlZENvbnZcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fV8ke2N9YCxpbnB1dERlcGVuZGVuY2llczptfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnI/cihuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6aH19LGdzPShlLHQsbixyKT0+e2xldCBvPWUubGVuZ3RoPjIsaT1YKG5bM10pLHM9WChuWzJdKSxhPXguc2l6ZShuKS9pL3MsdT1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdL2ldLGQ9W2VbMV0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMV0uZGltc1szXS9pXSxsPVtuWzBdLG5bMV0sblsyXSxuWzNdL2ldLGM9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6NixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX1dO0NlKHQsYyksYy5wdXNoKC4uLlAodSxkLGwpKTtsZXQgcD0ocy0xKSp0LnN0cmlkZXNbMV0rZFsxXSxmPW09PntsZXQgaD1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxsLmxlbmd0aCxpKSxiPXJlKGgudHlwZS50ZW5zb3IpLHk9SWUodCxoLnR5cGUudmFsdWUsYiksZz1TKFwieFwiLGVbMF0uZGF0YVR5cGUsdS5sZW5ndGgsaSksXz1TKFwid1wiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsaSksdz1bZyxfXTtvJiZ3LnB1c2goUyhcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxpKSk7bGV0IHY9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIsJD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtyZXR1cm4gQWUodCwkKSxgXG4gICR7bS5yZWdpc3RlclVuaWZvcm1zKCQpLmRlY2xhcmVWYXJpYWJsZXMoLi4udyxoKX1cbiAgJHttLm1haW5TdGFydCgpfVxuICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPSBnbG9iYWxfaWR4ICUgd2lkdGgwO1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke3N9dTtcbiAgICBsZXQgY29sID0gKGluZGV4MSAlIHdpZHRoMSkgKiAke3N9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHtnLnR5cGUudmFsdWV9LCAke3B9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke2gudHlwZS52YWx1ZX0sICR7c30+O1xuICAgIGxldCBpbnB1dF9jaGFubmVsID0gb3V0cHV0X2NoYW5uZWw7XG4gICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgZm9yIHcncyBoZWlnaHQvd2lkdGguXG4gICAgZm9yICh2YXIgd19oZWlnaHQ6IHUzMiA9IDB1OyB3X2hlaWdodCA8ICR7ZFswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHtnLmdldChcImJhdGNoXCIsXCJ1MzIoeF9oZWlnaHQpXCIsXCJ1MzIoeF93aWR0aClcIixcImlucHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke2cudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdfd2lkdGg6IHUzMiA9IDB1OyB3X3dpZHRoIDwgJHtkWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHtfLmdldChcIndfaGVpZ2h0XCIsXCJ3X3dpZHRoXCIsXCIwXCIsXCJvdXRwdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtzfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7c311OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7dn1cbiAgICAgICR7eX1cbiAgICAgICR7aC5zZXQoXCJiYXRjaFwiLFwicm93XCIsXCJjb2wgKyBpXCIsXCJvdXRwdXRfY2hhbm5lbFwiLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiR3JvdXBlZENvbnYtVmVjdG9yaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtpfTske3N9OyR7cH07JHtkWzBdfTske2RbMV19YCxpbnB1dERlcGVuZGVuY2llczpvP1tcInJhbmtcIixcInJhbmtcIixcInR5cGVcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3Iobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3JtczpjfSksZ2V0U2hhZGVyU291cmNlOmZ9fX0pO3ZhciBmbCxKbixobCxlcix0cixicyxnbCx5bCxucixfcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cSgpO2RzKCk7ZnMoKTt1bigpO3lzKCk7RmUoKTthbigpO1ZlKCk7Zmw9KGUsdCxuLHIsbyxpKT0+e2xldCBzPWVbMF0sYT1lLnNsaWNlKGk/MToyLGk/Mzo0KSx1PWEubGVuZ3RoLGQ9dFswXSxjPXQuc2xpY2UoMikubWFwKChtLGgpPT5tKyhtLTEpKihuW2hdLTEpKSxmPWEubWFwKChtLGgpPT5tK3JbaF0rcltoK3VdKS5tYXAoKG0saCk9Pk1hdGguZmxvb3IoKG0tY1toXStvW2hdKS9vW2hdKSk7cmV0dXJuIGYuc3BsaWNlKDAsMCxzKSxmLnNwbGljZShpPzM6MSwwLGQpLGZ9LEpuPVsyLDMsMSwwXSxobD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcImdyZWF0ZXIgdGhhbiA1RCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCBuPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxyPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKG4hPT1yKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBvPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke299RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtvfURgKTtpZih0LnBhZHMubGVuZ3RoIT09byoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtvKjJ9RGApO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIil9LGVyPShlLHQpPT57bGV0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO24ubGVuZ3RoPHRbMV0uZGltcy5sZW5ndGgtMiYmbi5wdXNoKC4uLkFycmF5KHRbMV0uZGltcy5sZW5ndGgtMi1uLmxlbmd0aCkuZmlsbCgwKSk7Zm9yKGxldCBpPTI7aTx0WzFdLmRpbXMubGVuZ3RoOysraSluW2ktMl09PT0wJiYobltpLTJdPXRbMV0uZGltc1tpXSk7bGV0IHI9ZS5wYWRzLnNsaWNlKCk7WGUuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHRbMF0uZGltcyxlLnN0cmlkZXMsZS5kaWxhdGlvbnMsbixyLGUuZm9ybWF0PT09XCJOSFdDXCIsZS5hdXRvUGFkKTtsZXQgbz1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKG8se2tlcm5lbFNoYXBlOm4scGFkczpyfSksb30sdHI9ZT0+e2xldCB0PXJuKGUpLG49ZS5mb3JtYXQscj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLG89ZS5kaWxhdGlvbnMsaT1lLmdyb3VwLHM9ZS5rZXJuZWxfc2hhcGUsYT1lLnBhZHMsdT1lLnN0cmlkZXMsZD1lLndfaXNfY29uc3QoKTtyZXR1cm57YXV0b1BhZDpyLGZvcm1hdDpuLGRpbGF0aW9uczpvLGdyb3VwOmksa2VybmVsU2hhcGU6cyxwYWRzOmEsc3RyaWRlczp1LHdJc0NvbnN0OmQsLi4udCxjYWNoZUtleTpgJHtlLmZvcm1hdH07JHt0LmFjdGl2YXRpb259O2B9fSxicz0oZSx0LG4scik9PntsZXQgbz1uLmZvcm1hdD09PVwiTkhXQ1wiLGk9ZmwodFswXS5kaW1zLHRbMV0uZGltcyxuLmRpbGF0aW9ucyxuLnBhZHMsbi5zdHJpZGVzLG8pO2lmKG4uZ3JvdXAhPT0xKXtsZXQgJD1bdFswXV07aWYobyl7bGV0IEk9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUocGUodFsxXSxKbikse2lucHV0czpbMV0sb3V0cHV0czpbbi53SXNDb25zdD8tMjotMV19KVswXTtuLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUkpLCQucHVzaChJKX1lbHNlICQucHVzaCh0WzFdKTt0Lmxlbmd0aD09PTMmJiQucHVzaCh0WzJdKSwhZS5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZShcImFtcGVyZVwiKSYmbyYmdFsxXS5kaW1zWzBdPT09bi5ncm91cCYmdFsxXS5kaW1zWzFdPT09MSYmbi5kaWxhdGlvbnNbMF09PT0xJiZuLmRpbGF0aW9uc1sxXT09PTE/ZS5jb21wdXRlKGdzKCQsbixpLHIpLHtpbnB1dHM6JH0pOmUuY29tcHV0ZShocygkLG4saSxyKSx7aW5wdXRzOiR9KTtyZXR1cm59bGV0IHM9dC5sZW5ndGg9PT0zLGE9dFswXS5kaW1zW28/MToyXSx1PXRbMF0uZGltc1tvPzI6M10sZD10WzBdLmRpbXNbbz8zOjFdLGw9dFsxXS5kaW1zWzJdLGM9dFsxXS5kaW1zWzNdLHA9aVtvPzE6Ml0sZj1pW28/MjozXSxtPWlbbz8zOjFdLGg9byYmbD09PWEmJmM9PT11JiZuLnBhZHNbMF09PT0wJiZuLnBhZHNbMV09PT0wO2lmKGh8fGw9PT0xJiZjPT09MSYmbi5kaWxhdGlvbnNbMF09PT0xJiZuLmRpbGF0aW9uc1sxXT09PTEmJm4uc3RyaWRlc1swXT09PTEmJm4uc3RyaWRlc1sxXT09PTEmJm4ucGFkc1swXT09PTAmJm4ucGFkc1sxXT09PTApe2xldCAkPWlbMF0sVCxJLEEsej1bXTtpZihvKXtsZXQgRz1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShwZSh0WzFdLEpuKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO2lmKG4ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9RyksaCl7bGV0IEI9YSp1KmQ7VD10WzBdLnJlc2hhcGUoWzEsJCxCXSksST1HLnJlc2hhcGUoWzEsQixtXSksQT1bMSwkLG1dfWVsc2UgVD10WzBdLnJlc2hhcGUoWyQsYSp1LGRdKSxJPUcucmVzaGFwZShbMSxkLG1dKSxBPVskLHAqZixtXTt6LnB1c2goVCksei5wdXNoKEkpfWVsc2UgVD10WzBdLnJlc2hhcGUoWyQsZCxhKnVdKSxJPXRbMV0ucmVzaGFwZShbMSxtLGRdKSxBPVskLG0scCpmXSx6LnB1c2goSSksei5wdXNoKFQpO3MmJnoucHVzaCh0WzJdKTtsZXQgTT1BWzJdLFU9elswXS5kaW1zW3pbMF0uZGltcy5sZW5ndGgtMV07TTw4JiZVPDg/ZS5jb21wdXRlKHNuKHosbixpLEEsbyxyKSx7aW5wdXRzOnp9KTplLmNvbXB1dGUoYnQoeixuLGksQSxvLHIpLHtpbnB1dHM6en0pO3JldHVybn1sZXQgYj0hMCx5PWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKHBlKHRbMV0sSm4pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07bi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD15KTtsZXQgZz1bdFswXSx5XTtzJiZnLnB1c2godFsyXSk7bGV0IF89bz9wKmY6bSx3PW8/bTpwKmYsdj1sKmMqZDtlLmNvbXB1dGUodXMoZyxuLGksXyx3LHYscyxiLHIpLHtpbnB1dHM6Z30pfSxnbD0oZSx0KT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIscj1bZS5pbnB1dHNbMF0ucmVzaGFwZShuP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmci5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbz1bMCx0LnBhZHNbMF0sMCx0LnBhZHNbMV1dLGk9WzFdLmNvbmNhdCh0LnN0cmlkZXMpLHM9WzFdLmNvbmNhdCh0LmRpbGF0aW9ucyksYT1bMV0uY29uY2F0KHQua2VybmVsU2hhcGUpLHU9ZXIoey4uLnQscGFkczpvLHN0cmlkZXM6aSxkaWxhdGlvbnM6cyxrZXJuZWxTaGFwZTphfSxyKTticyhlLHIsdSxkPT5uP1tkWzBdLGRbMl0sZFszXV06W2RbMF0sZFsxXSxkWzNdXSl9LHlsPShlLHQsbik9PntsZXQgcj1uLmZvcm1hdD09PVwiTkhXQ1wiP1wiY2hhbm5lbHNMYXN0XCI6XCJjaGFubmVsc0ZpcnN0XCIsbz1lcihuLHQpLGk9bi5hdXRvUGFkPT09XCJOT1RTRVRcIj9uLnBhZHM6bi5hdXRvUGFkLHM9cHModFswXS5kaW1zLHRbMV0uZGltcyxuLnN0cmlkZXMsbi5kaWxhdGlvbnMsaSwhMSxyKTtlLmNvbXB1dGUobXModCxvLHMub3V0U2hhcGUsW3MuZmlsdGVyRGVwdGgscy5maWx0ZXJIZWlnaHQscy5maWx0ZXJXaWR0aF0sW3MucGFkSW5mby5mcm9udCxzLnBhZEluZm8udG9wLHMucGFkSW5mby5sZWZ0XSxyKSl9LG5yPShlLHQpPT57aWYoaGwoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zKWdsKGUsdCk7ZWxzZSBpZihlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTUpeWwoZSxlLmlucHV0cyx0KTtlbHNle2xldCBuPWVyKHQsZS5pbnB1dHMpO2JzKGUsZS5pbnB1dHMsbil9fX0pO3ZhciB3cywkcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO2tlKCk7cSgpO0soKTt3cz0oZSx0LG4pPT57bGV0IHI9ZS5sZW5ndGg+MixvPXQub3V0cHV0U2hhcGUsaT10LmZvcm1hdD09PVwiTkhXQ1wiLHM9dC5ncm91cCxhPWVbMV0uZGltcyx1PWFbMl0vcyxkPWFbM10sbD1pP1godSk6MSxjPWkmJmQ9PT0xJiZ1Pj00LHA9Yz9NYXRoLmZsb29yKHUvNCkqNDpNYXRoLmZsb29yKHUvbCkqbCxmPXUtcCxtPWk/WChkKToxLGg9aT9kPT09MT9sOm06MSxiPXguc2l6ZShvKS9tLHk9W01hdGguY2VpbChiLzY0KSwxLDFdO2ooXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX2JhY2twcm9wX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3l9YCk7bGV0IGc9W1wicmFua1wiLFwicmFua1wiXSxfPVt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXSx3PVt0Lmtlcm5lbFNoYXBlW2k/MToyXSx0Lmtlcm5lbFNoYXBlW2k/MjozXV0sdj1bdC5kaWxhdGlvbnNbMF0sdC5kaWxhdGlvbnNbMV1dLCQ9W3dbMF0rKHQuZGlsYXRpb25zWzBdPD0xPzA6KHQua2VybmVsU2hhcGVbaT8xOjJdLTEpKih0LmRpbGF0aW9uc1swXS0xKSksd1sxXSsodC5kaWxhdGlvbnNbMV08PTE/MDoodC5rZXJuZWxTaGFwZVtpPzI6M10tMSkqKHQuZGlsYXRpb25zWzFdLTEpKV0sVD1bJFswXS0xLU1hdGguZmxvb3IoKHQucGFkc1swXSt0LnBhZHNbMl0pLzIpLCRbMV0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMV0rdC5wYWRzWzNdKS8yKV0sST1be3R5cGU6MTIsZGF0YTpifSx7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6d30se3R5cGU6MTIsZGF0YTp2fSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjYsZGF0YTpUfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6dX0se3R5cGU6MTIsZGF0YTpkfSwuLi5QKGVbMF0uZGltcyxlWzFdLmRpbXMpXTtyJiYoSS5wdXNoKC4uLlAoZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSksSS5wdXNoKC4uLlAobykpO2xldCBBPXo9PntsZXQgTT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dy5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp3Lmxlbmd0aH0se25hbWU6XCJlZmZlY3RpdmVfZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOiQubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOlQubGVuZ3RofSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cF9pbnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XSxVPXJlKGVbMF0uZGF0YVR5cGUpLEc9aT8xOjIsQj1pPzI6MyxlZT1pPzM6MSxXPVMoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLGgpLEQ9UyhcIkR5XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGwpLFo9W0QsV107ciYmWi5wdXNoKFMoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxbb1tlZV1dLmxlbmd0aCxtKSk7bGV0IFI9QyhcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsbSksUT0oKT0+e2xldCBIPVwiXCI7aWYoYylsPT09ND9IKz1gXG4gICAgICAgIGxldCB4VmFsdWUgPSAke0QuZ2V0QnlPZmZzZXQoXCJ4X29mZnNldFwiKX07XG4gICAgICAgIGxldCB3VmFsdWUgPSAke1cuZ2V0QnlPZmZzZXQoXCJ3X29mZnNldFwiKX07XG4gICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtcbiAgICAgICAgeF9vZmZzZXQgKz0gMXU7XG4gICAgICAgIHdfb2Zmc2V0ICs9IDF1O2A6bD09PTI/SCs9YFxuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHZlYzQ8JHtVfT4oJHtELmdldEJ5T2Zmc2V0KFwieF9vZmZzZXRcIil9LCAke0QuZ2V0QnlPZmZzZXQoXCJ4X29mZnNldCArIDF1XCIpfSksIHZlYzQ8JHtVfT4oJHtXLmdldEJ5T2Zmc2V0KFwid19vZmZzZXRcIil9LCAke1cuZ2V0QnlPZmZzZXQoXCJ3X29mZnNldCArIDF1XCIpfSkpO1xuICAgICAgICAgIHhfb2Zmc2V0ICs9IDJ1O1xuICAgICAgICAgIHdfb2Zmc2V0ICs9IDJ1O2A6bD09PTEmJihIKz1gXG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QodmVjNDwke1V9Pigke0QuZ2V0QnlPZmZzZXQoXCJ4X29mZnNldFwiKX0sICR7RC5nZXRCeU9mZnNldChcInhfb2Zmc2V0ICsgMXVcIil9LCAke0QuZ2V0QnlPZmZzZXQoXCJ4X29mZnNldCArIDJ1XCIpfSwgJHtELmdldEJ5T2Zmc2V0KFwieF9vZmZzZXQgKyAzdVwiKX0pLCB2ZWM0PCR7VX0+KCR7Vy5nZXRCeU9mZnNldChcIndfb2Zmc2V0XCIpfSwgJHtXLmdldEJ5T2Zmc2V0KFwid19vZmZzZXQgKyAxdVwiKX0sICR7Vy5nZXRCeU9mZnNldChcIndfb2Zmc2V0ICsgMnVcIil9LCAke1cuZ2V0QnlPZmZzZXQoXCJ3X29mZnNldCArIDN1XCIpfSkpO1xuICAgICAgICAgIHhfb2Zmc2V0ICs9IDR1O1xuICAgICAgICAgIHdfb2Zmc2V0ICs9IDR1O2ApO2Vsc2UgaWYoSCs9YFxuICAgICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7aT9ELmdldEJ5T2Zmc2V0KGAke0QuaW5kaWNlc1RvT2Zmc2V0KGAke0QudHlwZS5pbmRpY2VzfShiYXRjaCwgaWR5UiwgaWR5QywgaW5wdXRDaGFubmVsKWApfSAvICR7bH1gKTpELmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xuICAgICAgICBgLGw9PT0xKUgrPWBcbiAgICAgICAgICBsZXQgd19vZmZzZXQgPSAke1cuaW5kaWNlc1RvT2Zmc2V0KGAke1cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9O1xuICAgICAgICAgIGxldCB3VmFsdWUgPSAke1cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0IC8gJHtofWApfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO2Vsc2UgZm9yKGxldCBFPTA7RTxsO0UrKylIKz1gXG4gICAgICAgICAgICBsZXQgd1ZhbHVlJHtFfSA9ICR7Vy5nZXRCeU9mZnNldChgJHtXLmluZGljZXNUb09mZnNldChgJHtXLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwgKyAke0V9LCB3T3V0Q2hhbm5lbClgKX0gLyAke2h9YCl9O1xuICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWVbJHtFfV0gKiB3VmFsdWUke0V9O2A7cmV0dXJuIEh9LHdlPSgpPT57aWYoZj09PTApcmV0dXJuXCJcIjtpZighYyl0aHJvdyBuZXcgRXJyb3IoYHBhY2tJbnB1dEFzNCAke2N9IGlzIG5vdCB0cnVlLmApO2xldCBIPVwiXCI7aWYobD09PTEpe0grPVwiZG90UHJvZCA9IGRvdFByb2RcIjtmb3IobGV0IEU9MDtFPGY7RSsrKUgrPWBcbiAgICAgICAgICAgICsgJHtELmdldEJ5T2Zmc2V0KGB4X29mZnNldCArICR7RX1gKX0gKiAke1cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0ICsgJHtFfWApfWA7SCs9XCI7XCJ9ZWxzZSBpZihsPT09Mil7aWYoZiE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlucHV0Q2hhbm5lbHNSZW1haW5kZXIgJHtmfS5gKTtIKz1gXG4gICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7RC5nZXRCeU9mZnNldChcInhfb2Zmc2V0XCIpfTtcbiAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtXLmdldEJ5T2Zmc2V0KFwid19vZmZzZXRcIil9O1xuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtgfXJldHVybiBIfSxzZT1gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Ui5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke219YCl9O1xuICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtSLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsMCl9O1xuICAgICAgICAgICAgbGV0IGQxID0gJHtSLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsZWUpfTtcbiAgICAgICAgICAgIGxldCByID0gJHtSLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRyl9O1xuICAgICAgICAgICAgbGV0IGMgPSAke1IuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixCKX07XG4gICAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAke1IudHlwZS52YWx1ZX0oMC4wKTtcbiAgICAgICAgICAgIHZhciB3UjogdTMyID0gMDtcbiAgICAgICAgICAgIGlmICh1bmlmb3Jtcy5kaWxhdGlvbnMueCA9PSAxKSB7XG4gICAgICAgICAgICAgIC8vIE1pbmltdW0gd1IgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlSQ29ybmVyICsgd1IpICUgKHVuaWZvcm1zLnN0cmlkZXMueCkgPT0gMFxuICAgICAgICAgICAgICB3UiA9IHUzMigoKGR5UkNvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIGR5UkNvcm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtVfShkeVJDb3JuZXIpICsgJHtVfSh3UikpIC8gJHtVfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtVfSh1bmlmb3Jtcy5EeV9zaGFwZVske0d9XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcbiAgICAgICAgICAgICAgdmFyIHdDOiB1MzIgPSAwO1xuICAgICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gd0MgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlDQ29ybmVyICsgd0MpICUgKHVuaWZvcm1zLnN0cmlkZXMueSkgPT0gMFxuICAgICAgICAgICAgICAgIHdDID0gdTMyKCgoZHlDQ29ybmVyICsgaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkgLSAxKSAvIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpKSAqIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gZHlDQ29ybmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAod0MgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke1V9KGR5Q0Nvcm5lcikgKyAke1V9KHdDKSkgLyAke1V9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke1V9KHVuaWZvcm1zLkR5X3NoYXBlWyR7Qn1dKSB8fFxuICAgICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgICAgJHtjP2BcbiAgICAgICAgICAgICAgICB2YXIgeF9vZmZzZXQgPSAke0QuaW5kaWNlc1RvT2Zmc2V0KGAke0QudHlwZS5pbmRpY2VzfShiYXRjaCwgaWR5UiwgaWR5QywgaW5wdXRDaGFubmVsKWApfSAvICR7bH07XG4gICAgICAgICAgICAgICAgdmFyIHdfb2Zmc2V0ID0gJHtXLmluZGljZXNUb09mZnNldChgJHtXLnR5cGUuaW5kaWNlc30od1JQZXJtLCB3Q1Blcm0sIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9IC8gJHtofTtcbiAgICAgICAgICAgICAgICAgIGA6XCJcIn1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXBfaW50OyBkMiA9IGQyICsgJHtjPzQ6bH0pIHtcbiAgICAgICAgICAgICAgICAgICR7USgpfVxuICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgJHtjPzQ6bH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR7d2UoKX1cbiAgICAgICAgICAgICAgICB3QyA9IHdDICsgdW5pZm9ybXMuc3RyaWRlcy55IC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3UiA9IHdSICsgdW5pZm9ybXMuc3RyaWRlc1swXSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kJHtyP2AgKyBiaWFzW2QxIC8gJHttfV1gOlwiXCJ9O1xuICAgICAgICAgICAgJHtSLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgICAgIGA7cmV0dXJuYFxuICAgICR7ei5yZWdpc3RlclVuaWZvcm1zKE0pLmRlY2xhcmVWYXJpYWJsZXMoLi4uWixSKX1cbiAgICAgICR7ei5tYWluU3RhcnQoKX1cbiAgICAgICR7ei5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9O1xuICAgICR7c2V9fWB9O3JldHVybntuYW1lOlwiQ29udlRyYW5zcG9zZTJEXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtsfSR7aH0ke219JHtjfSR7Zn1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7ZGlzcGF0Y2hHcm91cDp7eDp5WzBdLHk6eVsxXSx6OnlbMl19LG91dHB1dHM6W3tkaW1zOm4/bihvKTpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6SX0pLGdldFNoYWRlclNvdXJjZTpBfX19KTt2YXIgYmwsX2wsd2wsdnMseHMsJGwsU3MsdmwsVHMsSXM9aygoKT0+e1widXNlIHN0cmljdFwiOyRzKCk7RmUoKTtWZSgpO2JsPShlLHQsbixyLG8saSk9PihlLTEpKnQrbisoci0xKSpvKzEtaSxfbD0oZSx0LG4scixvKT0+e2xldCBpPU1hdGguZmxvb3IoZS8yKTt0PT09XCJTQU1FX1VQUEVSXCI/KG5bcl09aSxuW29dPWUtaSk6dD09PVwiU0FNRV9MT1dFUlwiJiYobltyXT1lLWksbltvXT1pKX0sd2w9KGUsdCxuLHIsbyxpLHMsYSx1LGQpPT57bGV0IGw9ZS5sZW5ndGgtMixjPWQubGVuZ3RoPT09MDt1Lmxlbmd0aDxsJiZ1LnB1c2goLi4uQXJyYXkobC11Lmxlbmd0aCkuZmlsbCgwKSk7bGV0IHA9ZVswXSxmPXRbYT8zOjFdKm87Zm9yKGxldCBtPTAsaD1lLmxlbmd0aC1sLShhPzE6MCk7bTxsOysrbSwrK2gpe2xldCBiPWVbaF0seT1jP2Iqc1ttXTpkW21dLGc9YmwoYixzW21dLGlbbV0sdFtoXSxuW21dLHkpO19sKGcscixpLG0sbStsKSxjJiZkLnB1c2goc1ttXSooYi0xKSt1W21dKyh0W2hdLTEpKm5bbV0rMS1pW21dLWlbbStsXSl9ZC5zcGxpY2UoMCwwLHApLGQuc3BsaWNlKGE/MzoxLDAsZil9LHZzPShlLHQpPT57bGV0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPT09MHx8ZS5rZXJuZWxTaGFwZS5yZWR1Y2UoKGMscCk9PmMqcCwxKT09PTApe24ubGVuZ3RoPTA7Zm9yKGxldCBjPTI7Yzx0WzFdLmRpbXMubGVuZ3RoOysrYyluLnB1c2godFsxXS5kaW1zW2NdKX1sZXQgcj1lLmZvcm1hdD09PVwiTkhXQ1wiO24uc3BsaWNlKDAsMCx0WzFdLmRpbXNbMF0pLG4uc3BsaWNlKHI/MzoxLDAsdFsxXS5kaW1zWzFdKTtsZXQgbz1lLnBhZHMuc2xpY2UoKSxpPWUub3V0cHV0U2hhcGUuc2xpY2UoKSxzPWUub3V0cHV0UGFkZGluZy5zbGljZSgpLGE9dFswXS5kaW1zLHU9ZS5kaWxhdGlvbnMuc2xpY2UoKTtpZih1LnJlZHVjZSgoYyxwKT0+YytwLDApPT09MCl7bGV0IGM9dFswXS5kaW1zLmxlbmd0aC0yO3U9bmV3IEFycmF5KGMpLmZpbGwoMSl9bGV0IGQ9ZS5zdHJpZGVzLnNsaWNlKCk7aWYoZC5yZWR1Y2UoKGMscCk9PmMrcCwwKT09PTApe2xldCBjPXRbMF0uZGltcy5sZW5ndGgtMjtkPW5ldyBBcnJheShjKS5maWxsKDEpfXdsKGEsbix1LGUuYXV0b1BhZCxlLmdyb3VwLG8sZCxyLHMsaSk7bGV0IGw9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihsLHtrZXJuZWxTaGFwZTpuLHBhZHM6byxvdXRwdXRQYWRkaW5nOnMsb3V0cHV0U2hhcGU6aSxkaWxhdGlvbnM6dSxzdHJpZGVzOmR9KSxsfSx4cz1lPT57bGV0IHQ9cm4oZSksbj1lLmZvcm1hdCxyPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bdHlwZW9mIGUuYXV0b1BhZD5cInVcIj8wOmUuYXV0b1BhZF0sbz1lLmRpbGF0aW9ucyxpPWUuZ3JvdXAscz1lLmtlcm5lbFNoYXBlLGE9ZS5wYWRzLHU9ZS5zdHJpZGVzLGQ9ZS53SXNDb25zdCgpLGw9ZS5vdXRwdXRQYWRkaW5nLGM9ZS5vdXRwdXRTaGFwZTtyZXR1cm57YXV0b1BhZDpyLGZvcm1hdDpuLGRpbGF0aW9uczpvLGdyb3VwOmksa2VybmVsU2hhcGU6cyxvdXRwdXRQYWRkaW5nOmwsb3V0cHV0U2hhcGU6YyxwYWRzOmEsc3RyaWRlczp1LHdJc0NvbnN0OmQsLi4udCxjYWNoZUtleTpgJHtlLmZvcm1hdH07JHt0LmFjdGl2YXRpb259O2B9fSwkbD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCBuPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxyPWVbMV0uZGltc1swXTtpZihuIT09cil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2xldCBvPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzJdLmRpbXNbMF0hPT1vKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IGk9ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLnJlZHVjZSgobCxjKT0+bCtjLDApPjAmJnQuZGlsYXRpb25zLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5zdHJpZGVzLnJlZHVjZSgobCxjKT0+bCtjLDApPjAmJnQuc3RyaWRlcy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtpfURgKTtpZih0LnBhZHMucmVkdWNlKChsLGMpPT5sK2MsMCk+MCYmdC5wYWRzLmxlbmd0aCE9PWkqMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7aSoyfURgKTtpZih0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09aSYmdC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtpfURgKTtpZih0Lmtlcm5lbFNoYXBlLnJlZHVjZSgobCxjKT0+bCtjLDApPjAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYodC5vdXRwdXRTaGFwZS5sZW5ndGghPT0wJiZ0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG91dHB1dCBzaGFwZVwiKX0sU3M9KGUsdCxuLHIpPT57bGV0IG89ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUocGUodFsxXSxbMiwzLDAsMV0pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07bi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1vKTtsZXQgaT1bdFswXSxvXTt0Lmxlbmd0aD09PTMmJmkucHVzaCh0WzJdKSxlLmNvbXB1dGUod3MoaSxuLHIpLHtpbnB1dHM6aX0pfSx2bD0oZSx0KT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIscj1bZS5pbnB1dHNbMF0ucmVzaGFwZShuP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmci5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbz10Lmtlcm5lbFNoYXBlOyhvLmxlbmd0aD09PTB8fG9bMF09PT0wKSYmKG89W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgaT10LmRpbGF0aW9uczsoaS5sZW5ndGg9PT0wfHxpWzBdPT09MCkmJihpPVsxXSk7bGV0IHM9dC5zdHJpZGVzOyhzLmxlbmd0aD09PTB8fHNbMF09PT0wKSYmKHM9WzFdKTtsZXQgYT10LnBhZHM7YS5sZW5ndGg9PT0wJiYoYT1bMCwwXSksYT1bMCxhWzBdLDAsYVsxXV0scz1bMV0uY29uY2F0KHMpLGk9WzFdLmNvbmNhdChpKSxvPVsxXS5jb25jYXQobyk7bGV0IHU9dC5vdXRwdXRQYWRkaW5nO3U9WzBdLmNvbmNhdCh1KTtsZXQgZD12cyh7Li4udCxwYWRzOmEsc3RyaWRlczpzLGRpbGF0aW9uczppLGtlcm5lbFNoYXBlOm8sb3V0cHV0UGFkZGluZzp1fSxyKTtTcyhlLHIsZCxsPT5uP1tsWzBdLGxbMl0sbFszXV06W2xbMF0sbFsxXSxsWzNdXSl9LFRzPShlLHQpPT57aWYoJGwoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zKXZsKGUsdCk7ZWxzZXtsZXQgbj12cyh0LGUuaW5wdXRzKTtTcyhlLGUuaW5wdXRzLG4pfX19KTt2YXIgeGwsQ3MsQXMsRXM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7eGw9KGUsdCxuLHIpPT57bGV0IG89eC5zaXplKHQpLGk9dC5sZW5ndGgscz1TKFwiaW5wdXRcIixlLGkpLGE9QyhcIm91dHB1dFwiLGUsaSksdT1uLmRhdGFUeXBlPT09Nj9uLmdldEludDMyQXJyYXkoKVswXTpOdW1iZXIobi5nZXRCaWdJbnQ2NEFycmF5KClbMF0pLGQ9eC5ub3JtYWxpemVBeGlzKHUsaSksbD1jPT57bGV0IHA9YCBpMzIoJHtzLmluZGljZXNHZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9KSBgLGY9TyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJ1bmlmb3Jtcy5heGlzXCIsaSksbT1yLnJldmVyc2U/cCsoci5leGNsdXNpdmU/XCIgKyAxXCI6XCJcIik6XCIwXCIsaD1yLnJldmVyc2U/ZjpwKyhyLmV4Y2x1c2l2ZT9cIlwiOlwiICsgMVwiKTtyZXR1cm5gXG4gICAgICAgICAgICAgICAgJHtjLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhzLGEpfVxuICAgICAgICAgICAgICAgICR7Yy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7Yy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0IDogaTMyID0gJHttfTtcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHtofTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAke3MuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGkpXCIpfTtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHtzLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAke2Euc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkN1bVN1bVwiLHNoYWRlckNhY2hlOntoaW50OnIuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6ZH0sLi4uUCh0LHQpXX0pLGdldFNoYWRlclNvdXJjZTpsfX0sQ3M9KGUsdCk9PntsZXQgbj1lLmlucHV0c1swXS5kaW1zLHI9ZS5pbnB1dHNbMF0uZGF0YVR5cGUsbz1lLmlucHV0c1sxXTtlLmNvbXB1dGUoeGwocixuLG8sdCkse2lucHV0czpbMF19KX0sQXM9ZT0+e2xldCB0PWUuZXhjbHVzaXZlPT09MSxuPWUucmV2ZXJzZT09PTE7cmV0dXJuIE4oe2V4Y2x1c2l2ZTp0LHJldmVyc2U6bn0pfX0pO3ZhciBTbCxUbCxJbCxrcyxQcyx6cz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtTbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDREIGlucHV0LlwiKX0sVGw9KGUsdCxuLHIpPT57bGV0IG89W107by5wdXNoKGBmbiBwZXJtKGk6ICR7ci50eXBlLmluZGljZXN9KSAtPiAke24udHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7bi50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgaT0wO2k8dDsrK2kpby5wdXNoKG4uaW5kaWNlc1NldChcImFcIixlW2ldLGBpWyR7aX1dYCkpO3JldHVybiBvLnB1c2goXCJyZXR1cm4gYTt9XCIpLG8uam9pbihgXG5gKX0sSWw9KGUsdCk9PntsZXQgbixyLG8saSxzLGEsdT10LmZvcm1hdD09PVwiTkhXQ1wiLGQ9dC5ibG9ja3NpemUsbD10Lm1vZGU9PT1cIkRDUlwiO3U/KFtuLHIsbyxpXT1lLmRpbXMscz1sP1tuLHIsbyxkLGQsaS9kKioyXTpbbixyLG8saS9kKioyLGQsZF0sYT1sP1swLDEsMywyLDQsNV06WzAsMSw0LDIsNSwzXSk6KFtuLHIsbyxpXT1bZS5kaW1zWzBdLGUuZGltc1syXSxlLmRpbXNbM10sZS5kaW1zWzFdXSxzPWw/W24sZCxkLGkvZCoqMixyLG9dOltuLGkvZCoqMixkLGQscixvXSxhPWw/WzAsMyw0LDEsNSwyXTpbMCwxLDQsMiw1LDNdKTtsZXQgYz1lLnJlc2hhcGUocykscD1jLmRpbXMubGVuZ3RoLGY9ZS5kYXRhVHlwZSxtPVMoXCJhXCIsZixwKSxoPUMoXCJvdXRwdXRcIixmLHApLGI9eT0+YFxuICAke3kucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0saCl9XG5cbiAgJHtUbChhLHAsbSxoKX1cblxuICAke3kubWFpblN0YXJ0KCl9XG4gICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHtoLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke2guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbS5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gO3JldHVybntuYW1lOlwiRGVwdGhUb1NwYWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ZS5kaW1zfTske3QuYmxvY2tzaXplfTske3QubW9kZX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6eT0+e2xldCBnPXU/W24scipkLG8qZCxpL2QqKjJdOltuLGkvZCoqMixyKmQsbypkXSxfPXguc2l6ZShnKSx3PWMuZGltcyx2PXguc29ydEJhc2VkT25QZXJtKHcsYSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmcsZGF0YVR5cGU6eVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKF8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6X30sLi4uUCh3LHYpXX19LGdldFNoYWRlclNvdXJjZTpifX0sa3M9KGUsdCk9PntTbChlLmlucHV0cyksZS5jb21wdXRlKElsKGUuaW5wdXRzWzBdLHQpKX0sUHM9ZT0+Tih7YmxvY2tzaXplOmUuYmxvY2tzaXplLG1vZGU6ZS5tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIHJyLGxuLEJzLENsLEFsLG9yLGlyLERzLEVsLE9zLE1zLFVzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO3JyPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIsbG49XCIoXCIrcnIrXCIpK1wiLEJzPVwiXlwiK2xuK1wiJFwiLENsPVwiKFwiK2xuK1wiLCkqXCIrbG4sQWw9XCJeXCIrQ2wrXCIkXCIsb3I9Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxuKXtsZXQgcj10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7cj09PXZvaWQgMD9yPVtuXTpyLnB1c2gobiksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQscil9fSxpcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMuZXF1YXRpb249bjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbcixvXT1uLmluY2x1ZGVzKFwiLT5cIik/bi5zcGxpdChcIi0+XCIsMik6W24sXCJcIl07aWYoIXIubWF0Y2goUmVnRXhwKEFsKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihyLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChhLHUpPT57bGV0IGQ9dFt1XS5kaW1zLnNsaWNlKCk7aWYoIWEubWF0Y2goUmVnRXhwKEJzKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbD10aGlzLnByb2Nlc3NUZXJtKGEsITAsZCx1KTt0aGlzLmxocy5wdXNoKGwpfSksbz09PVwiXCIpbys9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbYSx1XSk9PnUuY291bnQ9PT0xfHxhPT09XCIuLi5cIikubWFwKChbYV0pPT5hKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW8ubWF0Y2goUmVnRXhwKGxuKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7by5tYXRjaChSZWdFeHAocnIsXCJnXCIpKT8uZm9yRWFjaChhPT57aWYoYT09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IHU9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGEpO2lmKHU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKHUuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obywhMSx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LG4scil7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG8hPT12b2lkIDApe2lmKG8uZGltVmFsdWUhPT1uJiZvLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7by5jb3VudCsrLG8uaW5wdXRJbmRpY2VzLnB1c2gocil9ZWxzZSBvPXtjb3VudDoxLGRpbVZhbHVlOm4saW5wdXRJbmRpY2VzOltyXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbyl9cHJvY2Vzc1Rlcm0odCxuLHIsbz0tMSl7bGV0IGk9ci5sZW5ndGgscz0hMSxhPVtdLHU9MDtpZighdC5tYXRjaChSZWdFeHAoQnMpKSYmIW4mJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IGQ9dC5tYXRjaChSZWdFeHAocnIsXCJnXCIpKSxsPW5ldyBvcihvKTtyZXR1cm4gZD8uZm9yRWFjaCgoYyxwKT0+e2lmKGM9PT1cIi4uLlwiKXtpZihzKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7cz0hMDtsZXQgZj1pLWQubGVuZ3RoKzE7aWYoZjwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoYT1yLnNsaWNlKHUsdStmKSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1hLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWEudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYobil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgbT0wO208YS5sZW5ndGg7bSsrKXtsZXQgaD1TdHJpbmcuZnJvbUNoYXJDb2RlKDQ4K20pO2wuYWRkU3ltYm9sKGgscCttKSx0aGlzLmFkZFN5bWJvbChoLHJbdSsrXSxvKX19ZWxzZSBsLmFkZFN5bWJvbChjLHArKHRoaXMuaGFzRWxsaXBzaXM/dGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoLTE6MCkpLHRoaXMuYWRkU3ltYm9sKGMsclt1KytdLG8pfSksbH19LERzPWU9PmUrXCJfbWF4XCIsRWw9KGUsdCxuLHIpPT57bGV0IGk9ZS5tYXAobD0+bC5sZW5ndGgpLm1hcCgobCxjKT0+UyhgaW5wdXQke2N9YCx0LGwpKSxzPXguc2l6ZShyKSxhPUMoXCJvdXRwdXRcIix0LHIubGVuZ3RoKSx1PVsuLi5uLnN5bWJvbFRvSW5mby5rZXlzKCldLmZpbHRlcihsPT4hbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhsKSksZD1sPT57bGV0IGM9W10scD1cInZhciBwcm9kID0gMS4wO1wiLGY9XCJ2YXIgc3VtID0gMC4wO1wiLG09XCJzdW0gKz0gcHJvZDtcIixoPVtdLGI9W10seT1bXSxnPVtdLF89bi5zeW1ib2xUb0luZm8uc2l6ZT09PW4ucmhzLnN5bWJvbFRvSW5kaWNlcy5zaXplO24uc3ltYm9sVG9JbmZvLmZvckVhY2goKHYsJCk9PntpZihuLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKCQpKXtsZXQgVD1uLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KCQpPy5bMF07VCE9PXZvaWQgMCYmbi5saHMuZm9yRWFjaCgoSSxBKT0+e2lmKHYuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKEEpKXtsZXQgej1JLnN5bWJvbFRvSW5kaWNlcy5nZXQoJCk7aWYoej09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTt6LmZvckVhY2goTT0+e2MucHVzaChgJHtpW0FdLmluZGljZXNTZXQoYGlucHV0JHtBfUluZGljZXNgLE0sYS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFQpKX1gKX0pfX0pfWVsc2Ugbi5saHMuZm9yRWFjaCgoVCxJKT0+e2lmKHYuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKEkpKXtsZXQgQT1ULnN5bWJvbFRvSW5kaWNlcy5nZXQoJCk7aWYoQT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtBLmZvckVhY2goej0+e2gucHVzaChgJHtpW0ldLmluZGljZXNTZXQoYGlucHV0JHtJfUluZGljZXNgLHosYCR7JH1gKX1gKX0pLGcucHVzaChgcHJvZCAqPSAke2lbSV0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7SX1JbmRpY2VzYCl9O2ApfX0pLGIucHVzaChgZm9yKHZhciAkeyR9OiB1MzIgPSAwOyAkeyR9IDwgdW5pZm9ybXMuJHtEcygkKX07ICR7JH0rKykge2ApLHkucHVzaChcIn1cIil9KTtsZXQgdz1fP1suLi5jLGBsZXQgc3VtID0gJHtpLm1hcCgodiwkKT0+di5nZXRCeUluZGljZXMoYGlucHV0JHskfUluZGljZXNgKSkuam9pbihcIiAqIFwiKX07YF06Wy4uLmMsZiwuLi5iLC4uLmgscCwuLi5nLG0sLi4ueV07cmV0dXJuYFxuICAgICAgICAgICAgJHtsLnJlZ2lzdGVyVW5pZm9ybXModS5tYXAodj0+KHtuYW1lOmAke0RzKHYpfWAsdHlwZTpcInUzMlwifSkpKS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyguLi5pLGEpfVxuXG4gICAgICAgICAgICAke2wubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICR7aS5tYXAoKHYsJCk9PmB2YXIgaW5wdXQkeyR9SW5kaWNlczogJHtpWyRdLnR5cGUuaW5kaWNlc307YCkuam9pbihgXG5gKX1cbiAgICAgICAgICAgICR7dy5qb2luKGBcbmApfTtcbiAgICAgICAgICAgICR7YS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6bi5lcXVhdGlvbixpbnB1dERlcGVuZGVuY2llczplLm1hcCgoKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT57bGV0IGw9dS5maWx0ZXIocD0+bi5zeW1ib2xUb0luZm8uaGFzKHApKS5tYXAocD0+KHt0eXBlOjEyLGRhdGE6bi5zeW1ib2xUb0luZm8uZ2V0KHApPy5kaW1WYWx1ZXx8MH0pKTtsLnB1c2goe3R5cGU6MTIsZGF0YTpzfSk7bGV0IGM9ZS5tYXAoKHAsZik9PlsuLi5QKHApXSkucmVkdWNlKChwLGYpPT5wLmNvbmNhdChmKSxsKTtyZXR1cm4gYy5wdXNoKC4uLlAocikpLHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOnR9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmN9fSxnZXRTaGFkZXJTb3VyY2U6ZH19LE9zPShlLHQpPT57bGV0IG49bmV3IGlyKGUuaW5wdXRzLHQuZXF1YXRpb24pLHI9bi5vdXRwdXREaW1zLG89ZS5pbnB1dHMubWFwKChpLHMpPT5pLmRpbXMpO2UuY29tcHV0ZShFbChvLGUuaW5wdXRzWzBdLmRhdGFUeXBlLG4scikpfSxNcz1lPT57bGV0IHQ9ZS5lcXVhdGlvbi5yZXBsYWNlKC9cXHMrL2csXCJcIik7cmV0dXJuIE4oe2VxdWF0aW9uOnR9KX19KTt2YXIga2wsUnMsUGwsemwsVnMsTnM9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO2tsPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMsbj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlcikscj1uLmxlbmd0aDx0Lmxlbmd0aD8wOm4ubGVuZ3RoLXQubGVuZ3RoLG89dC5sZW5ndGg8bi5sZW5ndGg/MDp0Lmxlbmd0aC1uLmxlbmd0aDtmb3IoO3I8bi5sZW5ndGgmJm88dC5sZW5ndGg7KytyLCsrbylpZihuW3JdIT09dFtvXSYmbltyXSE9PTEmJnRbb10hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxScz0oZSx0KT0+e2xldCBuPWUubGVuZ3RoLXQubGVuZ3RoLHI9W107Zm9yKGxldCBvPTA7bzxuOysrbylyLnB1c2goZVtvXSk7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pci5wdXNoKHRbb109PT0xP2VbbytuXTp0W29dKTtyZXR1cm4gcn0sUGw9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP1JzKGUsdCk6UnModCxlKSx6bD1lPT57bGV0IHQ9ZVswXS5kaW1zLG49QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLHI9UGwodCxuKSxvPWVbMF0uZGF0YVR5cGUsaT1vPT09OXx8eC5zaXplKHQpPT09MSxzPW89PT05fHx0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxhPWl8fHIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA/NDoxLHU9TWF0aC5jZWlsKHguc2l6ZShyKS9hKSxkPWM9PntsZXQgcD1TKFwiaW5wdXRcIixvLHQubGVuZ3RoLHMpLGY9QyhcIm91dHB1dFwiLG8sci5sZW5ndGgsYSksbTtpZihvPT09OSl7bGV0IGg9KGIseSxnPVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3l9ID0gJHtmLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHt5fXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7eX0gPSAke3AuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3l9YCxmKX07XG4gICAgICAgICAgbGV0IGluZGV4JHt5fSA9IG9mZnNldCR7eX0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt5fSA9IG9mZnNldCR7eX0gJSA0dTtcbiAgICAgICAgICAke2J9WyR7eX1dID0gJHtnfSgke3AuZ2V0QnlPZmZzZXQoYGluZGV4JHt5fWApfVtjb21wb25lbnQke3l9XSk7XG4gICAgICAgIGA7bT1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHthfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7aChcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAke2goXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHtoKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7aChcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAke2Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWB9ZWxzZSBtPWBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2Yub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHthfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtwLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLGYpfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke2YudHlwZS52YWx1ZX0oJHtwLmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7c31gKX0pO1xuICAgICAgICAke2Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWA7cmV0dXJuYFxuICAgICR7Yy5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocCxmKX1cbiAgICAke2MubWFpblN0YXJ0KCl9XG4gICAgJHtjLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAke219YH0sbD1be3R5cGU6MTIsZGF0YTp1fSwuLi5QKHQscildO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5sZW5ndGh9OyR7c30ke2F9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6ZCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bH0pfX0sVnM9ZT0+e2tsKGUuaW5wdXRzKSxlLmNvbXB1dGUoemwoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIEJsLExzLFdzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtubigpO0JsPWU9PntsZXQgdD1lWzBdLmRhdGFUeXBlLG49eC5zaXplKGVbMF0uZGltcykscj14LnNpemUoZVsxXS5kaW1zKSxvPXIlND09PTAsaT1zPT57bGV0IGE9UyhcInhcIix0LFsxXSw0KSx1PVMoXCJiaWFzXCIsdCxbMV0sNCksZD1DKFwieVwiLHQsWzFdLDQpLGw9W3tuYW1lOlwib3V0cHV0X3ZlY19zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dLGM9Zj0+YFxuICAgICAgbGV0IGJpYXMke2Z9X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtmfSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7Zn0gPSAke3UuZ2V0QnlPZmZzZXQoYGJpYXMke2Z9X29mZnNldCAvIDRgKX1bYmlhcyR7Zn1fb2Zmc2V0ICUgNF07YCxwPW8/YFxuICAgICAgbGV0IGJpYXMgPSAke3UuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpXCIpfTtgOmAke2MoMCl9JHtjKDEpfSR7YygyKX0ke2MoMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7YS50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtyZXR1cm5gJHtzLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyhhLHUsZCl9XG5cbiAgICAke1puKGNlKHQpKX1cblxuICAgICR7cy5tYWluU3RhcnQoWWUpfVxuICAgICAgJHtzLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemVcIil9XG5cbiAgICAgIGxldCB4ID0gJHthLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke3B9XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFFuKFwieF9pblwiKSl9XG4gICAgfWB9O3JldHVybntuYW1lOlwiRmFzdEdlbHVXaXRoQmlhc1wiLHNoYWRlckNhY2hlOntoaW50OmAke299YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6aSxnZXRSdW5EYXRhOnM9Pih7b3V0cHV0czpbe2RpbXM6c1swXS5kaW1zLGRhdGFUeXBlOnNbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKG4vNCl9LHt0eXBlOjEyLGRhdGE6cn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vWWUvNCl9fSl9fSxMcz1lPT57ZS5pbnB1dHMubGVuZ3RoPDJ8fHguc2l6ZShlLmlucHV0c1sxXS5kaW1zKT09PTA/VWkoZSk6ZS5jb21wdXRlKEJsKGUuaW5wdXRzKSl9fSk7dmFyIERsLE9sLEdzLEhzLHFzPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO0RsPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LE9sPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9ZVsxXS5kaW1zLG89bi5sZW5ndGgsaT14Lm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLHM9bi5zbGljZSgwKTtzLnNwbGljZShpLDEsLi4ucik7bGV0IGE9bltpXSx1PWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxkPU1hdGguY2VpbCh4LnNpemUocykvdSksbD1be3R5cGU6MTIsZGF0YTpkfSx7dHlwZTo2LGRhdGE6YX0se3R5cGU6MTIsZGF0YTppfSwuLi5QKGVbMF0uZGltcyxlWzFdLmRpbXMscyldLGM9cD0+e2xldCBmPVMoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLHUpLG09UyhcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksaD1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxzLmxlbmd0aCx1KSxiPWc9PntsZXQgXz1yLmxlbmd0aCx3PWB2YXIgaW5kaWNlc0luZGljZXMke2d9ICA9ICR7bS50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCB2PTA7djxfO3YrKyl3Kz1gJHtfPjE/YGluZGljZXNJbmRpY2VzJHtnfVske3Z9XWA6YGluZGljZXNJbmRpY2VzJHtnfWB9ID0gJHtzLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHtnfVt1bmlmb3Jtcy5heGlzICsgJHt2fV1gOmBvdXRwdXRJbmRpY2VzJHtnfWB9O2A7dys9YFxuICAgICAgICAgIHZhciBpZHgke2d9ID0gJHttLmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke2d9YCl9O1xuICAgICAgICAgIGlmIChpZHgke2d9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHtnfSA9IGlkeCR7Z30gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7Z30gOiAke2YudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtmb3IobGV0IHY9MCwkPTA7djxvO3YrKyl2PT09aT8odys9YCR7bz4xP2BkYXRhSW5kaWNlcyR7Z31bJHt2fV1gOmBkYXRhSW5kaWNlcyR7Z31gfSA9IHUzMihpZHgke2d9KTtgLCQrPV8pOih3Kz1gJHtvPjE/YGRhdGFJbmRpY2VzJHtnfVske3Z9XWA6YGRhdGFJbmRpY2VzJHtnfWB9ID0gJHtzLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHtnfVskeyR9XWA6YG91dHB1dEluZGljZXMke2d9YH07YCwkKyspO3JldHVybiB3fSx5O2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgZz0oXyx3LHY9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7d30gPSAke2gub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3d9dWApfTtcbiAgICAgICAgICAke2Iodyl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3d9ID0gJHtmLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke3d9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7d30gPSBvZmZzZXQke3d9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7d30gPSBvZmZzZXQke3d9ICUgNHU7XG4gICAgICAgICAgJHtffVske3d9XSA9ICR7dn0oJHtmLmdldEJ5T2Zmc2V0KGBpbmRleCR7d31gKX1bY29tcG9uZW50JHt3fV0pO1xuICAgICAgICBgO3k9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7dX07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtnKFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke2coXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHtnKFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke2guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSB5PWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtoLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHtiKFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Zi5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke2guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7cC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZixtLGgpfVxuICAgICAgJHtwLm1haW5TdGFydCgpfVxuICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7eX1cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6Y319LEdzPWU9Pk4oe2F4aXM6ZS5heGlzfSksSHM9KGUsdCk9PntsZXQgbj1lLmlucHV0cztEbChuKSxlLmNvbXB1dGUoT2woZS5pbnB1dHMsdCkpfX0pO3ZhciBNbCxGcyxLcyxqcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7TWw9KGUsdCxuLHIsbyxpLHMsYSx1KT0+e2xldCBkPVt7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnV9XSxsPVtpXTtkLnB1c2goLi4uUCh0LmRpbXMsbCkpO2xldCBjPXA9PntsZXQgZj1TKFwiaW5kaWNlc19kYXRhXCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxtPUMoXCJpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFcIiwxMiwxLDEpLGg9W2YsbV0sYj1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiYXRjaF9kaW1zXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImlucHV0X2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm8ubGVuZ3RofSx7bmFtZTpcInNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpuLmxlbmd0aH0se25hbWU6XCJudW1fc2xpY2VzX3Blcl9iYXRjaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9iYXRjaF9zdHJpZGVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX3NsaWNlX2RpbXNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7cC5yZWdpc3RlclVuaWZvcm1zKGIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaCl9XG4gICR7cC5tYWluU3RhcnQoKX1cbiAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMubnVtX3NsaWNlc19wZXJfYmF0Y2g7XG4gICAgbGV0IGJhc2Vfb2Zmc2V0ID0gYmF0Y2hfaWR4ICogdW5pZm9ybXMuaW5wdXRfYmF0Y2hfc3RyaWRlO1xuXG4gICAgbGV0IHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7XG4gICAgdmFyIHJlbGF0aXZlX3NsaWNlX29mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgZGltX2lkeCA9IDB1OyBkaW1faWR4IDwgdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7IGRpbV9pZHggKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzX2RhdGFbZGltX2lkeCArIHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXRdLngpO1xuICAgICAgbGV0IGlucHV0X2RpbV9pZHggPSB1bmlmb3Jtcy5iYXRjaF9kaW1zICsgZGltX2lkeDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgJHtvLmxlbmd0aD09PTE/XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltcyk7XCI6XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltc1tpbnB1dF9kaW1faWR4XSk7XCJ9XG4gICAgICB9XG4gICAgICAke24ubGVuZ3RoPT09MT9cInJlbGF0aXZlX3NsaWNlX29mZnNldCArPSBpbmRleCAqIGkzMih1bmlmb3Jtcy5zaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YSk7XCI6XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFbZGltX2lkeF0pO1wifVxuICAgIH1cblxuICAgIGlucHV0X3NsaWNlX29mZnNldHNfZGF0YVtnbG9iYWxfaWR4XSA9ICBiYXNlX29mZnNldCArIHUzMihyZWxhdGl2ZV9zbGljZV9vZmZzZXQpO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcImNvbXB1dGVTbGljZU9mZnNldHNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvLmxlbmd0aH1fJHtuLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmlucHV0c1sxXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pLGdldFNoYWRlclNvdXJjZTpjfSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXX0sRnM9KGUsdCk9PntsZXQgbj1lLmlucHV0cyxyPW5bMF0uZGltcyxvPW5bMF0uZGF0YVR5cGUsaT1uWzFdLmRpbXMscz1pW2kubGVuZ3RoLTFdLGE9eC5zaXplVG9EaW1lbnNpb24oaSxpLmxlbmd0aC0xKSx1PXguc2l6ZUZyb21EaW1lbnNpb24ocix0LmJhdGNoRGltcytzKSxkPXguc2l6ZVRvRGltZW5zaW9uKHIsdC5iYXRjaERpbXMpLGw9eC5zaXplRnJvbURpbWVuc2lvbihyLHQuYmF0Y2hEaW1zKSxjPWEvZCxwPW5ldyBBcnJheShzKSxmPXU7Zm9yKGxldCB3PTA7dzxzOysrdylwW3MtMS13XT1mLGYqPXJbdC5iYXRjaERpbXMrcy0xLXddO2xldCBtPU1sKGUsblsxXSxwLHQuYmF0Y2hEaW1zLHIsYSxjLGwscyksaD10LmJhdGNoRGltcytzO2lmKGg+ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5kaWNlcyBtdXN0IG5vdCBiZSBsYXJnZXIgdGhhbiByYW5rIG9mIGlucHV0IHRlbnNvclwiKTtsZXQgYj1pLnNsaWNlKDAsLTEpLmNvbmNhdChyLnNsaWNlKGgpKSx5PXguc2l6ZShiKSxnPVt7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEyLGRhdGE6dX0sLi4uUChuWzBdLmRpbXMsbS5kaW1zLGIpXSxfPXc9PntsZXQgdj1TKFwiZGF0YVwiLG5bMF0uZGF0YVR5cGUsblswXS5kaW1zLmxlbmd0aCksJD1TKFwic2xpY2Vfb2Zmc2V0c1wiLDEyLG0uZGltcy5sZW5ndGgpLFQ9QyhcIm91dHB1dFwiLG5bMF0uZGF0YVR5cGUsYi5sZW5ndGgpO3JldHVybmBcbiAgICAgICAgICAke3cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzbGljZV9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh2LCQsVCl9XG4gICAgICAgICAgICAke3cubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBzbGljZV9vZmZzZXQgPSBzbGljZV9vZmZzZXRzW2dsb2JhbF9pZHggLyB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBkYXRhW3UzMihzbGljZV9vZmZzZXQpICsgZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xuICAgICAgICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiR2F0aGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YixkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeS82NCl9LHByb2dyYW1Vbmlmb3JtczpnfSksZ2V0U2hhZGVyU291cmNlOl99LHtpbnB1dHM6W25bMF0sbV19KX0sS3M9ZT0+KHtiYXRjaERpbXM6ZS5iYXRjaF9kaW1zLGNhY2hlS2V5OlwiXCJ9KX0pO3ZhciBVbCxSbCxacyxRcyxYcz1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtVbD0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWQgcmVxdWlyZXMgMyBvciA0IGlucHV0cy5cIik7bGV0IG49eC5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLGVbMF0uZGltcy5sZW5ndGgpLHI9dC5ibG9ja1NpemUsbz1lWzBdLGk9ZVsyXSxzPWUubGVuZ3RoPT09ND9lWzNdOnZvaWQgMDtpZihpLmRpbXMubGVuZ3RoIT09by5kaW1zLmxlbmd0aHx8IW8uZGltcy5tYXAoKGEsdSk9PnU9PT1uP01hdGguY2VpbChhL3IpPT09aS5kaW1zW3VdOmE9PT1pLmRpbXNbdV0pLnJlZHVjZSgoYSx1KT0+YSYmdSwhMCkpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gZ2F0aGVyQXhpcy5cIik7aWYocyl7aWYocy5kYXRhVHlwZSE9PW8uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKHMuZGltcy5sZW5ndGghPT1pLmRpbXMubGVuZ3RofHwhcy5kaW1zLm1hcCgoYSx1KT0+YT09PWkuZGltc1t1XSkucmVkdWNlKChhLHUpPT5hJiZ1LCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gcXVhbnRpemVBeGlzLlwiKX19LFJsPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9ZVsxXS5kaW1zLG89bi5sZW5ndGgsaT14Lm5vcm1hbGl6ZUF4aXModC5nYXRoZXJBeGlzLG8pLHM9eC5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLG8pLGE9bi5zbGljZSgwKTthLnNwbGljZShpLDEsLi4ucik7bGV0IHU9eC5zaXplKGEpLGQ9ZVsyXS5kYXRhVHlwZSxjPWVbMF0uZGF0YVR5cGU9PT0yMixwPVt7dHlwZToxMixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5QKC4uLmUubWFwKChtLGgpPT5tLmRpbXMpLGEpXSxmPW09PntsZXQgaD1TKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksYj1TKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSx5PVMoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLGc9ZS5sZW5ndGg+Mz9TKFwiemVyb1BvaW50XCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDAsXz1DKFwib3V0cHV0XCIsZCxhLmxlbmd0aCksdz1baCxiLHldO2cmJncucHVzaChnKTtsZXQgdj1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJxdWFudGl6ZV9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImdhdGhlcl9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAgICR7bS5yZWdpc3RlclVuaWZvcm1zKHYpLmRlY2xhcmVWYXJpYWJsZXMoLi4udyxfKX1cbiAgICAgICAgJHttLm1haW5TdGFydCgpfVxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbmRpY2VzX2luZGljZXMgPSAke2IudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgJHtyLmxlbmd0aD4xP2BcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtfLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyBpXCIpfTtcbiAgICAgICAgICAgICR7Yi5pbmRpY2VzU2V0KFwiaW5kaWNlc19pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgfWA6YGluZGljZXNfaW5kaWNlcyA9ICR7Xy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIpfTtgfTtcbiAgICAgICAgdmFyIGRhdGFfaW5kaWNlcyA9ICR7aC50eXBlLmluZGljZXN9KDApO1xuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZ2F0aGVyX2F4aXM7IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Xy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICR7aC5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4X2Zyb21faW5kaWNlcyA9ICR7Yi5nZXRCeUluZGljZXMoXCJpbmRpY2VzX2luZGljZXNcIil9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke25baV19O1xuICAgICAgICB9XG4gICAgICAgICR7aC5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiLFwidTMyKGluZGV4X2Zyb21faW5kaWNlcylcIil9O1xuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHthLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Xy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixgaSArICR7ci5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2guaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhX29mZnNldCA9ICR7aC5pbmRpY2VzVG9PZmZzZXQoXCJkYXRhX2luZGljZXNcIil9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtoLmdldEJ5T2Zmc2V0KFwiZGF0YV9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgbGV0IHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhID0gKHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID4+ICg0ICogKGRhdGFfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhX3ZlYyA9ICR7Yz9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YSA9IHF1YW50aXplZF9kYXRhX3ZlY1tkYXRhX2luZGV4IC8gMl07XG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7eS5pbmRpY2VzR2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICR7eS5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiLFwicXVhbnRpemVfYXhpc19pbmRleFwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7eS5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgJHtnP2BcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kaWNlcyA9IHNjYWxlX2luZGljZXM7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7Zy5pbmRpY2VzVG9PZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGljZXNcIil9O1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID0gJHtnLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtjP1widW5wYWNrNHhJOFwiOlwidW5wYWNrNHhVOFwifSh1MzIocGFja2VkXzhiaXRfemVyb19wb2ludHMpKTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4IC8gMl07YDpcInZhciB6ZXJvX3BvaW50ID0gMFwifTtcbiAgICAgICAgbGV0IGRlcXVhbnRpemVkX2RhdGEgPSAke2NlKGQpfShxdWFudGl6ZWRfZGF0YSAtIHplcm9fcG9pbnQpICogc2NhbGU7XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRlcXVhbnRpemVkX2RhdGFcIil9O1xuICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlckJsb2NrUXVhbnRpemVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtlLmZpbHRlcigobSxoKT0+aCE9PTEpLm1hcChtPT5tLmRpbXMuam9pbihcIl9cIikpLmpvaW4oXCI7XCIpfWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkuZnJvbSh7bGVuZ3RoOmUubGVuZ3RofSwobSxoKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTpmfX0sWnM9KGUsdCk9PntsZXQgbj1lLmlucHV0cztVbChuLHQpLGUuY29tcHV0ZShSbChlLmlucHV0cyx0KSl9LFFzPWU9Pk4oe2Jsb2NrU2l6ZTplLmJsb2NrU2l6ZSxnYXRoZXJBeGlzOmUuZ2F0aGVyQXhpcyxxdWFudGl6ZUF4aXM6ZS5xdWFudGl6ZUF4aXN9KX0pO3ZhciBWbCxObCxZcyxKcyxlYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtWbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxObD0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMF0uZGF0YVR5cGUsbz1uLmxlbmd0aCxpPWVbMV0uZGltcyxzPWVbMV0uZGF0YVR5cGUsYT14Lm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLHU9blthXSxkPWkuc2xpY2UoMCksbD14LnNpemUoZCksYz1TKFwiaW5wdXRcIixyLG8pLHA9UyhcImluZGljZXNJbnB1dFwiLHMsaS5sZW5ndGgpLGY9QyhcIm91dHB1dFwiLHIsZC5sZW5ndGgpLG09W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6NixkYXRhOnV9LHt0eXBlOjEyLGRhdGE6YX1dO3JldHVybiBtLnB1c2goLi4uUChuLGksZCkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eT0+YFxuICAgICAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhjLHAsZil9XG4gICAgICAke3kubWFpblN0YXJ0KCl9XG4gICAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtmLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtwLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtjLnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke2MuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHtjLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7Zi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxZcz1lPT5OKHtheGlzOmUuYXhpc30pLEpzPShlLHQpPT57bGV0IG49ZS5pbnB1dHM7VmwobiksZS5jb21wdXRlKE5sKGUuaW5wdXRzLHQpKX19KTt2YXIgTGwsV2wsdGEsbmEscmE9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO0xsPWU9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IG51bWJlci5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzJdLmRpbXMubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT1lWzFdLmRhdGFUeXBlfHxlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfSxXbD0oZSx0KT0+e2xldCBuPWVbMF0uZGltcy5zbGljZSgpLHI9ZVsxXS5kaW1zLnNsaWNlKCksW28saSxzXT1HdC5nZXRTaGFwZU9mR2VtbVJlc3VsdChuLHQudHJhbnNBLHIsdC50cmFuc0IsZS5sZW5ndGg9PT0zP2VbMl0uZGltczp2b2lkIDApLGE9W28saV07aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IHU9MTYsZD1NYXRoLmNlaWwoaS91KSxsPU1hdGguY2VpbChvL3UpLGM9ITAscD14LnNpemUoYSksZj1be3R5cGU6MTIsZGF0YTpjP2Q6cH0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MSxkYXRhOnQuYWxwaGF9LHt0eXBlOjEsZGF0YTp0LmJldGF9XSxtPVtcInR5cGVcIixcInR5cGVcIl07ZS5sZW5ndGg9PT0zJiYoZi5wdXNoKC4uLlAoZVsyXS5kaW1zKSksbS5wdXNoKFwicmFua1wiKSksZi5wdXNoKC4uLlAoYSkpO2xldCBoPXk9PntsZXQgZz1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj9nPVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/Zz1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP2c9XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJihnPVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiKTtsZXQgXz10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCIsdz1TKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSx2PVMoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLCQ9dy50eXBlLnZhbHVlLFQ9bnVsbCxJPVt3LHZdO2UubGVuZ3RoPT09MyYmKFQ9UyhcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEkucHVzaChUKSk7bGV0IEE9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgpO0kucHVzaChBKTtsZXQgej1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke3kucmVnaXN0ZXJVbmlmb3Jtcyh6KS5kZWNsYXJlVmFyaWFibGVzKC4uLkkpfVxuXG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xuXG4gICAgdmFyIHZhbHVlID0gJHskfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgJHtnfVxuICAgIH1cblxuICAgICR7X31cbiAgICAke1QhPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtULmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLEEpfTsgdmFsdWUgKz0gJHskfSh1bmlmb3Jtcy5iZXRhKSAqICR7VC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIn1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWB9LGI9eT0+e2xldCBnPVMoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLF89UyhcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksdz1udWxsLHY9W2csX107ZS5sZW5ndGg9PT0zJiYodz1TKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksdi5wdXNoKHcpKTtsZXQgJD1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCk7di5wdXNoKCQpO2xldCBUPVt7bmFtZTpcIm51bV90aWxlX25cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dLEk9XCJcIixBPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCPyhBPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2cudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtfLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxJPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTp0LnRyYW5zQSYmIXQudHJhbnNCPyhBPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2cudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtfLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxJPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTohdC50cmFuc0EmJnQudHJhbnNCPyhBPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2cudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtfLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxJPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTohdC50cmFuc0EmJiF0LnRyYW5zQiYmKEE9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Zy50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke18udHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEk9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpO2xldCB6PXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIjtyZXR1cm5gXG4gICR7eS5yZWdpc3RlclVuaWZvcm1zKFQpLmRlY2xhcmVWYXJpYWJsZXMoLi4udil9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHtnLnR5cGUuc3RvcmFnZX0sICR7dX0+LCAke3V9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZV9iOiBhcnJheTxhcnJheTwke18udHlwZS5zdG9yYWdlfSwgJHt1fT4sICR7dX0+O1xuICAke3kubWFpblN0YXJ0KFt1LHUsMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7dX07XG4gICAgbGV0IHRpbGVfcm93X3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLm51bV90aWxlX24pICogJHt1fTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7dX0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHskLnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7QX1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHt1fTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke3V9OyBrKyspIHtcbiAgICAgICAgJHtJfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgICR7en1cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAke3chPW51bGw/YGxldCBjT2Zmc2V0ID0gJHt3LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLCQpfTsgdmFsdWUgKz0gJHskLnR5cGUudmFsdWV9KHVuaWZvcm1zLmJldGEpICogJHt3LmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07YDpcIlwifVxuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgb3V0cHV0W20gKiB1bmlmb3Jtcy5OICsgbl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1gfTtyZXR1cm4gYz97bmFtZTpcIkdlbW1TaGFyZWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6bX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OmQqbH0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6Yn06e25hbWU6XCJHZW1tXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOm19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOmh9fSx0YT1lPT57bGV0IHQ9ZS50cmFuc0Esbj1lLnRyYW5zQixyPWUuYWxwaGEsbz1lLmJldGE7cmV0dXJue3RyYW5zQTp0LHRyYW5zQjpuLGFscGhhOnIsYmV0YTpvLGNhY2hlS2V5OmAke2UudHJhbnNBfTske2UudHJhbnNCfTske2UuYWxwaGE9PT0xfWB9fSxuYT0oZSx0KT0+e0xsKGUuaW5wdXRzKSxlLmNvbXB1dGUoV2woZS5pbnB1dHMsdCkpfX0pO3ZhciBOZSxLZSxpdCxzdCxHbCxIbCxxbCxGbCxLbCxqbCxabCxRbCxvYSxpYSxzYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtbTmUsS2UsaXQsc3RdPVswLDEsMiwzXSxHbD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwib25seSA0LUQgdGVuc29yIGlzIHN1cHBvcnRlZC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIHRvIGdyaWQgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoLTIhPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0xXSl0aHJvdyBuZXcgRXJyb3IoYGxhc3QgZGltZW5zaW9uIG9mIGdyaWQgbXVzdCBiZSBlcXVhbCB0byAke2VbMF0uZGltcy5sZW5ndGgtMn1gKTtpZihlWzBdLmRpbXNbMF0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwiZ3JpZCBiYXRjaCBzaXplIG11c3QgbWF0Y2ggaW5wdXQgYmF0Y2ggc2l6ZVwiKX0sSGw9YFxuICBmbiBnc19nZXRfY3ViaWNfY29lZmZzKHg6IGYzMikgLT4gdmVjNDxmMzI+IHtcbiAgICBsZXQgY3ViaWNfYWxwaGEgPSAtMC43NWY7XG4gICAgbGV0IHhfYWJzID0gYWJzKHgpO1xuICAgIHZhciBjb2VmZnM6IHZlYzQ8ZjMyPjtcbiAgICBjb2VmZnNbMF0gPSAoKChjdWJpY19hbHBoYSAqICh4X2FicyArIDEpIC0gNSAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpICsgOCAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICBjb2VmZnNbMV0gPSAoKChjdWJpY19hbHBoYSArIDIpICogeF9hYnMgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiB4X2FicyAqIHhfYWJzICsgMSk7XG4gICAgY29lZmZzWzJdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqICgxIC0geF9hYnMpIC0gKGN1YmljX2FscGhhICsgMykpICogKDEgLSB4X2FicykgKiAoMSAtIHhfYWJzKSArIDEpO1xuICAgIGNvZWZmc1szXSA9ICgoKGN1YmljX2FscGhhICogKDIgLSB4X2FicykgLSA1ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgKyA4ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cbmAscWw9ZT0+YFxuICBmbiBnc19iaWN1YmljX2ludGVycG9sYXRlKHA6IG1hdDR4NDwke2V9PiwgeDogZjMyLCB5OiBmMzIpIC0+ICR7ZX0ge1xuICAgIHZhciB2OiB2ZWM0PGYzMj47XG4gICAgdmFyIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZbaV0gPSBjb2VmZnNbMF0gKiBwW2ldWzBdICsgY29lZmZzWzFdICogcFtpXVsxXSArIGNvZWZmc1syXSAqIHBbaV1bMl0gKyBjb2VmZnNbM10gKiBwW2ldWzNdO1xuICAgIH1cbiAgICBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHkpO1xuICAgIGxldCBwaXhlbCA9ICR7ZX0oY29lZmZzWzBdICogdlswXSArIGNvZWZmc1sxXSAqIHZbMV0gKyBjb2VmZnNbMl0gKiB2WzJdICsgY29lZmZzWzNdICogdlszXSk7XG4gICAgcmV0dXJuIHBpeGVsO1xuICB9XG5gLEZsPWU9PmBcbiAgZm4gZ3NfZGVub3JtYWxpemUobjogZjMyLCBsZW5ndGg6IGkzMikgLT4gZjMyIHtcbiAgICAke2UuYWxpZ25Db3JuZXJzPT09MD9gXG4gICAgLy8gYWxpZ25Db3JuZXJzOiBmYWxzZSA9PiBbLTEsIDFdIHRvIFstMC41LCBsZW5ndGggLSAwLjVdXG4gICAgcmV0dXJuICgobiArIDEuMCkgKiBmMzIobGVuZ3RoKSAtIDEuMCkgLyAyLjA7XG4gICAgYDpgXG4gICAgLy8gYWxpZ25Db3JuZXJzOiB0cnVlID0+IFstMSwgMV0gdG8gWzAsIGxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIChuICsgMS4wKSAvIDIuMCAqIChmMzIobGVuZ3RoIC0gMSkpO1xuICAgIGB9XG4gIH1cbmAsS2w9ZT0+YFxuICAke2UucGFkZGluZ01vZGU9PT1cInJlZmxlY3Rpb25cIj9gXG4gICAgICBmbiBnc19yZWZsZWN0KHg6IGkzMiwgeF9taW46IGYzMiwgeF9tYXg6IGYzMikgLT4gdTMyIHtcbiAgICAgICAgdmFyIGR4ID0gMC4wO1xuICAgICAgICB2YXIgZnggPSBmMzIoeCk7XG4gICAgICAgIGxldCByYW5nZSA9IHhfbWF4IC0geF9taW47XG4gICAgICAgIGlmIChmeCA8IHhfbWluKSB7XG4gICAgICAgICAgZHggPSB4X21pbiAtIGZ4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmeCA+IHhfbWF4KSB7XG4gICAgICAgICAgZHggPSBmeCAtIHhfbWF4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdTMyKGZ4KTtcbiAgICAgIH1gOlwiXCJ9XG5gLGpsPShlLHQsbik9PmBcbiAgZm4gcGl4ZWxfYXRfZ3JpZChyOiBpMzIsIGM6IGkzMiwgSDogaTMyLCBXOiBpMzIsIGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgYm9yZGVyOiB2ZWM0PGYzMj4pIC0+ICR7dH0ge1xuICAgICB2YXIgcGl4ZWwgPSAke3R9KDApO1xuICAgICB2YXIgaW5kaWNlcyA9IHZlYzQ8dTMyPigwKTtcbiAgICAgaW5kaWNlc1ske05lfV0gPSBiYXRjaDtcbiAgICAgaW5kaWNlc1ske0tlfV0gPSBjaGFubmVsO2ArKCgpPT57c3dpdGNoKG4ucGFkZGluZ01vZGUpe2Nhc2VcInplcm9zXCI6cmV0dXJuYFxuICAgICAgICAgIGlmIChyID49IDAgJiYgciA8IEggJiYgYyA+PTAgJiYgYyA8IFcpIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtpdH1dID0gdTMyKHIpO1xuICAgICAgICAgICAgaW5kaWNlc1ske3N0fV0gPSB1MzIoYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAke3R9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJib3JkZXJcIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske2l0fV0gPSB1MzIoY2xhbXAociwgMCwgSCAtIDEpKTtcbiAgICAgICAgICBpbmRpY2VzWyR7c3R9XSA9IHUzMihjbGFtcChjLCAwLCBXIC0gMSkpO1xuICAgICAgICBgO2Nhc2VcInJlZmxlY3Rpb25cIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske2l0fV0gPSBnc19yZWZsZWN0KHIsIGJvcmRlclsxXSwgYm9yZGVyWzNdKTtcbiAgICAgICAgICBpbmRpY2VzWyR7c3R9XSA9IGdzX3JlZmxlY3QoYywgYm9yZGVyWzBdLCBib3JkZXJbMl0pO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nIG1vZGUgJHtuLnBhZGRpbmdNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgXG4gICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpfTtcbiAgfVxuYCxabD0oZSx0LG4pPT4oKCk9Pntzd2l0Y2gobi5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgIGxldCByZXN1bHQgPSBwaXhlbF9hdF9ncmlkKGkzMihyb3VuZCh5KSksIGkzMihyb3VuZCh4KSksIEhfaW4sIFdfaW4sIGluZGljZXNbJHtOZX1dLCBpbmRpY2VzWyR7S2V9XSwgYm9yZGVyKTtcbiAgICAgICAgYDtjYXNlXCJiaWxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICBsZXQgeDEgPSBpMzIoZmxvb3IoeCkpO1xuICAgICAgICAgIGxldCB5MSA9IGkzMihmbG9vcih5KSk7XG4gICAgICAgICAgbGV0IHgyID0geDEgKyAxO1xuICAgICAgICAgIGxldCB5MiA9IHkxICsgMTtcblxuICAgICAgICAgIGxldCBwMTEgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske05lfV0sIGluZGljZXNbJHtLZX1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMTIgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske05lfV0sIGluZGljZXNbJHtLZX1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjEgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske05lfV0sIGluZGljZXNbJHtLZX1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjIgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske05lfV0sIGluZGljZXNbJHtLZX1dLCBib3JkZXIpO1xuXG4gICAgICAgICAgbGV0IGR4MiA9ICR7dH0oZjMyKHgyKSAtIHgpO1xuICAgICAgICAgIGxldCBkeDEgPSAke3R9KHggLSBmMzIoeDEpKTtcbiAgICAgICAgICBsZXQgZHkyID0gJHt0fShmMzIoeTIpIC0geSk7XG4gICAgICAgICAgbGV0IGR5MSA9ICR7dH0oeSAtIGYzMih5MSkpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBkeTIgKiAoZHgyICogcDExICsgZHgxICogcDEyKSArIGR5MSAqIChkeDIgKiBwMjEgKyBkeDEgKiBwMjIpO1xuICAgICAgICBgO2Nhc2VcImJpY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgwID0gaTMyKGZsb29yKHgpKSAtIDE7XG4gICAgICAgICAgbGV0IHkwID0gaTMyKGZsb29yKHkpKSAtIDE7XG4gICAgICAgICAgdmFyIHA6IG1hdDR4NDwke3R9PjtcbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IDQ7IGgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCA0OyB3KyspIHtcbiAgICAgICAgICAgICAgcFtoXVt3XSA9IHBpeGVsX2F0X2dyaWQoaCArIHkwLCB3ICsgeDAsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtOZX1dLCBpbmRpY2VzWyR7S2V9XSwgYm9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZHggPSB4IC0gZjMyKHgwICsgMSk7XG4gICAgICAgICAgbGV0IGR5ID0geSAtIGYzMih5MCArIDEpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBnc19iaWN1YmljX2ludGVycG9sYXRlKHAsIGR4LCBkeSk7XG4gICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG1vZGUgJHtuLm1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK2Ake2Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJyZXN1bHRcIil9YCxRbD0oZSx0KT0+e2xldCBuPVMoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxyPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV0sbz1TKFwiZ3JpZFwiLGVbMV0uZGF0YVR5cGUsci5sZW5ndGgsMiksaT1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdXTt0LmZvcm1hdD09PVwiTkhXQ1wiJiYoaT1bZVswXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl0sZVswXS5kaW1zWzNdXSxbTmUsS2UsaXQsc3RdPVswLDMsMSwyXSk7bGV0IHM9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsaS5sZW5ndGgpLGE9bi50eXBlLnZhbHVlLHU9eC5zaXplKGkpLGQ9W3t0eXBlOjEyLGRhdGE6dX0sLi4uUChlWzBdLmRpbXMscixpKV0sbD1jPT5gXG4gICR7Yy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobixvLHMpfVxuICAke0hsfVxuICAke3FsKGEpfVxuICAke0ZsKHQpfVxuICAke0tsKHQpfVxuICAke2psKG4sYSx0KX1cblxuICAke2MubWFpblN0YXJ0KCl9XG4gICAgJHtjLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBIX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtpdH1dKTtcbiAgICAgIGxldCBXX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtzdH1dKTtcblxuICAgICAgJHt0LmFsaWduQ29ybmVycz09PTA/YFxuICAgICAgbGV0IHhfbWluID0gLTAuNTtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDAuNTtcbiAgICAgIGxldCB5X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAwLjU7XG4gICAgICBgOmBcbiAgICAgIGxldCB4X21pbiA9IDAuMDtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDEuMDtcbiAgICAgIGxldCB5X21pbiA9IDAuMDtcbiAgICAgIGxldCB5X21heCA9IGYzMihIX2luKSAtIDEuMDtcbiAgICAgIGB9O1xuICAgICAgbGV0IGJvcmRlciA9IHZlYzQ8ZjMyPih4X21pbiwgeV9taW4sIHhfbWF4LCB5X21heCk7XG5cbiAgICAgIGxldCBpbmRpY2VzID0gJHtzLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGdyaWRfaW5kaWNlcyA9IHZlYzM8dTMyPihpbmRpY2VzWyR7TmV9XSwgaW5kaWNlc1ske2l0fV0sIGluZGljZXNbJHtzdH1dKTtcbiAgICAgIGxldCBueHkgPSAke28uZ2V0QnlJbmRpY2VzKFwiZ3JpZF9pbmRpY2VzXCIpfTtcbiAgICAgIHZhciB4ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVswXSksIFdfaW4pO1xuICAgICAgdmFyIHkgPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzFdKSwgSF9pbik7XG5cbiAgICAgICR7WmwocyxhLHQpfVxuICB9YDtyZXR1cm57bmFtZTpcIkdyaWRTYW1wbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTpjPT57bGV0IHA9eC5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmNbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9fSxnZXRTaGFkZXJTb3VyY2U6bH19LG9hPShlLHQpPT57R2woZS5pbnB1dHMpLGUuY29tcHV0ZShRbChlLmlucHV0cyx0KSl9LGlhPWU9Pk4oe2FsaWduQ29ybmVyczplLmFsaWduX2Nvcm5lcnMsbW9kZTplLm1vZGUscGFkZGluZ01vZGU6ZS5wYWRkaW5nX21vZGUsZm9ybWF0OmUuZm9ybWF0fSl9KTt2YXIgZ2UsSmwsdWEsYWEsZWMsX3QsZGEsc3I9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtadCgpO2VuKCk7SygpO1ZlKCk7Z2U9KGUsdCk9PmUubGVuZ3RoPnQmJmVbdF0uZGltcy5sZW5ndGg+MD9lW3RdOnZvaWQgMCxKbD0oZSx0KT0+e2xldCBuPWVbMF0scj1nZShlLDEpLG89Z2UoZSwyKSxpPWdlKGUsMykscz1nZShlLDQpLGE9Z2UoZSw1KSx1PWdlKGUsNiksZD1nZShlLDcpO2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBsPW4uZGltc1swXSxjPW4uZGltc1sxXSxwPW4uZGltcy5sZW5ndGg9PT0zP24uZGltc1syXTp0Lm51bUhlYWRzKm4uZGltc1s0XSxmPWMsbT0wLGg9MCxiPU1hdGguZmxvb3IocC90Lm51bUhlYWRzKTtpZih1JiZkJiZ4LnNpemUodS5kaW1zKSYmeC5zaXplKGQuZGltcykpe2lmKHUuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYodS5kaW1zWzBdIT09bHx8dS5kaW1zWzFdIT09dC5udW1IZWFkc3x8dS5kaW1zWzNdIT09Yil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO2lmKGQuZGltc1swXSE9PWx8fGQuZGltc1sxXSE9PXQubnVtSGVhZHN8fGQuZGltc1szXSE9PWIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO2lmKHUuZGltc1syXSE9PWQuZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChwYXN0X3NlcXVlbmNlX2xlbmd0aCknKTtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7bT11LmRpbXNbMl0saD11LmRpbXNbMl19ZWxzZSBpZih1JiZ4LnNpemUodS5kaW1zKXx8ZCYmeC5zaXplKGQuZGltcykpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO2xldCB5O2lmKHImJnguc2l6ZShyLmRpbXMpPjApe2lmKG4uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYoci5kaW1zLmxlbmd0aDwzfHxyLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09ci5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihyLmRpbXMubGVuZ3RoPT09Myl7aWYoci5kaW1zWzJdIT09bi5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAoaGlkZGVuX3NpemUpJyk7eT0yLGY9ci5kaW1zWzFdfWVsc2UgaWYoci5kaW1zLmxlbmd0aD09PTUpe2lmKHIuZGltc1syXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PTJ8fHIuZGltc1s0XSE9PWIpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO3k9NSxmPXIuZGltc1sxXX1lbHNle2lmKHIuZGltc1sxXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PWIpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7eT0wLGY9ci5kaW1zWzJdfX1lbHNle2lmKG4uZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTt5PTN9aWYoaSYmeC5zaXplKGkuZGltcyk+MCl7aWYoaS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uJyk7aWYociYmci5kaW1zLmxlbmd0aD09PTUmJnIuZGltc1szXT09PTIpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LlwiKX1sZXQgZz1tK2YsXz0wO2lmKHMmJnguc2l6ZShzLmRpbXMpPjApe189ODtsZXQgVD1zLmRpbXM7dGhyb3cgVC5sZW5ndGg9PT0xP1RbMF09PT1sP189MTpUWzBdPT09MypsKzImJihfPTMpOlQubGVuZ3RoPT09MiYmVFswXT09PWwmJlRbMV09PT1nJiYoXz01KSxfPT09OD9uZXcgRXJyb3IoJ0lucHV0IFwia2V5X3BhZGRpbmdfbWFza1wiIHNoYXBlIHNoYWxsIGJlIChiYXRjaF9zaXplKSBvciAoYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpOm5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKX1sZXQgdz0hMSx2PXA7aWYobyYmeC5zaXplKG8uZGltcyk+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKGYhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO3Y9by5kaW1zWzJdfWVsc2V7aWYoZiE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7dj1vLmRpbXNbMV0qby5kaW1zWzNdLHc9ITB9fWxldCAkPSExO2lmKHMmJnguc2l6ZShzLmRpbXMpPjApdGhyb3cgbmV3IEVycm9yKFwiS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGEmJnguc2l6ZShhLmRpbXMpPjApe2lmKGEuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoYS5kaW1zWzBdIT09bHx8YS5kaW1zWzFdIT09dC5udW1IZWFkc3x8YS5kaW1zWzJdIT09Y3x8YS5kaW1zWzNdIT09Zyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOmMscGFzdFNlcXVlbmNlTGVuZ3RoOm0sa3ZTZXF1ZW5jZUxlbmd0aDpmLHRvdGFsU2VxdWVuY2VMZW5ndGg6ZyxtYXhTZXF1ZW5jZUxlbmd0aDpoLGlucHV0SGlkZGVuU2l6ZTowLGhpZGRlblNpemU6cCx2SGlkZGVuU2l6ZTp2LGhlYWRTaXplOmIsdkhlYWRTaXplOk1hdGguZmxvb3Iodi90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6XyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6JCxwYXNzUGFzdEluS3Y6dyxxa3ZGb3JtYXQ6eX19LHVhPWU9Pk4oey4uLmV9KSxhYT1OKHtwZXJtOlswLDIsMSwzXX0pLGVjPShlLHQsbixyLG8saSxzKT0+e2xldCBhPVtyLG8saV0sdT14LnNpemUoYSksZD1be3R5cGU6MTIsZGF0YTp1fSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6aX1dLGw9Yz0+e2xldCBwPUMoXCJxa3Zfd2l0aF9iaWFzXCIsdC5kYXRhVHlwZSxhKSxmPVMoXCJxa3ZcIix0LmRhdGFUeXBlLGEpLG09UyhcImJpYXNcIixuLmRhdGFUeXBlLGEpLGg9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmlhc19vZmZzZXRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7Yy5yZWdpc3RlclVuaWZvcm1zKGgpLmRlY2xhcmVWYXJpYWJsZXMoZixtLHApfVxuICAke2MubWFpblN0YXJ0KCl9XG4gICAgJHtjLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmlhc19vZmZzZXRfaWR4ID0gKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgKyB1bmlmb3Jtcy5iaWFzX29mZnNldDtcblxuICAgIHFrdl93aXRoX2JpYXNbZ2xvYmFsX2lkeF0gPSBxa3ZbZ2xvYmFsX2lkeF0gKyBiaWFzW2JpYXNfb2Zmc2V0X2lkeF07XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiTXVsdGlIZWFkQXR0ZW50aW9uQWRkQmlhc1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodS82NCl9LHByb2dyYW1Vbmlmb3JtczpkfSksZ2V0U2hhZGVyU291cmNlOmx9LHtpbnB1dHM6W3Qsbl0sb3V0cHV0czpbLTFdfSlbMF19LF90PShlLHQsbixyLG8saSxzLGEpPT57bGV0IHU9aTtpZihzJiZ4LnNpemUocy5kaW1zKT4wKXtpZihyPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1ZcIik7cmV0dXJuIHU9ZWMoZSxpLHMsdCxyLG4qbyxhKSx1PXUucmVzaGFwZShbdCxyLG4sb10pLG49PT0xfHxyPT09MT91OmUuY29tcHV0ZShwZSh1LGFhLnBlcm0pLHtpbnB1dHM6W3VdLG91dHB1dHM6Wy0xXX0pWzBdfWVsc2UgcmV0dXJuIGkuZGltcy5sZW5ndGg9PT0zJiYodT1pLnJlc2hhcGUoW3QscixuLG9dKSksbj09PTF8fHI9PT0xP3U6ZS5jb21wdXRlKHBlKHUsYWEucGVybSkse2lucHV0czpbdV0sb3V0cHV0czpbLTFdfSlbMF19LGRhPShlLHQpPT57bGV0IG49SmwoZS5pbnB1dHMsdCkscj1lLmlucHV0c1swXSxvPWdlKGUuaW5wdXRzLDEpLGk9Z2UoZS5pbnB1dHMsMikscz1nZShlLmlucHV0cywzKSxhPWdlKGUuaW5wdXRzLDQpLHU9Z2UoZS5pbnB1dHMsNSksZD1nZShlLmlucHV0cyw2KSxsPWdlKGUuaW5wdXRzLDcpO2lmKHIuZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKG8/LmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2xldCBjPW8mJmkmJm8uZGltcy5sZW5ndGg9PT00JiZpLmRpbXMubGVuZ3RoPT09NCxwPV90KGUsbi5iYXRjaFNpemUsbi5udW1IZWFkcyxuLnNlcXVlbmNlTGVuZ3RoLG4uaGVhZFNpemUscixzLDApO2lmKGMpcmV0dXJuIG90KGUscCxvLGksYSx2b2lkIDAsZCxsLHUsbik7aWYoIW98fCFpKXRocm93IG5ldyBFcnJvcihcImtleSBhbmQgdmFsdWUgbXVzdCBiZSBwcm92aWRlZFwiKTtsZXQgZj1fdChlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5rdlNlcXVlbmNlTGVuZ3RoLG4uaGVhZFNpemUsbyxzLG4uaGlkZGVuU2l6ZSksbT1fdChlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5rdlNlcXVlbmNlTGVuZ3RoLG4udkhlYWRTaXplLGkscywyKm4uaGlkZGVuU2l6ZSk7b3QoZSxwLGYsbSxhLHZvaWQgMCxkLGwsdSxuKX19KTt2YXIgdGMsbmMscmMsb2MsYXIsbGEsY2EsdXI9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7dGM9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSxuYz0oZSx0KT0+e2xldCBuPVtdLHI9dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobz0+bi5wdXNoKE51bWJlcihvKSkpLHI9bi5sZW5ndGgpLE4oe251bU91dHB1dHM6cixheGlzOnQuYXhpcyxzcGxpdFNpemVzOm59KX0scmM9ZT0+YFxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8ICR7TyhcInVuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpc1wiLFwiaVwiLGUpfSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbn1gLG9jPWU9PntsZXQgdD1lLmxlbmd0aCxuPVtdO2ZvcihsZXQgcj0wO3I8dDsrK3Ipe2xldCBvPWVbcl0uc2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiLFwiaW5wdXRbZ2xvYmFsX2lkeF1cIik7dD09PTE/bi5wdXNoKG8pOnI9PT0wP24ucHVzaChgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtyfXUpIHsgJHtvfSB9YCk6cj09PXQtMT9uLnB1c2goYGVsc2UgeyAke299IH1gKTpuLnB1c2goYGVsc2UgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtyfSkgeyAke299IH1gKX1yZXR1cm5gXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke2VbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7bi5qb2luKGBcbmApfVxuICAgICAgfWB9LGFyPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9eC5zaXplKG4pLG89ZVswXS5kYXRhVHlwZSxpPXgubm9ybWFsaXplQXhpcyh0LmF4aXMsbi5sZW5ndGgpLHM9bmV3IEFycmF5KHQubnVtT3V0cHV0cyksYT1TKFwiaW5wdXRcIixvLG4ubGVuZ3RoKSx1PW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLGQ9W10sbD1bXSxjPTAscD1be3R5cGU6MTIsZGF0YTpyfV07Zm9yKGxldCBtPTA7bTx0Lm51bU91dHB1dHM7bSsrKXtjKz10LnNwbGl0U2l6ZXNbbV0sdVttXT1jO2xldCBoPW4uc2xpY2UoKTtoW2ldPXQuc3BsaXRTaXplc1ttXSxsLnB1c2goaCksc1ttXT1DKGBvdXRwdXQke219YCxvLGgubGVuZ3RoKSxkLnB1c2goe2RpbXM6bFttXSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSl9cC5wdXNoKHt0eXBlOjEyLGRhdGE6dX0sLi4uUChuLC4uLmwpKTtsZXQgZj1tPT5gXG4gICR7bS5yZWdpc3RlclVuaWZvcm0oXCJpbnB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJ1MzJcIix1Lmxlbmd0aCkuZGVjbGFyZVZhcmlhYmxlcyhhLC4uLnMpfVxuICAke3JjKHUubGVuZ3RoKX1cbiAgJHtvYyhzKX1cblxuICAke20ubWFpblN0YXJ0KCl9XG4gICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5pbnB1dF9zaXplXCIpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgdmFyIGluZGV4ID0gJHthLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsaSl9O1xuICAgIGxldCBvdXRwdXRfbnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXgpO1xuICAgIGlmIChvdXRwdXRfbnVtYmVyICE9IDApIHtcbiAgICAgIGluZGV4IC09ICR7TyhcInVuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpc1wiLFwib3V0cHV0X251bWJlciAtIDF1XCIsdS5sZW5ndGgpfTtcbiAgICAgICR7YS5pbmRpY2VzU2V0KFwiaW5kaWNlc1wiLGksXCJpbmRleFwiKX07XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyLCBpbmRpY2VzLCBnbG9iYWxfaWR4KTtcbiAgfWA7cmV0dXJue25hbWU6XCJTcGxpdFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmYsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOmQsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSl9fSxsYT0oZSx0KT0+e3RjKGUuaW5wdXRzKTtsZXQgbj1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6bmMoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKGFyKGUuaW5wdXRzLG4pLHtpbnB1dHM6WzBdfSl9LGNhPWU9PntsZXQgdD1lLmF4aXMsbj1lLnNwbGl0U2l6ZXMscj1lLm51bU91dHB1dHM8MD9uLmxlbmd0aDplLm51bU91dHB1dHM7aWYociE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm51bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ3RoIG11c3QgYmUgZXF1YWxcIik7cmV0dXJuIE4oe2F4aXM6dCxudW1PdXRwdXRzOnIsc3BsaXRTaXplczpufSl9fSk7dmFyIGljLGNuLHBhLGRyPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO2ljPShlLHQpPT57bGV0W24scixvLGldPWUse251bUhlYWRzOnMscm90YXJ5RW1iZWRkaW5nRGltOmF9PXQ7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke24uZGltcy5sZW5ndGh9YCk7aWYoIXguYXJlRXF1YWwoci5kaW1zLFtdKSYmIXguYXJlRXF1YWwoci5kaW1zLFsxXSkmJnIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke3IuZGltcy5sZW5ndGh9YCk7aWYoby5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7by5kaW1zLmxlbmd0aH1gKTtpZihpLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdzaW5fY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtpLmRpbXMubGVuZ3RofWApO2lmKCF4LmFyZUVxdWFsKG8uZGltcyxpLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIklucHV0cyAnY29zX2NhY2hlJyBhbmQgJ3Npbl9jYWNoZScgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7aWYoYT4wJiZzPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWRcIik7bGV0IHU9bi5kaW1zWzBdLGQ9bi5kaW1zW24uZGltcy5sZW5ndGgtMl0sbD1vLmRpbXNbMF0sYz14LnNpemVGcm9tRGltZW5zaW9uKG4uZGltcywxKS9kLHA9YT09PTA/by5kaW1zWzFdKjI6Yy9zO2lmKGE+cCl0aHJvdyBuZXcgRXJyb3IoXCJyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemVcIik7aWYoci5kaW1zLmxlbmd0aD09PTIpe2lmKHUhPT1yLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtyLmRpbXNbMF19YCk7aWYoZCE9PXIuZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7ci5kaW1zWzFdfWApfWlmKHAvMiE9PW8uZGltc1sxXSYmYS8yIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke28uZGltc1sxXX1gKTtpZihkPmwpdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpfSxjbj0oZSx0KT0+e2xldHtpbnRlcmxlYXZlZDpuLG51bUhlYWRzOnIscm90YXJ5RW1iZWRkaW5nRGltOm8sc2NhbGU6aX09dCxzPWVbMF0uZGltc1swXSxhPXguc2l6ZUZyb21EaW1lbnNpb24oZVswXS5kaW1zLDEpLHU9ZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMl0sZD1hL3UsbD1lWzJdLmRpbXNbMV0sYz1vPT09MD9sKjI6ZC9yLHA9bmV3IEFycmF5KHMsdSxkL2MsYy1sKSxmPXguY29tcHV0ZVN0cmlkZXMocCksbT1be3R5cGU6MSxkYXRhOml9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTpmfSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09Mz9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbYSxkLGMsMV19KTpbXSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09ND9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbYSxjLHUqYywxXX0pOltdLC4uLlAoZVswXS5kaW1zLGVbMV0uZGltcyxlWzJdLmRpbXMsZVszXS5kaW1zLGVbMF0uZGltcyldLGg9Yj0+e2xldCB5PVMoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksZz1TKFwicG9zaXRpb25faWRzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxfPVMoXCJjb3NfY2FjaGVcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLHc9UyhcInNpbl9jYWNoZVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCksdj1DKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKTtyZXR1cm4gYi5yZWdpc3RlclVuaWZvcm1zKFt7bmFtZTpcInNjYWxlXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImdsb2JhbF9zaGFwZVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6cC5sZW5ndGh9LHtuYW1lOlwiZ2xvYmFsX3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmYubGVuZ3RofSx7bmFtZTpcImlucHV0X291dHB1dF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpmLmxlbmd0aH1dKSxgXG4gICAgICAgICR7Yi5kZWNsYXJlVmFyaWFibGVzKHksZyxfLHcsdil9XG5cbiAgICAgICAgJHtiLm1haW5TdGFydChZZSl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke18ubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInNpemVcIil9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke2cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJic25oLnh5XCIsQyhcIlwiLGcudHlwZS50ZW5zb3IsMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7Zy5nZXRCeU9mZnNldChcInBvc2l0aW9uX2lkc19pZHhcIil9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7bn0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7bn0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHt5LmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke18uZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9IC1cbiAgICAgICAgICAgICAgICAke3kuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7dy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke3Yuc2V0QnlPZmZzZXQoXCJpXCIsXCJyZVwiKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7eS5nZXRCeU9mZnNldChcImlcIil9ICogJHt3LmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSArXG4gICAgICAgICAgICAgICAgJHt5LmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke18uZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHt2LnNldEJ5T2Zmc2V0KFwialwiLFwiaW1cIil9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XG4gICAgICAgICAgICAke3Yuc2V0QnlPZmZzZXQoXCJrXCIseS5nZXRCeU9mZnNldChcImtcIikpfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiUm90YXJ5RW1iZWRkaW5nXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6Tih7aW50ZXJsZWF2ZWQ6bn0pLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpoLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh4LnNpemUocCkvWWUpfSxwcm9ncmFtVW5pZm9ybXM6bX0pfX0scGE9KGUsdCk9PntpYyhlLmlucHV0cyx0KSxlLmNvbXB1dGUoY24oZS5pbnB1dHMsdCkpfX0pO3ZhciBzYyxhYyxtYSx1YyxmYSxoYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aWUoKTtWKCk7ZW4oKTtzcigpO3VyKCk7VmUoKTtkcigpO0soKTtzYz0oZSx0KT0+e2lmKHQuZG9Sb3RhcnkmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZFwiKTtsZXQgbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1lWzNdLHM9ZVs0XTtpZih0LmRvUm90YXJ5IT09MCYmZS5sZW5ndGg8PTcpdGhyb3cgbmV3IEVycm9yKFwiY29zX2Nhc3QgYW5kIHNpbl9jYWNoZSBhcmUgZXhwZWN0ZWQgaWYgZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub24temVyb1wiKTtpZih0LmxvY2FsV2luZG93U2l6ZSE9PS0xKXRocm93IG5ldyBFcnJvcihcIkxvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc29mdGNhcCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wKXRocm93IG5ldyBFcnJvcihcIlJvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc21vb3RoU29mdG1heCl0aHJvdyBuZXcgRXJyb3IoXCJTbW9vdGggc29mdG1heCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBhPSExLHU9bi5kaW1zWzBdLGQ9bi5kaW1zWzFdLGw9bi5kaW1zLmxlbmd0aD09PTM/YT9uLmRpbXNbMl0vMzpuLmRpbXNbMl06dC5udW1IZWFkcypuLmRpbXNbNF0sYz1kLHA9MCxmPSFyfHxyLmRpbXMubGVuZ3RoPT09MCxtPU1hdGguZmxvb3IoZj9sLyh0Lm51bUhlYWRzKzIqdC5rdk51bUhlYWRzKTpsL3QubnVtSGVhZHMpO2YmJihsPW0qdC5udW1IZWFkcyk7bGV0IGg9aSYmaS5kaW1zLmxlbmd0aCE9PTAsYj1zJiZzLmRpbXMubGVuZ3RoIT09MDtpZihoJiZpLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zWzBdPT09dSYmaS5kaW1zWzFdIT09dC5rdk51bUhlYWRzJiZpLmRpbXNbMl09PT10Lmt2TnVtSGVhZHMmJmkuZGltc1szXT09PW0pdGhyb3cgbmV3IEVycm9yKFwiQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGgmJmIpe2lmKGkuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYocy5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO3A9aS5kaW1zWzJdfWVsc2UgaWYoaHx8Yil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0IGc9MTtpZihyJiZyLmRpbXMubGVuZ3RoPjApe2lmKG4uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYoci5kaW1zLmxlbmd0aDwzfHxyLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09ci5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihyLmRpbXMubGVuZ3RoPT09Myl7aWYobi5kaW1zWzJdJXIuZGltc1syXSE9PTApdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO2M9ci5kaW1zWzFdfWVsc2UgaWYoci5kaW1zLmxlbmd0aD09PTUpe2lmKHIuZGltc1syXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PTJ8fHIuZGltc1s0XSE9PW0pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO2M9ci5kaW1zWzFdfWVsc2V7aWYoci5kaW1zWzFdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09bSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtjPXIuZGltc1syXX19ZWxzZXtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKG4uZGltcy5sZW5ndGg9PT01JiYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7Zz0zfWxldCBfPTAsdz0hMSx2PXQua3ZOdW1IZWFkcz9tKnQua3ZOdW1IZWFkczpsO2lmKG8mJm8uZGltcy5sZW5ndGg+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKGMhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO3Y9by5kaW1zWzJdfWVsc2V7aWYoYyE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO3Y9by5kaW1zWzFdKm8uZGltc1szXSx3PSEwfX1sZXQgJD1lLmxlbmd0aD40P2VbNV06dm9pZCAwO2lmKCQmJiQuZGltcy5sZW5ndGghPT0xJiYkLmRpbXNbMF0hPT11KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJzZXFsZW5zXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbiBhbmQgdGhlIHNhbWUgZGltIDAgYXMgYmF0Y2hfc2l6ZScpO3JldHVybntiYXRjaFNpemU6dSxzZXF1ZW5jZUxlbmd0aDpkLHBhc3RTZXF1ZW5jZUxlbmd0aDpwLGt2U2VxdWVuY2VMZW5ndGg6Yyx0b3RhbFNlcXVlbmNlTGVuZ3RoOi0xLG1heFNlcXVlbmNlTGVuZ3RoOi0xLGlucHV0SGlkZGVuU2l6ZTowLGhpZGRlblNpemU6bCx2SGlkZGVuU2l6ZTp2LGhlYWRTaXplOm0sdkhlYWRTaXplOk1hdGguZmxvb3Iodi90Lmt2TnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsa3ZOdW1IZWFkczp0Lmt2TnVtSGVhZHMsblJlcHM6dC5udW1IZWFkcy90Lmt2TnVtSGVhZHMscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrVHlwZTpfLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6dyxxa3ZGb3JtYXQ6Z319LGFjPU4oe3Blcm06WzAsMiwxLDNdfSksbWE9KGUsdCxuKT0+e2xldCByPXQsbz1uLmt2TnVtSGVhZHM7cmV0dXJuIHQuZGltcy5sZW5ndGg9PT0zJiZuLmt2U2VxdWVuY2VMZW5ndGghPT0wJiYocj10LnJlc2hhcGUoW24uYmF0Y2hTaXplLG4ua3ZTZXF1ZW5jZUxlbmd0aCxvLG4uaGVhZFNpemVdKSxyPWUuY29tcHV0ZShwZShyLGFjLnBlcm0pLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xXX0pWzBdKSxyfSx1Yz0oZSx0LG4scik9PntsZXQgbz03LGk9W1widHlwZVwiLFwidHlwZVwiXSxzPVtlKnRdLGE9ZSp0LHU9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp0fSx7dHlwZToxMixkYXRhOmV9XSxkPWw9PntsZXQgYz1TKFwic2VxX2xlbnNcIixuLmRhdGFUeXBlLG4uZGltcykscD1TKFwidG90YWxfc2VxX2xlbnNcIixyLmRhdGFUeXBlLHIuZGltcyksZj1DKFwicG9zX2lkc1wiLG8scyksbT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgJHtsLnJlZ2lzdGVyVW5pZm9ybXMobSkuZGVjbGFyZVZhcmlhYmxlcyhjLHAsZil9XG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtwLmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBsZXQgaXNfZmlyc3RfcHJvbXB0ID0gIWlzX3N1YnNlcXVlbnRfcHJvbXB0ICYmIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgbGV0IGJhdGNoX2lkeCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgbGV0IHNlcXVlbmNlX2lkeCA9IGkzMihnbG9iYWxfaWR4ICUgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICB2YXIgcG9zX2lkOiBpMzIgPSAwO1xuICAgIGxldCBzZXFsZW4gPSAke2MuZ2V0QnlPZmZzZXQoXCJiYXRjaF9pZHhcIil9O1xuICAgIGxldCB0b3RhbF9zZXFsZW4gPSBzZXFsZW4gKyAxO1xuICAgIGlmIChpc19maXJzdF9wcm9tcHQpIHtcbiAgICAgIGlmIChzZXF1ZW5jZV9pZHggPCB0b3RhbF9zZXFsZW4pIHtcbiAgICAgICAgcG9zX2lkID0gc2VxdWVuY2VfaWR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zX2lkID0gMTtcbiAgICAgIH1cbiAgICAgICR7Zi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInBvc19pZFwiKX1cbiAgICB9IGVsc2UgaWYgKGlzX3N1YnNlcXVlbnRfcHJvbXB0KSB7XG4gICAgICBsZXQgcGFzdF9zZXFsZW4gPSB0b3RhbF9zZXFsZW4gLSBpMzIodW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICAgIGlmIChwYXN0X3NlcWxlbiArIHNlcXVlbmNlX2lkeCA8IHRvdGFsX3NlcWxlbikge1xuICAgICAgICBwb3NfaWQgPSBwYXN0X3NlcWxlbiArIHNlcXVlbmNlX2lkeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc19pZCA9IDE7XG4gICAgICB9XG4gICAgICAke2Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJwb3NfaWRcIil9XG4gICAgfSBlbHNlIGlmIChnbG9iYWxfaWR4IDwgdW5pZm9ybXMuYmF0Y2hfc2l6ZSkge1xuICAgICAgJHtmLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic2VxbGVuXCIpfVxuICAgIH07XG4gIH1cbiAgYH07cmV0dXJue25hbWU6XCJHZW5lcmF0ZVBvc2l0aW9uSWRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ZX07JHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6aX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnV9KSxnZXRTaGFkZXJTb3VyY2U6ZH19LGZhPShlLHQpPT57bGV0IG49c2MoZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgcj1lLmlucHV0c1swXSxvPWUuaW5wdXRzWzFdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzFdOnZvaWQgMCxpPWUuaW5wdXRzWzJdJiZlLmlucHV0c1syXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzJdOnZvaWQgMCxzPWUuaW5wdXRzWzNdJiZlLmlucHV0c1szXS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbM106dm9pZCAwLGE9ZS5pbnB1dHNbNF0mJmUuaW5wdXRzWzRdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1s0XTp2b2lkIDAsdT1lLmlucHV0cy5sZW5ndGg+ND9lLmlucHV0c1s1XTp2b2lkIDAsZD1lLmlucHV0cy5sZW5ndGg+NT9lLmlucHV0c1s2XTp2b2lkIDAsbD1uLmt2TnVtSGVhZHM/bi5rdk51bUhlYWRzOm4ubnVtSGVhZHMsYz1OKHtheGlzOjIsbnVtT3V0cHV0czozLHNwbGl0U2l6ZXM6W24ubnVtSGVhZHMqbi5oZWFkU2l6ZSxsKm4uaGVhZFNpemUsbCpuLmhlYWRTaXplXX0pLFtwLGYsbV09IW8mJiFpP2UuY29tcHV0ZShhcihbcl0sYykse2lucHV0czpbcl0sb3V0cHV0czpbLTEsLTEsLTFdfSk6W3IsbyxpXSxoLGI7aWYodC5kb1JvdGFyeSl7bGV0IHc9ZS5jb21wdXRlKHVjKG4uYmF0Y2hTaXplLG4uc2VxdWVuY2VMZW5ndGgsdSxkKSx7aW5wdXRzOlt1LGRdLG91dHB1dHM6Wy0xXX0pWzBdLHY9ZS5pbnB1dHNbN10sJD1lLmlucHV0c1s4XSxUPU4oe2ludGVybGVhdmVkOnQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wLG51bUhlYWRzOm4ubnVtSGVhZHMscm90YXJ5RW1iZWRkaW5nRGltOjAsc2NhbGU6dC5zY2FsZX0pLEk9W3Asdyx2LCRdLEE9Wy0xXTtoPWUuY29tcHV0ZShjbihJLFQpLHtpbnB1dHM6SSxvdXRwdXRzOkF9KVswXSxJLnNwbGljZSgwLDEsZik7bGV0IHo9Tih7aW50ZXJsZWF2ZWQ6dC5yb3RhcnlJbnRlcmxlYXZlZCE9PTAsbnVtSGVhZHM6bi5rdk51bUhlYWRzLHJvdGFyeUVtYmVkZGluZ0RpbTowLHNjYWxlOnQuc2NhbGV9KTtiPWUuY29tcHV0ZShjbihJLHopLHtpbnB1dHM6SSxvdXRwdXRzOkF9KVswXX1sZXQgeT1fdChlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5zZXF1ZW5jZUxlbmd0aCxuLmhlYWRTaXplLHQuZG9Sb3Rhcnk/aDpwLHZvaWQgMCwwKSxnPW1hKGUsdC5kb1JvdGFyeT9iOmYsbiksXz1tYShlLG0sbik7b3QoZSx5LGcsXyx2b2lkIDAsdm9pZCAwLHMsYSx2b2lkIDAsbix1LGQpfX0pO3ZhciBnYSxkYyxsYyx5YSxiYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtWZSgpO0soKTtnYT0oZSx0LG4scixvLGkscyxhKT0+e2xldCB1PVgoaSksZD11PT09MT9cImYzMlwiOmB2ZWMke3V9ZmAsbD11PT09MT9cInZlYzJmXCI6YG1hdDJ4JHt1fWZgLGM9bypzLHA9NjQ7Yz09PTEmJihwPTI1Nik7bGV0IGY9W28scyxpL3VdLG09W28scywyXSxoPVtcInJhbmtcIixcInR5cGVcIixcInR5cGVcIl0sYj1bXTtiLnB1c2goLi4uUChmLG0pKTtsZXQgeT1nPT57bGV0IF89UyhcInhcIix0LmRhdGFUeXBlLDMsdSksdz1TKFwic2NhbGVcIixuLmRhdGFUeXBlLG4uZGltcyksdj1TKFwiYmlhc1wiLHIuZGF0YVR5cGUsci5kaW1zKSwkPUMoXCJvdXRwdXRcIiwxLDMsMiksVD1bXyx3LHYsJF07cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHtsfSwgJHtwfT47XG4gIGNvbnN0IHdvcmtncm91cF9zaXplID0gJHtwfXU7XG4gICR7Zy5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAke2cubWFpblN0YXJ0KHApfVxuICAgIGxldCBiYXRjaCA9IHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIHN1bSA9ICR7ZH0oMCk7XG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtkfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxfaWR4OyBoIDwgaGlnaHQ7IGggKz0gd29ya2dyb3VwX3NpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7ZH0oJHtfLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke2x9KHN1bSwgc3F1YXJlZF9zdW0pO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdICsgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7VGUoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdXCIsdSl9IC8gZjMyKGhpZ2h0ICogJHt1fSk7XG4gICAgICBsZXQgc3F1YXJlZF9zdW1fZmluYWwgPSAke1RlKFwid29ya2dyb3VwX3NoYXJlZFswXVsxXVwiLHUpfSAvIGYzMihoaWdodCAqICR7dX0pO1xuXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2F9KSk7XG4gICAgICBsZXQgY2hhbm5lbF9zY2FsZSA9IGludl9zdGRfZGV2ICogZjMyKHNjYWxlW2NoYW5uZWxdKTtcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3V9OyR7YX07JHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6aH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczptLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4OmN9LHByb2dyYW1Vbmlmb3JtczpifSksZ2V0U2hhZGVyU291cmNlOnl9LHtpbnB1dHM6W3QsbixyXSxvdXRwdXRzOlstMV19KVswXX0sZGM9KGUsdCxuKT0+e2xldCByPXRbMF0uZGltcyxvPXIsaT0yLHM9clswXSxhPXJbMV0sdT14LnNpemVGcm9tRGltZW5zaW9uKHIsaSksZD1YKHUpLGw9eC5zaXplKG8pL2QsYz1nYShlLHRbMF0sdFsxXSx0WzJdLHMsdSxhLG4uZXBzaWxvbikscD1bcyxhLHUvZF0sZj1bcyxhXSxtPVtcInR5cGVcIixcIm5vbmVcIl0saD1iPT57bGV0IHk9UyhcInhcIix0WzBdLmRhdGFUeXBlLHAubGVuZ3RoLGQpLGc9UyhcInNjYWxlX3NoaWZ0XCIsMSxmLmxlbmd0aCwyKSxfPUMoXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLHAubGVuZ3RoLGQpLHc9W3ksZyxfXTtyZXR1cm5gXG4gICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4udyl9XG4gICR7Yi5tYWluU3RhcnQoKX1cbiAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgbGV0IGJhdGNoID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICAgIGxldCBjaGFubmVsID0gb3V0cHV0SW5kaWNlc1sxXTtcbiAgICAgIGxldCBzY2FsZV9zaGlmdCA9ICR7Zy5nZXRCeUluZGljZXMoXCJ2ZWMyPHUzMj4oYmF0Y2gsIGNoYW5uZWwpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7eS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9ICogJHtfLnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtfLnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xuICAgICAgJHtfLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ZH1gLGlucHV0RGVwZW5kZW5jaWVzOm19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpsfSwuLi5QKHAsZixwKV19KSxnZXRTaGFkZXJTb3VyY2U6aH0se2lucHV0czpbdFswXSxjXX0pfSxsYz0oZSx0LG4pPT57bGV0IHI9dFswXS5kaW1zLG89cixpPXJbMF0scz1yW3IubGVuZ3RoLTFdLGE9eC5zaXplRnJvbURpbWVuc2lvbihyLDEpL3MsdT1YKHMpLGQ9eC5zaXplKG8pL3UsbD1be3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOk1hdGguZmxvb3Iocy91KX1dLGM9W1widHlwZVwiLFwidHlwZVwiXSxwPSExLGY9WzAsci5sZW5ndGgtMV07Zm9yKGxldCB5PTA7eTxyLmxlbmd0aC0yO3krKylwPXB8fHJbeSsxXSE9PTEsZi5wdXNoKHkrMSk7cD1wJiZyW3IubGVuZ3RoLTFdIT09MTtsZXQgbT1wP2UuY29tcHV0ZShwZShlLmlucHV0c1swXSxmKSx7aW5wdXRzOltlLmlucHV0c1swXV0sb3V0cHV0czpbLTFdfSlbMF06ZS5pbnB1dHNbMF0ucmVzaGFwZShBcnJheS5mcm9tKHtsZW5ndGg6ci5sZW5ndGh9LCh5LGcpPT5yW2ZbZ11dKSksaD1nYShlLG0sdFsxXSx0WzJdLGksYSxzLG4uZXBzaWxvbiksYj15PT57bGV0IGc9cmUodFswXS5kYXRhVHlwZSksXz11PT09MT9cInZlYzJmXCI6YG1hdCR7dX14MmZgLHc9VD0+e2xldCBJPVQ9PT0wP1wieFwiOlwieVwiLEE9dT09PTE/XCJmMzJcIjpgdmVjJHt1fWZgO3N3aXRjaCh1KXtjYXNlIDE6cmV0dXJuYCR7Z30oJHtBfShzY2FsZS4ke0l9KSlgO2Nhc2UgMjpyZXR1cm5gdmVjMjwke2d9Pigke0F9KHNjYWxlWzBdLiR7SX0sIHNjYWxlWzFdLiR7SX0pKWA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7Z30+KCR7QX0oc2NhbGVbMF0uJHtJfSwgc2NhbGVbMV0uJHtJfSwgc2NhbGVbMl0uJHtJfSwgc2NhbGVbM10uJHtJfSkpYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBjb21wb2VudHMgJHt1fWApfX0sdj1TKFwiaW5wdXRcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyx1KSwkPUMoXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLG8sdSk7cmV0dXJuYFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHt2LnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlX2lucHV0IDogYXJyYXk8JHtffT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHskLnR5cGUuc3RvcmFnZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge0g6IHUzMiwgQyA6IHUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICBsZXQgY3VycmVudF9pbWFnZV9udW1iZXIgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLkMgKiB1bmlmb3Jtcy5IKTtcbiAgICBsZXQgY3VycmVudF9jaGFubmVsX251bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlX29mZnNldCA9IGN1cnJlbnRfaW1hZ2VfbnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRfY2hhbm5lbF9udW1iZXI7XG4gICAgbGV0IHNjYWxlID0gc2NhbGVfaW5wdXRbc2NhbGVfb2Zmc2V0XTtcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7dygwKX0sICR7dygxKX0pO1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQ1wiLHNoYWRlckNhY2hlOntoaW50OmAke3V9YCxpbnB1dERlcGVuZGVuY2llczpjfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bH0pLGdldFNoYWRlclNvdXJjZTpifSx7aW5wdXRzOlt0WzBdLGhdfSl9LHlhPShlLHQpPT57dC5mb3JtYXQ9PT1cIk5IV0NcIj9sYyhlLGUuaW5wdXRzLHQpOmRjKGUsZS5pbnB1dHMsdCl9fSk7dmFyIGNjLHBjLF9hLHdhPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO0soKTtjYz1lPT57aWYoIWV8fGUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLlwiKX0scGM9KGUsdCxuKT0+e2xldCByPXQuc2ltcGxpZmllZCxvPWVbMF0uZGltcyxpPWVbMV0scz0hciYmZVsyXSxhPW8sdT14Lm5vcm1hbGl6ZUF4aXModC5heGlzLG8ubGVuZ3RoKSxkPXguc2l6ZVRvRGltZW5zaW9uKG8sdSksbD14LnNpemVGcm9tRGltZW5zaW9uKG8sdSksYz14LnNpemUoaS5kaW1zKSxwPXM/eC5zaXplKHMuZGltcyk6MDtpZihjIT09bHx8cyYmcCE9PWwpdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHtsfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7Y30gYW5kIGJpYXMgc2l6ZSBvZiAke3B9YCk7bGV0IGY9W107Zm9yKGxldCB2PTA7djxvLmxlbmd0aDsrK3Ypdjx1P2YucHVzaChvW3ZdKTpmLnB1c2goMSk7bGV0IG09WChsKSxoPVtcInR5cGVcIixcInR5cGVcIl0sYj1be3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKGwvbSl9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XTtzJiZoLnB1c2goXCJ0eXBlXCIpO2xldCB5PW4+MSxnPW4+MixfPXY9PntsZXQgJD1yZShlWzBdLmRhdGFUeXBlKSxUPVtTKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLG0pLFMoXCJzY2FsZVwiLGkuZGF0YVR5cGUsaS5kaW1zLG0pXTtzJiZULnB1c2goUyhcImJpYXNcIixzLmRhdGFUeXBlLHMuZGltcyxtKSksVC5wdXNoKEMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGEsbSkpLHkmJlQucHVzaChDKFwibWVhbl9kYXRhX291dHB1dFwiLDEsZikpLGcmJlQucHVzaChDKFwiaW52X3N0ZF9vdXRwdXRcIiwxLGYpKTtsZXQgST1be25hbWU6XCJub3JtX2NvdW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJub3JtX3NpemVfdmVjdG9yaXplZFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke3YucmVnaXN0ZXJVbmlmb3JtcyhJKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAke3YubWFpblN0YXJ0KCl9XG4gICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5ub3JtX2NvdW50XCIpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHtxbihcImYzMlwiLG0pfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHtxbihcImYzMlwiLG0pfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtKZSgkLG0sXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtUZShcIm1lYW5fdmVjdG9yXCIsbSl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7VGUoXCJtZWFuX3NxdWFyZV92ZWN0b3JcIixtKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtyP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtKZSgkLG0sXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7SmUoJCxtLFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtUWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke3I/XCJcIjpcIi0gbWVhblwifSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7cz9gKyAke0plKCQsbSxcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAke3k/XCJtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7Zz9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXZcIjpcIlwifTtcbiAgfWB9LHc9W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiB5JiZ3LnB1c2goe2RpbXM6ZixkYXRhVHlwZToxfSksZyYmdy5wdXNoKHtkaW1zOmYsZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bX07JHtufTske3J9YCxpbnB1dERlcGVuZGVuY2llczpofSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6dyxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmJ9KSxnZXRTaGFkZXJTb3VyY2U6X319LF9hPShlLHQpPT57Y2MoZS5pbnB1dHMpLGUuY29tcHV0ZShwYyhlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgbWMsJGEsdmE9aygoKT0+e1widXNlIHN0cmljdFwiO3EoKTthbigpO3VuKCk7bWM9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSwkYT1lPT57bWMoZS5pbnB1dHMpO2xldCB0PVBlLmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IG49dFt0Lmxlbmd0aC0xXSxyPWUuaW5wdXRzWzBdLmRpbXNbZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgtMV07aWYobjw4JiZyPDgpZS5jb21wdXRlKHNuKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCJ9LHQpKTtlbHNle2xldCBvPXRbdC5sZW5ndGgtMl0saT14LnNpemUoZS5pbnB1dHNbMF0uZGltcy5zbGljZSgwLC0yKSkscz14LnNpemUoZS5pbnB1dHNbMV0uZGltcy5zbGljZSgwLC0yKSk7aWYoaSE9PTEmJm89PT0xJiZzPT09MSl7bGV0IGE9ZS5pbnB1dHNbMF0ucmVzaGFwZShbMSxpLHJdKSx1PWUuaW5wdXRzWzFdLnJlc2hhcGUoWzEscixuXSksZD1bMSxpLG5dLGw9W2EsdV07ZS5jb21wdXRlKGJ0KGwse2FjdGl2YXRpb246XCJcIn0sdCxkKSx7aW5wdXRzOmx9KX1lbHNlIGUuY29tcHV0ZShidChlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSl9fX0pO3ZhciBmYyxoYyxnYyx4YSxTYSxUYT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtpZSgpO0soKTtmYz0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsTkJpdHMgcmVxdWlyZXMgMyBvciA0IGlucHV0c1wiKTtsZXQgbj1lWzBdLHI9bi5kaW1zLmxlbmd0aDtpZihuLmRpbXNbci0xXSE9PXQuayl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWVcIik7bGV0IG89TWF0aC5mbG9vcigodC5rK3QuYmxvY2tTaXplLTEpL3QuYmxvY2tTaXplKSxpPXQuYmxvY2tTaXplLzgqdC5iaXRzLHM9ZVsxXTtpZigheC5hcmVFcXVhbChzLmRpbXMsW3QubixvLGldKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemVcIik7bGV0IHU9ZVsyXS5kaW1zO2lmKHguc2l6ZSh1KSE9PXQubipvKXRocm93IG5ldyBFcnJvcihcInNjYWxlcyBpbnB1dCBzaXplIGVycm9yLlwiKTtpZihlLmxlbmd0aD09PTQpe2xldCBsPWVbM10uZGltcyxjPXQubioodC5iaXRzPT09OD9vOk1hdGguZmxvb3IoKG8qdC5iaXRzKzcpLzgpKTtpZih4LnNpemUobCkhPT1jKXRocm93IG5ldyBFcnJvcihcInplcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci5cIil9fSxoYz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPW4ubGVuZ3RoLG89bltyLTJdLGk9dC5rLHM9dC5uLGE9bi5zbGljZSgwLHItMiksdT14LnNpemUoYSksbD1lWzFdLmRpbXNbMl0vNCxjPWVbMF0uZGF0YVR5cGUscD1YKHQuayksZj1YKGwpLG09WChzKSxoPWEuY29uY2F0KFtvLHNdKSxiPW8+MSYmcy9tJTI9PT0wPzI6MSx5PXguc2l6ZShoKS9tL2IsZz02NCxfPVtdLHc9W3UsbyxpL3BdLHY9eC5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO3Yuc3BsaWNlKC0xLDEsbC9mKSxfLnB1c2goLi4uUCh3KSksXy5wdXNoKC4uLlAodikpLF8ucHVzaCguLi5QKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmXy5wdXNoKC4uLlAoeC5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCAkPVt1LG8scy9tXTtfLnB1c2goLi4uUCgkKSk7bGV0IFQ9ST0+e2xldCBBPXcubGVuZ3RoLHo9UyhcImFcIixlWzBdLmRhdGFUeXBlLEEscCksTT1TKFwiYlwiLDEyLHYubGVuZ3RoLGYpLFU9UyhcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksRz1beixNLFVdLEI9ZS5sZW5ndGg9PT00P1MoXCJ6ZXJvX3BvaW50c1wiLDEyLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMDtCJiZHLnB1c2goQik7bGV0IGVlPSQubGVuZ3RoLFc9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZWUsbSksRD1yZShlWzBdLmRhdGFUeXBlKSxaPSgoKT0+e3N3aXRjaChwKXtjYXNlIDE6cmV0dXJuYGFycmF5PCR7RH0sIDg+YDtjYXNlIDI6cmV0dXJuYG1hdDR4Mjwke0R9PmA7Y2FzZSA0OnJldHVybmBtYXQyeDQ8JHtEfT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke3B9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0pKCksUj0oKT0+e2xldCBzZT1gXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhXG4gICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0ID0gJHt6LmluZGljZXNUb09mZnNldChgJHt6LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgd29yZF9vZmZzZXQpYCl9O1xuICAgICAgICAgICAgdmFyIGFfZGF0YTogJHtafTtcbiAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCAkezgvcH07IGorKykge1xuICAgICAgICAgICAgICBhX2RhdGFbal0gPSAke3ouZ2V0QnlPZmZzZXQoXCJpbnB1dF9vZmZzZXRcIil9O1xuICAgICAgICAgICAgICBpbnB1dF9vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO2ZvcihsZXQgSD0wO0g8bSpiO0grKylzZSs9YFxuICAgICAgICAgICAgYl92YWx1ZSA9ICR7Zj09PTE/YGIke0h9X2RhdGFgOmBiJHtIfV9kYXRhW2ldYH07XG4gICAgICAgICAgICBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfcXVhbnRpemVkX3ZhbHVlcyA9ICR7Wn0oJHtBcnJheS5mcm9tKHtsZW5ndGg6NH0sKEUsTCk9PmAke0R9KGJfdmFsdWVfbG93ZXJbJHtMfV0pLCAke0R9KGJfdmFsdWVfdXBwZXJbJHtMfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7cD09PTE/YCR7Wn0oJHtBcnJheS5mcm9tKHtsZW5ndGg6OH0sKEUsTCk9PmAoYl9xdWFudGl6ZWRfdmFsdWVzWyR7TH1dIC0gJHtCP2B6ZXJvX3BvaW50JHtIfWA6XCJ6ZXJvX3BvaW50XCJ9KSAqIHNjYWxlJHtIfWApLmpvaW4oXCIsIFwiKX0pO2A6YChiX3F1YW50aXplZF92YWx1ZXMgLSAke1p9KCR7QXJyYXkoOCkuZmlsbChgJHtCP2B6ZXJvX3BvaW50JHtIfWA6XCJ6ZXJvX3BvaW50XCJ9YCkuam9pbihcIixcIil9KSkgKiBzY2FsZSR7SH07YH07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke2J9ICsgJHtNYXRoLmZsb29yKEgvbSl9XSR7bT4xP2BbJHtIJW19XWA6XCJcIn0gKz0gJHtBcnJheS5mcm9tKHtsZW5ndGg6OC9wfSwoRSxMKT0+YCR7cD09PTE/YGFfZGF0YVske0x9XSAqIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7TH1dYDpgZG90KGFfZGF0YVske0x9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtMfV0pYH1gKS5qb2luKFwiICsgXCIpfTtcbiAgICAgICAgICBgO3JldHVybiBzZX0sUT0oKT0+e2xldCBzZT1gXG4gICAgICAgICAgICB2YXIgY29sX2luZGV4ID0gY29sICogJHttfTtcbiAgICAgICAgICAgICR7Qj9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke0R9KDgpO2B9XG4gICAgICAgICAgICBgO2ZvcihsZXQgSD0wO0g8bSpiO0grKylzZSs9YFxuICAgICAgICAgICAgbGV0IHNjYWxlJHtIfSA9ICR7VS5nZXRCeU9mZnNldChcImNvbF9pbmRleCAqIG5CbG9ja3NQZXJDb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICAke0I/YFxuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX2NvdW50ID0gY29sX2luZGV4ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmQgPSAke0IuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCR7SH0gPSAke0R9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpcIlwifVxuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtyZXR1cm4gc2V9LHdlPSgpPT57bGV0IHNlPWBjb2xfaW5kZXggPSBjb2wgKiAke219O2A7Zm9yKGxldCBIPTA7SDxtKmI7SCsrKXNlKz1gXG4gICAgICAgICAgICBsZXQgYiR7SH1fZGF0YSA9ICR7TS5nZXRCeUluZGljZXMoYCR7TS50eXBlLmluZGljZXN9KGNvbF9pbmRleCwgYmxvY2ssIHdvcmQpYCl9O1xuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtyZXR1cm4gc2UrPWBcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlOiB1MzI7XG4gICAgICAgICAgICBsZXQgYl9tYXNrOiB1MzIgPSAweDBGMEYwRjBGdTtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX2xvd2VyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV91cHBlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfcXVhbnRpemVkX3ZhbHVlczogJHtafTtcbiAgICAgICAgICAgIHZhciBiX2RlcXVhbnRpemVkX3ZhbHVlczogJHtafTtgLHNlfTtyZXR1cm5gXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQ6IGFycmF5PCR7Vy50eXBlLnZhbHVlfSwgJHtiKmd9PjtcbiAgICAgICAgJHtJLmRlY2xhcmVWYXJpYWJsZXMoLi4uRyxXKX1cbiAgICAgICAgJHtJLm1haW5TdGFydChbZywxLDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1cub2Zmc2V0VG9JbmRpY2VzKGAoZ2xvYmFsX2lkeCAvICR7Z30pICogJHtifWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuQmxvY2tzUGVyQ29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcblxuICAgICAgICAgIGZvciAodmFyIGJsb2NrID0gbG9jYWxfaWQueDsgYmxvY2sgPCBuQmxvY2tzUGVyQ29sOyBibG9jayArPSAke2d9KSB7XG4gICAgICAgICAgICAvL3Byb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrICogJHt0LmJsb2NrU2l6ZS9wfTtcbiAgICAgICAgICAgICR7USgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7bH07IHdvcmQgKz0gJHtmfSkge1xuICAgICAgICAgICAgICAke3dlKCl9XG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2Z9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAke1IoKX1cbiAgICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvcH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkLnggPCAke2J9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke1cudHlwZS52YWx1ZX0gPSAke1cudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7Z311OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke2J9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtXLnNldEJ5SW5kaWNlcyhgJHtXLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLFwib3V0cHV0X3ZhbHVlXCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIk1hdE11bE5CaXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5ibG9ja1NpemV9OyR7dC5iaXRzfTske3B9OyR7Zn07JHttfTske2J9OyR7Z31gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5KGUubGVuZ3RoKS5maWxsKFwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpoLGRhdGFUeXBlOmN9XSxkaXNwYXRjaEdyb3VwOnt4Onl9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOlR9fSxnYz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPW4ubGVuZ3RoLG89bltyLTJdLGk9dC5rLHM9dC5uLGE9bi5zbGljZSgwLHItMiksdT14LnNpemUoYSksbD1lWzFdLmRpbXNbMl0vNCxjPWVbMF0uZGF0YVR5cGUscD1YKHQuayksZj1YKGwpLG09YS5jb25jYXQoW28sc10pLGg9MTI4LGI9cyU4PT09MD84OnMlND09PTA/NDoxLHk9aC9iLGc9eSpmKjgsXz1nL3Asdz1nL3QuYmxvY2tTaXplLHY9eC5zaXplKG0pL2IsJD1bXSxUPVt1LG8saS9wXSxJPXguY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTtJLnNwbGljZSgtMSwxLGwvZiksJC5wdXNoKC4uLlAoVCkpLCQucHVzaCguLi5QKEkpKSwkLnB1c2goLi4uUChlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJiQucHVzaCguLi5QKHguY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgQT1bdSxvLHNdOyQucHVzaCguLi5QKEEpKTtsZXQgej1NPT57bGV0IFU9VC5sZW5ndGgsRz1TKFwiYVwiLGVbMF0uZGF0YVR5cGUsVSxwKSxCPVMoXCJiXCIsMTIsSS5sZW5ndGgsZiksZWU9UyhcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVz1bRyxCLGVlXSxEPWUubGVuZ3RoPT09ND9TKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7RCYmVy5wdXNoKEQpO2xldCBaPUEubGVuZ3RoLFI9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsWiksUT1yZShlWzBdLmRhdGFUeXBlKSx3ZT0oKT0+e3N3aXRjaChwKXtjYXNlIDE6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke1F9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke1F9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO2Nhc2UgMjpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7UX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7UX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtwfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7Ry50eXBlLnZhbHVlfSwgJHtffT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7Ui50eXBlLnZhbHVlfSwgJHt5fT4sICR7Yn0+O1xuICAgICAgICAke00uZGVjbGFyZVZhcmlhYmxlcyguLi5XLFIpfVxuICAgICAgICAke00ubWFpblN0YXJ0KFt5LGIsMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Ui5vZmZzZXRUb0luZGljZXMoYHdvcmtncm91cF9pbmRleCAqICR7Yn1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHt3fSArIDE7XG5cbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBhX2NvbF9zdGFydCA9IHRpbGUgKiAke199O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHtffTsgYV9vZmZzZXQgKz0gJHtofSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGFfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsyXSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Ry5nZXRCeUluZGljZXMoYCR7Ry50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke0cudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgICAgLy8gZWFjaCB0aHJlYWQgcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHt3fSArIGxvY2FsX2lkLng7XG4gICAgICAgICAgICAke0Q/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHtELmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF93b3JkX2luZGV4XCIpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke1F9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtRfSg4KTtgfVxuICAgICAgICAgICAgbGV0IHNjYWxlID0gJHtlZS5nZXRCeU9mZnNldChcImJfcm93ICogbl9ibG9ja3NfcGVyX2NvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgIGxldCBiX2RhdGEgPSAke0IuZ2V0QnlJbmRpY2VzKGAke0IudHlwZS5pbmRpY2VzfShiX3JvdywgYmxvY2ssIDApYCl9O1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0ID0gbG9jYWxfaWQueCAqICR7dC5ibG9ja1NpemUvcH07XG4gICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtmfTsgaSsrKSB7XG4gICAgICAgICAgICAgICR7d2UoKX1cbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWUgPSAke2Y9PT0xP1wiYl9kYXRhXCI6XCJiX2RhdGFbaV1cIn07XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3F1YW50aXplZF92YWx1ZXMgPSBtYXQyeDQ8JHtRfT4oJHtBcnJheS5mcm9tKHtsZW5ndGg6NH0sKHNlLEgpPT5gJHtRfShiX3ZhbHVlX2xvd2VyWyR7SH1dKSwgJHtRfShiX3ZhbHVlX3VwcGVyWyR7SH1dKWApLmpvaW4oXCIsIFwiKX0pO1xuICAgICAgICAgICAgICBsZXQgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gbWF0Mng0PCR7UX0+KCR7QXJyYXkoOCkuZmlsbChcInplcm9fcG9pbnRcIikuam9pbihcIixcIil9KSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgaW50ZXJfcmVzdWx0c1tsb2NhbF9pZC55XVtsb2NhbF9pZC54XSArPSAke0FycmF5LmZyb20oe2xlbmd0aDoyfSwoc2UsSCk9PmAke2Bkb3QoYV9kYXRhJHtIfSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtIfV0pYH1gKS5qb2luKFwiICsgXCIpfTtcbiAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L3B9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke2J9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke1IudHlwZS52YWx1ZX0gPSAke1IudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMHU7IGIgPCAke3l9OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IGludGVyX3Jlc3VsdHNbbG9jYWxfaWR4XVtiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgKyBsb2NhbF9pZHggPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICR7Ui5zZXRCeUluZGljZXMoYCR7Ui50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLFwib3V0cHV0X3ZhbHVlXCIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQmxvY2t3aXNlTWF0TXVsTkJpdHMzMlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3B9OyR7Zn07JHt5fTske2J9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTpjfV0sZGlzcGF0Y2hHcm91cDp7eDp2fSxwcm9ncmFtVW5pZm9ybXM6JH0pLGdldFNoYWRlclNvdXJjZTp6fX0seGE9KGUsdCk9PntmYyhlLmlucHV0cyx0KSx0LmJsb2NrU2l6ZT09PTMyJiZlLmFkYXB0ZXJJbmZvLmlzVmVuZG9yKFwiaW50ZWxcIikmJmUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJnZW4tMTJscFwiKT9lLmNvbXB1dGUoZ2MoZS5pbnB1dHMsdCkpOmUuY29tcHV0ZShoYyhlLmlucHV0cyx0KSl9LFNhPWU9Pk4oZSl9KTt2YXIgeWMsYmMsX2Msd2MsJGMsdmMseGMsU2MsSWEsQ2E9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO3ljPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZmV3IGlucHV0c1wiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LlwiKTtpZihlLmxlbmd0aD49Mil7bGV0IHQ9ZVswXS5kaW1zLmxlbmd0aCoyPT09ZVsxXS5kaW1zWzBdO2lmKGUubGVuZ3RoPT09NCYmKHQ9ZVszXS5kaW1zWzBdKjI9PT1lWzFdLmRpbXNbMF0pLCF0KXRocm93IG5ldyBFcnJvcihcIlRoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLlwiKX19LGJjPShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtPKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7TyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke08oXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgIHZhbHVlID0gJHtlLnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke3J9XG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICBgfSxfYz0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke08oXCJ1bmlmb3Jtcy5wYWRzXCIsbyxuKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7TyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkgLSAxKTtcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XG4gICAgICAgICAgICAgICAgICBpZihrID49IGkzMigke08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7TyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3J9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHdjPShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7TyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtPKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayA9IGkzMigke08oXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtPKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7cn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sJGM9KGUsdCxuKT0+e2xldCByPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbylyKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtPKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7TyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtPKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtPKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtPKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7cn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sdmM9KGUsdCxuKT0+e3N3aXRjaChuLm1vZGUpe2Nhc2UgMDpyZXR1cm4gYmMoZSx0LG4ucGFkcy5sZW5ndGgpO2Nhc2UgMTpyZXR1cm4gX2MoZSx0LG4ucGFkcy5sZW5ndGgpO2Nhc2UgMjpyZXR1cm4gd2MoZSx0LG4ucGFkcy5sZW5ndGgpO2Nhc2UgMzpyZXR1cm4gJGMoZSx0LG4ucGFkcy5sZW5ndGgpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0seGM9KGUsdCk9PntsZXQgbj14LnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcykscj1lWzBdLmRpbXMsbz14LnNpemUobiksaT1be3R5cGU6MTIsZGF0YTpvfSx7dHlwZTo2LGRhdGE6dC5wYWRzfV0scz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhO3QubW9kZT09PTAmJmkucHVzaCh7dHlwZTpzP2VbMl0uZGF0YVR5cGU6MSxkYXRhOnQudmFsdWV9KSxpLnB1c2goLi4uUChlWzBdLmRpbXMsbikpO2xldCBhPVtcInJhbmtcIl0sdT1kPT57bGV0IGw9QyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgpLGM9UyhcInhcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSxwPWMudHlwZS52YWx1ZSxmPXZjKGwsci5sZW5ndGgsdCksbT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofV07cmV0dXJuIHQubW9kZT09PTAmJm0ucHVzaCh7bmFtZTpcImNvbnN0YW50X3ZhbHVlXCIsdHlwZTpzP3A6XCJmMzJcIn0pLGBcbiAgICAgICAgICAgICR7ZC5yZWdpc3RlclVuaWZvcm1zKG0pLmRlY2xhcmVWYXJpYWJsZXMoYyxsKX1cbiAgICAgICAgICAgICR7ZC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7ZC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtsLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke3B9KDApO1xuICAgICAgICAgICAgJHtmfVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlBhZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QubW9kZX0ke3N9YCxpbnB1dERlcGVuZGVuY2llczphfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHguc2l6ZShuKS82NCl9LHByb2dyYW1Vbmlmb3JtczppfSksZ2V0U2hhZGVyU291cmNlOnV9fSxTYz0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCBuPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLHI9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmRhdGFUeXBlPT09MTA/ZVsyXS5nZXRVaW50MTZBcnJheSgpWzBdOmVbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MCxvPWVbMF0uZGltcy5sZW5ndGgsaT1uZXcgSW50MzJBcnJheSgyKm8pLmZpbGwoMCk7aWYoZS5sZW5ndGg+PTQpe2xldCBhPWVbM10uZ2V0QmlnSW50NjRBcnJheSgpO2ZvcihsZXQgdT0wO3U8YS5sZW5ndGg7dSsrKWlbTnVtYmVyKGFbdV0pXT1OdW1iZXIoblt1XSksaVtOdW1iZXIoYVt1XSkrb109TnVtYmVyKG5bdSthLmxlbmd0aF0pfWVsc2Ugbi5mb3JFYWNoKChhLHUpPT5pW051bWJlcih1KV09TnVtYmVyKGEpKTtsZXQgcz1bXTtyZXR1cm4gaS5mb3JFYWNoKGE9PnMucHVzaChhKSkse21vZGU6dC5tb2RlLHZhbHVlOnIscGFkczpzfX1lbHNlIHJldHVybiB0fSxJYT0oZSx0KT0+e3ljKGUuaW5wdXRzKTtsZXQgbj1TYyhlLmlucHV0cyx0KTtlLmNvbXB1dGUoeGMoZS5pbnB1dHMsbikse2lucHV0czpbMF19KX19KTt2YXIgcG4sQWEsRWEsa2EsUGEsVGMsSWMsemEsQmEsRGEsT2EsTWEsVWEsUmEsVmEsTmEsTGEsV2EsR2EsSGE9aygoKT0+e1widXNlIHN0cmljdFwiO3llKCk7VigpO3EoKTtLKCk7cG49ZT0+e2lmKHRlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmKCFlfHxlLmxlbmd0aCE9PTEpKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxBYT0oZSx0LG4pPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixvPWUuZGltcy5zbGljZSgpO3ImJm8uc3BsaWNlKDEsMCxvLnBvcCgpKTtsZXQgaT1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLHM9dC5rZXJuZWxTaGFwZS5zbGljZSgpLGE9dC5zdHJpZGVzLnNsaWNlKCksdT1pP3QuZGlsYXRpb25zLnNsaWNlKCk6W10sZD10LnBhZHMuc2xpY2UoKTtYZS5hZGp1c3RQb29sQXR0cmlidXRlcyhuLG8scyxhLHUsZCk7bGV0IGw9WGUuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShuLG8sYSx1LHMsZCx0LmF1dG9QYWQpLGM9T2JqZWN0LmFzc2lnbih7fSx0KTtpP09iamVjdC5hc3NpZ24oYyx7a2VybmVsU2hhcGU6cyxzdHJpZGVzOmEscGFkczpkLGRpbGF0aW9uczp1LGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKGMse2tlcm5lbFNoYXBlOnMsc3RyaWRlczphLHBhZHM6ZCxjYWNoZUtleTp0LmNhY2hlS2V5fSk7bGV0IHA9bC5zbGljZSgpO3JldHVybiBwLnB1c2gocC5zcGxpY2UoMSwxKVswXSksW2Mscj9wOmxdfSxFYT0oZSx0KT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIscj14LnNpemUoZSksbz14LnNpemUodC5rZXJuZWxTaGFwZSksaT1be3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99XSxzPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgYT10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLHU9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0sZD10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLGw9dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0sYz0hIShkK2wpO2kucHVzaCh7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6dX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9KSxzLnB1c2goe25hbWU6XCJrd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd1N0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3RW5kXCIsdHlwZTpcInUzMlwifSk7bGV0IHA9ITE7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgZj10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTJdLG09dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMl0saD10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTJdLGI9dC5wYWRzW3QucGFkcy5sZW5ndGgtMl07cD0hIShoK2IpLGkucHVzaCh7dHlwZToxMixkYXRhOmZ9LHt0eXBlOjEyLGRhdGE6bX0se3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOmJ9KSxzLnB1c2goe25hbWU6XCJraFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaFN0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBoRW5kXCIsdHlwZTpcInUzMlwifSl9cmV0dXJuW2kscywhMCxjLHBdfWVsc2V7aWYobil0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IGE9eC5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKTtpLnB1c2goe3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnQucGFkc30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9KSxzLnB1c2goe25hbWU6XCJrZXJuZWxTdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDphLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuc3RyaWRlcy5sZW5ndGh9KTtsZXQgdT10LnBhZHMucmVkdWNlKChkLGwpPT5kK2wpO3JldHVybltpLHMsISF1LCExLCExXX19LGthPShlLHQsbixyLG8saSxzLGEsdSxkLGwsYyk9PntsZXQgcD1vLmZvcm1hdD09PVwiTkhXQ1wiLGY9dC50eXBlLnZhbHVlLG09QyhcIm91dHB1dFwiLHQudHlwZS50ZW5zb3Iscik7aWYoby5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCBoPVwiXCIsYj1cIlwiLHk9XCJcIixnPW4tKHA/MjoxKTtpZihsP2g9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtnfV0gPSBpbmRpY2VzWyR7Z31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2d9XSA8IDAgfHwgeEluZGljZXNbJHtnfV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7Z31dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWA6aD1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2d9XSA9IGluZGljZXNbJHtnfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgICB9YCxvLmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCB3PW4tKHA/MzoyKTtjP2I9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt3fV0gPSBpbmRpY2VzWyR7d31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske3d9XSA8IDAgfHwgeEluZGljZXNbJHt3fV0gPj0gdW5pZm9ybXMueF9zaGFwZVske3d9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA6Yj1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3d9XSA9IGluZGljZXNbJHt3fV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGAseT1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXModSkuZGVjbGFyZVZhcmlhYmxlcyh0LG0pfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7Zn0oJHthfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICAke2J9XG4gICAgICAgICAgICAgICR7aH1cbiAgICAgICAgICAgICAgJHt5fVxuICAgICAgICAgICAgICAke3N9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH1lbHNle2lmKHApdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBoPW8ua2VybmVsU2hhcGUubGVuZ3RoLGI9by5wYWRzLmxlbmd0aCx5PVwiXCI7cmV0dXJuIGQ/eT1gXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IHVuaWZvcm1zLnhfc2hhcGVbal0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgfWA6eT1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgYCxgXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3Jtcyh1KS5kZWNsYXJlVmFyaWFibGVzKHQsbSl9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7aH0+O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7Zn0oJHthfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7aC0xfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7TyhcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIixoKX07XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7TyhcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIixoKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtoLTF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7bi1ofXU7IGogPCAke259dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke08oXCJ1bmlmb3Jtcy5zdHJpZGVzXCIsYGogLSAke24taH11YCxoKX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke24taH11XSAtICR7TyhcInVuaWZvcm1zLnBhZHNcIixcImogLSAydVwiLGIpfTtcbiAgICAgICAgICAgICAgICAgICR7eX1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3N9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH19LFBhPWU9PmAke2UuZm9ybWF0fTske2UuY2VpbE1vZGV9OyR7ZS5hdXRvUGFkfTske2Uua2VybmVsU2hhcGUubGVuZ3RofWAsVGM9ZT0+YCR7UGEoZSl9OyR7ZS5jb3VudEluY2x1ZGVQYWR9YCxJYz1lPT5gJHtQYShlKX07JHtlLnN0b3JhZ2VPcmRlcn07JHtlLmRpbGF0aW9uc31gLHphPWU9Pih7Zm9ybWF0OmUuZm9ybWF0LGF1dG9QYWQ6W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxjZWlsTW9kZTplLmNlaWxfbW9kZSxrZXJuZWxTaGFwZTplLmtlcm5lbF9zaGFwZSxzdHJpZGVzOmUuc3RyaWRlcyxwYWRzOmUucGFkc30pLEJhPShlLHQsbixyKT0+e2xldFtvLGldPUFhKHQscixuKSxzPVMoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxhPXMudHlwZS52YWx1ZSx1PVwidmFsdWUgKz0geF92YWw7XCIsZD1cIlwiO28uY291bnRJbmNsdWRlUGFkP2QrPWB2YWx1ZSAvPSAke2F9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A6ZCs9YHZhbHVlIC89ICR7YX0oaTMyKHVuaWZvcm1zLmtlcm5lbFNpemUpIC0gcGFkKTtgO2xldFtsLGMscCxmLG1dPUVhKGksbyk7bC5wdXNoKC4uLlAodC5kaW1zLGkpKTtsZXQgaD1bXCJyYW5rXCJdO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5jYWNoZUtleX07JHtwfTske2Z9OyR7bX1gLGlucHV0RGVwZW5kZW5jaWVzOmh9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeC5zaXplKGkpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6Yj0+a2EoYixzLHQuZGltcy5sZW5ndGgsaS5sZW5ndGgsbyx1LGQsMCxjLHAsZixtKX19LERhPWU9PntsZXQgdD1lLmNvdW50X2luY2x1ZGVfcGFkIT09MCxuPXphKGUpO2lmKG4uY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7bGV0IHI9e2NvdW50SW5jbHVkZVBhZDp0LC4uLm4sY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLnIsY2FjaGVLZXk6VGMocil9fSxPYT0oZSx0KT0+e3BuKGUuaW5wdXRzKSxlLmNvbXB1dGUoQmEoXCJBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sTWE9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdfSxVYT1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLk1hLGNhY2hlS2V5OnR9fSxSYT0oZSx0KT0+e3BuKGUuaW5wdXRzKSxlLmNvbXB1dGUoQmEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX0sVmE9KGUsdCxuLHIpPT57bGV0W28saV09QWEodCxyLG4pLHM9YFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgLGE9XCJcIix1PVMoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxkPVtcInJhbmtcIl0sW2wsYyxwLGYsbV09RWEoaSxvKTtyZXR1cm4gbC5wdXNoKC4uLlAodC5kaW1zLGkpKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3IuY2FjaGVLZXl9OyR7cH07JHtmfTske219YCxpbnB1dERlcGVuZGVuY2llczpkfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHguc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczpsfSksZ2V0U2hhZGVyU291cmNlOmg9PmthKGgsdSx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8scyxhLHQuZGF0YVR5cGU9PT0xMD8tNjU1MDQ6LTFlNSxjLHAsZixtKX19LE5hPShlLHQpPT57cG4oZS5pbnB1dHMpLGUuY29tcHV0ZShWYShcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LExhPWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIsbj1lLmRpbGF0aW9ucyxyPXphKGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKHIuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtsZXQgbz17c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOm4sLi4ucixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4ubyxjYWNoZUtleTpJYyhvKX19LFdhPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4uTWEsY2FjaGVLZXk6dH19LEdhPShlLHQpPT57cG4oZS5pbnB1dHMpLGUuY29tcHV0ZShWYShcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIEFjLEVjLHFhLEZhLEthPWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO0FjPShlLHQpPT57aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJEZXF1YW50aXplTGluZWFyIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsxXS5kaW1zPT09ZVsyXS5kaW1zKXRocm93IG5ldyBFcnJvcihcIngtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXCIpO2lmKGVbMF0uZGF0YVR5cGU9PT02JiZlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkluIHRoZSBjYXNlIG9mIGRlcXVhbnRpemluZyBpbnQzMiB0aGVyZSBpcyBubyB6ZXJvIHBvaW50LlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MCYmZVsxXS5kaW1zLmxlbmd0aCE9PTEmJmVbMV0uZGltcy5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGlucHV0IG11c3QgYmUgYSBzY2FsYXIsIGEgMUQgdGVuc29yLCBvciBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvci5cIik7aWYoZS5sZW5ndGg+Mil7aWYoZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT1lWzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuay5cIik7aWYoIWVbMV0uZGltcy5tYXAoKG4scik9Pm49PT1lWzJdLmRpbXNbcl0pLnJlZHVjZSgobixyKT0+biYmciwhMCkpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZS5cIil9aWYodC5ibG9ja1NpemU+MCl7aWYoZVsxXS5kaW1zLmxlbmd0aD09PTB8fGVbMV0uZGltcy5sZW5ndGg9PT0xJiZlWzFdLmRpbXNbMF09PT0xKXRocm93IG5ldyBFcnJvcihcImJsb2NrU2l6ZSBtdXN0IGJlIHNldCBvbmx5IGZvciBibG9jayBxdWFudGl6YXRpb24uXCIpO2lmKCFlWzFdLmRpbXMubWFwKChvLGkpPT5pPT09dC5heGlzfHxvPT09ZVswXS5kaW1zW2ldKS5yZWR1Y2UoKG8saSk9Pm8mJmksITApKXRocm93IG5ldyBFcnJvcihcIkZvciBibG9jayBxdW5hdGl6YXRpb24sIHNjYWxlIGlucHV0IHNoYXBlIHRvIG1hdGNoIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgZm9yIHRoZSBheGlzXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkZvciBibG9jayBxdW5hdGl6YXRpb24gdGhlIHNjYWxlIGlucHV0IHJhbmsgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgeCByYW5rLlwiKTtsZXQgbj1lWzBdLmRpbXNbdC5heGlzXSxyPWVbMV0uZGltc1t0LmF4aXNdO2lmKHQuYmxvY2tTaXplPE1hdGguY2VpbChuL3IpfHx0LmJsb2NrU2l6ZT5NYXRoLmNlaWwobi8oci0xKS0xKSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSB3aXRoIGluIHRoZSByYW5nZSBbY2VpbChkSSAvIFNpKSwgY2VpbChkSSAvIChTaSAtIDEpIC0gMSldLlwiKX19LEVjPShlLHQpPT57bGV0IG49eC5ub3JtYWxpemVBeGlzKHQuYXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxyPWVbMF0uZGF0YVR5cGUsbz1yPT09MyxpPWVbMF0uZGltcyxzPWVbMV0uZGF0YVR5cGUsYT14LnNpemUoaSksdT1yPT09M3x8cj09PTIsZD11P1tNYXRoLmNlaWwoeC5zaXplKGVbMF0uZGltcykvNCldOmVbMF0uZGltcyxsPWVbMV0uZGltcyxjPWUubGVuZ3RoPjI/ZVsyXTp2b2lkIDAscD1jP3U/W01hdGguY2VpbCh4LnNpemUoYy5kaW1zKS80KV06Yy5kaW1zOnZvaWQgMCxmPWwubGVuZ3RoPT09MHx8bC5sZW5ndGg9PT0xJiZsWzBdPT09MSxtPWY9PT0hMSYmbC5sZW5ndGg9PT0xLGg9WChhKSxiPWYmJighdXx8aD09PTQpLHk9Yj9oOjEsZz1iJiYhdT9oOjEsXz1TKFwiaW5wdXRcIix1PzEyOnIsZC5sZW5ndGgsZyksdz1TKFwic2NhbGVcIixzLGwubGVuZ3RoKSx2PWM/UyhcInplcm9fcG9pbnRcIix1PzEyOnIscC5sZW5ndGgpOnZvaWQgMCwkPUMoXCJvdXRwdXRcIixzLGkubGVuZ3RoLHkpLFQ9W18sd107diYmVC5wdXNoKHYpO2xldCBJPVtkLGxdO2MmJkkucHVzaChwKTtsZXQgQT1be3R5cGU6MTIsZGF0YTphL3l9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uUCguLi5JLGkpXSx6PU09PntsZXQgVT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJheGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAke00ucmVnaXN0ZXJVbmlmb3JtcyhVKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsJCl9XG4gICAgICAke00ubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtNLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAvLyBTZXQgaW5wdXQgeFxuICAgICAgICAgICR7dT9gXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSAke18uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4IC8gNFwiKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KGlucHV0KVwiOlwidW5wYWNrNHhVOChpbnB1dClcIn07XG4gICAgICAgICAgICBsZXQgeF92YWx1ZSA9ICR7eT09PTE/XCJ4X3ZlY1tnbG9iYWxfaWR4ICUgNF1cIjpcInhfdmVjXCJ9O2A6YGxldCB4X3ZhbHVlID0gJHtfLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07YH07XG5cbiAgICAgICAgICAvLyBTZXQgc2NhbGUgaW5wdXRcbiAgICAgICAgICAke2Y/YGxldCBzY2FsZV92YWx1ZT0gJHt3LmdldEJ5T2Zmc2V0KFwiMFwiKX1gOm0/YFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHskLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7dy5nZXRCeU9mZnNldChcInNjYWxlX2luZGV4XCIpfTtgOmBcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke3cudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHt3LmluZGljZXNHZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke3cuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcImluZGV4XCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHt3LmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2B9O1xuXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcbiAgICAgICAgICAke3Y/Zj91P2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7di5nZXRCeU9mZnNldChcIjBcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlPSB6ZXJvX3BvaW50X3ZlY1swXWA6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt2LmdldEJ5T2Zmc2V0KFwiMFwiKX1gOm0/dT9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAkeyQuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7di5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXggLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggJSA0XWA6YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHskLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGV4XCIpfTtgOnU/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7dy5pbmRpY2VzVG9PZmZzZXQoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7di5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfb2Zmc2V0IC8gNFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfb2Zmc2V0ICUgNF07YDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3YuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07YDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3U/bz9cImkzMlwiOlwidTMyXCI6Xy50eXBlLnZhbHVlfSgwKTtgfTtcbiAgICAgIC8vIENvbXB1dGUgYW5kIHdyaXRlIG91dHB1dFxuICAgICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGAkeyQudHlwZS52YWx1ZX0oeF92YWx1ZSAtIHplcm9fcG9pbnRfdmFsdWUpICogc2NhbGVfdmFsdWVgKX07XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJEZXF1YW50aXplTGluZWFyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczp2P1tcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOnosZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhL3kvNjQpLHk6MSx6OjF9LHByb2dyYW1Vbmlmb3JtczpBfSl9fSxxYT0oZSx0KT0+e0FjKGUuaW5wdXRzLHQpLGUuY29tcHV0ZShFYyhlLmlucHV0cyx0KSl9LEZhPWU9Pk4oe2F4aXM6ZS5heGlzLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZX0pfSk7dmFyIGtjLFBjLGphLFphPWsoKCk9PntcInVzZSBzdHJpY3RcIjt5ZSgpO1YoKTtLKCk7a2M9KGUsdCxuKT0+e2xldCByPWU9PT10LG89ZTx0JiZuPDAsaT1lPnQmJm4+MDtpZihyfHxvfHxpKXRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0cycgY29udGVudHMgYXJlIGludmFsaWQuXCIpfSxQYz0oZSx0LG4scik9PntsZXQgbz1NYXRoLmFicyhNYXRoLmNlaWwoKHQtZSkvbikpLGk9W29dLHM9byxhPVt7dHlwZToxMixkYXRhOnN9LHt0eXBlOnIsZGF0YTplfSx7dHlwZTpyLGRhdGE6bn0sLi4uUChpKV0sdT1kPT57bGV0IGw9QyhcIm91dHB1dFwiLHIsaS5sZW5ndGgpLGM9bC50eXBlLnZhbHVlLHA9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydFwiLHR5cGU6Y30se25hbWU6XCJkZWx0YVwiLHR5cGU6Y31dO3JldHVybmBcbiAgICAgICAgJHtkLnJlZ2lzdGVyVW5pZm9ybXMocCkuZGVjbGFyZVZhcmlhYmxlcyhsKX1cbiAgICAgICAgJHtkLm1haW5TdGFydCgpfVxuICAgICAgICAke2QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHVuaWZvcm1zLnN0YXJ0ICsgJHtjfShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiUmFuZ2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyfWB9LGdldFNoYWRlclNvdXJjZTp1LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTpyfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9LHByb2dyYW1Vbmlmb3JtczphfSl9fSxqYT1lPT57bGV0IHQ9MCxuPTAscj0wO2UuaW5wdXRzWzBdLmRhdGFUeXBlPT09Nj8odD1lLmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF0sbj1lLmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF0scj1lLmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF0pOmUuaW5wdXRzWzBdLmRhdGFUeXBlPT09MSYmKHQ9ZS5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF0sbj1lLmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdKSx0ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJmtjKHQsbixyKSxlLmNvbXB1dGUoUGModCxuLHIsZS5pbnB1dHNbMF0uZGF0YVR5cGUpLHtpbnB1dHM6W119KX19KTt2YXIgemMsQmMsUWEsWGEsWWE9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7emM9KGUsdCxuLHIpPT57aWYoZSE9PVwibm9uZVwiJiZyIT09XCJpMzJcIiYmciE9PVwidTMyXCImJnIhPT1cImYzMlwiKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtyfSBpcyBub3Qgc3VwcG9ydGVkIHdpdGggcmVkdWN0aW9uICR7ZX0uYCk7bGV0IG89YHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGxvb3Age1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRjMyID1gLGk9YDtcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGJpdGNhc3Q8aTMyPihuZXdWYWx1ZUYzMik7XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzID0gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhaygmJHt0fSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIHJlcy5leGNoYW5nZWQge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzLm9sZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1gO3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuYCR7dH09JHtufTtgO2Nhc2VcImFkZFwiOnJldHVybiByPT09XCJpMzJcInx8cj09PVwidTMyXCI/YGF0b21pY0FkZCgmJHt0fSwgYml0Y2FzdDwke3J9Pigke259KSk7YDpgXG4gICAgICAgICAgICAgICR7b31iaXRjYXN0PCR7cn0+KG9sZFZhbHVlKSArICgke259KSR7aX1gO2Nhc2VcIm1heFwiOnJldHVybiByPT09XCJpMzJcInx8cj09PVwidTMyXCI/YGF0b21pY01heCgmJHt0fSwgYml0Y2FzdDwke3J9Pigke259KSk7YDpgXG4gICAgICAgICAgICAgICAgJHtvfW1heChiaXRjYXN0PGYzMj4ob2xkVmFsdWUpLCAoJHtufSkpJHtpfWA7Y2FzZVwibWluXCI6cmV0dXJuIHI9PT1cImkzMlwifHxyPT09XCJ1MzJcIj9gYXRvbWljTWluKCYke3R9LCBiaXRjYXN0PCR7cn0+KCR7bn0pKTtgOmAke299bWluKGJpdGNhc3Q8JHtyfT4ob2xkVmFsdWUpLCAoJHtufSkpJHtpfWA7Y2FzZVwibXVsXCI6cmV0dXJuYCR7b30oYml0Y2FzdDwke3J9PihvbGRWYWx1ZSkgKiAoJHtufSkpJHtpfWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFJlZHVjdGlvbiAke2V9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxCYz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMV0uZGltcyxvPW4saT0xLHM9TWF0aC5jZWlsKHguc2l6ZVRvRGltZW5zaW9uKHIsci5sZW5ndGgtMSkvaSksYT1yW3IubGVuZ3RoLTFdLHU9eC5zaXplRnJvbURpbWVuc2lvbihuLGEpLGQ9W3t0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnV9LC4uLlAoZVsxXS5kaW1zLGVbMl0uZGltcyxvKV0sbD1jPT57bGV0IHA9UyhcImluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLGY9UyhcInVwZGF0ZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsaSksbT10LnJlZHVjdGlvbiE9PVwibm9uZVwiJiZ0LnJlZHVjdGlvbiE9PVwiXCI/U28oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoKTpDKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCxpKTtyZXR1cm5gXG4gICAgICAke2MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJsYXN0X2luZGV4X2RpbWVuc2lvblwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcIm51bV91cGRhdGVzX2VsZW1lbnRzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhwLGYsbSl9XG4gICAgICAke2MubWFpblN0YXJ0KCl9XG4gICAgICAgICR7Yy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gIHZhciBkYXRhX29mZnNldCA9IDB1O1xuICBsZXQgaW5kaWNlc19zdGFydCA9IHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uICogZ2xvYmFsX2lkeDtcbiAgbGV0IGluZGljZXNfZW5kID0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uO1xuICBmb3IgKHZhciBpID0gaW5kaWNlc19zdGFydDsgaSA8IGluZGljZXNfZW5kOyBpKyspIHtcbiAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc1tpXS54KTtcbiAgICAke2VbMF0uZGltcy5sZW5ndGg9PT0xP2BcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlcztcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlO2A6YFxuICAgIGxldCBlbGVtZW50X2NvdW50X2RpbSA9IHVuaWZvcm1zLm91dHB1dF9zdHJpZGVzW2kgLSBpbmRpY2VzX3N0YXJ0XTtcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlW2kgLSBpbmRpY2VzX3N0YXJ0XTtgfVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAoaW5kZXggPj0gaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xuICAgICR7emModC5yZWR1Y3Rpb24sXCJvdXRwdXRbZGF0YV9vZmZzZXQgKyBpXVwiLFwidmFsdWVcIixtLnR5cGUudmFsdWUpfVxuICB9XG5cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlNjYXR0ZXJORFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dC5yZWR1Y3Rpb259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pLGdldFNoYWRlclNvdXJjZTpsfX0sUWE9ZT0+Tih7cmVkdWN0aW9uOmUucmVkdWN0aW9ufSksWGE9KGUsdCk9PntlLmNvbXB1dGUoQmMoZS5pbnB1dHMsdCkse2lucHV0czpbZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLG91dHB1dHM6W119KX19KTt2YXIgRGMsT2MsTWMsSmEsVWMsUmMsVmMsTmMsTGMsV2MsR2MsSGMsZXUscWMsRmMsS2MsamMsWmMsdHUsbnUscnU9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7aWUoKTtLKCk7RGM9KGUsdCk9PntpZihlLmV2ZXJ5KG49Pm4+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09M3x8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xfHxlLmxlbmd0aD09PTUmJmVbMF09PT0xJiZlWzFdPT09MSkpdGhyb3cgbmV3IEVycm9yKGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgKX1lbHNlIGlmKHQubW9kZT09PVwiY3ViaWNcIiYmIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZVwiKX19LE9jPShlLHQsbik9Pnt0LmV2ZXJ5KG89Pm8+PTAmJm88bnx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFua1wiKX0pKTtsZXQgcj1uZXcgQXJyYXkobikuZmlsbCgxKTtyZXR1cm4gdC5mb3JFYWNoKChvLGkpPT5yW29dPWVbaV0pLHJ9LE1jPShlLHQsbixyLG8saSk9PntsZXRbcyxhLHVdPW4+MTA/WzEsMiwzXTpbLTEsZS5sZW5ndGg+MT8xOi0xLC0xXSxkPWVbMF0uZGltcy5sZW5ndGg7aWYocz4wJiZlLmxlbmd0aD5zJiZlW3NdLmRpbXMubGVuZ3RoPjApZVtzXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKGw9PmkucHVzaChsKSk7ZWxzZSBpZih0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZVwiKTtpZihhPjAmJmUubGVuZ3RoPmEmJmVbYV0uZGltcy5sZW5ndGg9PT0xJiZlW2FdLmRpbXNbMF0+MCl7aWYoZVthXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKGw9PnIucHVzaChsKSksci5sZW5ndGghPT0wJiZyLmxlbmd0aCE9PWQmJm4+PTE4JiZyLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtEYyhyLHQpLHQuYXhlcy5sZW5ndGg+MCYmT2Mocix0LmF4ZXMsZCkuZm9yRWFjaCgobCxjKT0+cltjXT1sKX1pZih1PjAmJmUubGVuZ3RoPnUmJmVbdV0uZGltcy5sZW5ndGg9PT0xJiZlW3VdLmRpbXNbMF0+MCYmKGVbdV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobD0+by5wdXNoKE51bWJlcihsKSkpLG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT1kJiZuPj0xOCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihyLmxlbmd0aCE9PTAmJnIubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO2lmKG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpfWlmKHR5cGVvZiByPFwidVwiJiZ0eXBlb2YgbzxcInVcIiYmci5sZW5ndGg+MCYmby5sZW5ndGg+ZCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkXCIpfSxKYT0oZSx0LG4scik9PmBcbiAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xuICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cbiAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxuICBsZXQgYmlnID0gKCR7ZX0pICogKCR7dH0pO1xuICBsZXQgd2hvbGUgPSAke3J9KGJpZyAvICgke259KSk7XG4gIGxldCBmcmFjdCA9ICR7cn0oYmlnICUgKCR7bn0pKSAvICR7cn0oJHtufSk7XG4gIHJldHVybiB3aG9sZSArIGZyYWN0O1xuYCxVYz0oZSx0KT0+YGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHt0fSB7IGArKCgpPT57c3dpdGNoKGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHhTY2FsZSA8IDEuMCB8fCBmbG9vcih4U2NhbGUpICE9IHhTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuICR7dH0oeFJlc2l6ZWQpIC8gJHt0fSh4U2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke0phKFwieFJlc2l6ZWRcIixcImxlbmd0aE9yaWdpbmFsXCIsXCJsZW5ndGhSZXNpemVkXCIsdCl9XG4gICAgICAgICAgfVxuICAgICAgICBgO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5gcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR7SmEoXCJ4UmVzaXplZFwiLFwibGVuZ3RoT3JpZ2luYWwgLSAxXCIsXCJsZW5ndGhSZXNpemVkIC0gMVwiLHQpfVxuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfY3JvcF9hbmRfcmVzaXplXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHt0fShyb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7dH0oeFJlc2l6ZWQpICogJHt0fShyb2lFbmQgLSByb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7dH0ocm9pU3RhcnQgKyByb2lFbmQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwiaGFsZl9waXhlbF9zeW1tZXRyaWNcIjpyZXR1cm5gY29uc3Qgb3V0cHV0V2lkdGggPSAke3R9eFNjYWxlICogJHt0fShsZW5ndGhSZXNpemVkKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSAke3R9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke3R9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2Nhc2VcImhhbGZfcGl4ZWxcIjpyZXR1cm5gcmV0dXJuICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsUmM9KGUsdCxuKT0+YGZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6ICR7bn0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtufSB7YCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwicm91bmRfcHJlZmVyX2NlaWxcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICB9XCI7Y2FzZVwiZmxvb3JcIjpyZXR1cm5cInJldHVybiBmbG9vcih4T3JpZ2luYWwpO1wiO2Nhc2VcImNlaWxcIjpyZXR1cm5cInJldHVybiBjZWlsKHhPcmlnaW5hbCk7XCI7Y2FzZVwicm91bmRfcHJlZmVyX2Zsb29yXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInNpbXBsZVwiOmRlZmF1bHQ6aWYodDwxMSlyZXR1cm5cImlmIChpc0Rvd25TYW1wbGUpICAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgICAgICAgICAgICAgICAgICAgICB9XCI7dGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixWYz0oZSx0LG4pPT57bGV0IHI9bmV3IEFycmF5KG4pLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShuKS5maWxsKDEpKSxvPWUubGVuZ3RoPT09MD9yOmUuc2xpY2UoKTtyZXR1cm4gdC5sZW5ndGg+MD8odC5mb3JFYWNoKChpLHMpPT57cltpXT1vW3NdLHJbcytuXT1vW3QubGVuZ3RoK3NdfSkscik6b30sTmM9KGUsdCxuLHIpPT57bGV0IG89W107aWYobi5sZW5ndGg+MClpZihyLmxlbmd0aD4wKXtpZihlLmZvckVhY2goaT0+by5wdXNoKGkpKSxNYXRoLm1heCguLi5yKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzIGlzIG91dCBvZiBib3VuZFwiKTtyLmZvckVhY2goKGkscyk9Pm9baV09bltzXSl9ZWxzZSBuLmZvckVhY2goaT0+by5wdXNoKGkpKTtlbHNle2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy5cIik7bz1lLm1hcCgoaSxzKT0+TWF0aC5yb3VuZChpKnRbc10pKX1yZXR1cm4gb30sTGM9KGUsdCxuKT0+e2xldCByPSgoKT0+e3N3aXRjaChuLmtlZXBBc3BlY3RSYXRpb1BvbGljeSl7Y2FzZVwibm90X2xhcmdlclwiOnJldHVybiBuLmF4ZXMubGVuZ3RoPjA/TWF0aC5taW4oLi4ubi5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUFYX1ZBTFVFKTpNYXRoLm1pbiguLi50LE51bWJlci5NQVhfVkFMVUUpO2Nhc2VcIm5vdF9zbWFsbGVyXCI6cmV0dXJuIG4uYXhlcy5sZW5ndGg+MD9NYXRoLm1heCguLi5uLmF4ZXMubWFwKGk9PnRbaV0pLE51bWJlci5NSU5fVkFMVUUpOk1hdGgubWF4KC4uLnQsTnVtYmVyLk1JTl9WQUxVRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke24ua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKTt0LmZpbGwoMSwwLHQubGVuZ3RoKTtsZXQgbz1lLnNsaWNlKCk7cmV0dXJuIG4uYXhlcy5sZW5ndGg+MD8obi5heGVzLmZvckVhY2goaT0+dFtpXT1yKSxuLmF4ZXMuZm9yRWFjaChpPT5vW2ldPU1hdGgucm91bmQoZVtpXSp0W2ldKSkpOih0LmZpbGwociwwLHQubGVuZ3RoKSxvLmZvckVhY2goKGkscyk9Pm9bc109TWF0aC5yb3VuZChpKnRbc10pKSksb30sV2M9KGUsdCxuLHIsbyk9PmBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtuLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7bi5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke08oXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixyKX07XG4gICAgICAgIHZhciByb2lfbG93ID0gJHtPKFwidW5pZm9ybXMucm9pXCIsXCJpXCIsbyl9O1xuICAgICAgICB2YXIgcm9pX2hpID0gJHtPKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3QubGVuZ3RofWAsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9ICR7ZS50eXBlLnZhbHVlfShvdXRwdXRfaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtPKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7TyhcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xuICAgIH1gLEdjPShlLHQsbixyLG8saSxzKT0+YFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRleDogdTMyO1xuICAgICAgICB2YXIgc2NhbGUgPSAke08oXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixvKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7TyhcInVuaWZvcm1zLnJvaVwiLFwiaVwiLGkpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtPKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke24ubGVuZ3RofWAsaSl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtPKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7TyhcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgICAgaWYgKCEke3N9IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgfWAsSGM9KGUsdCk9PmBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtPKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9YCxldT0oZSx0LG4scik9PmUucmFuaz5yP2BcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIix0LFwiY2hhbm5lbFwiKX07XG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbixcImJhdGNoXCIpfTtcbmA6XCJcIixxYz0oZSx0LG4scixvKT0+e2xldFtzLGEsdSxkXT1uLmxlbmd0aD09PTI/Wy0xLDAsMSwtMV06WzAsMiwzLDFdLGw9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiAke2x9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGEsYG1heCgwLCBtaW4ocm93LCAke25bYV19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdSxgbWF4KDAsIG1pbihjb2wsICR7blt1XX0gLSAxKSlgKX07XG4gICAgICAke2V1KGUsZCxzLDIpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2x9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7bH0gPSBvcmlnaW5hbEluZGljZXNbJHthfV07XG4gICAgICB2YXIgY29sOiR7bH0gPSBvcmlnaW5hbEluZGljZXNbJHt1fV07XG4gICAgICAke3I/YGlmIChyb3cgPCAwIHx8IHJvdyA+ICgke25bYV19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtuW3VdfSAtIDEpKSB7XG4gICAgICAgIHJldHVybiAke299O1xuICAgICAgfWA6XCJcIn07XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtuW2FdfSAtIDEpKTtcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke25bdV19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtuLmxlbmd0aD4yP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7ZH1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtuLmxlbmd0aD4yP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7c31dKWA6XCIwXCJ9O1xuICAgICAgdmFyIHgxMTogJHtsfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xuICAgICAgdmFyIHgxMjogJHtsfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xuICAgICAgdmFyIHgyMTogJHtsfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogJHtsfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xuICAgICAgdmFyIGR4MTogJHtsfSA9IGFicyhyb3cgLSAke2x9KHJvdzEpKTtcbiAgICAgIHZhciBkeDI6ICR7bH0gPSBhYnMoJHtsfShyb3cyKSAtIHJvdyk7XG4gICAgICB2YXIgZHkxOiAke2x9ID0gYWJzKGNvbCAtICR7bH0oY29sMSkpO1xuICAgICAgdmFyIGR5MjogJHtsfSA9IGFicygke2x9KGNvbDIpIC0gY29sKTtcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gfSxGYz0oZSx0LG4scixvLGkscyxhLHUsZCk9PntsZXQgbD1uLmxlbmd0aD09PTIsYz0hMCxbcCxmXT1sP1swLDFdOmM/WzIsM106WzEsMl0sbT1lLnR5cGUudmFsdWUsaD1iPT57bGV0IHk9Yj09PXA/XCJyb3dcIjpcImNvbFwiO3JldHVybmBcbiAgICAgIGZuICR7eX1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsYil9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6ICR7bX0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke29bYl19LFxuICAgICAgICAke3JbYl19LCAke25bYl19LCAke2lbYl19LCAke2lbYl19ICsgJHtuLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHttfSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHthfSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7bltiXX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHt1fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YTogYXJyYXk8JHttfSwgND4gPSBhcnJheTwke219LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAke3l9OiAke219ID0gb3JpZ2luYWxJZHggKyAke219KGkpO1xuICAgICAgICAgIGlmICgke3l9IDwgMCB8fCAke3l9ID49ICR7bltiXX0pIHtcbiAgICAgICAgICAgICR7ZD9gY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDphP2ByZXR1cm4gJHt1fTtgOmAke3l9ID0gbWF4KDAsIG1pbigke3l9LCAke25bYl19IC0gMSkpO2B9O1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtlLnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc19jb3B5XCIsYixgdTMyKCR7eX0pYCl9O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHtiPT09cD9lLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNfY29weVwiKTpcInJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKVwifTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWB9O3JldHVybmBcbiAgICAke2gocCl9O1xuICAgICR7aChmKX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7bX0pIC0+IGFycmF5PCR7bX0sIDQ+IHtcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcbiAgICB2YXIgY29lZmZzOiBhcnJheTwke219LCA0PiA9IGFycmF5PCR7bX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHttfSA9IDEuMCAtIGFic1M7XG4gICAgdmFyIHR3b01pbnVzQWJzUzogJHttfSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke219ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7c30gKiBvbmVQbHVzQWJzUyAtIDUgKiAke3N9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7c30pICogb25lUGx1c0Fic1MgLSA0ICogJHtzfTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7c30gKyAyKSAqIGFic1MgLSAoJHtzfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7c30gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke3N9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7c30gKiB0d29NaW51c0Fic1MgLSA1ICogJHtzfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHtzfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtzfTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHttfSwgND4sIGNvZWZzOiBhcnJheTwke219LCA0PikgLT4gJHttfSB7XG4gICAgdmFyIGNvZWZzU3VtOiAke219ID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xuICB9XG5cbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke219IHtcbiAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGB9LEtjPShlLHQsbixyLG8pPT57bGV0W3MsYSx1LGQsbF09bi5sZW5ndGg9PT0zP1stMSwwLDEsMiwtMV06WzAsMiwzLDQsMV0sYz1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBkZXB0aDp1MzIsIGhlaWdodDogdTMyLCB3aWR0aDogdTMyKSAtPiAke2N9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGEsYG1heCgwLCBtaW4oZGVwdGgsICR7blthXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIix1LGBtYXgoMCwgbWluKGhlaWdodCwgJHtuW3VdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsYG1heCgwLCBtaW4od2lkdGgsICR7bltkXX0gLSAxKSlgKX07XG4gICAgICAke2V1KGUsbCxzLDMpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtjfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7Y30gPSBvcmlnaW5hbEluZGljZXNbJHthfV07XG4gICAgICB2YXIgaGVpZ2h0OiR7Y30gPSBvcmlnaW5hbEluZGljZXNbJHt1fV07XG4gICAgICB2YXIgd2lkdGg6JHtjfSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgICR7cj9gaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke25bYV19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtuW3VdfSAtIDEpIHx8IHdpZHRoIDwgMCB8fCAod2lkdGggPiAke25bZF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke299O1xuICAgICAgICB9YDpcIlwifTtcblxuICAgIGRlcHRoID0gbWF4KDAsIG1pbihkZXB0aCwgJHtuW2FdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke25bdV19IC0gMSkpO1xuICAgICAgd2lkdGggPSBtYXgoMCwgbWluKHdpZHRoLCAke25bZF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke24ubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHtsfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke24ubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHtzfV0pYDpcIjBcIn07XG5cbiAgICAgIHZhciB4MTExOiAke2N9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMTI6ICR7Y30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDEyMTogJHtjfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke2N9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMTE6ICR7Y30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIxMjogJHtjfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke2N9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMjI6ICR7Y30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgZHgxOiAke2N9ID0gYWJzKGRlcHRoIC0gJHtjfShkZXB0aDEpKTtcbiAgICAgIHZhciBkeDI6ICR7Y30gPSBhYnMoJHtjfShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHtjfSA9IGFicyhoZWlnaHQgLSAke2N9KGhlaWdodDEpKTtcbiAgICAgIHZhciBkeTI6ICR7Y30gPSBhYnMoJHtjfShoZWlnaHQyKSAtIGhlaWdodCk7XG4gICAgICB2YXIgZHoxOiAke2N9ID0gYWJzKHdpZHRoIC0gJHtjfSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7Y30gPSBhYnMoJHtjfSh3aWR0aDIpIC0gd2lkdGgpO1xuICAgICAgaWYgKGRlcHRoMSA9PSBkZXB0aDIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0MSA9PSBoZWlnaHQyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcbiAgICAgICAgZHoxID0gMC41O1xuICAgICAgICBkejIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMTEgKiBkeDIgKiBkeTIgKiBkejIgKyB4MTEyICogZHgyICogZHkyICogZHoxICsgeDEyMSAqIGR4MiAqIGR5MSAqZHoyICsgeDEyMiAqIGR4MiAqIGR5MSAqIGR6MSArXG4gICAgICAgICAgICAgIHgyMTEgKiBkeDEgKiBkeTIgKiBkejIgKyB4MjEyICogZHgxICogZHkyICogZHoxICsgeDIyMSAqIGR4MSAqIGR5MSAqZHoyICsgeDIyMiAqIGR4MSAqIGR5MSAqIGR6MSk7XG4gICAgfWB9LGpjPShlLHQsbixyLG8saSk9PntsZXQgcz1lLmRpbXMsYT1WYyhpLHQuYXhlcyxzLmxlbmd0aCksdT1OYyhzLHIsbyx0LmF4ZXMpLGQ9ci5zbGljZSgpO3IubGVuZ3RoPT09MCYmKGQ9cy5tYXAoKGcsXyk9Pmc9PT0wPzE6dVtfXS9nKSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYodT1MYyhzLGQsdCkpKTtsZXQgbD1DKFwib3V0cHV0XCIsZS5kYXRhVHlwZSx1Lmxlbmd0aCksYz1TKFwiaW5wdXRcIixlLmRhdGFUeXBlLHMubGVuZ3RoKSxwPXguc2l6ZSh1KSxmPXMubGVuZ3RoPT09dS5sZW5ndGgmJnMuZXZlcnkoKGcsXyk9Pmc9PT11W19dKSxtPXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLGg9dC5leHRyYXBvbGF0aW9uVmFsdWUsYj1jLnR5cGUudmFsdWUseT1nPT5gXG4gICAgICAke2Y/XCJcIjpgXG4gICAgICAke1VjKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsYil9O1xuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke0hjKGMscyl9O1xuICAgICAgICAgICAgICAke1JjKHQubmVhcmVzdE1vZGUsbixiKX07XG4gICAgICAgICAgICAgICR7R2MoYyxsLHMsdSxkLmxlbmd0aCxhLmxlbmd0aCxtKX07XG4gICAgICAgICAgICAgIGA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke1djKGwscyx1LGQubGVuZ3RoLGEubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpPT57aWYocy5sZW5ndGg9PT0yfHxzLmxlbmd0aD09PTQpcmV0dXJuYCR7cWMoYyxsLHMsbSxoKX1gO2lmKHMubGVuZ3RoPT09M3x8cy5sZW5ndGg9PT01KXJldHVybmAke0tjKGMsbCxzLG0saCl9YDt0aHJvdyBFcnJvcihcIkxpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2Nhc2VcImN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgICAgJHsoKCk9PntpZihzLmxlbmd0aD09PTJ8fHMubGVuZ3RoPT09NClyZXR1cm5gJHtGYyhjLGwscyx1LGQsYSx0LmN1YmljQ29lZmZBLG0sdC5leHRyYXBvbGF0aW9uVmFsdWUsdC5leGNsdWRlT3V0c2lkZSl9YDt0aHJvdyBFcnJvcihcIkN1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS5cIil9KSgpfTtcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XG4gICAgICBgfVxuICAgICAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2NhbGVzXCIsXCJmMzJcIixkLmxlbmd0aCkucmVnaXN0ZXJVbmlmb3JtKFwicm9pXCIsXCJmMzJcIixhLmxlbmd0aCkuZGVjbGFyZVZhcmlhYmxlcyhjLGwpfVxuICAgICAgJHtnLm1haW5TdGFydCgpfVxuICAgICAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAke2Y/XCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcIjpgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7bC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7Yy50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7Yy5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7cy5sZW5ndGg9PT0yfHxzLmxlbmd0aD09PTQ/XCJiaWxpbmVhckludGVycG9sYXRpb25cIjpcInRyaWxpbmVhckludGVycG9sYXRpb25cIn0ob3V0cHV0X2luZGljZXMpO2A7Y2FzZVwiY3ViaWNcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTtcIjtkZWZhdWx0OnRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHt0Lm1vZGV9YCl9fSkoKX07XG5gfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke259fCR7ZC5sZW5ndGg+MD90Lm1vZGU9PT1cImN1YmljXCI/ZDpkLmxlbmd0aDpcIlwifXwke28ubGVuZ3RoPjA/bzpcIlwifXwke2EubGVuZ3RoPjA/YTpcIlwifXwke2Z9fCR7dC5tb2RlPT09XCJuZWFyZXN0XCI/cy5sZW5ndGg6c31gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp5LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6ZH0se3R5cGU6MSxkYXRhOmF9LC4uLlAocyx1KV19KX19LFpjPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sdHU9KGUsdCk9PntsZXQgbj1bXSxyPVtdLG89W10saT1aYyhlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTtNYyhlLmlucHV0cyx0LGksbixyLG8pLGUuY29tcHV0ZShqYyhlLmlucHV0c1swXSx0LGksbixyLG8pLHtpbnB1dHM6WzBdfSl9LG51PWU9PntsZXQgdD1lLmFudGlhbGlhcyxuPWUuYXhlcyxyPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbz1lLmN1YmljQ29lZmZBLGk9ZS5leGNsdWRlT3V0c2lkZSE9PTAscz1lLmV4dHJhcG9sYXRpb25WYWx1ZSxhPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LHU9ZS5tb2RlLGQ9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiBOKHthbnRpYWxpYXM6dCxheGVzOm4sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6cixjdWJpY0NvZWZmQTpvLGV4Y2x1ZGVPdXRzaWRlOmksZXh0cmFwb2xhdGlvblZhbHVlOnMsa2VlcEFzcGVjdFJhdGlvUG9saWN5OmEsbW9kZTp1LG5lYXJlc3RNb2RlOmR9KX19KTt2YXIgUWMsWGMsb3UsaXU9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtxKCk7SygpO1FjPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0sbj1lWzFdLHI9ZVsyXTtpZih0LmRhdGFUeXBlIT09bi5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PXIuZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG89dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0saT10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihuLmRpbXNbbi5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYobi5kaW1zW24uZGltcy5sZW5ndGgtMl0hPT1pKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihyLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IHM9ZVszXTtpZihzLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYocy5kaW1zW3MuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCBzPWVbNF07aWYocy5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKHMuZGltc1tzLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFhjPShlLHQsbixyKT0+e2xldCBvPXQuc2ltcGxpZmllZCxpPWVbMF0uZGltcyxzPXguc2l6ZShpKSxhPWksdT1zLGQ9aS5zbGljZSgtMSlbMF0sbD1yP2kuc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLGM9IW8mJmUubGVuZ3RoPjMscD1lLmxlbmd0aD40LGY9ciYmbj4xLG09ciYmbj4yLGg9bj4zLGI9NjQseT1YKGQpLGc9W3t0eXBlOjEyLGRhdGE6dX0se3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XSxfPXY9PntsZXQgJD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJjb21wb25lbnRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XSxUPVtTKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHkpLFMoXCJza2lwXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMseSksUyhcImdhbW1hXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMseSldO2MmJlQucHVzaChTKFwiYmV0YVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLHkpKSxwJiZULnB1c2goUyhcImJpYXNcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyx5KSksVC5wdXNoKEMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGEseSkpLGYmJlQucHVzaChDKFwibWVhbl9vdXRwdXRcIiwxLGwpKSxtJiZULnB1c2goQyhcImludl9zdGRfb3V0cHV0XCIsMSxsKSksaCYmVC5wdXNoKEMoXCJpbnB1dF9za2lwX2JpYXNfc3VtXCIsZVswXS5kYXRhVHlwZSxhLHkpKTtsZXQgST1yZShlWzBdLmRhdGFUeXBlKSxBPXJlKDEseSk7cmV0dXJuYFxuXG4gICAgICAke3YucmVnaXN0ZXJVbmlmb3JtcygkKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7QX0sICR7Yn0+O1xuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NxdWFyZWRfc2hhcmVkIDogYXJyYXk8JHtBfSwgJHtifT47XG5cbiAgICAgICR7di5tYWluU3RhcnQoW2IsMSwxXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHtifTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7Yn07XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke2ItMX0pIHtcbiAgICAgICAgICBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC0gc3RyaWRlICogaXg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNraXBfdmFsdWUgPSBza2lwW29mZnNldCArIGldO1xuICAgICAgICAgIGxldCBiaWFzX3ZhbHVlID0gJHtwP1wiYmlhc1tvZmZzZXQxZCArIGldXCI6SStcIigwLjApXCJ9O1xuICAgICAgICAgIGxldCBpbnB1dF92YWx1ZSA9IHhbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRfdmFsdWUgKyBza2lwX3ZhbHVlICsgYmlhc192YWx1ZTtcbiAgICAgICAgICAke2g/XCJpbnB1dF9za2lwX2JpYXNfc3VtW29mZnNldCArIGldID0gdmFsdWU7XCI6XCJcIn1cbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcbiAgICAgICAgICBsZXQgZjMyX3ZhbHVlID0gJHtKZShJLHksXCJ2YWx1ZVwiKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke2J9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke1RlKFwic3VtXCIseSl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtUZShcInNxdWFyZV9zdW1cIix5KX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7bz9cIlwiOlwiLSBtZWFuICogbWVhblwifSArIHVuaWZvcm1zLmVwc2lsb24pO1xuICAgICAgICAke2Y/XCJtZWFuX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW47XCI6XCJcIn1cbiAgICAgICAgJHttP1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjtcIjpcIlwifVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtvP1wiXCI6YC0gJHtJfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke0l9KGludl9zdGRfZGV2KSAqIGdhbW1hW29mZnNldDFkICsgaV1cbiAgICAgICAgICAgICR7Yz9cIisgYmV0YVtvZmZzZXQxZCArIGldXCI6XCJcIn07XG4gICAgICAgIH1cbiAgICAgIH1gfSx3PVt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gbj4xJiZ3LnB1c2goe2RpbXM6bCxkYXRhVHlwZToxfSksbj4yJiZ3LnB1c2goe2RpbXM6bCxkYXRhVHlwZToxfSksbj4zJiZ3LnB1c2goe2RpbXM6aSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSkse25hbWU6XCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eX07JHtmfTske219OyR7aH1gLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKCh2LCQpPT5cInR5cGVcIil9LGdldFNoYWRlclNvdXJjZTpfLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czp3LGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvZCl9LHByb2dyYW1Vbmlmb3JtczpnfSl9fSxvdT0oZSx0KT0+e1FjKGUuaW5wdXRzKTtsZXQgcj1bMF07ZS5vdXRwdXRDb3VudD4xJiZyLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MiYmci5wdXNoKC0zKSxlLm91dHB1dENvdW50PjMmJnIucHVzaCgzKSxlLmNvbXB1dGUoWGMoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50LCExKSx7b3V0cHV0czpyfSl9fSk7dmFyIFljLG1uLEpjLHN1LGVwLHRwLGF1LHV1LGR1PWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7SygpO1ljPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7aWYodC5heGVzLmxlbmd0aCE9PTApe2lmKHQuYXhlcy5sZW5ndGghPT10LnN0YXJ0cy5sZW5ndGh8fHQuYXhlcy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpfWVsc2UgaWYodC5zdGFydHMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtlLnNsaWNlKDEpLmZvckVhY2goKG4scik9PntpZihlW3IrMV0uZGF0YVR5cGUhPT02JiZlW3IrMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtyfSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCl9KX0sbW49KGUsdCk9PntsZXQgbj1bXTtpZihlLmxlbmd0aD50KWlmKGVbdF0uZGF0YVR5cGU9PT03KWVbdF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gocj0+bi5wdXNoKE51bWJlcihyKSkpO2Vsc2UgaWYoZVt0XS5kYXRhVHlwZT09PTYpZVt0XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaChyPT5uLnB1c2goTnVtYmVyKHIpKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO3JldHVybiBufSxKYz0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCBuPW1uKGUsMSkscj1tbihlLDIpLG89bW4oZSwzKTtyZXR1cm4gby5sZW5ndGg9PT0wJiYobz1bLi4uQXJyYXkoZVswXS5kaW1zLmxlbmd0aCkua2V5cygpXSksTih7c3RhcnRzOm4sZW5kczpyLGF4ZXM6b30pfWVsc2UgcmV0dXJuIHR9LHN1PShlLHQsbixyLG8pPT57bGV0IGk9ZTtyZXR1cm4gZTwwJiYoaSs9bltyW3RdXSksb1t0XTwwP01hdGgubWF4KDAsTWF0aC5taW4oaSxuW3JbdF1dLTEpKTpNYXRoLm1heCgwLE1hdGgubWluKGksbltyW3RdXSkpfSxlcD0oZSx0LG4pPT5gZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtuLmxlbmd0aC0xfTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtPKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke08oXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7TyhcInVuaWZvcm1zLnNpZ25zXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7TyhcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWAsdHA9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj14LnNpemUobiksbz10LmF4ZXMubGVuZ3RoPjA/eC5ub3JtYWxpemVBeGVzKHQuYXhlcyxuLmxlbmd0aCk6Wy4uLkFycmF5KG4ubGVuZ3RoKS5rZXlzKCldLGk9bW4oZSw0KTtpLmZvckVhY2goeT0+eSE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSksaS5sZW5ndGg9PT0wJiYoaT1BcnJheShvLmxlbmd0aCkuZmlsbCgxKSk7bGV0IHM9dC5zdGFydHMubWFwKCh5LGcpPT5zdSh5LGcsbixvLGkpKSxhPXQuZW5kcy5tYXAoKHksZyk9PnN1KHksZyxuLG8saSkpO2lmKG8ubGVuZ3RoIT09cy5sZW5ndGh8fG8ubGVuZ3RoIT09YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO2lmKG8ubGVuZ3RoIT09bi5sZW5ndGgpZm9yKGxldCB5PTA7eTxuLmxlbmd0aDsrK3kpby5pbmNsdWRlcyh5KXx8KHMuc3BsaWNlKHksMCwwKSxhLnNwbGljZSh5LDAsblt5XSksaS5zcGxpY2UoeSwwLDEpKTtsZXQgdT1pLm1hcCh5PT5NYXRoLnNpZ24oeSkpO2kuZm9yRWFjaCgoeSxnLF8pPT57aWYoeTwwKXtsZXQgdz0oYVtnXS1zW2ddKS95LHY9c1tnXSwkPXYrdyppW2ddO3NbZ109JCxhW2ddPXYsX1tnXT0teX19KTtsZXQgZD1uLnNsaWNlKDApO28uZm9yRWFjaCgoeSxnKT0+e2RbeV09TWF0aC5jZWlsKChhW3ldLXNbeV0pL2lbeV0pfSk7bGV0IGw9e2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSxjPUMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKSxwPVMoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksZj14LnNpemUoZCksbT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0c1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6cy5sZW5ndGh9LHtuYW1lOlwic2lnbnNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOnUubGVuZ3RofSx7bmFtZTpcInN0ZXBzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDppLmxlbmd0aH1dLGg9W3t0eXBlOjEyLGRhdGE6Zn0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZTo2LGRhdGE6dX0se3R5cGU6MTIsZGF0YTppfSwuLi5QKGVbMF0uZGltcyxkKV0sYj15PT5gXG4gICAgICAke3kucmVnaXN0ZXJVbmlmb3JtcyhtKS5kZWNsYXJlVmFyaWFibGVzKHAsYyl9XG4gICAgICAgICR7ZXAocCxjLG4pfVxuICAgICAgICAke3kubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Yy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHtjLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHAuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dS5sZW5ndGh9XyR7cy5sZW5ndGh9XyR7aS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6YixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W2xdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sYXU9KGUsdCk9PntZYyhlLmlucHV0cyx0KTtsZXQgbj1KYyhlLmlucHV0cyx0KTtlLmNvbXB1dGUodHAoZS5pbnB1dHMsbikse2lucHV0czpbMF19KX0sdXU9ZT0+e2xldCB0PWUuc3RhcnRzLG49ZS5lbmRzLHI9ZS5heGVzO3JldHVybiBOKHtzdGFydHM6dCxlbmRzOm4sYXhlczpyfSl9fSk7dmFyIG5wLHJwLGx1LGN1LHB1PWsoKCk9PntcInVzZSBzdHJpY3RcIjtWKCk7cSgpO2llKCk7VmUoKTtLKCk7bnA9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0scnA9KGUsdCk9PntsZXQgbj1lLmlucHV0c1swXSxyPW4uZGltcyxvPXguc2l6ZShyKSxpPXIubGVuZ3RoLHM9eC5ub3JtYWxpemVBeGlzKHQuYXhpcyxpKSxhPXM8ci5sZW5ndGgtMSx1LGQ9W107YT8oZD1BcnJheS5mcm9tKHtsZW5ndGg6aX0sKFQsSSk9PkkpLGRbc109aS0xLGRbaS0xXT1zLHU9ZS5jb21wdXRlKHBlKG4sZCkse2lucHV0czpbbl0sb3V0cHV0czpbLTFdfSlbMF0pOnU9bjtsZXQgbD11LmRpbXMsYz1sW2ktMV0scD1vL2MsZj1YKGMpLG09Yy9mLGg9NjQ7cD09PTEmJihoPTI1Nik7bGV0IGI9KFQsSSk9Pkk9PT00P2BtYXgobWF4KCR7VH0ueCwgJHtUfS55KSwgbWF4KCR7VH0ueiwgJHtUfS53KSlgOkk9PT0yP2BtYXgoJHtUfS54LCAke1R9LnkpYDpJPT09Mz9gbWF4KG1heCgke1R9LngsICR7VH0ueSksICR7VH0ueilgOlQseT1TKFwieFwiLHUuZGF0YVR5cGUsdS5kaW1zLGYpLGc9QyhcInJlc3VsdFwiLHUuZGF0YVR5cGUsdS5kaW1zLGYpLF89eS50eXBlLnZhbHVlLHc9cmUodS5kYXRhVHlwZSk9PT1cImYzMlwiP2B2YXIgdGhyZWFkTWF4ID0gJHtffSgtMy40MDI4MjNlKzM4Zik7YDpgdmFyIHRocmVhZE1heCA9ICR7X30oLTY1NTA0LjBoKTtgLHY9VD0+YFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93TWF4U2hhcmVkIDogJHtffTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7X307XG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke199LCAke2h9PjtcblxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7X30ge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXR1cm4geFtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZuIHNldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyLCB2YWx1ZTogJHtffSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke1QucmVnaXN0ZXJVbmlmb3JtKFwicGFja2VkQ29sc1wiLFwiaTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxnKX1cbiAgICAgICR7VC5tYWluU3RhcnQoaCl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke2h9O1xuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XG4gICAgICAgIGxldCBjb2xzID0gdW5pZm9ybXMucGFja2VkQ29scztcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XG4gICAgICAgICR7d31cbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHtffSgke2IoXCJ0aHJlYWRTaGFyZWRbMF1cIixmKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHtffSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHtffSgke1RlKFwidGhyZWFkU2hhcmVkWzBdXCIsZil9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHJvd1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xuICAgICAgICAgIC8vIG1heCBvcGVyYXRpb24gcHJvdGVjdHMgYWdhaW5zdCBOYU4gc2luY2UgYWxsIHZhbHVlcyBzaG91bGQgYmUgPj0wXG4gICAgICAgICAgdmFsdWUgPSBtYXgodmFsdWUsICR7X30oMC4wKSk7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWAsJD1lLmNvbXB1dGUoe25hbWU6XCJTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7Zn07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOnUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnB9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6NixkYXRhOm19XX0pLGdldFNoYWRlclNvdXJjZTp2fSx7aW5wdXRzOlt1XSxvdXRwdXRzOlthPy0xOjBdfSlbMF07YSYmZS5jb21wdXRlKHBlKCQsZCkse2lucHV0czpbJF19KX0sbHU9KGUsdCk9PntucChlLmlucHV0cykscnAoZSx0KX0sY3U9ZT0+Tih7YXhpczplLmF4aXN9KX0pO3ZhciBtdSxvcCxpcCxzcCxmdSxodT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7bXU9ZT0+QXJyYXkuZnJvbShlLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG9wPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09MTAmJmVbMF0uZGF0YVR5cGUhPT02JiZlWzBdLmRhdGFUeXBlIT09MTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGZsb2F0MTYsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXNcIik7aWYoZVsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZVwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EXCIpO2lmKG11KGVbMV0pLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvclwiKX0saXA9KGUsdCk9PntsZXQgbj1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrciluLnB1c2goZVtyXSp0W3JdKTtyZXR1cm4gbn0sc3A9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj10Pz9tdShlWzFdKSxvPWlwKG4sciksaT14LnNpemUobykscz1lWzBdLmRhdGFUeXBlLGE9UyhcImlucHV0XCIscyxuLmxlbmd0aCksdT1DKFwib3V0cHV0XCIscyxvLmxlbmd0aCksZD1sPT5gXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHthLmluZGljZXMoLi4ubil9O1xuICAgICAgJHtsLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhhLHUpfVxuICAgICAgJHtsLm1haW5TdGFydCgpfVxuICAgICAgJHtsLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2EuaW5kaWNlc0dldChcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIpfTtcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7dS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9ICAlIGlucHV0X2RpbV9pO1xuXG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfZGltX3ZhbHVlXCIpfVxuICAgICAgfVxuICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGEuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgfWA7cmV0dXJue25hbWU6XCJUaWxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTppfSwuLi5QKGVbMF0uZGltcyxvKV19KSxnZXRTaGFkZXJTb3VyY2U6ZH19LGZ1PWU9PntvcChlLmlucHV0cyksZS5jb21wdXRlKHNwKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBhcCx1cCxndSx5dT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VigpO3EoKTtLKCk7YXA9KGUsdCxuLHIsbyk9PntsZXQgaT1DKFwib3V0cHV0X2RhdGFcIixvLG4ubGVuZ3RoLDQpLHM9UyhcImFfZGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLmxlbmd0aCw0KSxhPVMoXCJiX2RhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcy5sZW5ndGgsNCksdT1TKFwiY19kYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMubGVuZ3RoLDQpLGQsbD0oYyxwLGYpPT5gc2VsZWN0KCR7cH0sICR7Y30sICR7Zn0pYDtpZighcilkPWkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbChzLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxhLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSx1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IGM9KHAsZixtPVwiXCIpPT57bGV0IGg9YGFfZGF0YVtpbmRleF9hJHtmfV1bY29tcG9uZW50X2Eke2Z9XWAsYj1gYl9kYXRhW2luZGV4X2Ike2Z9XVtjb21wb25lbnRfYiR7Zn1dYCx5PWBib29sKGNfZGF0YVtpbmRleF9jJHtmfV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHtmfSAqIDgpKSlgO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7Zn0gPSAke2kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke2Z9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7Zn0gPSAke3MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtmfWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHtmfSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke2Z9YCxpKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke2Z9ID0gJHt1LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7Zn1gLGkpfTtcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHtmfSA9IG9mZnNldF9hJHtmfSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Ike2Z9ID0gb2Zmc2V0X2Ike2Z9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7Zn0gPSBvZmZzZXRfYyR7Zn0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7Zn0gPSBvZmZzZXRfYSR7Zn0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7Zn0gPSBvZmZzZXRfYiR7Zn0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7Zn0gPSBvZmZzZXRfYyR7Zn0gJSA0dTtcbiAgICAgICAgICAgICR7cH1bJHtmfV0gPSAke219KCR7bChoLGIseSl9KTtcbiAgICAgICAgICBgfTtvPT09OT9kPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtjKFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2MoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7YyhcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtjKFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOmQ9YFxuICAgICAgICAgICAgJHtjKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7YyhcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke2MoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHtjKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh1LHMsYSxpKX1cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAke2R9XG4gICAgICB9YH0sdXA9ZT0+e2xldCB0PWVbMV0uZGltcyxuPWVbMl0uZGltcyxyPWVbMF0uZGltcyxvPWVbMV0uZGF0YVR5cGUsaT0hKHguYXJlRXF1YWwodCxuKSYmeC5hcmVFcXVhbChuLHIpKSxzPXQsYT14LnNpemUodCk7aWYoaSl7bGV0IGQ9UGUuY2FsY1NoYXBlKFBlLmNhbGNTaGFwZSh0LG4sITEpLHIsITEpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7cz1kLGE9eC5zaXplKHMpfWxldCB1PU1hdGguY2VpbChhLzQpO3JldHVybntuYW1lOlwiV2hlcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmQ9PmFwKGQsZSxzLGksbyksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6dX0sLi4uUChyLHQsbixzKV19KX19LGd1PWU9PntlLmNvbXB1dGUodXAoZS5pbnB1dHMpKX19KTt2YXIgYnUsX3U9aygoKT0+e1widXNlIHN0cmljdFwiO0pvKCk7ZW4oKTtuaSgpO29pKCk7R2koKTtlcygpO3JzKCk7X3MoKTtJcygpO0VzKCk7enMoKTtVcygpO05zKCk7V3MoKTtxcygpO2pzKCk7WHMoKTtlYSgpO3JhKCk7c2EoKTtoYSgpO2JhKCk7d2EoKTt2YSgpO1RhKCk7c3IoKTtDYSgpO0hhKCk7S2EoKTtaYSgpO1lhKCk7WXQoKTtydSgpO2RyKCk7aXUoKTtkdSgpO3B1KCk7dXIoKTtodSgpO1ZlKCk7bm4oKTt5dSgpO2J1PW5ldyBNYXAoW1tcIkFic1wiLFtpaV1dLFtcIkFjb3NcIixbc2ldXSxbXCJBY29zaFwiLFthaV1dLFtcIkFkZFwiLFtIaV1dLFtcIkFyZ01heFwiLFtZbyxLbl1dLFtcIkFyZ01pblwiLFtYbyxLbl1dLFtcIkFzaW5cIixbdWldXSxbXCJBc2luaFwiLFtkaV1dLFtcIkF0YW5cIixbbGldXSxbXCJBdGFuaFwiLFtjaV1dLFtcIkF0dGVudGlvblwiLFtlaV1dLFtcIkF2ZXJhZ2VQb29sXCIsW09hLERhXV0sW1wiQmF0Y2hOb3JtYWxpemF0aW9uXCIsW3RpXV0sW1wiQmlhc0FkZFwiLFtyaV1dLFtcIkJpYXNTcGxpdEdlbHVcIixbV2ldXSxbXCJDYXN0XCIsW21pLHBpXV0sW1wiQ2VpbFwiLFtoaV1dLFtcIkNsaXBcIixbZmldXSxbXCJDb25jYXRcIixbdHMsbnNdXSxbXCJDb252XCIsW25yLHRyXV0sW1wiQ29udlRyYW5zcG9zZVwiLFtUcyx4c11dLFtcIkNvc1wiLFtnaV1dLFtcIkNvc2hcIixbeWldXSxbXCJDdW1TdW1cIixbQ3MsQXNdXSxbXCJEZXB0aFRvU3BhY2VcIixba3MsUHNdXSxbXCJEZXF1YW50aXplTGluZWFyXCIsW3FhLEZhXV0sW1wiRGl2XCIsW3FpXV0sW1wiRWluc3VtXCIsW09zLE1zXV0sW1wiRWx1XCIsW2JpLGd0XV0sW1wiRXF1YWxcIixbRmldXSxbXCJFcmZcIixbX2ldXSxbXCJFeHBcIixbd2ldXSxbXCJFeHBhbmRcIixbVnNdXSxbXCJGYXN0R2VsdVwiLFtMc11dLFtcIkZsb29yXCIsWyRpXV0sW1wiRnVzZWRDb252XCIsW25yLHRyXV0sW1wiR2F0aGVyXCIsW0hzLEdzXV0sW1wiR2F0aGVyRWxlbWVudHNcIixbSnMsWXNdXSxbXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLFtacyxRc11dLFtcIkdhdGhlck5EXCIsW0ZzLEtzXV0sW1wiR2VsdVwiLFt2aV1dLFtcIkdlbW1cIixbbmEsdGFdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFtSYSxVYV1dLFtcIkdsb2JhbE1heFBvb2xcIixbR2EsV2FdXSxbXCJHcmVhdGVyXCIsW1FpXV0sW1wiR3JlYXRlck9yRXF1YWxcIixbWWldXSxbXCJHcmlkU2FtcGxlXCIsW29hLGlhXV0sW1wiR3JvdXBRdWVyeUF0dGVudGlvblwiLFtmYV1dLFtcIkhhcmRTaWdtb2lkXCIsW2tpLEVpXV0sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsW3lhXV0sW1wiTGF5ZXJOb3JtYWxpemF0aW9uXCIsW19hXV0sW1wiTGVha3lSZWx1XCIsW3hpLGd0XV0sW1wiTGVzc1wiLFtYaV1dLFtcIkxlc3NPckVxdWFsXCIsW0ppXV0sW1wiTG9nXCIsW1ZpXV0sW1wiTWF0TXVsXCIsWyRhXV0sW1wiTWF0TXVsTkJpdHNcIixbeGEsU2FdXSxbXCJNYXhQb29sXCIsW05hLExhXV0sW1wiTXVsXCIsW0tpXV0sW1wiTXVsdGlIZWFkQXR0ZW50aW9uXCIsW2RhLHVhXV0sW1wiTmVnXCIsW1RpXV0sW1wiTm90XCIsW1NpXV0sW1wiUGFkXCIsW0lhXV0sW1wiUG93XCIsW2ppXV0sW1wiUXVpY2tHZWx1XCIsW05pLGd0XV0sW1wiUmFuZ2VcIixbamFdXSxbXCJSZWNpcHJvY2FsXCIsW0lpXV0sW1wiUmVkdWNlTWluXCIsW3FvXV0sW1wiUmVkdWNlTWVhblwiLFtOb11dLFtcIlJlZHVjZU1heFwiLFtIb11dLFtcIlJlZHVjZVN1bVwiLFtLb11dLFtcIlJlZHVjZVByb2RcIixbRm9dXSxbXCJSZWR1Y2VMMVwiLFtMb11dLFtcIlJlZHVjZUwyXCIsW1dvXV0sW1wiUmVkdWNlTG9nU3VtXCIsW1pvXV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW0dvXV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW2pvXV0sW1wiUmVsdVwiLFtDaV1dLFtcIlJlc2l6ZVwiLFt0dSxudV1dLFtcIlJvdGFyeUVtYmVkZGluZ1wiLFtwYV1dLFtcIlNjYXR0ZXJORFwiLFtYYSxRYV1dLFtcIlNpZ21vaWRcIixbQWldXSxbXCJTaW5cIixbUGldXSxbXCJTaW5oXCIsW3ppXV0sW1wiU2xpY2VcIixbYXUsdXVdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW291XV0sW1wiU3BsaXRcIixbbGEsY2FdXSxbXCJTcXJ0XCIsW0JpXV0sW1wiU29mdG1heFwiLFtsdSxjdV1dLFtcIlN1YlwiLFtaaV1dLFtcIlRhblwiLFtEaV1dLFtcIlRhbmhcIixbTWldXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbUmksZ3RdXSxbXCJUaWxlXCIsW2Z1XV0sW1wiVHJhbnNwb3NlXCIsW0NvLEFvXV0sW1wiV2hlcmVcIixbZ3VdXV0pfSk7dmFyIGZuLHd1PWsoKCk9PntcInVzZSBzdHJpY3RcIjt5ZSgpO2tlKCk7SygpO2ZuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KHQpe3JldHVybiB0aGlzLnJlcG8uZ2V0KHQpfXNldEFydGlmYWN0KHQsbil7dGhpcy5yZXBvLnNldCh0LG4pfXJ1bih0LG4scixvLGkpe2hlKHQucHJvZ3JhbUluZm8ubmFtZSk7bGV0IHM9dGhpcy5iYWNrZW5kLmRldmljZSxhPXRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTt0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKTtsZXQgdT1bXTtmb3IobGV0IGwgb2Ygbil1LnB1c2goe2JpbmRpbmc6dS5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpsLmJ1ZmZlcn19KTtmb3IobGV0IGwgb2Ygcil1LnB1c2goe2JpbmRpbmc6dS5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpsLmJ1ZmZlcn19KTtpJiZ1LnB1c2goe2JpbmRpbmc6dS5sZW5ndGgscmVzb3VyY2U6aX0pO2xldCBkPXMuY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6dC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6dSxsYWJlbDp0LnByb2dyYW1JbmZvLm5hbWV9KTtpZih0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBsPXtrZXJuZWxJZDp0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbElkLGNvbXB1dGVQaXBlbGluZTp0LmNvbXB1dGVQaXBlbGluZSxiaW5kR3JvdXA6ZCxkaXNwYXRjaEdyb3VwOm99O3RoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCkucHVzaChsKX1hLnNldFBpcGVsaW5lKHQuY29tcHV0ZVBpcGVsaW5lKSxhLnNldEJpbmRHcm91cCgwLGQpLGEuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLm8pLHRoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMSksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXJ8fHRoaXMuYmFja2VuZC5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmJhY2tlbmQuZmx1c2goKSxmZSh0LnByb2dyYW1JbmZvLm5hbWUpfWRpc3Bvc2UoKXt9YnVpbGQodCxuKXtoZSh0Lm5hbWUpO2xldCByPXRoaXMuYmFja2VuZC5kZXZpY2Usbz1bXTtbe2ZlYXR1cmU6XCJzaGFkZXItZjE2XCIsZXh0ZW5zaW9uOlwiZjE2XCJ9LHtmZWF0dXJlOlwic3ViZ3JvdXBzXCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzXCJ9XS5mb3JFYWNoKGM9PntyLmZlYXR1cmVzLmhhcyhjLmZlYXR1cmUpJiZvLnB1c2goYGVuYWJsZSAke2MuZXh0ZW5zaW9ufTtgKX0pO2xldCBzPVRvKG4sdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMpLGE9dC5nZXRTaGFkZXJTb3VyY2UocyksdT1gJHtvLmpvaW4oYFxuYCl9XG4ke3MuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cbiR7YX1gLGQ9ci5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6dSxsYWJlbDp0Lm5hbWV9KTtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gJHt0Lm5hbWV9IHNoYWRlciBjb2RlOiAke3V9YCk7bGV0IGw9ci5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2NvbXB1dGU6e21vZHVsZTpkLGVudHJ5UG9pbnQ6XCJtYWluXCJ9LGxheW91dDpcImF1dG9cIixsYWJlbDp0Lm5hbWV9KTtyZXR1cm4gZmUodC5uYW1lKSx7cHJvZ3JhbUluZm86dCxjb21wdXRlUGlwZWxpbmU6bCx1bmlmb3JtVmFyaWFibGVzSW5mbzpzLnZhcmlhYmxlc0luZm99fW5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHQpe2xldCBuPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC54LHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnl8fDEsbz10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQuenx8MSxpPXRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO2lmKG48PWkmJnI8PWkmJm88PWkpcmV0dXJuW24scixvXTtsZXQgcz1uKnIqbyxhPU1hdGguY2VpbChNYXRoLnNxcnQocykpO2lmKGE+aSl7aWYoYT1NYXRoLmNlaWwoTWF0aC5jYnJ0KHMpKSxhPmkpdGhyb3cgbmV3IEVycm9yKFwiVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLlwiKTtyZXR1cm5bYSxhLGFdfWVsc2UgcmV0dXJuW2EsYSwxXX19fSk7dmFyICR1PXt9O250KCR1LHtXZWJHcHVCYWNrZW5kOigpPT5jcn0pO3ZhciBkcCxscCxscixjcix2dT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtWKCk7a2UoKTtPbigpO3hvKCk7X3UoKTt3dSgpO2RwPShlLHQpPT57aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke3QubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke2UubGVuZ3RofS5gKTtsZXQgbj1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcil7bGV0IG89ZVtyXS5kYXRhVHlwZTtzd2l0Y2godFtyXSl7Y2FzZVwibm9uZVwiOntuLnB1c2goXCJcIik7YnJlYWt9Y2FzZVwidHlwZVwiOntuLnB1c2goYCR7b31gKTticmVha31jYXNlXCJyYW5rXCI6e2xldCBpPWVbcl0uZGltcy5sZW5ndGg7bi5wdXNoKGAke299OyR7aX1gKTticmVha31jYXNlXCJkaW1zXCI6e2xldCBpPWVbcl0uZGltcy5qb2luKFwiLFwiKTtuLnB1c2goYCR7b307JHtpfWApO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke3Rbcl19YCl9fXJldHVybiBuLmpvaW4oXCJ8XCIpfSxscD0oZSx0LG4pPT57bGV0IHI9ZS5uYW1lO3JldHVybiBlLnNoYWRlckNhY2hlPy5oaW50JiYocis9XCJbXCIrZS5zaGFkZXJDYWNoZS5oaW50K1wiXVwiKSxyKz1cIjpcIituK2A6JHtkcCh0LGUuc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzPz9uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoXCJkaW1zXCIpKX1gLHJ9LGxyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3QmJih0aGlzLmFyY2hpdGVjdHVyZT10LmFyY2hpdGVjdHVyZSx0aGlzLnZlbmRvcj10LnZlbmRvcil9aXNBcmNoaXRlY3R1cmUodCl7cmV0dXJuIHRoaXMuYXJjaGl0ZWN0dXJlPT09dH1pc1ZlbmRvcih0KXtyZXR1cm4gdGhpcy52ZW5kb3I9PT10fX0sY3I9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9bnVsbDt0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsO3RoaXMuY29tbWFuZEVuY29kZXI9bnVsbDt0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsO3RoaXMubWF4RGlzcGF0Y2hOdW1iZXI9MTY7dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO3RoaXMucGVuZGluZ1F1ZXJpZXM9bmV3IE1hcDt0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCI7dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0PW5ldyBNYXA7dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzPW5ldyBNYXA7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQsbil7dGhpcy5lbnY9dDtsZXQgcj1bXSxvPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6bi5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6bi5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6bi5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOnJ9LGk9cz0+bi5mZWF0dXJlcy5oYXMocykmJnIucHVzaChzKSYmITA7aShcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKXx8aShcInRpbWVzdGFtcC1xdWVyeVwiKSxpKFwic2hhZGVyLWYxNlwiKSxpKFwic3ViZ3JvdXBzXCIpLHRoaXMuZGV2aWNlPWF3YWl0IG4ucmVxdWVzdERldmljZShvKSx0aGlzLmFkYXB0ZXJJbmZvPW5ldyBscihuLmluZm98fGF3YWl0IG4ucmVxdWVzdEFkYXB0ZXJJbmZvKCkpLHRoaXMuZ3B1RGF0YU1hbmFnZXI9dm8odGhpcyksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgZm4odGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLFd0KHQubG9nTGV2ZWwsISF0LmRlYnVnKSx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj1zPT57cy5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHtzLmVycm9yLm1lc3NhZ2V9YCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJkZXZpY2VcIix7dmFsdWU6dGhpcy5kZXZpY2Usd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiYWRhcHRlclwiLHt2YWx1ZTpuLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksdGhpcy5zZXRRdWVyeVR5cGUoKX1kaXNwb3NlKCl7dHlwZW9mIHRoaXMucXVlcnlTZXQ8XCJ1XCImJnRoaXMucXVlcnlTZXQuZGVzdHJveSgpLHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpfWdldENvbW1hbmRFbmNvZGVyKCl7cmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXJ8fCh0aGlzLmNvbW1hbmRFbmNvZGVyPXRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCkpLHRoaXMuY29tbWFuZEVuY29kZXJ9Z2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCl7aWYoIXRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKXtsZXQgdD10aGlzLmdldENvbW1hbmRFbmNvZGVyKCksbj17fTt0aGlzLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCImJihuLnRpbWVzdGFtcFdyaXRlcz17cXVlcnlTZXQ6dGhpcy5xdWVyeVNldCxiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsZW5kT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzF9KSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj10LmJlZ2luQ29tcHV0ZVBhc3Mobil9cmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe2lmKCF0aGlzLmNvbW1hbmRFbmNvZGVyKXJldHVybjtoZSgpLHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtsZXQgdDt0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiYodGhpcy5jb21tYW5kRW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQodGhpcy5xdWVyeVNldCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCksdD10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSksdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQodCx0aGlzLnBlbmRpbmdLZXJuZWxzKSx0aGlzLnBlbmRpbmdLZXJuZWxzPVtdLHRoaXMuY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDAsdCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCkpLHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTAsdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdC5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCk9PntsZXQgbj1uZXcgQmlnVWludDY0QXJyYXkodC5nZXRNYXBwZWRSYW5nZSgpKSxyPXRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHQpO2ZvcihsZXQgbz0wO288bi5sZW5ndGgvMjtvKyspe2xldCBpPXJbb10scz1pLmtlcm5lbElkLGE9dGhpcy5rZXJuZWxzLmdldChzKSx1PWEua2VybmVsVHlwZSxkPWEua2VybmVsTmFtZSxsPWkucHJvZ3JhbU5hbWUsYz1pLmlucHV0VGVuc29yVmlld3MscD1pLm91dHB1dFRlbnNvclZpZXdzLGY9bltvKjJdLG09bltvKjIrMV07dHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZT5cInVcIiYmKHRoaXMucXVlcnlUaW1lQmFzZT1mKTtsZXQgaD1OdW1iZXIoZi10aGlzLnF1ZXJ5VGltZUJhc2UpLGI9TnVtYmVyKG0tdGhpcy5xdWVyeVRpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIoaCl8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihiKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7aWYodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKXRoaXMuZW52LndlYmdwdS5wcm9maWxpbmcub25kYXRhKHt2ZXJzaW9uOjEsaW5wdXRzTWV0YWRhdGE6Yy5tYXAoeT0+KHtkaW1zOnkuZGltcyxkYXRhVHlwZTpFZSh5LmRhdGFUeXBlKX0pKSxvdXRwdXRzTWV0YWRhdGE6cC5tYXAoeT0+KHtkaW1zOnkuZGltcyxkYXRhVHlwZTpFZSh5LmRhdGFUeXBlKX0pKSxrZXJuZWxJZDpzLGtlcm5lbFR5cGU6dSxrZXJuZWxOYW1lOmQscHJvZ3JhbU5hbWU6bCxzdGFydFRpbWU6aCxlbmRUaW1lOmJ9KTtlbHNle2xldCB5PVwiXCI7Yy5mb3JFYWNoKChfLHcpPT57eSs9YGlucHV0WyR7d31dOiBbJHtfLmRpbXN9XSB8ICR7RWUoXy5kYXRhVHlwZSl9LCBgfSk7bGV0IGc9XCJcIjtwLmZvckVhY2goKF8sdyk9PntnKz1gb3V0cHV0WyR7d31dOiBbJHtfLmRpbXN9XSB8ICR7RWUoXy5kYXRhVHlwZSl9LCBgfSksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7c318JHt1fXwke2R9fCR7bH1cIiAke3l9JHtnfXN0YXJ0IHRpbWU6ICR7aH0gbnMsIGV4ZWN1dGlvbiB0aW1lOiAke2ItaH0gbnNgKX1jdChcIkdQVVwiLGAke2x9Ojoke2Z9Ojoke219YCl9dC51bm1hcCgpLHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHQpfSksZmUoKX1ydW4odCxuLHIsbyxpLHMpe2hlKHQubmFtZSk7bGV0IGE9W107Zm9yKGxldCBfPTA7XzxuLmxlbmd0aDsrK18pe2xldCB3PW5bX10uZGF0YTtpZih3PT09MCljb250aW51ZTtsZXQgdj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh3KTtpZighdil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHt3fWApO2EucHVzaCh2KX1sZXR7b3V0cHV0czp1LGRpc3BhdGNoR3JvdXA6ZCxwcm9ncmFtVW5pZm9ybXM6bH09dC5nZXRSdW5EYXRhKG4pLGM9ci5sZW5ndGg9PT0wP3UubWFwKChfLHcpPT53KTpyO2lmKGMubGVuZ3RoIT09dS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke2MubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7dS5sZW5ndGh9LmApO2xldCBwPVtdLGY9W107Zm9yKGxldCBfPTA7Xzx1Lmxlbmd0aDsrK18pe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGNbX10pfHxjW19dPC0zfHxjW19dPj1zKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7Y1tfXX1gKTtpZihjW19dPT09LTMpY29udGludWU7bGV0IHc9Y1tfXT09PS0xLHY9Y1tfXT09PS0yLCQ9d3x8dj9pKHVbX10uZGF0YVR5cGUsdVtfXS5kaW1zKTpvKGNbX10sdVtfXS5kYXRhVHlwZSx1W19dLmRpbXMpO2lmKHAucHVzaCgkKSwkLmRhdGE9PT0wKWNvbnRpbnVlO2xldCBUPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KCQuZGF0YSk7aWYoIVQpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAkeyQuZGF0YX1gKTtpZih3JiZ0aGlzLnRlbXBvcmFyeURhdGEucHVzaChUKSx2KXtsZXQgST10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7SXx8KEk9W10sdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsSSkpLEkucHVzaChUKX1mLnB1c2goVCl9aWYoYS5sZW5ndGghPT1uLmxlbmd0aHx8Zi5sZW5ndGghPT1wLmxlbmd0aCl7aWYoZi5sZW5ndGg9PT0wKXJldHVybiBmZSh0Lm5hbWUpLHA7dGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtICR7dC5uYW1lfSBoYXMgemVyby1zaXplZCB0ZW5zb3IocykgaW4gaW5wdXRzIG9yIG91dHB1dHMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cuYCl9bGV0IG07aWYobCl7bGV0IF89MCx3PVtdO2wuZm9yRWFjaChJPT57bGV0IEE9dHlwZW9mIEkuZGF0YT09XCJudW1iZXJcIj9bSS5kYXRhXTpJLmRhdGE7aWYoQS5sZW5ndGg9PT0wKXJldHVybjtsZXQgej1JLnR5cGU9PT0xMD8yOjQsTSxVO0kudHlwZT09PTEwPyhVPUEubGVuZ3RoPjQ/MTY6QS5sZW5ndGg+Mj84OkEubGVuZ3RoKnosTT1BLmxlbmd0aD40PzE2OnoqQS5sZW5ndGgpOihVPUEubGVuZ3RoPD0yP0EubGVuZ3RoKno6MTYsTT0xNiksXz1NYXRoLmNlaWwoXy9VKSpVLHcucHVzaChfKTtsZXQgRz1JLnR5cGU9PT0xMD84OjQ7Xys9QS5sZW5ndGg+ND9NYXRoLmNlaWwoQS5sZW5ndGgvRykqTTpBLmxlbmd0aCp6fSk7bGV0IHY9MTY7Xz1NYXRoLmNlaWwoXy92KSp2O2xldCAkPW5ldyBBcnJheUJ1ZmZlcihfKTtsLmZvckVhY2goKEksQSk9PntsZXQgej13W0FdLE09dHlwZW9mIEkuZGF0YT09XCJudW1iZXJcIj9bSS5kYXRhXTpJLmRhdGE7aWYoSS50eXBlPT09NiluZXcgSW50MzJBcnJheSgkLHosTS5sZW5ndGgpLnNldChNKTtlbHNlIGlmKEkudHlwZT09PTEyKW5ldyBVaW50MzJBcnJheSgkLHosTS5sZW5ndGgpLnNldChNKTtlbHNlIGlmKEkudHlwZT09PTEwKW5ldyBVaW50MTZBcnJheSgkLHosTS5sZW5ndGgpLnNldChNKTtlbHNlIGlmKEkudHlwZT09PTEpbmV3IEZsb2F0MzJBcnJheSgkLHosTS5sZW5ndGgpLnNldChNKTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke0VlKEkudHlwZSl9YCl9KTtsZXQgVD10aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShfLEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO3RoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFQuYnVmZmVyLDAsJCwwLF8pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShULmlkKSxtPXtvZmZzZXQ6MCxzaXplOl8sYnVmZmVyOlQuYnVmZmVyfX1sZXQgaD10aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGQpLGI9aFsxXT09PTEmJmhbMl09PT0xLHk9bHAodCxuLGIpLGc9dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdCh5KTtpZihnfHwoZz10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHQsaCksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdCh5LGcpLGooXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHt5fSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxsJiZnLnVuaWZvcm1WYXJpYWJsZXNJbmZvKXtpZihsLmxlbmd0aCE9PWcudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke2cudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7bC5sZW5ndGh9IGluIHByb2dyYW0gXCIke2cucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtmb3IobGV0IF89MDtfPGwubGVuZ3RoO18rKyl7bGV0IHc9bFtfXSx2PXcudHlwZSwkPXR5cGVvZiB3LmRhdGE9PVwibnVtYmVyXCI/MTp3LmRhdGEubGVuZ3RoLFtULEldPWcudW5pZm9ybVZhcmlhYmxlc0luZm9bX107aWYodiE9PVR8fCQhPT1JKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke199IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke1R9IHdpdGggc2l6ZSAke0l9LCBnb3QgdHlwZSAke3Z9IHdpdGggc2l6ZSAkeyR9IGluIHByb2dyYW0gXCIke2cucHJvZ3JhbUluZm8ubmFtZX1cIi5gKX19aWYoaihcImluZm9cIiwoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHt0Lm5hbWV9XCIgKGtleT0ke3l9KSB3aXRoICR7aFswXX14JHtoWzFdfXgke2hbMl19YCksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcInx8dGhpcy5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IF89e2tlcm5lbElkOnRoaXMuY3VycmVudEtlcm5lbElkLHByb2dyYW1OYW1lOmcucHJvZ3JhbUluZm8ubmFtZSxpbnB1dFRlbnNvclZpZXdzOm4sb3V0cHV0VGVuc29yVmlld3M6cH07dGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKF8pLHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCImJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKF8pfXJldHVybiB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihnLGEsZixoLG0pLGZlKHQubmFtZSkscH11cGxvYWQodCxuKXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZCh0LG4pfW1lbWNweSh0LG4pe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHQsbil9YXN5bmMgZG93bmxvYWQodCxuKXthd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKHQsbil9YWxsb2ModCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHQpLmlkfWZyZWUodCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0KX1jcmVhdGVLZXJuZWwodCxuLHIsbyl7bGV0IGk9YnUuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHt0fWApO2xldCBzPXtrZXJuZWxUeXBlOnQsa2VybmVsTmFtZTpvLGtlcm5lbEVudHJ5OmlbMF0sYXR0cmlidXRlczpbaVsxXSxyXX07dGhpcy5rZXJuZWxzLnNldChuLHMpfXJlbGVhc2VLZXJuZWwodCl7bGV0IG49dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodCk7aWYobil7Zm9yKGxldCByIG9mIG4pdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHIuaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKHQpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUodCksdGhpcy5rZXJuZWxzLmRlbGV0ZSh0KX1jb21wdXRlS2VybmVsKHQsbixyKXtsZXQgbz10aGlzLmtlcm5lbHMuZ2V0KHQpO2lmKCFvKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke3R9YCk7bGV0IGk9by5rZXJuZWxUeXBlLHM9by5rZXJuZWxOYW1lLGE9by5rZXJuZWxFbnRyeSx1PW8uYXR0cmlidXRlcztpZih0aGlzLmN1cnJlbnRLZXJuZWxJZCE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtpfV0gJHtzfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPXQsdVswXSYmKHVbMV09dVswXSh1WzFdKSx1WzBdPXZvaWQgMCksaihcImluZm9cIiwoKT0+YFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtpfV0gJHtzfVwiLi4uYCk7bGV0IGQ9dGhpcy5lbnYuZGVidWc7dGhpcy50ZW1wb3JhcnlEYXRhPVtdO3RyeXtyZXR1cm4gZCYmdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoXCJ2YWxpZGF0aW9uXCIpLGEobix1WzFdKSwwfWNhdGNoKGwpe3JldHVybiByLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtpfV0gJHtzfVwiIGZhaWxlZC4gJHtsfWApKSwxfWZpbmFsbHl7ZCYmci5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKGw9Pmw/YEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtpfV0gJHtzfVwiOiAke2wubWVzc2FnZX1gOm51bGwpKTtmb3IobGV0IGwgb2YgdGhpcy50ZW1wb3JhcnlEYXRhKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShsLmlkKTt0aGlzLnRlbXBvcmFyeURhdGE9W10sdGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbH19cmVnaXN0ZXJCdWZmZXIodCxuLHIsbyl7bGV0IGk9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7aXx8KGk9bmV3IE1hcCx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldCh0LGkpKTtsZXQgcz1pLmdldChuKSxhPXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihyLG8scyk7cmV0dXJuIGkuc2V0KG4sW2Escl0pLGF9dW5yZWdpc3RlckJ1ZmZlcnModCl7bGV0IG49dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7biYmKG4uZm9yRWFjaChyPT50aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihyWzBdKSksdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUodCkpfWdldEJ1ZmZlcih0KXtsZXQgbj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7dH1gKTtyZXR1cm4gbi5idWZmZXJ9Y3JlYXRlRG93bmxvYWRlcih0LG4scil7cmV0dXJuIGFzeW5jKCk9PntsZXQgbz1hd2FpdCBMbih0aGlzLHQsbik7cmV0dXJuIEh0KG8uYnVmZmVyLHIpfX13cml0ZVRpbWVzdGFtcCh0KXt0aGlzLnF1ZXJ5VHlwZT09PVwiaW5zaWRlLXBhc3Nlc1wiJiZ0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci53cml0ZVRpbWVzdGFtcCh0aGlzLnF1ZXJ5U2V0LHQpfXNldFF1ZXJ5VHlwZSgpe3RoaXMucXVlcnlUeXBlPVwibm9uZVwiLCh0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlPT09XCJkZWZhdWx0XCJ8fCh0eXBlb2YgdGhpcy5lbnYudHJhY2U+XCJ1XCI/dGhpcy5lbnYud2FzbS50cmFjZTp0aGlzLmVudi50cmFjZSkpJiYodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpP3RoaXMucXVlcnlUeXBlPVwiaW5zaWRlLXBhc3Nlc1wiOnRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmKHRoaXMucXVlcnlUeXBlPVwiYXQtcGFzc2VzXCIpLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnR5cGVvZiB0aGlzLnF1ZXJ5U2V0PlwidVwiJiYodGhpcy5xdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMn0pLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyPXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFfSkpKX1jYXB0dXJlQmVnaW4oKXtqKFwiaW5mb1wiLFwiY2FwdHVyZUJlZ2luXCIpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJjYXB0dXJpbmdcIn1jYXB0dXJlRW5kKCl7aihcImluZm9cIixcImNhcHR1cmVFbmRcIiksdGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1yZXBsYXkoKXtqKFwiaW5mb1wiLFwicmVwbGF5XCIpLHRoaXMuc2Vzc2lvblN0YXR1cz1cInJlcGxheWluZ1wiO2xldCB0PXRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKSxuPXRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKSxyPXQubGVuZ3RoO3RoaXMucGVuZGluZ0tlcm5lbHM9W107Zm9yKGxldCBvPTA7bzxyO28rKyl7bGV0IGk9dGhpcy5nZXRDb21wdXRlUGFzc0VuY29kZXIoKSxzPXRbb107dGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKSxpLnNldFBpcGVsaW5lKHMuY29tcHV0ZVBpcGVsaW5lKSxpLnNldEJpbmRHcm91cCgwLHMuYmluZEdyb3VwKSxpLmRpc3BhdGNoV29ya2dyb3VwcyguLi5zLmRpc3BhdGNoR3JvdXApLHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChuW29dKSwodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMubWF4RGlzcGF0Y2hOdW1iZXJ8fHRoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5mbHVzaCgpfXRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5ncHVEYXRhTWFuYWdlci5vbkNyZWF0ZVNlc3Npb24oKX1vblJlbGVhc2VTZXNzaW9uKHQpe3RoaXMudW5yZWdpc3RlckJ1ZmZlcnModCksdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0KSYmdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmRlbGV0ZSh0KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZGVsZXRlKHQpLHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbih0KX1vblJ1blN0YXJ0KHQpe3RoaXMuY3VycmVudFNlc3Npb25JZD10LHRoaXMuc2V0UXVlcnlUeXBlKCl9fX0pO3ZhciB4dT17fTtudCh4dSx7aW5pdDooKT0+Y3B9KTt2YXIgd3QscHIsY3AsU3U9aygoKT0+e1widXNlIHN0cmljdFwiO1YoKTtrZSgpO3EoKTtibygpO3d0PWNsYXNzIGV7Y29uc3RydWN0b3IodCxuLHIsbyl7dGhpcy5tb2R1bGU9dDt0aGlzLmRhdGFUeXBlPW47dGhpcy5kYXRhPXI7dGhpcy5kaW1zPW99Z2V0RmxvYXQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9eC5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBGbG9hdDMyQXJyYXk6bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEJpZ0ludDY0QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD14LnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEJpZ0ludDY0QXJyYXk6bmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRJbnQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTYpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9eC5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBJbnQzMkFycmF5Om5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0VWludDE2QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MTAmJnRoaXMuZGF0YVR5cGUhPT00KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PXguc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgVWludDE2QXJyYXk6bmV3IFVpbnQxNkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9cmVzaGFwZSh0KXtpZih4LnNpemUodCkhPT14LnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IGUodGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsdCl9fSxwcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4scil7dGhpcy5tb2R1bGU9dDt0aGlzLmJhY2tlbmQ9bjt0aGlzLmN1c3RvbURhdGFPZmZzZXQ9MDt0aGlzLmN1c3RvbURhdGFTaXplPTA7dGhpcy5hZGFwdGVySW5mbz1uLmFkYXB0ZXJJbmZvO2xldCBvPXQuUFRSX1NJWkUsaT1yL3QuUFRSX1NJWkUscz1vPT09ND9cImkzMlwiOlwiaTY0XCI7dGhpcy5vcEtlcm5lbENvbnRleHQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKysscykpO2xldCBhPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLHMpKTt0aGlzLm91dHB1dENvdW50PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLHMpKSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssXCIqXCIpKSx0aGlzLmN1c3RvbURhdGFTaXplPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLHMpKTtsZXQgdT1bXTtmb3IobGV0IGQ9MDtkPGE7ZCsrKXtsZXQgbD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxzKSksYz1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxcIipcIikpLHA9TnVtYmVyKHQuZ2V0VmFsdWUobyppKysscykpLGY9W107Zm9yKGxldCBtPTA7bTxwO20rKylmLnB1c2goTnVtYmVyKHQuZ2V0VmFsdWUobyppKysscykpKTt1LnB1c2gobmV3IHd0KHQsbCxjLGYpKX10aGlzLmlucHV0cz11fWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQsbil7bGV0IHI9bj8uaW5wdXRzPy5tYXAoYT0+dHlwZW9mIGE9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbYV06YSk/P3RoaXMuaW5wdXRzLG89bj8ub3V0cHV0cz8/W10saT0oYSx1LGQpPT5uZXcgd3QodGhpcy5tb2R1bGUsdSx0aGlzLm91dHB1dChhLGQpLGQpLHM9KGEsdSk9PntsZXQgZD1xZShhLHUpO2lmKCFkKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2F9YCk7bGV0IGw9ZD4wP3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUoZCkuaWQ6MDtyZXR1cm4gbmV3IHd0KHRoaXMubW9kdWxlLGEsbCx1KX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxyLG8saSxzLHRoaXMub3V0cHV0Q291bnQpfW91dHB1dCh0LG4pe2xldCByPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10aGlzLm1vZHVsZS5QVFJfU0laRSxpPW89PT00P1wiaTMyXCI6XCJpNjRcIixzPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErbi5sZW5ndGgpKm8pO3RoaXMubW9kdWxlLnNldFZhbHVlKHMsbi5sZW5ndGgsaSk7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDthKyspdGhpcy5tb2R1bGUuc2V0VmFsdWUocytvKihhKzEpLG5bYV0saSk7cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQscyl9Y2F0Y2gobyl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtufV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtvfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKHIpfX19LGNwPWFzeW5jKGUsdCxuLHIpPT57bGV0IG89dC5qc2VwSW5pdDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC5cIik7aWYoZT09PVwid2ViZ3B1XCIpe2xldCBpPSh2dSgpLGR0KCR1KSkuV2ViR3B1QmFja2VuZCxzPW5ldyBpO2F3YWl0IHMuaW5pdGlhbGl6ZShuLHIpLG8oXCJ3ZWJncHVcIixbcyxhPT5zLmFsbG9jKE51bWJlcihhKSksYT0+cy5mcmVlKGEpLChhLHUsZCxsPSExKT0+e2lmKGwpaihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke051bWJlcihhKX0sIGRzdD0ke051bWJlcih1KX0sIHNpemU9JHtOdW1iZXIoZCl9YCkscy5tZW1jcHkoTnVtYmVyKGEpLE51bWJlcih1KSk7ZWxzZXtqKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke051bWJlcihhKX0sIGdwdURhdGFJZD0ke051bWJlcih1KX0sIHNpemU9JHtOdW1iZXIoZCl9YCk7bGV0IGM9dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGE+Pj4wKSxOdW1iZXIoYT4+PjApK051bWJlcihkKSk7cy51cGxvYWQoTnVtYmVyKHUpLGMpfX0sYXN5bmMoYSx1LGQpPT57aihcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke2F9LCBkYXRhT2Zmc2V0PSR7dX0sIHNpemU9JHtkfWApLGF3YWl0IHMuZG93bmxvYWQoTnVtYmVyKGEpLCgpPT50LkhFQVBVOC5zdWJhcnJheShOdW1iZXIodSk+Pj4wLE51bWJlcih1K2QpPj4+MCkpfSwoYSx1LGQpPT5zLmNyZWF0ZUtlcm5lbChhLE51bWJlcih1KSxkLHQuVVRGOFRvU3RyaW5nKHQuX0pzZXBHZXROb2RlTmFtZShOdW1iZXIodSkpKSksYT0+cy5yZWxlYXNlS2VybmVsKGEpLChhLHUsZCxsKT0+e2ooXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7ZH0sIGtlcm5lbD0ke2F9LCBjb250ZXh0RGF0YU9mZnNldD0ke3V9YCk7bGV0IGM9bmV3IHByKHQscyxOdW1iZXIodSkpO3JldHVybiBzLmNvbXB1dGVLZXJuZWwoTnVtYmVyKGEpLGMsbCl9LCgpPT5zLmNhcHR1cmVCZWdpbigpLCgpPT5zLmNhcHR1cmVFbmQoKSwoKT0+cy5yZXBsYXkoKV0pfWVsc2V7bGV0IGk9bmV3IGp0KG4pO28oXCJ3ZWJublwiLFtpLCgpPT5pLnJlc2VydmVUZW5zb3JJZCgpLHM9PmkucmVsZWFzZVRlbnNvcklkKHMpLGFzeW5jKHMsYSx1LGQsbCk9PmkuZW5zdXJlVGVuc29yKHMsYSx1LGQsbCksKHMsYSk9PntpLnVwbG9hZFRlbnNvcihzLGEpfSxhc3luYyhzLGEpPT5pLmRvd25sb2FkVGVuc29yKHMsYSksKHMsYSk9PmkucmVnaXN0ZXJNTENvbnRleHQocyxhKSwhIW4udHJhY2VdKX19fSk7dmFyIHBwLEV0LGt0LGV0LG1wLFR1LHB0LFB0LHp0LEl1LEJ0LER0LE90LEFuPWsoKCk9PntcInVzZSBzdHJpY3RcIjt5ZSgpO29vKCk7c28oKTtWKCk7R2UoKTtSdCgpO0JuKCk7cHA9KGUsdCk9PntuZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZZKFwiQ2FuJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LEV0PWFzeW5jIGU9PntwcChlLndhc20ubnVtVGhyZWFkcyxmdChlLmxvZ0xldmVsKSl9LGt0PWFzeW5jKGUsdCk9PntuZSgpLmFzeW5jSW5pdD8uKCk7bGV0IG49ZS53ZWJncHUuYWRhcHRlcjtpZih0PT09XCJ3ZWJncHVcIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTtpZihuKXtpZih0eXBlb2Ygbi5saW1pdHMhPVwib2JqZWN0XCJ8fHR5cGVvZiBuLmZlYXR1cmVzIT1cIm9iamVjdFwifHx0eXBlb2Ygbi5yZXF1ZXN0RGV2aWNlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC5cIil9ZWxzZXtsZXQgcj1lLndlYmdwdS5wb3dlclByZWZlcmVuY2U7aWYociE9PXZvaWQgMCYmciE9PVwibG93LXBvd2VyXCImJnIhPT1cImhpZ2gtcGVyZm9ybWFuY2VcIil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG93ZXJQcmVmZXJlbmNlIHNldHRpbmc6IFwiJHtyfVwiYCk7bGV0IG89ZS53ZWJncHUuZm9yY2VGYWxsYmFja0FkYXB0ZXI7aWYobyE9PXZvaWQgMCYmdHlwZW9mIG8hPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JjZUZhbGxiYWNrQWRhcHRlciBzZXR0aW5nOiBcIiR7b31cImApO2lmKG49YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcih7cG93ZXJQcmVmZXJlbmNlOnIsZm9yY2VGYWxsYmFja0FkYXB0ZXI6b30pLCFuKXRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpfX1pZih0PT09XCJ3ZWJublwiJiYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5tbCkpdGhyb3cgbmV3IEVycm9yKFwiV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50XCIpO3tsZXQgcj0oU3UoKSxkdCh4dSkpLmluaXQ7dD09PVwid2ViZ3B1XCImJmF3YWl0IHIoXCJ3ZWJncHVcIixuZSgpLGUsbiksdD09PVwid2Vibm5cIiYmYXdhaXQgcihcIndlYm5uXCIsbmUoKSxlKX19LGV0PW5ldyBNYXAsbXA9ZT0+e2xldCB0PW5lKCksbj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgcj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqcik7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbytyKSE9PTAmJlkoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpO2xldCBzPXI9PT00P1wiaTMyXCI6XCJpNjRcIjtyZXR1cm5bTnVtYmVyKHQuZ2V0VmFsdWUobyxzKSksTnVtYmVyKHQuZ2V0VmFsdWUobytyLHMpKV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShuKX19LFR1PShlLHQpPT57bGV0IG49bmUoKSxyPW4uc3RhY2tTYXZlKCksbz0wO3RyeXtsZXQgaT1uLlBUUl9TSVpFLHM9bi5zdGFja0FsbG9jKDIqaSk7bi5fT3J0R2V0SW5wdXRPdXRwdXRNZXRhZGF0YShlLHQscyxzK2kpIT09MCYmWShcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBtZXRhZGF0YS5cIik7bGV0IHU9TnVtYmVyKG4uZ2V0VmFsdWUocyxcIipcIikpO289TnVtYmVyKG4uZ2V0VmFsdWUocytpLFwiKlwiKSk7bGV0IGQ9bi5IRUFQMzJbby80XTtpZihkPT09MClyZXR1cm5bdSwwXTtsZXQgbD1uLkhFQVBVMzJbby80KzFdLGM9W107Zm9yKGxldCBwPTA7cDxsO3ArKyl7bGV0IGY9TnVtYmVyKG4uZ2V0VmFsdWUobys4K3AqaSxcIipcIikpO2MucHVzaChmIT09MD9uLlVURjhUb1N0cmluZyhmKTpOdW1iZXIobi5nZXRWYWx1ZShvKzgrKHArbCkqaSxcIipcIikpKX1yZXR1cm5bdSxkLGNdfWZpbmFsbHl7bi5zdGFja1Jlc3RvcmUociksbyE9PTAmJm4uX09ydEZyZWUobyl9fSxwdD1lPT57bGV0IHQ9bmUoKSxuPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKG49PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxuKSxbbixlLmJ5dGVMZW5ndGhdfSxQdD1hc3luYyhlLHQpPT57bGV0IG4scixvPW5lKCk7QXJyYXkuaXNBcnJheShlKT9bbixyXT1lOmUuYnVmZmVyPT09by5IRUFQVTguYnVmZmVyP1tuLHJdPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbbixyXT1wdChlKTtsZXQgaT0wLHM9MCxhPTAsdT1bXSxkPVtdLGw9W107dHJ5e2lmKFtzLHVdPWF3YWl0IGlvKHQpLHQ/LmV4dGVybmFsRGF0YSYmby5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHc9W107Zm9yKGxldCB2IG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgJD10eXBlb2Ygdj09XCJzdHJpbmdcIj92OnYucGF0aDt3LnB1c2goaHQodHlwZW9mIHY9PVwic3RyaW5nXCI/djp2LmRhdGEpLnRoZW4oVD0+e28ubW91bnRFeHRlcm5hbERhdGEoJCxUKX0pKX1hd2FpdCBQcm9taXNlLmFsbCh3KX1mb3IobGV0IHcgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHc9PVwic3RyaW5nXCI/dzp3Lm5hbWUpPT09XCJ3ZWJublwiKXtpZihvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgdyE9XCJzdHJpbmdcIil7bGV0ICQ9dyxUPSQ/LmNvbnRleHQsST0kPy5ncHVEZXZpY2UsQT0kPy5kZXZpY2VUeXBlLHo9JD8ucG93ZXJQcmVmZXJlbmNlO1Q/by5jdXJyZW50Q29udGV4dD1UOkk/by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLndlYm5uQ3JlYXRlTUxDb250ZXh0KEkpOm8uY3VycmVudENvbnRleHQ9YXdhaXQgby53ZWJubkNyZWF0ZU1MQ29udGV4dCh7ZGV2aWNlVHlwZTpBLHBvd2VyUHJlZmVyZW5jZTp6fSl9ZWxzZSBvLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8ud2Vibm5DcmVhdGVNTENvbnRleHQoKTticmVha31pPWF3YWl0IG8uX09ydENyZWF0ZVNlc3Npb24obixyLHMpLG8ud2ViZ3B1T25DcmVhdGVTZXNzaW9uPy4oaSksaT09PTAmJlkoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKSxvLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpLG8uY3VycmVudENvbnRleHQmJihvLndlYm5uUmVnaXN0ZXJNTENvbnRleHQoaSxvLmN1cnJlbnRDb250ZXh0KSxvLmN1cnJlbnRDb250ZXh0PXZvaWQgMCxvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMCk7bGV0W2MscF09bXAoaSksZj0hIXQ/LmVuYWJsZUdyYXBoQ2FwdHVyZSxtPVtdLGg9W10sYj1bXSx5PVtdLGc9W107Zm9yKGxldCB3PTA7dzxjO3crKyl7bGV0W3YsJCxUXT1UdShpLHcpO3Y9PT0wJiZZKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLGQucHVzaCh2KTtsZXQgST1vLlVURjhUb1N0cmluZyh2KTttLnB1c2goSSksYi5wdXNoKCQ9PT0wP3tuYW1lOkksaXNUZW5zb3I6ITF9OntuYW1lOkksaXNUZW5zb3I6ITAsdHlwZTpFZSgkKSxzaGFwZTpUfSl9Zm9yKGxldCB3PTA7dzxwO3crKyl7bGV0W3YsJCxUXT1UdShpLHcrYyk7dj09PTAmJlkoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLGwucHVzaCh2KTtsZXQgST1vLlVURjhUb1N0cmluZyh2KTtoLnB1c2goSSkseS5wdXNoKCQ9PT0wP3tuYW1lOkksaXNUZW5zb3I6ITF9OntuYW1lOkksaXNUZW5zb3I6ITAsdHlwZTpFZSgkKSxzaGFwZTpUfSk7e2lmKGYmJnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT09dm9pZCAwKXtnLnB1c2goXCJncHUtYnVmZmVyXCIpO2NvbnRpbnVlfWxldCBBPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bSV0/P1wiY3B1XCIsej1vLndlYm5uSXNHcmFwaE91dHB1dDtpZihBPT09XCJjcHVcIiYmeiYmeihpLEkpKXtnLnB1c2goXCJtbC10ZW5zb3ItY3B1LW91dHB1dFwiKTtjb250aW51ZX1pZihBIT09XCJjcHVcIiYmQSE9PVwiY3B1LXBpbm5lZFwiJiZBIT09XCJncHUtYnVmZmVyXCImJkEhPT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke0F9LmApO2lmKGYmJkEhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7Zy5wdXNoKEEpfX1sZXQgXz1udWxsO3JldHVybiBnLnNvbWUodz0+dz09PVwiZ3B1LWJ1ZmZlclwifHx3PT09XCJtbC10ZW5zb3JcInx8dz09PVwibWwtdGVuc29yLWNwdS1vdXRwdXRcIikmJihhPW8uX09ydENyZWF0ZUJpbmRpbmcoaSksYT09PTAmJlkoXCJDYW4ndCBjcmVhdGUgSU8gYmluZGluZy5cIiksXz17aGFuZGxlOmEsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOmcsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDpnLm1hcCh3PT53PT09XCJtbC10ZW5zb3ItY3B1LW91dHB1dFwiP1wibWwtdGVuc29yXCI6dykubWFwKHc9PnpuKHcpKX0pLGV0LnNldChpLFtpLGQsbCxfLGYsITFdKSxbaSxtLGgsYix5XX1jYXRjaChjKXt0aHJvdyBkLmZvckVhY2gocD0+by5fT3J0RnJlZShwKSksbC5mb3JFYWNoKHA9Pm8uX09ydEZyZWUocCkpLGEhPT0wJiZvLl9PcnRSZWxlYXNlQmluZGluZyhhKSE9PTAmJlkoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGkhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbihpKSE9PTAmJlkoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLGN9ZmluYWxseXtvLl9mcmVlKG4pLHMhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMocykhPT0wJiZZKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHUuZm9yRWFjaChjPT5vLl9mcmVlKGMpKSxvLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0senQ9ZT0+e2xldCB0PW5lKCksbj1ldC5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbcixvLGkscyxhXT1uO3MmJihhJiZ0Ll9PcnRDbGVhckJvdW5kT3V0cHV0cyhzLmhhbmRsZSkhPT0wJiZZKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcocy5oYW5kbGUpIT09MCYmWShcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIikpLHQuanNlcE9uUmVsZWFzZVNlc3Npb24/LihlKSx0LndlYm5uT25SZWxlYXNlU2Vzc2lvbj8uKGUpLHQud2ViZ3B1T25SZWxlYXNlU2Vzc2lvbj8uKGUpLG8uZm9yRWFjaCh1PT50Ll9PcnRGcmVlKHUpKSxpLmZvckVhY2godT0+dC5fT3J0RnJlZSh1KSksdC5fT3J0UmVsZWFzZVNlc3Npb24ocikhPT0wJiZZKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSxldC5kZWxldGUoZSl9LEl1PWFzeW5jKGUsdCxuLHIsbyxpLHM9ITEpPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IGE9bmUoKSx1PWEuUFRSX1NJWkUsZD1lWzBdLGw9ZVsxXSxjPWVbM10scD1jLGYsbTtpZihkPT09XCJzdHJpbmdcIiYmKGM9PT1cImdwdS1idWZmZXJcInx8Yz09PVwibWwtdGVuc29yXCIpKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKHMmJmMhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtpfSB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO2lmKGM9PT1cImdwdS1idWZmZXJcIil7bGV0IHk9ZVsyXS5ncHVCdWZmZXI7bT1xZShIZShkKSxsKTt7bGV0IGc9YS5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoIWcpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtmPWcocixpLHksbSl9fWVsc2UgaWYoYz09PVwibWwtdGVuc29yXCIpe2xldCB5PWVbMl0ubWxUZW5zb3I7bT1xZShIZShkKSxsKTtsZXQgZz1hLndlYm5uUmVnaXN0ZXJNTFRlbnNvcjtpZighZyl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtmPWcocix5LEhlKGQpLGwpfWVsc2V7bGV0IHk9ZVsyXTtpZihBcnJheS5pc0FycmF5KHkpKXttPXUqeS5sZW5ndGgsZj1hLl9tYWxsb2MobSksbi5wdXNoKGYpO2ZvcihsZXQgZz0wO2c8eS5sZW5ndGg7ZysrKXtpZih0eXBlb2YgeVtnXSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2d9IGlzIG5vdCBhIHN0cmluZ2ApO2Euc2V0VmFsdWUoZitnKnUsX2UoeVtnXSxuKSxcIipcIil9fWVsc2V7bGV0IGc9YS53ZWJubklzR3JhcGhJbnB1dCxfPWEud2Vibm5Jc0dyYXBoT3V0cHV0O2lmKGQhPT1cInN0cmluZ1wiJiZnJiZfKXtsZXQgdz1hLlVURjhUb1N0cmluZyhvKTtpZihnKHIsdyl8fF8ocix3KSl7bGV0IHY9SGUoZCk7bT1xZSh2LGwpLHA9XCJtbC10ZW5zb3JcIjtsZXQgJD1hLndlYm5uQ3JlYXRlVGVtcG9yYXJ5VGVuc29yLFQ9YS53ZWJublVwbG9hZFRlbnNvcjtpZighJHx8IVQpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7bGV0IEk9YXdhaXQgJChyLHYsbCk7VChJLG5ldyBVaW50OEFycmF5KHkuYnVmZmVyLHkuYnl0ZU9mZnNldCx5LmJ5dGVMZW5ndGgpKSxmPUl9ZWxzZSBtPXkuYnl0ZUxlbmd0aCxmPWEuX21hbGxvYyhtKSxuLnB1c2goZiksYS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHkuYnVmZmVyLHkuYnl0ZU9mZnNldCxtKSxmKX1lbHNlIG09eS5ieXRlTGVuZ3RoLGY9YS5fbWFsbG9jKG0pLG4ucHVzaChmKSxhLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoeS5idWZmZXIseS5ieXRlT2Zmc2V0LG0pLGYpfX1sZXQgaD1hLnN0YWNrU2F2ZSgpLGI9YS5zdGFja0FsbG9jKDQqbC5sZW5ndGgpO3RyeXtsLmZvckVhY2goKGcsXyk9PmEuc2V0VmFsdWUoYitfKnUsZyx1PT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgeT1hLl9PcnRDcmVhdGVUZW5zb3IoSGUoZCksZixtLGIsbC5sZW5ndGgsem4ocCkpO3k9PT0wJiZZKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtyfSwgaW5kZXg9JHtpfS5gKSx0LnB1c2goeSl9ZmluYWxseXthLnN0YWNrUmVzdG9yZShoKX19LEJ0PWFzeW5jKGUsdCxuLHIsbyxpKT0+e2xldCBzPW5lKCksYT1zLlBUUl9TSVpFLHU9ZXQuZ2V0KGUpO2lmKCF1KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldCBkPXVbMF0sbD11WzFdLGM9dVsyXSxwPXVbM10sZj11WzRdLG09dVs1XSxoPXQubGVuZ3RoLGI9ci5sZW5ndGgseT0wLGc9W10sXz1bXSx3PVtdLHY9W10sJD1zLnN0YWNrU2F2ZSgpLFQ9cy5zdGFja0FsbG9jKGgqYSksST1zLnN0YWNrQWxsb2MoaCphKSxBPXMuc3RhY2tBbGxvYyhiKmEpLHo9cy5zdGFja0FsbG9jKGIqYSk7dHJ5e1t5LGddPXJvKGkpLFVlKFwid2FzbSBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3JcIik7Zm9yKGxldCBCPTA7QjxoO0IrKylhd2FpdCBJdShuW0JdLF8sdixlLGxbdFtCXV0sdFtCXSxmKTtmb3IobGV0IEI9MDtCPGI7QisrKWF3YWl0IEl1KG9bQl0sdyx2LGUsY1tyW0JdXSxoK3JbQl0sZik7UmUoXCJ3YXNtIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvclwiKTtmb3IobGV0IEI9MDtCPGg7QisrKXMuc2V0VmFsdWUoVCtCKmEsX1tCXSxcIipcIikscy5zZXRWYWx1ZShJK0IqYSxsW3RbQl1dLFwiKlwiKTtmb3IobGV0IEI9MDtCPGI7QisrKXMuc2V0VmFsdWUoQStCKmEsd1tCXSxcIipcIikscy5zZXRWYWx1ZSh6K0IqYSxjW3JbQl1dLFwiKlwiKTtpZihwJiYhbSl7bGV0e2hhbmRsZTpCLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczplZSxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOld9PXA7aWYobC5sZW5ndGghPT1oKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtofSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7bC5sZW5ndGh9KS5gKTtVZShcIndhc20gYmluZElucHV0c091dHB1dHNcIik7Zm9yKGxldCBEPTA7RDxoO0QrKyl7bGV0IFo9dFtEXTthd2FpdCBzLl9PcnRCaW5kSW5wdXQoQixsW1pdLF9bRF0pIT09MCYmWShgQ2FuJ3QgYmluZCBpbnB1dFske0R9XSBmb3Igc2Vzc2lvbj0ke2V9LmApfWZvcihsZXQgRD0wO0Q8YjtEKyspe2xldCBaPXJbRF07b1tEXT8uWzNdP3MuX09ydEJpbmRPdXRwdXQoQixjW1pdLHdbRF0sMCkhPT0wJiZZKGBDYW4ndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7RH1dIGZvciBzZXNzaW9uPSR7ZX0uYCk6cy5fT3J0QmluZE91dHB1dChCLGNbWl0sMCxXW1pdKSE9PTAmJlkoYENhbid0IGJpbmQgb3V0cHV0WyR7RH1dIHRvICR7ZWVbRF19IGZvciBzZXNzaW9uPSR7ZX0uYCl9UmUoXCJ3YXNtIGJpbmRJbnB1dHNPdXRwdXRzXCIpLGV0LnNldChlLFtkLGwsYyxwLGYsITBdKX1zLmpzZXBPblJ1blN0YXJ0Py4oZCkscy53ZWJubk9uUnVuU3RhcnQ/LihkKTtsZXQgTTtwP009YXdhaXQgcy5fT3J0UnVuV2l0aEJpbmRpbmcoZCxwLmhhbmRsZSxiLEEseSk6TT1hd2FpdCBzLl9PcnRSdW4oZCxJLFQsaCx6LGIsQSx5KSxNIT09MCYmWShcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgVT1bXSxHPVtdO1VlKFwid2FzbSBQcm9jZXNzT3V0cHV0VGVuc29yXCIpO2ZvcihsZXQgQj0wO0I8YjtCKyspe2xldCBlZT1OdW1iZXIocy5nZXRWYWx1ZShBK0IqYSxcIipcIikpO2lmKGVlPT09d1tCXSl7VS5wdXNoKG9bQl0pO2NvbnRpbnVlfWxldCBXPXMuc3RhY2tTYXZlKCksRD1zLnN0YWNrQWxsb2MoNCphKSxaPSExLFIsUT0wO3RyeXtzLl9PcnRHZXRUZW5zb3JEYXRhKGVlLEQsRCthLEQrMiphLEQrMyphKSE9PTAmJlkoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtCfS5gKTtsZXQgc2U9YT09PTQ/XCJpMzJcIjpcImk2NFwiLEg9TnVtYmVyKHMuZ2V0VmFsdWUoRCxzZSkpO1E9cy5nZXRWYWx1ZShEK2EsXCIqXCIpO2xldCBFPXMuZ2V0VmFsdWUoRCthKjIsXCIqXCIpLEw9TnVtYmVyKHMuZ2V0VmFsdWUoRCthKjMsc2UpKSxvZT1bXTtmb3IobGV0IHVlPTA7dWU8TDt1ZSsrKW9lLnB1c2goTnVtYmVyKHMuZ2V0VmFsdWUoRSt1ZSphLHNlKSkpO3MuX09ydEZyZWUoRSkhPT0wJiZZKFwiQ2FuJ3QgZnJlZSBtZW1vcnkgZm9yIHRlbnNvciBkaW1zLlwiKTtsZXQgJGU9b2UucmVkdWNlKCh1ZSxhZSk9PnVlKmFlLDEpO1I9RWUoSCk7bGV0IFNlPXA/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1tyW0JdXTtpZihSPT09XCJzdHJpbmdcIil7aWYoU2U9PT1cImdwdS1idWZmZXJcInx8U2U9PT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCB1ZT1bXTtmb3IobGV0IGFlPTA7YWU8JGU7YWUrKyl7bGV0IExlPXMuZ2V0VmFsdWUoUSthZSphLFwiKlwiKSx2dD1zLmdldFZhbHVlKFErKGFlKzEpKmEsXCIqXCIpLGdyPWFlPT09JGUtMT92b2lkIDA6dnQtTGU7dWUucHVzaChzLlVURjhUb1N0cmluZyhMZSxncikpfVUucHVzaChbUixvZSx1ZSxcImNwdVwiXSl9ZWxzZSBpZihTZT09PVwiZ3B1LWJ1ZmZlclwiJiYkZT4wKXtsZXQgdWU9cy5qc2VwR2V0QnVmZmVyO2lmKCF1ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IGFlPXVlKFEpLExlPXFlKEgsJGUpO2lmKExlPT09dm9pZCAwfHwhTnQoUikpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7Un1gKTtaPSEwLFUucHVzaChbUixvZSx7Z3B1QnVmZmVyOmFlLGRvd25sb2FkOnMuanNlcENyZWF0ZURvd25sb2FkZXIoYWUsTGUsUiksZGlzcG9zZTooKT0+e3MuX09ydFJlbGVhc2VUZW5zb3IoZWUpIT09MCYmWShcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZSBpZihTZT09PVwibWwtdGVuc29yXCImJiRlPjApe2xldCB1ZT1zLndlYm5uRW5zdXJlVGVuc29yLGFlPXMud2Vibm5Jc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkO2lmKCF1ZXx8IWFlKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7aWYocWUoSCwkZSk9PT12b2lkIDB8fCFMdChSKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtSfWApO2lmKCFhZShlLFIsITEpKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBmb3IgJHtSfSBvdXRwdXQgaXMgbm90IHN1cHBvcnRlZCBieSBjdXJyZW50IFdlYk5OIENvbnRleHQuYCk7bGV0IHZ0PWF3YWl0IHVlKGUsUSxILG9lLCExKTtaPSEwLFUucHVzaChbUixvZSx7bWxUZW5zb3I6dnQsZG93bmxvYWQ6cy53ZWJubkNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihRLFIpLGRpc3Bvc2U6KCk9PntzLndlYm5uUmVsZWFzZVRlbnNvcklkKFEpLHMuX09ydFJlbGVhc2VUZW5zb3IoZWUpfX0sXCJtbC10ZW5zb3JcIl0pfWVsc2UgaWYoU2U9PT1cIm1sLXRlbnNvci1jcHUtb3V0cHV0XCImJiRlPjApe2xldCB1ZT1zLndlYm5uQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKFEsUikoKSxhZT1VLmxlbmd0aDtaPSEwLEcucHVzaCgoYXN5bmMoKT0+e2xldCBMZT1bYWUsYXdhaXQgdWVdO3JldHVybiBzLndlYm5uUmVsZWFzZVRlbnNvcklkKFEpLHMuX09ydFJlbGVhc2VUZW5zb3IoZWUpLExlfSkoKSksVS5wdXNoKFtSLG9lLFtdLFwiY3B1XCJdKX1lbHNle2xldCB1ZT1ydChSKSxhZT1uZXcgdWUoJGUpO25ldyBVaW50OEFycmF5KGFlLmJ1ZmZlcixhZS5ieXRlT2Zmc2V0LGFlLmJ5dGVMZW5ndGgpLnNldChzLkhFQVBVOC5zdWJhcnJheShRLFErYWUuYnl0ZUxlbmd0aCkpLFUucHVzaChbUixvZSxhZSxcImNwdVwiXSl9fWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUoVyksUj09PVwic3RyaW5nXCImJlEmJnMuX2ZyZWUoUSksWnx8cy5fT3J0UmVsZWFzZVRlbnNvcihlZSl9fXAmJiFmJiYocy5fT3J0Q2xlYXJCb3VuZE91dHB1dHMocC5oYW5kbGUpIT09MCYmWShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLGV0LnNldChlLFtkLGwsYyxwLGYsITFdKSk7Zm9yKGxldFtCLGVlXW9mIGF3YWl0IFByb21pc2UuYWxsKEcpKVVbQl1bMl09ZWU7cmV0dXJuIFJlKFwid2FzbSBQcm9jZXNzT3V0cHV0VGVuc29yXCIpLFV9ZmluYWxseXtzLndlYm5uT25SdW5FbmQ/LihkKSxzLnN0YWNrUmVzdG9yZSgkKSxfLmZvckVhY2goTT0+cy5fT3J0UmVsZWFzZVRlbnNvcihNKSksdy5mb3JFYWNoKE09PnMuX09ydFJlbGVhc2VUZW5zb3IoTSkpLHYuZm9yRWFjaChNPT5zLl9mcmVlKE0pKSx5IT09MCYmcy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoeSksZy5mb3JFYWNoKE09PnMuX2ZyZWUoTSkpfX0sRHQ9ZT0+e2xldCB0PW5lKCksbj1ldC5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCByPW5bMF0sbz10Ll9PcnRFbmRQcm9maWxpbmcocik7bz09PTAmJlkoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUobyl9LE90PWU9PntsZXQgdD1bXTtmb3IobGV0IG4gb2YgZSl7bGV0IHI9blsyXTshQXJyYXkuaXNBcnJheShyKSYmXCJidWZmZXJcImluIHImJnQucHVzaChyLmJ1ZmZlcil9cmV0dXJuIHR9fSk7dmFyIHR0LHhlLCR0LGduLHluLGhuLG1yLGZyLGF0LHV0LGhwLEN1LEF1LEV1LGt1LFB1LHp1LEJ1LGhyPWsoKCk9PntcInVzZSBzdHJpY3RcIjt5ZSgpO0FuKCk7R2UoKTtDdCgpO3R0PSgpPT4hIXRlLndhc20ucHJveHkmJnR5cGVvZiBkb2N1bWVudDxcInVcIiwkdD0hMSxnbj0hMSx5bj0hMSxmcj1uZXcgTWFwLGF0PShlLHQpPT57bGV0IG49ZnIuZ2V0KGUpO24/bi5wdXNoKHQpOmZyLnNldChlLFt0XSl9LHV0PSgpPT57aWYoJHR8fCFnbnx8eW58fCF4ZSl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxocD1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjokdD0hMSxlLmRhdGEuZXJyPyh5bj0hMCxtclsxXShlLmRhdGEuZXJyKSk6KGduPSEwLG1yWzBdKCkpLGhuJiYoVVJMLnJldm9rZU9iamVjdFVSTChobiksaG49dm9pZCAwKTticmVhaztjYXNlXCJpbml0LWVwXCI6Y2FzZVwiY29weS1mcm9tXCI6Y2FzZVwiY3JlYXRlXCI6Y2FzZVwicmVsZWFzZVwiOmNhc2VcInJ1blwiOmNhc2VcImVuZC1wcm9maWxpbmdcIjp7bGV0IHQ9ZnIuZ2V0KGUuZGF0YS50eXBlKTtlLmRhdGEuZXJyP3Quc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp0LnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWt9ZGVmYXVsdDp9fSxDdT1hc3luYygpPT57aWYoIWduKXtpZigkdCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKHluKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7aWYoJHQ9ITAsdHQoKSlyZXR1cm4gbmV3IFByb21pc2UoKGUsdCk9Pnt4ZT8udGVybWluYXRlKCksZW8oKS50aGVuKChbbixyXSk9Pnt0cnl7eGU9cix4ZS5vbmVycm9yPWk9PnQoaSkseGUub25tZXNzYWdlPWhwLG1yPVtlLHRdO2xldCBvPXt0eXBlOlwiaW5pdC13YXNtXCIsaW46dGV9O2lmKCFvLmluLndhc20ud2FzbVBhdGhzJiZuKXtsZXQgaT1NdCgpO2kmJihvLmluLndhc20ud2FzbVBhdGhzPWkpfXhlLnBvc3RNZXNzYWdlKG8pLGhuPW59Y2F0Y2gobyl7dChvKX19LHQpfSk7dHJ5e2F3YWl0IEF0KHRlLndhc20pLGF3YWl0IEV0KHRlKSxnbj0hMH1jYXRjaChlKXt0aHJvdyB5bj0hMCxlfWZpbmFsbHl7JHQ9ITF9fX0sQXU9YXN5bmMgZT0+e2lmKHR0KCkpcmV0dXJuIHV0KCksbmV3IFByb21pc2UoKHQsbik9PnthdChcImluaXQtZXBcIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJpbml0LWVwXCIsaW46e2VwTmFtZTplLGVudjp0ZX19O3hlLnBvc3RNZXNzYWdlKHIpfSk7YXdhaXQga3QodGUsZSl9LEV1PWFzeW5jIGU9PnR0KCk/KHV0KCksbmV3IFByb21pc2UoKHQsbik9PnthdChcImNvcHktZnJvbVwiLFt0LG5dKTtsZXQgcj17dHlwZTpcImNvcHktZnJvbVwiLGluOntidWZmZXI6ZX19O3hlLnBvc3RNZXNzYWdlKHIsW2UuYnVmZmVyXSl9KSk6cHQoZSksa3U9YXN5bmMoZSx0KT0+e2lmKHR0KCkpe2lmKHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKXRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO3JldHVybiB1dCgpLG5ldyBQcm9taXNlKChuLHIpPT57YXQoXCJjcmVhdGVcIixbbixyXSk7bGV0IG89e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6ZSxvcHRpb25zOnsuLi50fX19LGk9W107ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJmkucHVzaChlLmJ1ZmZlcikseGUucG9zdE1lc3NhZ2UobyxpKX0pfWVsc2UgcmV0dXJuIFB0KGUsdCl9LFB1PWFzeW5jIGU9PntpZih0dCgpKXJldHVybiB1dCgpLG5ldyBQcm9taXNlKCh0LG4pPT57YXQoXCJyZWxlYXNlXCIsW3Qsbl0pO2xldCByPXt0eXBlOlwicmVsZWFzZVwiLGluOmV9O3hlLnBvc3RNZXNzYWdlKHIpfSk7enQoZSl9LHp1PWFzeW5jKGUsdCxuLHIsbyxpKT0+e2lmKHR0KCkpe2lmKG4uc29tZShzPT5zWzNdIT09XCJjcHVcIikpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7aWYoby5zb21lKHM9PnMpKXRocm93IG5ldyBFcnJvcihcInByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7cmV0dXJuIHV0KCksbmV3IFByb21pc2UoKHMsYSk9PnthdChcInJ1blwiLFtzLGFdKTtsZXQgdT1uLGQ9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnQsaW5wdXRzOnUsb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6aX19O3hlLnBvc3RNZXNzYWdlKGQsT3QodSkpfSl9ZWxzZSByZXR1cm4gQnQoZSx0LG4scixvLGkpfSxCdT1hc3luYyBlPT57aWYodHQoKSlyZXR1cm4gdXQoKSxuZXcgUHJvbWlzZSgodCxuKT0+e2F0KFwiZW5kLXByb2ZpbGluZ1wiLFt0LG5dKTtsZXQgcj17dHlwZTpcImVuZC1wcm9maWxpbmdcIixpbjplfTt4ZS5wb3N0TWVzc2FnZShyKX0pO0R0KGUpfX0pO3ZhciBEdSxncCxibixPdT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtocigpO1YoKTtJdCgpO0JuKCk7RHU9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0sZ3A9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IHZlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIU50KHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6bixkb3dubG9hZDpyLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gdmUuZnJvbUdwdUJ1ZmZlcihuLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpyLGRpc3Bvc2U6b30pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFMdCh0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpuLGRvd25sb2FkOnIsZGlzcG9zZTpvfT1lWzJdO3JldHVybiB2ZS5mcm9tTUxUZW5zb3Iobix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6cixkaXNwb3NlOm99KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxibj1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gRXUoYXdhaXQgaHQodCkpfWFzeW5jIGxvYWRNb2RlbCh0LG4pe2hlKCk7bGV0IHI7dHlwZW9mIHQ9PVwic3RyaW5nXCI/cj1hd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpOnI9dCxbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXMsdGhpcy5pbnB1dE1ldGFkYXRhLHRoaXMub3V0cHV0TWV0YWRhdGFdPWF3YWl0IGt1KHIsbiksZmUoKX1hc3luYyBkaXNwb3NlKCl7cmV0dXJuIFB1KHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxuLHIpe2hlKCk7bGV0IG89W10saT1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKHA9PntsZXQgZj1wWzBdLG09cFsxXSxoPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGYpO2lmKGg9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7Zn0nYCk7by5wdXNoKG0pLGkucHVzaChoKX0pO2xldCBzPVtdLGE9W107T2JqZWN0LmVudHJpZXMobikuZm9yRWFjaChwPT57bGV0IGY9cFswXSxtPXBbMV0saD10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZik7aWYoaD09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7Zn0nYCk7cy5wdXNoKG0pLGEucHVzaChoKX0pO2xldCB1PW8ubWFwKChwLGYpPT5EdShwLCgpPT5gaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1tpW2ZdXX1cImApKSxkPXMubWFwKChwLGYpPT5wP0R1KHAsKCk9PmBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbYVtmXV19XCJgKTpudWxsKSxsPWF3YWl0IHp1KHRoaXMuc2Vzc2lvbklkLGksdSxhLGQsciksYz17fTtmb3IobGV0IHA9MDtwPGwubGVuZ3RoO3ArKyljW3RoaXMub3V0cHV0TmFtZXNbYVtwXV1dPXNbcF0/P2dwKGxbcF0pO3JldHVybiBmZSgpLGN9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7QnUodGhpcy5zZXNzaW9uSWQpfX19KTt2YXIgVXU9e307bnQoVXUse09ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kOigpPT5fbixpbml0aWFsaXplRmxhZ3M6KCk9Pk11LHdhc21CYWNrZW5kOigpPT55cH0pO3ZhciBNdSxfbix5cCxSdT1rKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWUoKTtocigpO091KCk7TXU9KCk9PnsodHlwZW9mIHRlLndhc20uaW5pdFRpbWVvdXQhPVwibnVtYmVyXCJ8fHRlLndhc20uaW5pdFRpbWVvdXQ8MCkmJih0ZS53YXNtLmluaXRUaW1lb3V0PTApO2xldCBlPXRlLndhc20uc2ltZDtpZih0eXBlb2YgZSE9XCJib29sZWFuXCImJmUhPT12b2lkIDAmJmUhPT1cImZpeGVkXCImJmUhPT1cInJlbGF4ZWRcIiYmKGNvbnNvbGUud2FybihgUHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIHVua25vd24gdmFsdWUgXCIke2V9XCIuIFJlc2V0IGl0IHRvIFxcYGZhbHNlXFxgIGFuZCBpZ25vcmUgU0lNRCBmZWF0dXJlIGNoZWNraW5nLmApLHRlLndhc20uc2ltZD0hMSksdHlwZW9mIHRlLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYodGUud2FzbS5wcm94eT0hMSksdHlwZW9mIHRlLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYodGUud2FzbS50cmFjZT0hMSksdHlwZW9mIHRlLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIodGUud2FzbS5udW1UaHJlYWRzKXx8dGUud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKXRlLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IHQ9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj8kbihcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTt0ZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKHR8fDEpLzIpKX19LF9uPWNsYXNze2FzeW5jIGluaXQodCl7TXUoKSxhd2FpdCBDdSgpLGF3YWl0IEF1KHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQsbil7bGV0IHI9bmV3IGJuO3JldHVybiBhd2FpdCByLmxvYWRNb2RlbCh0LG4pLHJ9fSx5cD1uZXcgX259KTt2YXIgX3A9e307bnQoX3Ase0luZmVyZW5jZVNlc3Npb246KCk9Pk5yLFRSQUNFOigpPT5jdCxUUkFDRV9FVkVOVF9CRUdJTjooKT0+VWUsVFJBQ0VfRVZFTlRfRU5EOigpPT5SZSxUUkFDRV9GVU5DX0JFR0lOOigpPT5oZSxUUkFDRV9GVU5DX0VORDooKT0+ZmUsVGVuc29yOigpPT52ZSxkZWZhdWx0OigpPT5icCxlbnY6KCk9PnRlLHJlZ2lzdGVyQmFja2VuZDooKT0+V2V9KTt5ZSgpO3llKCk7eWUoKTt2YXIgRnI9XCIxLjIzLjJcIjt2YXIgYnA9Q247e2xldCBlPShSdSgpLGR0KFV1KSkud2FzbUJhY2tlbmQ7V2UoXCJ3ZWJncHVcIixlLDUpLFdlKFwid2Vibm5cIixlLDUpLFdlKFwiY3B1XCIsZSwxMCksV2UoXCJ3YXNtXCIsZSwxMCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHRlLnZlcnNpb25zLFwid2ViXCIse3ZhbHVlOkZyLGVudW1lcmFibGU6ITB9KTtyZXR1cm4gZHQoX3ApO30pKCk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG50eXBlb2YgZXhwb3J0cz09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZT09XCJvYmplY3RcIiYmKG1vZHVsZS5leHBvcnRzPW9ydCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQubWluLmpzLm1hcFxuIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSA2ODc7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gc2VlIGFsc28gYWR2YW5jZWQgdXNhZ2Ugb2YgaW1wb3J0aW5nIE9OTlggUnVudGltZSBXZWI6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lLWluZmVyZW5jZS1leGFtcGxlcy90cmVlL21haW4vanMvaW1wb3J0aW5nX29ubnhydW50aW1lLXdlYlxuY29uc3Qgb3J0ID0gcmVxdWlyZSgnb25ueHJ1bnRpbWUtd2ViJyk7XG4vLyB1c2UgYW4gYXN5bmMgY29udGV4dCB0byBjYWxsIG9ubnhydW50aW1lIGZ1bmN0aW9ucy5cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHNlc3Npb24gYW5kIGxvYWQgdGhlIHNwZWNpZmljIG1vZGVsLlxuICAgICAgICAvL1xuICAgICAgICAvLyB0aGUgbW9kZWwgaW4gdGhpcyBleGFtcGxlIGNvbnRhaW5zIGEgc2luZ2xlIE1hdE11bCBub2RlXG4gICAgICAgIC8vIGl0IGhhcyAyIGlucHV0czogJ2EnKGZsb2F0MzIsIDN4NCkgYW5kICdiJyhmbG9hdDMyLCA0eDMpXG4gICAgICAgIC8vIGl0IGhhcyAxIG91dHB1dDogJ2MnKGZsb2F0MzIsIDN4MylcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgnLi9tb2RlbHMvYmVzdC5vbm54Jyk7XG4gICAgICAgIC8vIHByZXBhcmUgaW5wdXRzLiBhIHRlbnNvciBuZWVkIGl0cyBjb3JyZXNwb25kaW5nIFR5cGVkQXJyYXkgYXMgZGF0YVxuICAgICAgICBjb25zdCBkYXRhQSA9IEZsb2F0MzJBcnJheS5mcm9tKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXSk7XG4gICAgICAgIGNvbnN0IGRhdGFCID0gRmxvYXQzMkFycmF5LmZyb20oWzEwLCAyMCwgMzAsIDQwLCA1MCwgNjAsIDcwLCA4MCwgOTAsIDEwMCwgMTEwLCAxMjBdKTtcbiAgICAgICAgY29uc3QgdGVuc29yQSA9IG5ldyBvcnQuVGVuc29yKCdmbG9hdDMyJywgZGF0YUEsIFszLCA0XSk7XG4gICAgICAgIGNvbnN0IHRlbnNvckIgPSBuZXcgb3J0LlRlbnNvcignZmxvYXQzMicsIGRhdGFCLCBbNCwgM10pO1xuICAgICAgICAvLyBwcmVwYXJlIGZlZWRzLiB1c2UgbW9kZWwgaW5wdXQgbmFtZXMgYXMga2V5cy5cbiAgICAgICAgY29uc3QgZmVlZHMgPSB7IGE6IHRlbnNvckEsIGI6IHRlbnNvckIgfTtcbiAgICAgICAgLy8gZmVlZCBpbnB1dHMgYW5kIHJ1blxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc2Vzc2lvbi5ydW4oZmVlZHMpO1xuICAgICAgICAvLyByZWFkIGZyb20gcmVzdWx0c1xuICAgICAgICBjb25zdCBkYXRhQyA9IHJlc3VsdHMuYy5kYXRhO1xuICAgICAgICBkb2N1bWVudC53cml0ZShgZGF0YSBvZiByZXN1bHQgdGVuc29yICdjJzogJHtkYXRhQ31gKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZG9jdW1lbnQud3JpdGUoYGZhaWxlZCB0byBpbmZlcmVuY2UgT05OWCBtb2RlbDogJHtlfS5gKTtcbiAgICB9XG59XG5tYWluKCk7XG4iXSwibmFtZXMiOlsib3J0IiwieHQiLCJqZSIsIldlIiwiR3UiLCJ5ciIsIl9yIiwiJHIiLCJsZSIsInRlIiwieHIiLCJTciIsIlNuIiwiSXIiLCJDciIsIkFyIiwiRXIiLCJrciIsIlplIiwibHQiLCJ6ciIsIkJyIiwiT3IiLCJNciIsIm1lIiwidmUiLCJjdCIsIlJyIiwiaGUiLCJmZSIsIlVlIiwiUmUiLCJUdCIsIk5yIiwid24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIlZ1IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTnUiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiTHUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIiRuIiwiayIsImUiLCJ0IiwibnQiLCJuIiwiZ2V0IiwiZW51bWVyYWJsZSIsImR0IiwiciIsIm8iLCJjYWxsIiwiV3UiLCJ2YWx1ZSIsInZuIiwiTWFwIiwiaW5pdCIsImNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyIiwic2V0IiwiYmFja2VuZCIsInByaW9yaXR5IiwiRXJyb3IiLCJpbmRleE9mIiwic3BsaWNlIiwiaSIsImxlbmd0aCIsInB1c2giLCJUeXBlRXJyb3IiLCJhc3luYyIsImluaXRpYWxpemVkIiwiYWJvcnRlZCIsImVycm9yIiwiaW5pdFByb21pc2UiLCJleGVjdXRpb25Qcm92aWRlcnMiLCJtYXAiLCJ1IiwibmFtZSIsInMiLCJTZXQiLCJkIiwiZXJyIiwiYWRkIiwiam9pbiIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJhIiwiZmlsdGVyIiwiaGFzIiwiUHJveHkiLCJSZWZsZWN0IiwiYnIiLCJ3ciIsInhuIiwid2FzbSIsIndlYmdsIiwid2ViZ3B1IiwidmVyc2lvbnMiLCJjb21tb24iLCJsb2dMZXZlbCIsInZyIiwiVHIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJPZmZzY3JlZW5DYW52YXMiLCJ3aWR0aCIsImRpbXMiLCJoZWlnaHQiLCJnZXRDb250ZXh0IiwidGVuc29yTGF5b3V0IiwiZm9ybWF0Iiwibm9ybSIsIm1lYW4iLCJiaWFzIiwibCIsImMiLCJwIiwiZiIsIm0iLCJoIiwiYiIsInkiLCJkYXRhIiwiZyIsIl8iLCJ3IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b0RhdGFVUkwiLCJjcmVhdGVJbWFnZURhdGEiLCJ2IiwiUHIiLCJTdCIsInRlbnNvckZvcm1hdCIsIkZsb2F0MzJBcnJheSIsIkhUTUxJbWFnZUVsZW1lbnQiLCJJbWFnZURhdGEiLCJJbWFnZUJpdG1hcCIsIkhUTUxDYW52YXNFbGVtZW50IiwicmVzaXplZEhlaWdodCIsInJlc2l6ZWRXaWR0aCIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsIlByb21pc2UiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwicHV0SW1hZ2VEYXRhIiwiZG93bmxvYWQiLCJkaXNwb3NlIiwibG9jYXRpb24iLCJ0eXBlIiwidGV4dHVyZSIsImRhdGFUeXBlIiwiZ3B1QnVmZmVyIiwibWxUZW5zb3IiLCJEciIsIlVpbnQ4QXJyYXkiLCJJbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiVWludDMyQXJyYXkiLCJCaWdJbnQ2NEFycmF5IiwiZnJvbSIsIkJpZ1VpbnQ2NEFycmF5IiwiZ2xvYmFsVGhpcyIsIkZsb2F0MTZBcnJheSIsIlVyIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIlJhbmdlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInRoaXMiLCJkYXRhTG9jYXRpb24iLCJjcHVEYXRhIiwiZ3B1VGV4dHVyZURhdGEiLCJkb3dubG9hZGVyIiwiZGlzcG9zZXIiLCJncHVCdWZmZXJEYXRhIiwibWxUZW5zb3JEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiQmlnSW50IiwiVWludDhDbGFtcGVkQXJyYXkiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiTWF0aCIsImNlaWwiLCJzaXplIiwiZnJvbUltYWdlIiwiZnJvbVRleHR1cmUiLCJmcm9tR3B1QnVmZmVyIiwiZnJvbU1MVGVuc29yIiwiZnJvbVBpbm5lZEJ1ZmZlciIsInRvSW1hZ2VEYXRhIiwiZW5zdXJlVmFsaWQiLCJnZXREYXRhIiwiaXNEb3dubG9hZGluZyIsInJlc2hhcGUiLCJUbiIsIkluIiwidHJhY2UiLCJ0aW1lU3RhbXAiLCJzdGFjayIsInNwbGl0IiwidHJpbSIsInRpbWUiLCJ0aW1lRW5kIiwiVnIiLCJoYW5kbGVyIiwicnVuIiwib3V0cHV0TmFtZXMiLCJpbnB1dE5hbWVzIiwicmVsZWFzZSIsImNyZWF0ZSIsIkFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJpbnB1dE1ldGFkYXRhIiwib3V0cHV0TWV0YWRhdGEiLCJMciIsIldyIiwiR3IiLCJIciIsInFyIiwiQ24iLCJJbmZlcmVuY2VTZXNzaW9uIiwiVFJBQ0UiLCJUUkFDRV9FVkVOVF9CRUdJTiIsIlRSQUNFX0VWRU5UX0VORCIsIlRSQUNFX0ZVTkNfQkVHSU4iLCJUUkFDRV9GVU5DX0VORCIsIlRlbnNvciIsImVudiIsInJlZ2lzdGVyQmFja2VuZCIsInllIiwiSXQiLCJaciIsImRlZmF1bHQiLCJIdSIsIktyIiwianIiLCJxdSIsImJlIiwiTXQiLCJFbiIsIkt1IiwianUiLCJKciIsIlp1IiwiWHIiLCJlbyIsIllyIiwidG8iLCJrbiIsIlBuIiwiVXQiLCJubyIsIlF1IiwiWHUiLCJZdSIsIkF0IiwibmUiLCJfZSIsIm10IiwiWSIsInJvIiwiSnUiLCJlZCIsInRkIiwiVnQiLCJuZCIsImlvIiwiSGUiLCJFZSIsInFlIiwicnQiLCJmdCIsIk50IiwiTHQiLCJ6biIsImh0IiwicmQiLCJvZCIsImFvIiwidW8iLCJXdCIsImlkIiwiaiIsIkRuIiwiUGUiLCJ4IiwiWGUiLCJHdCIsImxvIiwiY28iLCJIdCIsIm1vIiwiVW4iLCJmbyIsInNkIiwicG8iLCJhZCIsImhvIiwicXQiLCJGdCIsIk1uIiwiZ28iLCJLdCIsInVkIiwianQiLCJfbyIsIlJuIiwiVm4iLCJkZCIsImxkIiwid28iLCJMbiIsIk5uIiwidm8iLCJXbiIsIk4iLCJZZSIsIkhuIiwicmUiLCJjZSIsIlAiLCJYIiwicW4iLCJKZSIsIlRlIiwiTyIsIlF0IiwiUyIsIkMiLCJTbyIsIlh0IiwiR24iLCJUbyIsImNkIiwiSW8iLCJwZCIsIm1kIiwiZmQiLCJoZCIsInBlIiwiQ28iLCJBbyIsImdkIiwieWQiLCJiZCIsIl9kIiwid2QiLCIkZCIsInZkIiwieGQiLCJTZCIsIlRkIiwiemUiLCJFbyIsImtvIiwiUG8iLCJ6byIsIkJvIiwiRG8iLCJPbyIsIk1vIiwiVW8iLCJSbyIsIkJlIiwiSWQiLCJKdCIsIkZuIiwiRGUiLCJDZCIsIkFkIiwiRWQiLCJrZCIsIlBkIiwiemQiLCJCZCIsIkRkIiwiT2QiLCJNZCIsIk9lIiwiTm8iLCJMbyIsIldvIiwiR28iLCJIbyIsInFvIiwiRm8iLCJLbyIsImpvIiwiWm8iLCJRbyIsIlhvIiwiWW8iLCJLbiIsIlVkIiwiam4iLCJSZCIsIlZkIiwiTmQiLCJvdCIsIkxkIiwiZWkiLCJXZCIsIkdkIiwiSGQiLCJ0aSIsInFkIiwiRmQiLCJyaSIsIktkIiwiSiIsImlpIiwic2kiLCJhaSIsInVpIiwiZGkiLCJsaSIsImNpIiwicGkiLCJtaSIsImpkIiwiZmkiLCJoaSIsImdpIiwieWkiLCJndCIsImJpIiwidG4iLCJfaSIsIndpIiwiJGkiLCJ2aSIsInhpIiwiU2kiLCJUaSIsIklpIiwiQ2kiLCJBaSIsIkVpIiwia2kiLCJQaSIsInppIiwiQmkiLCJEaSIsIk9pIiwiTWkiLCJabiIsIlFuIiwiVWkiLCJSaSIsIlZpIiwiWmQiLCJRZCIsIk5pIiwiWGQiLCJZZCIsIldpIiwiSmQiLCJlbCIsIk1lIiwiSGkiLCJxaSIsIkZpIiwiS2kiLCJqaSIsIlppIiwiUWkiLCJYaSIsIllpIiwiSmkiLCJubCIsInJsIiwib2wiLCJpbCIsInRzIiwibnMiLCJJZSIsIkNlIiwiQWUiLCJybiIsImRlIiwib3MiLCJpcyIsInl0Iiwic24iLCJzbCIsImFsIiwiWG4iLCJhcyIsInVsIiwiWW4iLCJkbCIsImJ0IiwibGwiLCJ1cyIsImNsIiwibHMiLCJkbiIsInBsIiwiY3MiLCJtbCIsInBzIiwibXMiLCJocyIsImdzIiwiZmwiLCJKbiIsImhsIiwiZXIiLCJ0ciIsImJzIiwiZ2wiLCJ5bCIsIm5yIiwid3MiLCJibCIsIl9sIiwid2wiLCJ2cyIsInhzIiwiJGwiLCJTcyIsInZsIiwiVHMiLCJ4bCIsIkNzIiwiQXMiLCJTbCIsIlRsIiwiSWwiLCJrcyIsIlBzIiwicnIiLCJsbiIsIkJzIiwiQWwiLCJvciIsImlyIiwiRHMiLCJFbCIsIk9zIiwiTXMiLCJrbCIsIlJzIiwiUGwiLCJ6bCIsIlZzIiwiQmwiLCJMcyIsIkRsIiwiT2wiLCJHcyIsIkhzIiwiTWwiLCJGcyIsIktzIiwiVWwiLCJSbCIsIlpzIiwiUXMiLCJWbCIsIk5sIiwiWXMiLCJKcyIsIkxsIiwiV2wiLCJ0YSIsIm5hIiwiTmUiLCJLZSIsIml0Iiwic3QiLCJHbCIsInFsIiwiRmwiLCJLbCIsImpsIiwiWmwiLCJRbCIsIm9hIiwiaWEiLCJnZSIsIkpsIiwidWEiLCJhYSIsImVjIiwiX3QiLCJkYSIsInRjIiwibmMiLCJyYyIsIm9jIiwiYXIiLCJsYSIsImNhIiwiaWMiLCJjbiIsInBhIiwic2MiLCJhYyIsIm1hIiwidWMiLCJmYSIsImdhIiwiZGMiLCJsYyIsInlhIiwiY2MiLCJwYyIsIl9hIiwibWMiLCIkYSIsImZjIiwiaGMiLCJnYyIsInhhIiwiU2EiLCJ5YyIsImJjIiwiX2MiLCJ3YyIsIiRjIiwidmMiLCJ4YyIsIlNjIiwiSWEiLCJwbiIsIkFhIiwiRWEiLCJrYSIsIlBhIiwiVGMiLCJJYyIsInphIiwiQmEiLCJEYSIsIk9hIiwiTWEiLCJVYSIsIlJhIiwiVmEiLCJOYSIsIkxhIiwiV2EiLCJHYSIsIkFjIiwiRWMiLCJxYSIsIkZhIiwia2MiLCJQYyIsImphIiwiemMiLCJCYyIsIlFhIiwiWGEiLCJEYyIsIk9jIiwiTWMiLCJKYSIsIlVjIiwiUmMiLCJWYyIsIk5jIiwiTGMiLCJXYyIsIkdjIiwiSGMiLCJldSIsInFjIiwiRmMiLCJLYyIsImpjIiwiWmMiLCJ0dSIsIm51IiwiUWMiLCJYYyIsIm91IiwiWWMiLCJtbiIsIkpjIiwic3UiLCJlcCIsInRwIiwiYXUiLCJ1dSIsIm5wIiwicnAiLCJsdSIsImN1IiwibXUiLCJvcCIsImlwIiwic3AiLCJmdSIsImFwIiwidXAiLCJndSIsImJ1IiwiZm4iLCJRciIsIkFuIiwiR2UiLCJDdCIsInNlbGYiLCJvbm1lc3NhZ2UiLCJpbiIsInRoZW4iLCJFdCIsInBvc3RNZXNzYWdlIiwiZXBOYW1lIiwia3QiLCJwdCIsIm91dCIsIm1vZGVsIiwib3B0aW9ucyIsIlB0IiwienQiLCJzZXNzaW9uSWQiLCJpbnB1dEluZGljZXMiLCJpbnB1dHMiLCJvdXRwdXRJbmRpY2VzIiwiQnQiLCJmaWxsIiwic29tZSIsIk90IiwiRHQiLCJXb3JrZXIiLCJvcmlnaW4iLCJjdXJyZW50U2NyaXB0IiwiaHJlZiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsIlVSTCIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJibG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwiaW1wb3J0IiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsIldlYkFzc2VtYmx5IiwidmFsaWRhdGUiLCJyZXNvbHZlIiwiaW5pdFRpbWVvdXQiLCJudW1UaHJlYWRzIiwic2ltZCIsImNyb3NzT3JpZ2luSXNvbGF0ZWQiLCJ3YXNtUGF0aHMiLCJtanMiLCJ3YXNtQmluYXJ5Iiwic2V0VGltZW91dCIsImxvY2F0ZUZpbGUiLCJyZXZva2VPYmplY3RVUkwiLCJyYWNlIiwiUnQiLCJsZW5ndGhCeXRlc1VURjgiLCJfbWFsbG9jIiwic3RyaW5nVG9VVEY4IiwiZW50cmllcyIsImZvckVhY2giLCJ0b1N0cmluZyIsInN0YWNrU2F2ZSIsIlBUUl9TSVpFIiwic3RhY2tBbGxvYyIsIl9PcnRHZXRMYXN0RXJyb3IiLCJnZXRWYWx1ZSIsIlVURjhUb1N0cmluZyIsInN0YWNrUmVzdG9yZSIsIm9vIiwibG9nU2V2ZXJpdHlMZXZlbCIsImlzSW50ZWdlciIsImxvZ1ZlcmJvc2l0eUxldmVsIiwidGVybWluYXRlIiwidGFnIiwiX09ydENyZWF0ZVJ1bk9wdGlvbnMiLCJleHRyYSIsIldlYWtTZXQiLCJfT3J0QWRkUnVuQ29uZmlnRW50cnkiLCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnMiLCJfZnJlZSIsInNvIiwic2Vzc2lvbiIsInVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkiLCJlbmFibGVNZW1QYXR0ZXJuIiwiX09ydEFkZFNlc3Npb25Db25maWdFbnRyeSIsImRldmljZVR5cGUiLCJwcmVmZXJyZWRMYXlvdXQiLCJzZXRWYWx1ZSIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwibG9nSWQiLCJvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJlbmFibGVQcm9maWxpbmciLCJlbmFibGVHcmFwaENhcHR1cmUiLCJmcmVlRGltZW5zaW9uT3ZlcnJpZGVzIiwiX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJWIiwicmVkdWNlIiwiQm4iLCJvayIsImhlYWRlcnMiLCJwYXJzZUludCIsImFycmF5QnVmZmVyIiwiYm9keSIsImdldFJlYWRlciIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwiZG9uZSIsInJlYWQiLCJCbG9iIiwia2UiLCJsb2ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJxIiwiY2FsY01hdE11bFNoYXBlIiwiY2FsY1NoYXBlIiwibWF4IiwiaXNWYWxpZEJyb2FkY2FzdCIsImdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UiLCJjb252ZXJ0U2hhcGUiLCJzaXplRnJvbURpbWVuc2lvbiIsInNpemVUb0RpbWVuc2lvbiIsImNvbXB1dGVTdHJpZGVzIiwibm9ybWFsaXplQXhpcyIsIm5vcm1hbGl6ZUF4ZXMiLCJzb3J0QmFzZWRPblBlcm0iLCJzbGljZSIsInJldmVyc2UiLCJwYWRTaGFwZSIsImFyZUVxdWFsIiwiZXZlcnkiLCJhZGp1c3RQb29sQXR0cmlidXRlcyIsImFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCIsImFkanVzdFBhZEFuZFJldHVyblNoYXBlIiwiY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSIsImNvbXB1dGVTaGFwZUhlbHBlciIsImNvbXB1dGVDb252T3V0cHV0U2hhcGUiLCJmbG9vciIsImdldFNoYXBlT2ZHZW1tUmVzdWx0IiwiT24iLCJ5byIsImlzRGF0YUNvbnZlcnRlZCIsImNvbnRleHQiLCJ0ZW5zb3IiLCJzaGFwZSIsImZhbGxiYWNrRGF0YVR5cGUiLCJtbENvbnRleHQiLCJ0ZW5zb3JTaGFwZSIsImZhbGxiYWNrVHlwZSIsImRlc3Ryb3kiLCJ3cml0ZSIsIndyaXRlVGVuc29yIiwicmVhZFRlbnNvciIsImNhblJldXNlVGVuc29yIiwic2V0SXNEYXRhQ29udmVydGVkIiwidGVuc29yTWFuYWdlciIsIndyYXBwZXIiLCJ0ZW5zb3JXcmFwcGVyIiwicmVsZWFzZVRlbnNvciIsImVuc3VyZVRlbnNvciIsImdldE1MQ29udGV4dCIsIm9wU3VwcG9ydExpbWl0cyIsImlucHV0IiwiZGF0YVR5cGVzIiwiYWN0aXZlVXBsb2FkIiwiTUxUZW5zb3JVc2FnZSIsIlJFQUQiLCJXUklURSIsImdldENhY2hlZFRlbnNvciIsInVwbG9hZCIsInRlbnNvclRyYWNrZXJzQnlJZCIsImZyZWVUZW5zb3JzIiwiZXh0ZXJuYWxUZW5zb3JzIiwicmVzZXJ2ZVRlbnNvcklkIiwicmVsZWFzZVRlbnNvcklkIiwiZGVsZXRlIiwicmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uIiwicmVnaXN0ZXJUZW5zb3IiLCJjcmVhdGVUZW5zb3IiLCJkaW1lbnNpb25zIiwidXNhZ2UiLCJ3cml0YWJsZSIsInJlYWRhYmxlIiwiYm8iLCJrZXlzIiwic29ydCIsIm1sQ29udGV4dEJ5U2Vzc2lvbklkIiwic2Vzc2lvbklkc0J5TUxDb250ZXh0IiwibWxDb250ZXh0Q2FjaGUiLCJzZXNzaW9uR3JhcGhJbnB1dHMiLCJzZXNzaW9uR3JhcGhPdXRwdXRzIiwidGVtcG9yYXJ5R3JhcGhJbnB1dHMiLCJ0ZW1wb3JhcnlHcmFwaE91dHB1dHMiLCJ0ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzIiwiZGVidWciLCJjdXJyZW50U2Vzc2lvbklkIiwiYWN0aXZlU2Vzc2lvbklkIiwib25SdW5TdGFydCIsIm9uUnVuRW5kIiwiY3JlYXRlTUxDb250ZXh0IiwiR1BVRGV2aWNlIiwiZmluZEluZGV4IiwiZ3B1RGV2aWNlIiwibmF2aWdhdG9yIiwiY3JlYXRlQ29udGV4dCIsInJlZ2lzdGVyTUxDb250ZXh0Iiwib25SZWxlYXNlU2Vzc2lvbiIsImNyZWF0ZVRlbXBvcmFyeVRlbnNvciIsInVwbG9hZFRlbnNvciIsInNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciIsImRvd25sb2FkVGVuc29yIiwiY3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIiwicmVnaXN0ZXJNTFRlbnNvciIsInJlZ2lzdGVyTUxDb25zdGFudCIsImNvbnN0YW50IiwicmVnaXN0ZXJHcmFwaElucHV0IiwicmVnaXN0ZXJHcmFwaE91dHB1dCIsImlzR3JhcGhJbnB1dCIsImlzR3JhcGhPdXRwdXQiLCJpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkIiwib3V0cHV0IiwiZmx1c2giLCJadCIsInhvIiwiZGV2aWNlIiwiY3JlYXRlQnVmZmVyIiwiR1BVQnVmZmVyVXNhZ2UiLCJDT1BZX0RTVCIsIk1BUF9SRUFEIiwiZ2V0Q29tbWFuZEVuY29kZXIiLCJlbmRDb21wdXRlUGFzcyIsImNvcHlCdWZmZXJUb0J1ZmZlciIsIm1hcEFzeW5jIiwiR1BVTWFwTW9kZSIsImdldE1hcHBlZFJhbmdlIiwic3RvcmFnZUNhY2hlIiwiZnJlZUJ1ZmZlcnMiLCJmcmVlVW5pZm9ybUJ1ZmZlcnMiLCJidWZmZXJzUGVuZGluZyIsImNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMiLCJzZXNzaW9uQ291bnQiLCJvcmlnaW5hbFNpemUiLCJtYXBwZWRBdENyZWF0aW9uIiwiTUFQX1dSSVRFIiwiQ09QWV9TUkMiLCJ1bm1hcCIsImNyZWF0ZUNvbW1hbmRFbmNvZGVyIiwiZ3B1RGF0YSIsInF1ZXVlIiwic3VibWl0IiwiZmluaXNoIiwibWVtY3B5IiwicmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlciIsImNhcHR1cmVkQ29tbWFuZExpc3QiLCJ1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJTVE9SQUdFIiwiVU5JRk9STSIsInBvcCIsInJlZnJlc2hQZW5kaW5nQnVmZmVycyIsInNlc3Npb25TdGF0dXMiLCJvbkNyZWF0ZVNlc3Npb24iLCJpZSIsImFzc2lnbiIsImNhY2hlS2V5Iiwia2V5IiwiSyIsImluZGljZXMiLCJzdG9yYWdlIiwiRSIsIm9mZnNldFRvSW5kaWNlcyIsImluZGljZXNUb09mZnNldCIsImJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0Iiwic2V0QnlJbmRpY2VzIiwiZ2V0QnlJbmRpY2VzIiwiJCIsIkkiLCJBIiwiTCIsIk0iLCJHIiwiQiIsImVlIiwiVyIsIm9lIiwiUiIsIlEiLCJpbXBsIiwidmFsdWVzIiwidW5zaGlmdCIsIiRlIiwiU2UiLCJ1ZSIsImluZGljZXNHZXQiLCJyYW5rIiwiaW5kaWNlc1NldCIsInNldEJ5T2Zmc2V0IiwiZ2V0QnlPZmZzZXQiLCJzdHJpZGVzIiwibm9ybWFsaXplZERpc3BhdGNoR3JvdXAiLCJsaW1pdHMiLCJpbnRlcm5hbFZhcmlhYmxlcyIsInZhcmlhYmxlcyIsInVuaWZvcm1zIiwidmFyaWFibGVJbmRleCIsImd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMiLCJtYWluU3RhcnQiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVoiLCJtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAiLCJhcHBlbmRWYXJpYWJsZVVuaWZvcm1zIiwicmVwbGFjZSIsImRlY2xhcmVWYXJpYWJsZSIsImRlY2xhcmVWYXJpYWJsZXMiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGUiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGVzIiwicmVnaXN0ZXJVbmlmb3JtIiwicmVnaXN0ZXJVbmlmb3JtcyIsImNvbmNhdCIsInVuaWZvcm1EZWNsYXJhdGlvbiIsImFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMiLCJ2YXJpYWJsZXNJbmZvIiwiVmUiLCJuZXdTaGFwZSIsIm5ld1Blcm0iLCJzaGFkZXJDYWNoZSIsImlucHV0RGVwZW5kZW5jaWVzIiwiZ2V0UnVuRGF0YSIsIm91dHB1dHMiLCJkaXNwYXRjaEdyb3VwIiwicHJvZ3JhbVVuaWZvcm1zIiwiZ2V0U2hhZGVyU291cmNlIiwiaGludCIsInBlcm0iLCJjb21wdXRlIiwiVm8iLCJZdCIsIm1pbiIsInN1bSIsInByb2QiLCJzdW1TcXVhcmUiLCJsb2dTdW1FeHAiLCJsMSIsImwyIiwibG9nU3VtIiwiYXhlcyIsIm5vb3BXaXRoRW1wdHlBeGVzIiwia2VlcERpbXMiLCJUIiwiZ2V0QmlnSW50NjRBcnJheSIsIkpvIiwic2VsZWN0TGFzdEluZGV4IiwiYXhpcyIsImVuIiwicWt2SGlkZGVuU2l6ZXMiLCJudW1IZWFkcyIsInBhc3RQcmVzZW50U2hhcmVCdWZmZXIiLCJiYXRjaFNpemUiLCJzZXF1ZW5jZUxlbmd0aCIsInBhc3RTZXF1ZW5jZUxlbmd0aCIsImt2U2VxdWVuY2VMZW5ndGgiLCJ0b3RhbFNlcXVlbmNlTGVuZ3RoIiwibWF4U2VxdWVuY2VMZW5ndGgiLCJpbnB1dEhpZGRlblNpemUiLCJoaWRkZW5TaXplIiwidkhpZGRlblNpemUiLCJoZWFkU2l6ZSIsInZIZWFkU2l6ZSIsImlzVW5pZGlyZWN0aW9uYWwiLCJtYXNrRmlsdGVyVmFsdWUiLCJtYXNrVHlwZSIsInNjYWxlIiwiYnJvYWRjYXN0UmVzUG9zQmlhcyIsInBhc3NQYXN0SW5LdiIsInFrdkZvcm1hdCIsInoiLCJrdk51bUhlYWRzIiwiblJlcHMiLCJzcXJ0IiwiZ3B1RGF0YVR5cGUiLCJVIiwiRCIsIm91dHB1dENvdW50IiwibmkiLCJzcGF0aWFsIiwiZXBzaWxvbiIsInZhbGlkYXRlSW5wdXRDb250ZW50IiwidHJhaW5pbmdNb2RlIiwib2kiLCJubiIsImdldEZsb2F0MzJBcnJheSIsImdldFVpbnQxNkFycmF5IiwiYWxwaGEiLCJiZXRhIiwiR2kiLCJlcyIsInNjYWxhciIsInZlY3RvciIsInJzIiwiRmUiLCJhY3RpdmF0aW9uIiwiY2xpcE1heCIsImNsaXBNaW4iLCJhY3RpdmF0aW9uX3BhcmFtcyIsIm9uIiwic3MiLCJhbiIsIloiLCJ1biIsIndlIiwic2UiLCJIIiwiZHMiLCJwYWRzIiwiZGlsYXRpb25zIiwiZnMiLCJ0cnVuYyIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImZyb250IiwiYmFjayIsInBhZEluZm8iLCJvdXREZXB0aCIsIm91dEhlaWdodCIsIm91dFdpZHRoIiwiZGF0YUZvcm1hdCIsImluRGVwdGgiLCJpbkhlaWdodCIsImluV2lkdGgiLCJpbkNoYW5uZWxzIiwib3V0Q2hhbm5lbHMiLCJzdHJpZGVEZXB0aCIsInN0cmlkZUhlaWdodCIsInN0cmlkZVdpZHRoIiwiZmlsdGVyRGVwdGgiLCJmaWx0ZXJIZWlnaHQiLCJmaWx0ZXJXaWR0aCIsImVmZmVjdGl2ZUZpbHRlckRlcHRoIiwiZWZmZWN0aXZlRmlsdGVySGVpZ2h0IiwiZWZmZWN0aXZlRmlsdGVyV2lkdGgiLCJkaWxhdGlvbkRlcHRoIiwiZGlsYXRpb25IZWlnaHQiLCJkaWxhdGlvbldpZHRoIiwiaW5TaGFwZSIsIm91dFNoYXBlIiwiZmlsdGVyU2hhcGUiLCJ5cyIsImdyb3VwIiwiX3MiLCJrZXJuZWxTaGFwZSIsImF1dG9QYWQiLCJhdXRvX3BhZCIsImtlcm5lbF9zaGFwZSIsIndJc0NvbnN0Iiwid19pc19jb25zdCIsImtlcm5lbEN1c3RvbURhdGEiLCJ3VCIsImFkYXB0ZXJJbmZvIiwiaXNBcmNoaXRlY3R1cmUiLCIkcyIsIm91dHB1dFNoYXBlIiwiSXMiLCJvdXRwdXRQYWRkaW5nIiwiRXMiLCJnZXRJbnQzMkFycmF5IiwiZXhjbHVzaXZlIiwienMiLCJibG9ja3NpemUiLCJtb2RlIiwiVXMiLCJzeW1ib2xUb0luZGljZXMiLCJpbnB1dEluZGV4IiwiYWRkU3ltYm9sIiwiZXF1YXRpb24iLCJoYXNFbGxpcHNpcyIsInN5bWJvbFRvSW5mbyIsImxocyIsIm91dHB1dERpbXMiLCJtYXRjaCIsIlJlZ0V4cCIsInByb2Nlc3NUZXJtIiwiY291bnQiLCJlbGxpcHNpc0RpbXMiLCJkaW1WYWx1ZSIsInJocyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk5zIiwiV3MiLCJxcyIsImpzIiwiYmF0Y2hEaW1zIiwiYmF0Y2hfZGltcyIsIlhzIiwicXVhbnRpemVBeGlzIiwiYmxvY2tTaXplIiwiZ2F0aGVyQXhpcyIsImVhIiwicmEiLCJ0cmFuc0EiLCJ0cmFuc0IiLCJzYSIsImFsaWduQ29ybmVycyIsInBhZGRpbmdNb2RlIiwiYWxpZ25fY29ybmVycyIsInBhZGRpbmdfbW9kZSIsInNyIiwidXIiLCJudW1PdXRwdXRzIiwic3BsaXRTaXplcyIsImRyIiwicm90YXJ5RW1iZWRkaW5nRGltIiwiaW50ZXJsZWF2ZWQiLCJoYSIsImRvUm90YXJ5IiwibG9jYWxXaW5kb3dTaXplIiwic29mdGNhcCIsInJvdGFyeUludGVybGVhdmVkIiwic21vb3RoU29mdG1heCIsImJhIiwid2EiLCJzaW1wbGlmaWVkIiwidmEiLCJUYSIsImJpdHMiLCJpc1ZlbmRvciIsIkNhIiwiSGEiLCJjZWlsTW9kZSIsImNvdW50SW5jbHVkZVBhZCIsInN0b3JhZ2VPcmRlciIsImNlaWxfbW9kZSIsImNvdW50X2luY2x1ZGVfcGFkIiwic3RvcmFnZV9vcmRlciIsIkthIiwiWmEiLCJhYnMiLCJZYSIsInJlZHVjdGlvbiIsInJ1IiwiY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUiLCJyb3VuZCIsImtlZXBBc3BlY3RSYXRpb1BvbGljeSIsIk1BWF9WQUxVRSIsIk1JTl9WQUxVRSIsImV4dHJhcG9sYXRpb25WYWx1ZSIsIm5lYXJlc3RNb2RlIiwiY3ViaWNDb2VmZkEiLCJleGNsdWRlT3V0c2lkZSIsImN1c3RvbURhdGFCdWZmZXIiLCJhbnRpYWxpYXMiLCJpdSIsImR1Iiwic3RhcnRzIiwiZW5kcyIsInNpZ24iLCJwdSIsImh1IiwieXUiLCJfdSIsInd1IiwicmVwbyIsImF0dHJpYnV0ZXNCb3VuZCIsImdldEFydGlmYWN0Iiwic2V0QXJ0aWZhY3QiLCJwcm9ncmFtSW5mbyIsImdldENvbXB1dGVQYXNzRW5jb2RlciIsIndyaXRlVGltZXN0YW1wIiwicGVuZGluZ0Rpc3BhdGNoTnVtYmVyIiwiYmluZGluZyIsInJlc291cmNlIiwiY3JlYXRlQmluZEdyb3VwIiwibGF5b3V0IiwiY29tcHV0ZVBpcGVsaW5lIiwiZ2V0QmluZEdyb3VwTGF5b3V0IiwibGFiZWwiLCJrZXJuZWxJZCIsImN1cnJlbnRLZXJuZWxJZCIsImJpbmRHcm91cCIsInNldFBpcGVsaW5lIiwic2V0QmluZEdyb3VwIiwiZGlzcGF0Y2hXb3JrZ3JvdXBzIiwibWF4RGlzcGF0Y2hOdW1iZXIiLCJxdWVyeVR5cGUiLCJidWlsZCIsImZlYXR1cmUiLCJleHRlbnNpb24iLCJmZWF0dXJlcyIsImNyZWF0ZVNoYWRlck1vZHVsZSIsImNvZGUiLCJjcmVhdGVDb21wdXRlUGlwZWxpbmUiLCJtb2R1bGUiLCJlbnRyeVBvaW50IiwidW5pZm9ybVZhcmlhYmxlc0luZm8iLCJub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSIsIm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uIiwiY2JydCIsIiR1IiwiV2ViR3B1QmFja2VuZCIsImNyIiwiZHAiLCJscCIsImxyIiwidnUiLCJhcmNoaXRlY3R1cmUiLCJ2ZW5kb3IiLCJjb21tYW5kRW5jb2RlciIsImNvbXB1dGVQYXNzRW5jb2RlciIsInBlbmRpbmdLZXJuZWxzIiwicGVuZGluZ1F1ZXJpZXMiLCJjYXB0dXJlZFBlbmRpbmdLZXJuZWxzIiwic2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmciLCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSIsImluaXRpYWxpemUiLCJyZXF1aXJlZExpbWl0cyIsIm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSIsIm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSIsIm1heEJ1ZmZlclNpemUiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVxdWVzdERldmljZSIsImluZm8iLCJyZXF1ZXN0QWRhcHRlckluZm8iLCJncHVEYXRhTWFuYWdlciIsInByb2dyYW1NYW5hZ2VyIiwia2VybmVscyIsImtlcm5lbFBlcnNpc3RlbnREYXRhIiwib251bmNhcHR1cmVkZXJyb3IiLCJHUFVWYWxpZGF0aW9uRXJyb3IiLCJtZXNzYWdlIiwiY29uZmlndXJhYmxlIiwic2V0UXVlcnlUeXBlIiwicXVlcnlTZXQiLCJ0aW1lc3RhbXBXcml0ZXMiLCJiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4IiwiZW5kT2ZQYXNzV3JpdGVJbmRleCIsImJlZ2luQ29tcHV0ZVBhc3MiLCJlbmQiLCJyZXNvbHZlUXVlcnlTZXQiLCJxdWVyeVJlc29sdmVCdWZmZXIiLCJrZXJuZWxUeXBlIiwia2VybmVsTmFtZSIsInByb2dyYW1OYW1lIiwiaW5wdXRUZW5zb3JWaWV3cyIsIm91dHB1dFRlbnNvclZpZXdzIiwicXVlcnlUaW1lQmFzZSIsInByb2ZpbGluZyIsIm9uZGF0YSIsInZlcnNpb24iLCJpbnB1dHNNZXRhZGF0YSIsIm91dHB1dHNNZXRhZGF0YSIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJ0ZW1wb3JhcnlEYXRhIiwid3JpdGVCdWZmZXIiLCJvZmZzZXQiLCJhbGxvYyIsImZyZWUiLCJjcmVhdGVLZXJuZWwiLCJrZXJuZWxFbnRyeSIsImF0dHJpYnV0ZXMiLCJyZWxlYXNlS2VybmVsIiwiY29tcHV0ZUtlcm5lbCIsInB1c2hFcnJvclNjb3BlIiwicG9wRXJyb3JTY29wZSIsInJlZ2lzdGVyQnVmZmVyIiwidW5yZWdpc3RlckJ1ZmZlcnMiLCJnZXRCdWZmZXIiLCJjcmVhdGVEb3dubG9hZGVyIiwiY3JlYXRlUXVlcnlTZXQiLCJRVUVSWV9SRVNPTFZFIiwiY2FwdHVyZUJlZ2luIiwiY2FwdHVyZUVuZCIsInJlcGxheSIsInh1IiwiY3AiLCJ3dCIsInByIiwicHAiLCJldCIsIm1wIiwiVHUiLCJJdSIsInR0IiwieGUiLCIkdCIsImduIiwieW4iLCJobiIsIm1yIiwiZnIiLCJhdCIsInV0IiwiaHAiLCJDdSIsIkF1IiwiRXUiLCJrdSIsIlB1IiwienUiLCJCdSIsIkR1IiwiZ3AiLCJibiIsIlN1IiwiSEVBUDgiLCJjdXN0b21EYXRhT2Zmc2V0IiwiY3VzdG9tRGF0YVNpemUiLCJvcEtlcm5lbENvbnRleHQiLCJIRUFQVTgiLCJzdWJhcnJheSIsIl9Kc2VwT3V0cHV0IiwianNlcEluaXQiLCJfSnNlcEdldE5vZGVOYW1lIiwiX09ydEluaXQiLCJhc3luY0luaXQiLCJhZGFwdGVyIiwiZ3B1IiwicG93ZXJQcmVmZXJlbmNlIiwiZm9yY2VGYWxsYmFja0FkYXB0ZXIiLCJyZXF1ZXN0QWRhcHRlciIsIl9PcnRHZXRJbnB1dE91dHB1dENvdW50IiwiX09ydEdldElucHV0T3V0cHV0TWV0YWRhdGEiLCJIRUFQMzIiLCJIRUFQVTMyIiwiX09ydEZyZWUiLCJleHRlcm5hbERhdGEiLCJtb3VudEV4dGVybmFsRGF0YSIsInBhdGgiLCJhbGwiLCJjdXJyZW50Q29udGV4dCIsIndlYm5uQ3JlYXRlTUxDb250ZXh0IiwiX09ydENyZWF0ZVNlc3Npb24iLCJ3ZWJncHVPbkNyZWF0ZVNlc3Npb24iLCJqc2VwT25DcmVhdGVTZXNzaW9uIiwid2Vibm5SZWdpc3Rlck1MQ29udGV4dCIsImlzVGVuc29yIiwicHJlZmVycmVkT3V0cHV0TG9jYXRpb24iLCJ3ZWJubklzR3JhcGhPdXRwdXQiLCJfT3J0Q3JlYXRlQmluZGluZyIsImhhbmRsZSIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9ucyIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQiLCJfT3J0UmVsZWFzZUJpbmRpbmciLCJfT3J0UmVsZWFzZVNlc3Npb24iLCJ1bm1vdW50RXh0ZXJuYWxEYXRhIiwiX09ydENsZWFyQm91bmRPdXRwdXRzIiwianNlcE9uUmVsZWFzZVNlc3Npb24iLCJ3ZWJubk9uUmVsZWFzZVNlc3Npb24iLCJ3ZWJncHVPblJlbGVhc2VTZXNzaW9uIiwianNlcFJlZ2lzdGVyQnVmZmVyIiwid2Vibm5SZWdpc3Rlck1MVGVuc29yIiwid2Vibm5Jc0dyYXBoSW5wdXQiLCJ3ZWJubkNyZWF0ZVRlbXBvcmFyeVRlbnNvciIsIndlYm5uVXBsb2FkVGVuc29yIiwiX09ydENyZWF0ZVRlbnNvciIsIl9PcnRCaW5kSW5wdXQiLCJfT3J0QmluZE91dHB1dCIsImpzZXBPblJ1blN0YXJ0Iiwid2Vibm5PblJ1blN0YXJ0IiwiX09ydFJ1bldpdGhCaW5kaW5nIiwiX09ydFJ1biIsIl9PcnRHZXRUZW5zb3JEYXRhIiwiYWUiLCJMZSIsInZ0IiwiZ3IiLCJqc2VwR2V0QnVmZmVyIiwianNlcENyZWF0ZURvd25sb2FkZXIiLCJfT3J0UmVsZWFzZVRlbnNvciIsIndlYm5uRW5zdXJlVGVuc29yIiwid2Vibm5Jc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkIiwid2Vibm5DcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJ3ZWJublJlbGVhc2VUZW5zb3JJZCIsIndlYm5uT25SdW5FbmQiLCJfT3J0RW5kUHJvZmlsaW5nIiwiaHIiLCJwcm94eSIsInNoaWZ0Iiwib25lcnJvciIsIk91IiwiZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkiLCJsb2FkTW9kZWwiLCJVdSIsIk9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kIiwiX24iLCJpbml0aWFsaXplRmxhZ3MiLCJNdSIsIndhc21CYWNrZW5kIiwieXAiLCJSdSIsImNwdXMiLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwiX3AiLCJicCIsImV4cG9ydHMiLCJ3ZWJwYWNrRW1wdHlDb250ZXh0IiwicmVxIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwidW5kZWZpbmVkIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIm9iaiIsInByb3AiLCJkYXRhQSIsImRhdGFCIiwiZmVlZHMiLCJkYXRhQyIsIm1haW4iXSwic291cmNlUm9vdCI6IiJ9